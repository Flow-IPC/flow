/* Flow
 * Copyright 2023 Akamai Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing
 * permissions and limitations under the License. */

/// @file
#pragma once

#include "flow/log/log_fwd.hpp"
/* Subtlety: The following is technically not required -- log_fwd.hpp is enough to fwd-declare Config, and we
 * only mention Config* here.  However in practice we are likely indirectly included by a *_logger.hpp, and guys such
 * as (e.g.) Simple_ostream_logger all take Config* as ctor arg, and in practice the user almost always will want
 * to instantiate a Config and thus require the following header file.  Of course, we could just make them
 * #include it themselves, and generally that is fine/good/a goal of _fwd.hpp pattern.  (Even if the user is
 * directly using Ostream_log_msg_writer, the same reasoning applies: probably they need to instantiate a Config.)
 * So just for convenience for the vast majority of users, just give 'em this.  (Truthfully this is partially to
 * avoid breaking some user code written before the _fwd.hpp pattern was applied to Flow.  However in my (ygoldfel)
 * opinion it would still be a decent argument even without that. */
#include "flow/log/config.hpp"
#include <ostream>
#include <boost/io/ios_state.hpp>
#include <boost/chrono/chrono.hpp>
#include <vector>

namespace flow::log
{

// Types.

/**
 * Utility class, each object of which wraps a given `ostream` and outputs discrete messages to it adorned with time
 * stamps and other formatting such as separating newlines.  A Config object controls certain aspects of its behavior;
 * pass this to the constructor.  The Config may come from the user as passed to the Logger (if any) using `*this`;
 * or that Logger (if any) can make its own from scratch.
 *
 * It is assumed that between the first and last calls to do_log() no other code whatsoever writes to the underlying
 * stream (as passed to ctor) at any point -- including any formatters.  At `*this` destruction formatter state
 * is restored.
 *
 * ### Rationale ###
 * This optional (but recommended for most Logger implementations, though technically not limited to their use)
 * utility class typically sits between some "physical" output medium -- a buffer in memory, a file, etc. --
 * that can be written to using an `ostream` (e.g., `std::ostringstream`, util::String_ostream, `std::ofstream`);
 * and a Logger implementation that promises to output log messages to that output medium.  When Logger::do_log()
 * is called, the message string passed to it will contain the user's original message plus various Msg_metadata
 * nuggets (like time stamp, severity, source code location) either generated by FLOW_LOG_WITHOUT_CHECKING()
 * implementation or provided by user.  The idea is the Logger is to decide on the output format of the various
 * metadata plus the message.  Therefore, the present class outputs all those pieces (as appropriate) plus
 * separating newlines.  Any Logger is free to use any format it wants; and some `Logger`s might not even generate
 * any output character stream but rather forward everything elsewhere (maybe even over the network); but
 * Ostream_log_msg_writer provides a reasonable output format to a character stream, to be used or not as desired.
 *
 * ### Thread safety ###
 * For a given `*this`, the class is not safe for concurrent calls to log().  The using code must provide any such
 * guarantees.
 *
 * See thread safety notes and to-dos regarding config in Simple_ostream_logger doc header.  These apply here also.
 */
class Ostream_log_msg_writer :
  private boost::noncopyable
{
public:
  // Types.

  // Constructors/destructor.

  /**
   * Constructs object wrapping the given `ostream`.  Does not write any characters to stream (so, for instance,
   * if it happens to be an `ofstream` then it is fine if it's not yet open or even associated with a path).  It may
   * however do stateful things such as format setting.
   *
   * If any non-default formatting has been applied to `os`, subsequent behavior is undefined.
   *
   * @param config
   *        Controls behavior of `*this`.  See thread safety notes in class doc header.
   *        This is saved *by reference* inside `*this`; it must remain valid through the last log() call.
   * @param os
   *        Stream to which to write subsequently via log().
   */
  explicit Ostream_log_msg_writer(const Config& config, std::ostream& os);

  /// Fairly boring destructor.  Restores formatting state of `os` to how it was before entry to constructor.
  ~Ostream_log_msg_writer();

  // Methods.

  /**
   * Logs to the wrapped `ostream` the given message and associated metadata like severity and time stamp; plus
   * a newline.
   *
   * @param metadata
   *        See `*metadata` in Logger::do_log().
   * @param msg
   *        The message.  No terminating newline is assumed (though there is no rule against it; but
   *        if one is present, a blank line will appear in wrapped `ostream`).
   */
  void log(const Msg_metadata& metadata, util::String_view msg);

private:

  // Types.

  /// Short-hand for an `ostream` state saver.
  using Ostream_state = boost::io::ios_all_saver;

  // Methods.

  /**
   * log() implementation with time stamp = seconds.microseconds since Epoch.
   *
   * @param metadata
   *        See do_log().
   * @param msg
   *        See do_log().
   */
  void do_log_with_epoch_time_stamp(const Msg_metadata& metadata, util::String_view msg);

  /**
   * log() implementation with time stamp = date/time with microsecond resolution/time zone, in
   * current OS time zone.
   *
   * @param metadata
   *        See do_log().
   * @param msg
   *        See do_log().
   */
  void do_log_with_human_friendly_time_stamp(const Msg_metadata& metadata, util::String_view msg);

  /**
   * Remainder of log() functionality after either do_log_with_epoch_time_stamp() or
   * do_log_with_human_friendly_time_stamp(), once either has logged the time stamp.
   *
   * @param metadata
   *        See do_log().
   * @param msg
   *        See do_log().
   */
  void log_past_time_stamp(const Msg_metadata& metadata, util::String_view msg);

  // Constants.

  /// Mapping from Sev to its brief string description.
  static const std::vector<util::String_view> S_SEV_STRS;

  /// Jan 1, 1970, 00:00.
  static const boost::chrono::system_clock::time_point S_POSIX_EPOCH;

  // Data.

  /// Reference to the config object passed to constructor.  See notes on thread safety.
  const Config& m_config;

  /// Pointer to function that do_log() will forward to when invoked.
  const Function<void (Ostream_log_msg_writer*, const Msg_metadata&, util::String_view)> m_do_log_func;

  /// Reference to stream to which to log messages.
  std::ostream& m_os;

  /// Formatter state of #m_os at construction.  Used at least in destructor (as of this writing) to restore it.
  Ostream_state m_clean_os_state;
}; // class Ostream_log_msg_writer

} // namespace flow::log
