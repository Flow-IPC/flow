<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flow module containing the API and implementation of the <em>Flow network protocol</em>, a TCP-inspired stream protocol that uses UDP as underlying transport.  
<a href="namespaceflow_1_1net__flow.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceflow_1_1net__flow_1_1asio"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow_1_1asio.html">asio</a></td></tr>
<tr class="memdesc:namespaceflow_1_1net__flow_1_1asio"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains classes that add boost.asio integration to the main Flow-protocol classes such as <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>, so that <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> sockets can be easily used in boost.asio-driven event loops, e.g., ones also performing TCP networking and scheduling timers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceflow_1_1net__flow_1_1error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow_1_1error.html">error</a></td></tr>
<tr class="memdesc:namespaceflow_1_1net__flow_1_1error"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a> module's extension of <a class="el" href="namespaceboost_1_1system.html" title="We may add some ADL-based overloads into this namespace outside flow.">boost.system</a> error conventions, so that Flow network protocol API can return codes/messages from within its own new set of error codes/messages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html">Ack_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level ACK packet.  <a href="structflow_1_1net__flow_1_1Ack__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic.html">Congestion_control_classic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classic congestion control, based on Reno (TCP RFC 5681), with congestion avoidance, slow start, and congestion window halving (etc.) upon a loss event.  <a href="classflow_1_1net__flow_1_1Congestion__control__classic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html">Congestion_control_classic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for use by <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a> implementations that implements congestion window and slow start threshold storage and classic Reno-style "slow start" and "congestion
avoidance" algorithms.  <a href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__with__bandwidth__est.html">Congestion_control_classic_with_bandwidth_est</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classic congestion control but with backoff to bandwidth estimate-based pipe size.  <a href="classflow_1_1net__flow_1_1Congestion__control__classic__with__bandwidth__est.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__selector.html">Congestion_control_selector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace-like class that enables an <code>enum</code>-based selection of the <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a> interface implementation to use for a given socket (for programmatic socket options) and facilitates stream I/O of these enums (allowing parsing and outputting these socket options).  <a href="classflow_1_1net__flow_1_1Congestion__control__selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html">Congestion_control_strategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface for a per-socket module that determines the socket's congestion control behavior.  <a href="classflow_1_1net__flow_1_1Congestion__control__strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level DATA packet.  <a href="structflow_1_1net__flow_1_1Data__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html">Drop_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> class that maintains the Drop Timer for DATA packet(s) to have been sent out over a connection but not yet acknowledged by the receiver.  <a href="classflow_1_1net__flow_1_1Drop__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html">Event_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user-set collection of sockets and desired conditions on those sockets (such as: "socket has data
to read"), with the ability to wait for those conditions to become true and signal the user when so.  <a href="classflow_1_1net__flow_1_1Event__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html">Low_lvl_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level packet structure and serves as the super-type for all specific packet types, represented by derived <code>struct</code>s like <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects of this class can be fed to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to make it internally simulate network conditions like loss, latency, and data duplication.  <a href="classflow_1_1net__flow_1_1Net__env__simulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer.  <a href="classflow_1_1net__flow_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of low-level options affecting a single Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, including <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects and other objects subsequently generated by that Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Node__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes and reliability support.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data store that keeps stats about the a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> connection.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of low-level options affecting a single <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html">Peer_socket_receive_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data store that keeps stats about the incoming direction of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> connection to another Flow-protocol <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that keeps a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html" title="A data store that keeps stats about the incoming direction of a Peer_socket connection to another Flo...">Peer_socket_receive_stats</a> data store, includes methods to conveniently accumulate data in it, and provides output to <code>ostream</code>.  <a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html">Peer_socket_send_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data store that keeps stats about the outgoing direction of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> connection to another Flow-protocol <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats__accumulator.html">Peer_socket_send_stats_accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that keeps a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html" title="A data store that keeps stats about the outgoing direction of a Peer_socket connection to another Flo...">Peer_socket_send_stats</a> data store, includes methods to conveniently accumulate data in it, and provides output to <code>ostream</code>.  <a href="classflow_1_1net__flow_1_1Peer__socket__send__stats__accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Port__space.html">Port_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> class that maintains the available Flow-protocol port space, somewhat similarly to the classic TCP or UDP port scheme.  <a href="classflow_1_1net__flow_1_1Port__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and the logical Flow-protocol port within that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Remote__endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html">Rst_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level RST packet.  <a href="structflow_1_1net__flow_1_1Rst__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html">Send_bandwidth_estimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A per-Peer_socket module that tries to estimate the bandwidth available to the outgoing flow.  <a href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html">Send_pacing_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current outgoing packet pacing state, including queue of low-level packets to be sent, for a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="structflow_1_1net__flow_1_1Send__pacing__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> sequence number identifying a piece of data.  <a href="classflow_1_1net__flow_1_1Sequence__number.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server socket able to listen on a single Flow port for incoming connections and return peer sockets (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects) to the local user once such connections are established.  <a href="classflow_1_1net__flow_1_1Server__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> class that implements a socket buffer, as used by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> for Send and Receive buffers.  <a href="classflow_1_1net__flow_1_1Socket__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html">Syn_ack_ack_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level SYN_ACK_ACK packet.  <a href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level SYN_ACK packet.  <a href="structflow_1_1net__flow_1_1Syn__ack__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html">Syn_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level SYN packet.  <a href="structflow_1_1net__flow_1_1Syn__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a079d8cd87a68d1c5f04c6bce71f0061d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> = uint16_t</td></tr>
<tr class="memdesc:a079d8cd87a68d1c5f04c6bce71f0061d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).  <a href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">More...</a><br /></td></tr>
<tr class="separator:a079d8cd87a68d1c5f04c6bce71f0061d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaeebb1db2f4bb19f78cada66784d91d5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5">Xfer_op_result</a> { <a class="el" href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5a168ab5e2776c3fc69c7efa4262ca489b">S_FULLY_XFERRED</a>
, <a class="el" href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5a23df894f5468a4b3c7dc593295fe87e2">S_PARTIALLY_XFERRED</a>
, <a class="el" href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5aac04e40d3b2f54f1f517d49594eb7849">S_ERROR</a>
 }</td></tr>
<tr class="memdesc:aaeebb1db2f4bb19f78cada66784d91d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of a send or receive operation, used at least in stat reporting.  <a href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5">More...</a><br /></td></tr>
<tr class="separator:aaeebb1db2f4bb19f78cada66784d91d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#aad968d3e7e9c3f284bea03e799d5fbc0">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;strategy_choice)</td></tr>
<tr class="memdesc:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> from a standard input stream.  <a href="namespaceflow_1_1net__flow.html#aad968d3e7e9c3f284bea03e799d5fbc0">More...</a><br /></td></tr>
<tr class="separator:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#ab9f537c84f77e9b8fa742fc5dc6d5693">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;strategy_choice)</td></tr>
<tr class="memdesc:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> to a standard <code>ostream</code> &ndash; the reverse of <a class="el" href="namespaceflow_1_1net__flow.html#aad968d3e7e9c3f284bea03e799d5fbc0" title="Deserializes a Peer_socket_options::Congestion_control_strategy_choice enum from a standard input str...">operator&gt;&gt;()</a>.  <a href="namespaceflow_1_1net__flow.html#ab9f537c84f77e9b8fa742fc5dc6d5693">More...</a><br /></td></tr>
<tr class="separator:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141b6e0eb37057ae02d08d4b34818f4b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a141b6e0eb37057ae02d08d4b34818f4b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; std::ostream &amp;(std::ostream &amp;)&gt; &amp;os_manip)</td></tr>
<tr class="memdesc:a141b6e0eb37057ae02d08d4b34818f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given <code>ostream</code> manipulator function to the given <code>ostream</code> &ndash; just like standard streams already allow, but with the function given as a <a class="el" href="classflow_1_1Function.html">flow::Function</a> object instead of a raw function pointer.  <a href="namespaceflow_1_1net__flow.html#a141b6e0eb37057ae02d08d4b34818f4b">More...</a><br /></td></tr>
<tr class="separator:a141b6e0eb37057ae02d08d4b34818f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23129de20e68f8e125ed8a9bbc483402"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a23129de20e68f8e125ed8a9bbc483402">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a> &amp;sock_buf)</td></tr>
<tr class="memdesc:a23129de20e68f8e125ed8a9bbc483402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a printable representation of the data in <code>sock_buf</code> to the given standard <code>ostream</code>.  <a href="namespaceflow_1_1net__flow.html#a23129de20e68f8e125ed8a9bbc483402">More...</a><br /></td></tr>
<tr class="separator:a23129de20e68f8e125ed8a9bbc483402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b19eb9e5f0043bcad407520bd90c1f9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a5b19eb9e5f0043bcad407520bd90c1f9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;seq_num)</td></tr>
<tr class="memdesc:a5b19eb9e5f0043bcad407520bd90c1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints given sequence number to given <code>ostream</code>.  <a href="namespaceflow_1_1net__flow.html#a5b19eb9e5f0043bcad407520bd90c1f9">More...</a><br /></td></tr>
<tr class="separator:a5b19eb9e5f0043bcad407520bd90c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152200ba9432e5ca229e41a1c5d9d226"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a152200ba9432e5ca229e41a1c5d9d226">hash_value</a> (const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;seq_num)</td></tr>
<tr class="memdesc:a152200ba9432e5ca229e41a1c5d9d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free function that returns <code>seq_num.hash()</code>; has to be a free function named <code>hash_value</code> for boost.hash to pick it up.  <a href="namespaceflow_1_1net__flow.html#a152200ba9432e5ca229e41a1c5d9d226">More...</a><br /></td></tr>
<tr class="separator:a152200ba9432e5ca229e41a1c5d9d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8504aeca20f41a8f2b98ae04803a600e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a8504aeca20f41a8f2b98ae04803a600e">operator==</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;lhs, const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8504aeca20f41a8f2b98ae04803a600e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <code>lhs</code> is equal to <code>rhs</code>.  <a href="namespaceflow_1_1net__flow.html#a8504aeca20f41a8f2b98ae04803a600e">More...</a><br /></td></tr>
<tr class="separator:a8504aeca20f41a8f2b98ae04803a600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e207ad5dc52f3832b5a5f73c75e11e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a84e207ad5dc52f3832b5a5f73c75e11e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;endpoint)</td></tr>
<tr class="memdesc:a84e207ad5dc52f3832b5a5f73c75e11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html" title="Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...">Remote_endpoint</a> to the given <code>ostream</code>.  <a href="namespaceflow_1_1net__flow.html#a84e207ad5dc52f3832b5a5f73c75e11e">More...</a><br /></td></tr>
<tr class="separator:a84e207ad5dc52f3832b5a5f73c75e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38246018ee64662d208371c55ffb1bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#ab38246018ee64662d208371c55ffb1bd">hash_value</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;remote_endpoint)</td></tr>
<tr class="memdesc:ab38246018ee64662d208371c55ffb1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free function that returns <code>remote_endpoint.hash()</code>; has to be a free function named <code>hash_value</code> for boost.hash to pick it up.  <a href="namespaceflow_1_1net__flow.html#ab38246018ee64662d208371c55ffb1bd">More...</a><br /></td></tr>
<tr class="separator:ab38246018ee64662d208371c55ffb1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#aebbf2b8f19e2b3d887fe234cd5bdcffc">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">Event_set::State</a> state)</td></tr>
<tr class="memdesc:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> state to given standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#aebbf2b8f19e2b3d887fe234cd5bdcffc">More...</a><br /></td></tr>
<tr class="separator:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57b16fd356cacb8432a8ce7b021b54c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#ac57b16fd356cacb8432a8ce7b021b54c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type)</td></tr>
<tr class="memdesc:ac57b16fd356cacb8432a8ce7b021b54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given event type to given standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#ac57b16fd356cacb8432a8ce7b021b54c">More...</a><br /></td></tr>
<tr class="separator:ac57b16fd356cacb8432a8ce7b021b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fb85d618cb12e9ee1b22f52bdfcaa5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a26fb85d618cb12e9ee1b22f52bdfcaa5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html">Peer_socket_receive_stats</a> &amp;stats)</td></tr>
<tr class="memdesc:a26fb85d618cb12e9ee1b22f52bdfcaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a26fb85d618cb12e9ee1b22f52bdfcaa5">More...</a><br /></td></tr>
<tr class="separator:a26fb85d618cb12e9ee1b22f52bdfcaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98357cf7d8e29ec9dd34bd11ab382108"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a98357cf7d8e29ec9dd34bd11ab382108">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html">Peer_socket_send_stats</a> &amp;stats)</td></tr>
<tr class="memdesc:a98357cf7d8e29ec9dd34bd11ab382108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a98357cf7d8e29ec9dd34bd11ab382108">More...</a><br /></td></tr>
<tr class="separator:a98357cf7d8e29ec9dd34bd11ab382108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13391099a7662dbbef0a2ea171d1e7e9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a13391099a7662dbbef0a2ea171d1e7e9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> &amp;stats)</td></tr>
<tr class="memdesc:a13391099a7662dbbef0a2ea171d1e7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a13391099a7662dbbef0a2ea171d1e7e9">More...</a><br /></td></tr>
<tr class="separator:a13391099a7662dbbef0a2ea171d1e7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e84102fc55993f914ec64d04566bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a5d6e84102fc55993f914ec64d04566bc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *sock)</td></tr>
<tr class="memdesc:a5d6e84102fc55993f914ec64d04566bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket to given standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a5d6e84102fc55993f914ec64d04566bc">More...</a><br /></td></tr>
<tr class="separator:a5d6e84102fc55993f914ec64d04566bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53102c8d63b1e7749104a263fb8574e8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a53102c8d63b1e7749104a263fb8574e8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *serv)</td></tr>
<tr class="memdesc:a53102c8d63b1e7749104a263fb8574e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket to given standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a53102c8d63b1e7749104a263fb8574e8">More...</a><br /></td></tr>
<tr class="separator:a53102c8d63b1e7749104a263fb8574e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665ca8642963a22acdc07e901dd23ee4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a665ca8642963a22acdc07e901dd23ee4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a665ca8642963a22acdc07e901dd23ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>, along with its current value, to the given <code>ostream</code>.  <a href="namespaceflow_1_1net__flow.html#a665ca8642963a22acdc07e901dd23ee4">More...</a><br /></td></tr>
<tr class="separator:a665ca8642963a22acdc07e901dd23ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c5c856d519777fa381fc29b4bf581"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#ae43c5c856d519777fa381fc29b4bf581">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:ae43c5c856d519777fa381fc29b4bf581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, along with its current value, to the given <code>ostream</code>.  <a href="namespaceflow_1_1net__flow.html#ae43c5c856d519777fa381fc29b4bf581">More...</a><br /></td></tr>
<tr class="separator:ae43c5c856d519777fa381fc29b4bf581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b5a60123429cfdfde6149a88ac508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a9e6b5a60123429cfdfde6149a88ac508">operator==</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;lhs, const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;rhs)</td></tr>
<tr class="separator:a9e6b5a60123429cfdfde6149a88ac508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a84ca63c060a64658d2bd4acc044dbc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a9a84ca63c060a64658d2bd4acc044dbc">hash_value</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;socket_id)</td></tr>
<tr class="separator:a9a84ca63c060a64658d2bd4acc044dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a8fc9f0d8cdfef76158add1f1d1ddc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#ad9a8fc9f0d8cdfef76158add1f1d1ddc">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a> state)</td></tr>
<tr class="separator:ad9a8fc9f0d8cdfef76158add1f1d1ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a48bc8803c67e75b955a1f2778a8ad2bf">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a> state)</td></tr>
<tr class="memdesc:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter.  <a href="namespaceflow_1_1net__flow.html#a48bc8803c67e75b955a1f2778a8ad2bf">More...</a><br /></td></tr>
<tr class="separator:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9dd0c9d8de00fab78d8b0a3f50dad2a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">S_PORT_ANY</a> = 0</td></tr>
<tr class="memdesc:a9dd0c9d8de00fab78d8b0a3f50dad2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special Flow port value used to indicate "invalid port" or "please pick a random available ephemeral
port," depending on the context.  <a href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">More...</a><br /></td></tr>
<tr class="separator:a9dd0c9d8de00fab78d8b0a3f50dad2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Flow module containing the API and implementation of the <em>Flow network protocol</em>, a TCP-inspired stream protocol that uses UDP as underlying transport. </p>
<p >See the large doc header on class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> for the "root" of all documentation w/r/t <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>, beyond the present brief sentences.</p>
<h3>Historical note</h3>
<p >Historically, the Flow project only existed in the first place to deliver the functionality now in this <code>namespace</code> <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>. However, since then, <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> has become merely one of several Flow modules, each providing functionality independent of the others'. In the past, all/most <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a>{}</code> contents resided directly in <code>namespace</code> <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a>, but now it has been segregated into its own namespace.</p>
<p ><code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> may still be, by volume, the largest module (hence also perhaps the largest user of general-use modules like <a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a> and <a class="el" href="namespaceflow_1_1util.html" title="Flow module containing miscellaneous general-use facilities that don&#39;t fit into any other Flow module...">flow::util</a>). Nevertheless, it is no longer "special."</p>
<dl class="section see"><dt>See also</dt><dd>Main class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a079d8cd87a68d1c5f04c6bce71f0061d" name="a079d8cd87a68d1c5f04c6bce71f0061d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079d8cd87a68d1c5f04c6bce71f0061d">&#9670;&nbsp;</a></span>flow_port_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow::net_flow::flow_port_t</a> = typedef uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP). </p>

<p class="definition">Definition at line <a class="el" href="net__flow__fwd_8hpp_source.html#l00054">54</a> of file <a class="el" href="net__flow__fwd_8hpp_source.html">net_flow_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aaeebb1db2f4bb19f78cada66784d91d5" name="aaeebb1db2f4bb19f78cada66784d91d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeebb1db2f4bb19f78cada66784d91d5">&#9670;&nbsp;</a></span>Xfer_op_result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceflow_1_1net__flow.html#aaeebb1db2f4bb19f78cada66784d91d5">flow::net_flow::Xfer_op_result</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result of a send or receive operation, used at least in stat reporting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaeebb1db2f4bb19f78cada66784d91d5a168ab5e2776c3fc69c7efa4262ca489b" name="aaeebb1db2f4bb19f78cada66784d91d5a168ab5e2776c3fc69c7efa4262ca489b"></a>S_FULLY_XFERRED&#160;</td><td class="fielddoc"><p >Bytes transferred equals bytes expected. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaeebb1db2f4bb19f78cada66784d91d5a23df894f5468a4b3c7dc593295fe87e2" name="aaeebb1db2f4bb19f78cada66784d91d5a23df894f5468a4b3c7dc593295fe87e2"></a>S_PARTIALLY_XFERRED&#160;</td><td class="fielddoc"><p >Bytes transferred less than bytes expected. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaeebb1db2f4bb19f78cada66784d91d5aac04e40d3b2f54f1f517d49594eb7849" name="aaeebb1db2f4bb19f78cada66784d91d5aac04e40d3b2f54f1f517d49594eb7849"></a>S_ERROR&#160;</td><td class="fielddoc"><p >Error occurred &ndash; probably no bytes transferred. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="net__flow__fwd_8hpp_source.html#l00043">43</a> of file <a class="el" href="net__flow__fwd_8hpp_source.html">net_flow_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9a84ca63c060a64658d2bd4acc044dbc" name="a9a84ca63c060a64658d2bd4acc044dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a84ca63c060a64658d2bd4acc044dbc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free function that returns socket_id.hash(); has to be a free function named <code><a class="el" href="namespaceflow_1_1net__flow.html#a152200ba9432e5ca229e41a1c5d9d226" title="Free function that returns seq_num.hash(); has to be a free function named hash_value for boost....">hash_value()</a></code> for boost.hash to pick it up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Socket ID to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket_id.hash(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01162">1162</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

</div>
</div>
<a id="ab38246018ee64662d208371c55ffb1bd" name="ab38246018ee64662d208371c55ffb1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38246018ee64662d208371c55ffb1bd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>remote_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free function that returns <code>remote_endpoint.hash()</code>; has to be a free function named <code>hash_value</code> for boost.hash to pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_endpoint</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>remote_endpoint.hash()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="endpoint_8cpp_source.html#l00070">70</a> of file <a class="el" href="endpoint_8cpp_source.html">endpoint.cpp</a>.</p>

</div>
</div>
<a id="a152200ba9432e5ca229e41a1c5d9d226" name="a152200ba9432e5ca229e41a1c5d9d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152200ba9432e5ca229e41a1c5d9d226">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;&#160;</td>
          <td class="paramname"><em>seq_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free function that returns <code>seq_num.hash()</code>; has to be a free function named <code>hash_value</code> for boost.hash to pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_num</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>seq_num.hash()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="seq__num_8cpp_source.html#l00275">275</a> of file <a class="el" href="seq__num_8cpp_source.html">seq_num.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="seq__num_8cpp_source.html#l00252">flow::net_flow::Sequence_number::hash()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1net__flow_a152200ba9432e5ca229e41a1c5d9d226_icgraph.svg" width="559" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a141b6e0eb37057ae02d08d4b34818f4b" name="a141b6e0eb37057ae02d08d4b34818f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141b6e0eb37057ae02d08d4b34818f4b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; std::ostream &amp;(std::ostream &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>os_manip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given <code>ostream</code> manipulator function to the given <code>ostream</code> &ndash; just like standard streams already allow, but with the function given as a <a class="el" href="classflow_1_1Function.html">flow::Function</a> object instead of a raw function pointer. </p>
<p >Without this, the <a class="el" href="classflow_1_1Function.html">flow::Function</a> is usually converted to a <code>bool</code> or something and just printed out as <code>"1"</code> &ndash; which is not useful.</p>
<p >Much like with standard function manipulators (<code>std::endl</code>, for example), the idea is for this to work:</p>
<div class="fragment"><div class="line">cout &lt;&lt; print_something_to_ostream &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; xyz;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// But in this case, print_something_to_stream is of type: Function&lt;ostream&amp; (ostream&amp;)&gt;.</span></div>
<div class="line"><span class="comment">// E.g., ahead of the `cout` this could have been done, assuming: ostream&amp; func(ostream&amp; os, bool some_flag):</span></div>
<div class="line"><a class="code hl_class" href="classflow_1_1Function.html">flow::Function</a>&lt;ostream&amp; (ostream&amp;)&gt; print_something_to_stream</div>
<div class="line">  = [](ostream&amp; os) -&gt; ostream&amp; { <span class="keywordflow">return</span> func(os, <span class="keyword">false</span>); };</div>
<div class="line"><span class="comment">// Or with a non-static class member function: class Some_class { ostream&amp; func(ostream&amp; os, bool some_flag); }.</span></div>
<div class="line">Some_class some_instance;</div>
<div class="line"><a class="code hl_class" href="classflow_1_1Function.html">flow::Function</a>&lt;ostream&amp; (ostream&amp;)&gt; print_something_to_stream</div>
<div class="line">  = [some_instance](ostream&amp; os) -&gt; ostream&amp; { <span class="keywordflow">return</span> some_instance-&gt;func(os, <span class="keyword">false</span>); };</div>
<div class="ttc" id="aclassflow_1_1Function_html"><div class="ttname"><a href="classflow_1_1Function.html">flow::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00506">common.hpp:506</a></div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It is important for this to be in namespace <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a></code>, not higher (such as <code>flow</code>) or lower. Otherwise the places needing this overload to be used won't, and it will either not compile; or compile but invoke some other, useless overload. Unfortunately placing it into a containing namespace makes it not work from within a contained namespace.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may note the above technique is not used for argument-bearing <code>std</code> stream manipulators; for example <code>std::setw()</code>. The technique used to make that work is that <code>setw()</code> would return some internal <code>struct</code> (of unknown-to-user type <code>T</code>), in which it has stored the argument to <code>setw()</code>; and an <code>operator&lt;&lt;(ostream, T)</code> overload is defined; this overload would actually set the field width (or whatever <code>setw()</code> is supposed to do) on the <code>ostream</code> &ndash; using the arg value stored in the <code>T</code>. That works, and it may be somewhat more performant than our solution; but our solution is <em>much</em> more elegant and concise; it lets one build stream manipulators out of any function at all, the only requirements on it being that it returns an <code>ostream&amp;</code> and takes same as <em>an</em> argument. The <code>std</code> technique allows the same, but we can do it with a single and expressive <code>bind()</code> call instead of a hidden internal <code>struct type</code>, explicitly storing arguments, documenting that stuff, etc. (We can change individual cases to use the <code>std</code>-style solution, if performance needs call for it, but so far there has been no such needs.) To be fair, the <code>std</code> solution is ALSO easier/more expressive at the actual call site. That is, in the above examples, one could just do: <code>cout &lt;&lt; func(false) &lt;&lt; ":" &lt;&lt; xyz;</code> or <code>cout &lt;&lt; some_instance.func(false) &lt;&lt; ":" &lt;&lt; xyz;</code>, respectively. That's easier to read than the <code>bind()</code> constructs above; but the code elsewhere that makes those <code>func()</code>s work is a huge mess that our solution completely avoids. For us, all that is needed behind the scenes is the present <code>operator&lt;&lt;</code> overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to write to/mutate. </td></tr>
    <tr><td class="paramname">os_manip</td><td>A <a class="el" href="classflow_1_1Function.html">flow::Function</a> object that points to a manipulator, which is a function that takes a mutable <code>ostream</code>, writes something to it and/or acts on it in some other non-<code>const</code> way; and returns the original reference to mutable <code>ostream</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="net__flow__util_8cpp_source.html#l00025">25</a> of file <a class="el" href="net__flow__util_8cpp_source.html">net_flow_util.cpp</a>.</p>

</div>
</div>
<a id="a665ca8642963a22acdc07e901dd23ee4" name="a665ca8642963a22acdc07e901dd23ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665ca8642963a22acdc07e901dd23ee4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>, along with its current value, to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">opts</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00152">152</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

</div>
</div>
<a id="a5d6e84102fc55993f914ec64d04566bc" name="a5d6e84102fc55993f914ec64d04566bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e84102fc55993f914ec64d04566bc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of given socket to given standard <code>ostream</code> and returns the latter. </p>
<p >The representation includes the local and remote endpoints and the hex pointer value.</p>
<dl class="section note"><dt>Note</dt><dd><code>shared_ptr</code> forwards <code>ostream</code> output to the underlying pointer type, so this will affect <code>Ptr</code> output as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">sock</td><td>Object to serialize. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06514">6514</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a13391099a7662dbbef0a2ea171d1e7e9" name="a13391099a7662dbbef0a2ea171d1e7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13391099a7662dbbef0a2ea171d1e7e9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter. </p>
<p >The representation is multi-line but ends in no newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to print. </td></tr>
    <tr><td class="paramname">stats</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="info_8cpp_source.html#l00513">513</a> of file <a class="el" href="info_8cpp_source.html">info.cpp</a>.</p>

</div>
</div>
<a id="ae43c5c856d519777fa381fc29b4bf581" name="ae43c5c856d519777fa381fc29b4bf581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43c5c856d519777fa381fc29b4bf581">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, along with its current value, to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">opts</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00484">484</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

</div>
</div>
<a id="ab9f537c84f77e9b8fa742fc5dc6d5693" name="ab9f537c84f77e9b8fa742fc5dc6d5693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f537c84f77e9b8fa742fc5dc6d5693">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy_choice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> to a standard <code>ostream</code> &ndash; the reverse of <a class="el" href="namespaceflow_1_1net__flow.html#aad968d3e7e9c3f284bea03e799d5fbc0" title="Deserializes a Peer_socket_options::Congestion_control_strategy_choice enum from a standard input str...">operator&gt;&gt;()</a>. </p>
<p >Writes a space-less token to the given stream based on the given strategy <code>enum</code> value. This enables a few key things to work, including output of defaults and values in the help via <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, and conversion to <code>string</code> via <code>boost::lexical_cast</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">strategy_choice</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cong__ctl_8cpp_source.html#l00146">146</a> of file <a class="el" href="cong__ctl_8cpp_source.html">cong_ctl.cpp</a>.</p>

</div>
</div>
<a id="a26fb85d618cb12e9ee1b22f52bdfcaa5" name="a26fb85d618cb12e9ee1b22f52bdfcaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fb85d618cb12e9ee1b22f52bdfcaa5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html">Peer_socket_receive_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter. </p>
<p >The representation is multi-line but ends in no newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to print. </td></tr>
    <tr><td class="paramname">stats</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="info_8cpp_source.html#l00156">156</a> of file <a class="el" href="info_8cpp_source.html">info.cpp</a>.</p>

</div>
</div>
<a id="a98357cf7d8e29ec9dd34bd11ab382108" name="a98357cf7d8e29ec9dd34bd11ab382108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98357cf7d8e29ec9dd34bd11ab382108">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html">Peer_socket_send_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter. </p>
<p >The representation is multi-line but ends in no newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to print. </td></tr>
    <tr><td class="paramname">stats</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="info_8cpp_source.html#l00286">286</a> of file <a class="el" href="info_8cpp_source.html">info.cpp</a>.</p>

</div>
</div>
<a id="a84e207ad5dc52f3832b5a5f73c75e11e" name="a84e207ad5dc52f3832b5a5f73c75e11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e207ad5dc52f3832b5a5f73c75e11e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html" title="Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...">Remote_endpoint</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">endpoint</td><td>Endpoint to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="endpoint_8cpp_source.html#l00065">65</a> of file <a class="el" href="endpoint_8cpp_source.html">endpoint.cpp</a>.</p>

</div>
</div>
<a id="a5b19eb9e5f0043bcad407520bd90c1f9" name="a5b19eb9e5f0043bcad407520bd90c1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b19eb9e5f0043bcad407520bd90c1f9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;&#160;</td>
          <td class="paramname"><em>seq_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints given sequence number to given <code>ostream</code>. </p>
<p >set_metadata()'s effects are felt here; see <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html" title="An internal net_flow sequence number identifying a piece of data.">Sequence_number</a> class doc header for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to print. </td></tr>
    <tr><td class="paramname">seq_num</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="seq__num_8cpp_source.html#l00169">169</a> of file <a class="el" href="seq__num_8cpp_source.html">seq_num.cpp</a>.</p>

</div>
</div>
<a id="a53102c8d63b1e7749104a263fb8574e8" name="a53102c8d63b1e7749104a263fb8574e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53102c8d63b1e7749104a263fb8574e8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td>
          <td class="paramname"><em>serv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of given socket to given standard <code>ostream</code> and returns the latter. </p>
<p >The representation includes the local endpoint and the hex pointer value.</p>
<dl class="section note"><dt>Note</dt><dd><code>shared_ptr</code> forwards <code>ostream</code> output to the underlying pointer type, so this will affect <code>Ptr</code> output as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">serv</td><td>Object to serialize. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00881">881</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

</div>
</div>
<a id="a23129de20e68f8e125ed8a9bbc483402" name="a23129de20e68f8e125ed8a9bbc483402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23129de20e68f8e125ed8a9bbc483402">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>sock_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a printable representation of the data in <code>sock_buf</code> to the given standard <code>ostream</code>. </p>
<p >Exactly one line per block is used. This implementation is slow; use only in DATA logging, or where performance does not matter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">sock_buf</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="socket__buffer_8cpp_source.html#l00176">176</a> of file <a class="el" href="socket__buffer_8cpp_source.html">socket_buffer.cpp</a>.</p>

</div>
</div>
<a id="ac57b16fd356cacb8432a8ce7b021b54c" name="ac57b16fd356cacb8432a8ce7b021b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57b16fd356cacb8432a8ce7b021b54c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of given event type to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">ev_type</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01532">1532</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

</div>
</div>
<a id="aebbf2b8f19e2b3d887fe234cd5bdcffc" name="aebbf2b8f19e2b3d887fe234cd5bdcffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbf2b8f19e2b3d887fe234cd5bdcffc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">Event_set::State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> state to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01509">1509</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

</div>
</div>
<a id="ad9a8fc9f0d8cdfef76158add1f1d1ddc" name="ad9a8fc9f0d8cdfef76158add1f1d1ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a8fc9f0d8cdfef76158add1f1d1ddc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000125">Todo:</a></b></dt><dd>There are a few guys like this which are marked <code>@internal</code> (Doxygen command) to hide from generated public documentation, and that works, but really they should not be visible in the publicly-exported (not in detail/) header source code; so this should be reorganized for cleanliness. The prototypes like this one can be moved to a detail/ header or maybe directly into .cpp that uses them (for those where it's only one).</dd></dl>
<p >Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06537">6537</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a48bc8803c67e75b955a1f2778a8ad2bf" name="a48bc8803c67e75b955a1f2778a8ad2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bc8803c67e75b955a1f2778a8ad2bf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00902">902</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

</div>
</div>
<a id="a9e6b5a60123429cfdfde6149a88ac508" name="a9e6b5a60123429cfdfde6149a88ac508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b5a60123429cfdfde6149a88ac508">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Whether <code>lhs</code> is equal to <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01157">1157</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

</div>
</div>
<a id="a8504aeca20f41a8f2b98ae04803a600e" name="a8504aeca20f41a8f2b98ae04803a600e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8504aeca20f41a8f2b98ae04803a600e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether <code>lhs</code> is equal to <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="endpoint_8cpp_source.html#l00060">60</a> of file <a class="el" href="endpoint_8cpp_source.html">endpoint.cpp</a>.</p>

</div>
</div>
<a id="aad968d3e7e9c3f284bea03e799d5fbc0" name="aad968d3e7e9c3f284bea03e799d5fbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad968d3e7e9c3f284bea03e799d5fbc0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy_choice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> from a standard input stream. </p>
<p >Reads a single space-delimited token from the given stream. Maps that token to an aforementioned enumeration value. If the token is not recognized or cannot be read, some reasonable default strategy is chosen. This enables a few key things to work, including parsing from config file/command line via and conversion from <code>string</code> via <code>boost::lexical_cast</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream from which to deserialize. </td></tr>
    <tr><td class="paramname">strategy_choice</td><td>Reference to <code>enum</code> value which to set to the mapped strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> stream inserter <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators should use the <a class="el" href="namespaceflow_1_1util.html#a18a29d6a6e65c3b96c52b5cad5971266" title="Deserializes an enum class value from a standard input stream.">flow::util::istream_to_enum()</a> pattern which is much easier than the overwrought old thing in there now involving two <code>map</code>s. Perhaps add a generic <code>enum_to_strings()</code> to provide the body for <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__selector.html#aca9ae5272088f3ef8fb81f40cc85224c" title="Returns a list of strings, called IDs, each of which textually represents a distinct Congestion_contr...">net_flow::Congestion_control_selector::get_ids()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cong__ctl_8cpp_source.html#l00124">124</a> of file <a class="el" href="cong__ctl_8cpp_source.html">cong_ctl.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9dd0c9d8de00fab78d8b0a3f50dad2a9" name="a9dd0c9d8de00fab78d8b0a3f50dad2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd0c9d8de00fab78d8b0a3f50dad2a9">&#9670;&nbsp;</a></span>S_PORT_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::S_PORT_ANY = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special Flow port value used to indicate "invalid port" or "please pick a random available ephemeral
port," depending on the context. </p>
<p >This is spiritually equivalent to TCP's port 0. </p>

<p class="definition">Definition at line <a class="el" href="port__space_8cpp_source.html#l00033">33</a> of file <a class="el" href="port__space_8cpp_source.html">port_space.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04011">flow::net_flow::Node::connect_worker()</a>, <a class="el" href="node_8cpp_source.html#l00426">flow::net_flow::Node::handle_incoming()</a>, <a class="el" href="server__socket_8cpp_source.html#l00218">flow::net_flow::Node::listen_worker()</a>, <a class="el" href="port__space_8cpp_source.html#l00045">flow::net_flow::Port_space::Port_space()</a>, <a class="el" href="port__space_8cpp_source.html#l00112">flow::net_flow::Port_space::reserve_ephemeral_port()</a>, and <a class="el" href="port__space_8cpp_source.html#l00075">flow::net_flow::Port_space::reserve_port()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 10 2024 01:42:58 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
