<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: net_flow/peer_socket.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_460afd45d0ec637b1427e0e06a6fbcf7.html">net_flow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">peer_socket.cpp</div></div>
</div><!--header-->
<div class="contents">
<a href="peer__socket_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/* Flow</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * Copyright 2023 Akamai Technologies, Inc.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> *</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> * Licensed under the Apache License, Version 2.0 (the</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> * &quot;License&quot;); you may not use this file except in</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> * compliance with the License.  You may obtain a copy</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment"> * of the License at</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"> *</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"> *</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment"> * Unless required by applicable law or agreed to in</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment"> * writing, software distributed under the License is</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment"> * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment"> * CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment"> * See the License for the specific language governing</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment"> * permissions and limitations under the License. */</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment"></span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment">/// @file</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment"></span><span class="preprocessor">#include &quot;<a class="code" href="peer__socket_8hpp.html">flow/net_flow/peer_socket.hpp</a>&quot;</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="preprocessor">#include &quot;<a class="code" href="drop__timer_8hpp.html">flow/net_flow/detail/drop_timer.hpp</a>&quot;</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="preprocessor">#include &quot;<a class="code" href="bandwidth_8hpp.html">flow/net_flow/detail/stats/bandwidth.hpp</a>&quot;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &quot;<a class="code" href="cong__ctl_8hpp.html">flow/net_flow/detail/cong_ctl.hpp</a>&quot;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &quot;<a class="code" href="node_8hpp.html">flow/net_flow/node.hpp</a>&quot;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="preprocessor">#include &quot;<a class="code" href="sched__task_8hpp.html">flow/util/sched_task.hpp</a>&quot;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &quot;<a class="code" href="async_2util_8hpp.html">flow/async/util.hpp</a>&quot;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="preprocessor">#include &lt;boost/algorithm/string.hpp&gt;</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span> </div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceflow_1_1net__flow.html">flow::net_flow</a></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>{</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span> </div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="comment">// Implementations.</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span> </div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="comment">// Peer_socket implementations.</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span> </div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">   37</a></span><a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">Peer_socket::Peer_socket</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr,</div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>                         <a class="code hl_typedef" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a>* task_engine,</div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>                         <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts) :</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>  Log_context(logger_ptr, <a class="code hl_enumeration" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">Flow_log_component</a>::S_NET_FLOW),</div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>  m_opts(opts),</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>  m_active_connect(false), <span class="comment">// Meaningless; set explicitly.</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span>  m_state(<a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a>::S_CLOSED), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>  m_open_sub_state(<a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a>::S_DISCONNECTING), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span>  m_node(0), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>  m_rcv_buf(logger_ptr, 0), <span class="comment">// Receive buffer mode: block size irrelevant (see Socket_buffer doc header).</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>   <span class="comment">// Send buffer mode: pack data into block-sized chunks for dequeueing speed.  See Socket_buffer doc header.</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>  m_snd_buf(logger_ptr, max_block_size()),</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>  m_serialized_metadata(logger_ptr),</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>  m_local_port(<a class="code hl_variable" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">S_PORT_ANY</a>), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>  m_int_state(<a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a>::S_CLOSED), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>  m_rcv_syn_rcvd_data_cumulative_size(0), <span class="comment">// Meaningless unless queue has elements but might as well initialize.</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>  m_rcv_reassembly_q_data_size(0),</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>  m_rcv_pending_acks_size_at_recv_handler_start(0),</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>  m_snd_pending_rcv_wnd(0), <span class="comment">// Meaningless originally but might as well initialize.</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>  m_rcv_last_sent_rcv_wnd(0),</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span>  m_rcv_in_rcv_wnd_recovery(false),</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>  m_rcv_delayed_ack_timer(*task_engine),</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span>  m_snd_flying_bytes(0),</div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span>  m_snd_last_order_num(0),</div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span>  m_snd_rexmit_q_size(0),</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>  m_snd_remote_rcv_wnd(0),</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span>  m_snd_smoothed_round_trip_time(0),</div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>  m_round_trip_time_variance(0),</div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>  m_snd_drop_timeout(0),</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>  m_snd_pacing_data(task_engine),</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>  m_security_token(0), <span class="comment">// Incorrect; set explicitly.</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>  m_init_rexmit_count(0)</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>{</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>  <span class="comment">// Only print pointer value, because most members are garbage at this point.</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Peer_socket [&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) &lt;&lt; <span class="stringliteral">&quot;] created.&quot;</span>);</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span> </div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>  <span class="comment">// Log initial option values.  Arguable if this should be INFO or TRACE.  @todo Reconsider?</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">options</a>());</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span>}</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span> </div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a729af2cb3465b67b811d8e9438b5af5d">   77</a></span><a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a729af2cb3465b67b811d8e9438b5af5d">Peer_socket::~Peer_socket</a>() <span class="comment">// Virtual.</span></div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>{</div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span>  <span class="comment">/* Note that m_snd_cong_ctl, m_snd_bandwidth_estimator (etc.) and others store no Ptr(this),</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment">   * so this dtor will indeed execute (no circular shared_ptr problem). */</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span> </div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Peer_socket [&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;] destroyed.&quot;</span>);</div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span>}</div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span> </div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">   85</a></span><a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">Peer_socket::state</a>(<a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a>* open_sub_state)<span class="keyword"> const</span></div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// State is liable to change at any time.</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span>  <span class="keywordflow">if</span> (open_sub_state &amp;&amp; (<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc">m_state</a> == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">State::S_OPEN</a>))</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span>  {</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    *open_sub_state = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95">m_open_sub_state</a>;</div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>  }</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc">m_state</a>;</div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span>}</div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span> </div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">   95</a></span><a class="code hl_class" href="classflow_1_1net__flow_1_1Node.html">Node</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">Peer_socket::node</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// m_node can simultaneously change to 0 if state changes to S_CLOSED.</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>;</div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span>}</div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span> </div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">  101</a></span><a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">Peer_socket::disconnect_cause</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>);</div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18">m_disconnect_cause</a>;</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span>}</div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span> </div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a94f1e498fdd2349075ee5bcd7906d308">  107</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">Peer_socket::sync_send</a>(std::nullptr_t, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>{</div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">sync_send</a>(<span class="keyword">nullptr</span>, Fine_duration::max(), err_code);</div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>}</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span> </div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">  112</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">Peer_socket::sync_send_reactor_pattern_impl</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span>{</div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span>  <span class="comment">// Similar to sync_send_impl(), so keeping comments light.  Reminder: Goal is to wait until *this is Writable.</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span> </div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<span class="keywordtype">size_t</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">sync_send_reactor_pattern_impl</a>, wait_until, _1);</div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span> </div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>);</div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span> </div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;size_t (<span class="keywordtype">size_t</span>)&gt; empty_snd_buf_feed_func;</div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span>  assert(empty_snd_buf_feed_func.empty());</div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span> </div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span>  lock.release();</div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span> </div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>  <span class="comment">// Intentionally pass empty function obj to indicate &quot;reactor pattern&quot; mode.</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">node_sync_send</a>(empty_snd_buf_feed_func, wait_until, err_code);</div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span>  <span class="keywordflow">return</span> !*err_code; <span class="comment">// Socket is Writable if and only if !*err_code (i.e., no timeout or other error while waiting).</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span>}</div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span> </div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe">  130</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe">Peer_socket::node_send</a>(<span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> (<span class="keywordtype">size_t</span> max_data_size)&gt;&amp; snd_buf_feed_func,</div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>                              <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>{</div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span>  <span class="comment">// Everything is locked.  (See send() template.)</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span> </div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span>  {</div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span>  }</div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span> </div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">send</a>(sock, snd_buf_feed_func, err_code);</div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span>}</div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span> </div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">  145</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">Peer_socket::node_sync_send</a>(<span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> (<span class="keywordtype">size_t</span> max_data_size)&gt;&amp; snd_buf_feed_func_or_empty,</div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span>                                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until,</div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span>                                   <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span>{</div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span>  <span class="keyword">using </span>boost::adopt_lock;</div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span> </div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>  <span class="comment">// Everything is locked.  (See sync_send() template.)</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>, adopt_lock); <span class="comment">// Adopt already-locked mutex.</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span> </div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>  {</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>  }</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span> </div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>  <span class="comment">/* Because all Node::sync_*() implementations would follow the same pattern (create Event_set,</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="comment">   * add Readable/Writable/Acceptable event, wait, try non-blocking op, if that fails try again with</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment">   * wait_until ever closer, etc.), for major code reuse we use the sync_op() function template and plug in</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment">   * the various Peer_socket/send-specific pieces as arguments.</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment">   *</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment">   * Performance cost: The only part about this that&#39;s not as fast as copy/pasting sync_op() N times, once</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment">   * for each type of socket/op, is the need to lambda the proper send() call into a function object.</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment">   * This amounts to storing and copying the arguments and the function pointer, which should not be</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment">   * too bad and is worth the code reuse IMO. */</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span> </div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>  lock.release(); <span class="comment">// Again, release lock (mutex is still locked!).</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span> </div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>  <span class="comment">/* Operating on Peer_sockets, returning size_t; Event_set socket set type is Peer_sockets.</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="comment">   * Object is sock; non-blocking operation is m_node-&gt;send(...) -- or N/A in &quot;reactor pattern&quot; mode.</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment">   * size_t(0) is the &quot;would-block&quot; return value for this operation.  S_PEER_SOCKET_WRITABLE</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">   * is the type of event to watch for here. */</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span>           -&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">sync_op</a>&lt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">Peer_socket</a>, <span class="keywordtype">size_t</span>&gt;</div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span>               (sock,</div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span>                snd_buf_feed_func_or_empty.empty()</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span>                  ? <a class="code hl_class" href="classflow_1_1Function.html">Function&lt;size_t ()&gt;</a>() <span class="comment">// Reactor pattern mode.</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>                  : <a class="code hl_class" href="classflow_1_1Function.html">Function&lt;size_t ()&gt;</a>([<span class="keyword">this</span>, sock, snd_buf_feed_func_or_empty, err_code]() -&gt; <span class="keywordtype">size_t</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>                                          { <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">send</a>(sock, snd_buf_feed_func_or_empty, err_code); }),</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span>                0, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a>,</div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>                wait_until, err_code);</div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>} <span class="comment">// Peer_socket::node_sync_send()</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span> </div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a207b46e4bd4d251f54951ce1e5d7439f">  188</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">Peer_socket::sync_receive</a>(std::nullptr_t, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>{</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">sync_receive</a>(<span class="keyword">nullptr</span>, Fine_duration::max(), err_code);</div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>}</div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span> </div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">  193</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">Peer_socket::sync_receive_reactor_pattern_impl</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span>{</div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span>  <span class="comment">// Similar to sync_receive_impl(), so keeping comments light.  Reminder: Goal is to wait until *this is Readable.</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span> </div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<span class="keywordtype">size_t</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">sync_receive_reactor_pattern_impl</a>, wait_until, _1);</div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span> </div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>);</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span> </div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;size_t ()&gt; empty_rcv_buf_consume_func;</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span>  assert(empty_rcv_buf_consume_func.empty());</div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span> </div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span>  lock.release();</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span> </div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>  <span class="comment">// Intentionally pass empty function obj to indicate &quot;reactor pattern&quot; mode.</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">node_sync_receive</a>(empty_rcv_buf_consume_func, wait_until, err_code);</div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span>  <span class="keywordflow">return</span> !*err_code; <span class="comment">// Socket is Readable if and only if !*err_code (i.e., no timeout or other error while waiting).</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>}</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span> </div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657">  211</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657">Peer_socket::node_receive</a>(<span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> ()&gt;&amp; rcv_buf_consume_func,</div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span>                                 <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>{</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>  <span class="comment">// Everything is locked.  (See receive() template.)</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span> </div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>  {</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>  }</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span> </div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">receive</a>(sock, rcv_buf_consume_func, err_code);</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>}</div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span> </div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">  226</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">Peer_socket::node_sync_receive</a>(<span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> ()&gt;&amp; rcv_buf_consume_func_or_empty,</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>                                      <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until,</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span>                                      <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>{</div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>  <span class="keyword">using </span>boost::adopt_lock;</div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span> </div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span>  <span class="comment">// Everything is locked.  (See sync_send() template.)</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>, adopt_lock); <span class="comment">// Adopt already-locked mutex.</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span> </div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>  {</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>  }</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span> </div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>  lock.release(); <span class="comment">// Again, release lock (mutex is still locked!).</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span> </div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>  <span class="comment">// See comment in Peer_socket::node_sync_send().</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span> </div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>  <span class="comment">/* Operating on Peer_sockets, returning size_t; Event_set socket set type is Peer_sockets.</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="comment">   * Object is sock; non-blocking operation is m_node-&gt;receive(...) -- or N/A in &quot;reactor pattern&quot; mode.</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="comment">   * size_t(0) is the &quot;would-block&quot; return value for this operation.   S_PEER_SOCKET_READABLE</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment">   * is the type of event to watch for here. */</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>           -&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">sync_op</a>&lt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">Peer_socket</a>, <span class="keywordtype">size_t</span>&gt;</div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>               (sock,</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>                rcv_buf_consume_func_or_empty.empty()</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>                  ? <a class="code hl_class" href="classflow_1_1Function.html">Function&lt;size_t ()&gt;</a>() <span class="comment">// Reactor pattern mode.</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>                  : <a class="code hl_class" href="classflow_1_1Function.html">Function&lt;size_t ()&gt;</a>([<span class="keyword">this</span>, sock, rcv_buf_consume_func_or_empty, err_code]() -&gt; <span class="keywordtype">size_t</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>                                          { <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">receive</a>(sock, rcv_buf_consume_func_or_empty, err_code); }),</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>                0, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">Event_set::Event_type::S_PEER_SOCKET_READABLE</a>,</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>                wait_until, err_code);</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>} <span class="comment">// Peer_socket::node_sync_receive()</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span> </div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">  261</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">Peer_socket::close_abruptly</a>(<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>{</div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceflow_1_1error.html#a48afa7f8c2e100acd461365dfb00a114">flow::error::exec_void_and_throw_on_error</a></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span>        ([<span class="keyword">this</span>](<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* actual_err_code) { <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">close_abruptly</a>(actual_err_code); },</div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>         err_code, <a class="code hl_define" href="util__fwd_8hpp.html#a0cc4c82ac54e53b7a8a2431b66ff30df">FLOW_UTIL_WHERE_AM_I_STR</a>()))</div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>  {</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>  }</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span> </div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>  <span class="comment">// We are in user thread U != W.</span></div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span> </div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// Lock m_node/m_state; also it&#39;s a pre-condition for Node::close_abruptly().</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span> </div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span>  {</div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span>    <span class="comment">// *err_code will be set to original close reason (m_disconnect_cause) in this case, as advertised.</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>  }</div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span> </div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span>  <span class="comment">// Forward to Node, as is the general pattern for Peer_socket method implementations.</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span>  lock.release(); <span class="comment">// Let go of the mutex (mutex is still LOCKED).</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>  <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">close_abruptly</a>(sock, err_code);</div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>  <span class="comment">// No m_mutex.unlock(): Node::close_abruptly() MUST take care of it.</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span>} <span class="comment">// Peer_socket::close_abruptly()</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span> </div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">  289</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">Peer_socket::set_options</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>{</div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<span class="keywordtype">bool</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">set_options</a>, opts, _1);</div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span>  <span class="comment">// ^-- Call ourselves and return if err_code is null.  If got to present line, err_code is not null.</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span> </div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span>  <span class="comment">// We are in thread U != W.</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span> </div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// Lock m_node at least.</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span> </div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, err_code)) <span class="comment">// Ensure it&#39;s open, so that we can access m_node.</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span>  {</div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span>  }</div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span> </div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span>  <span class="comment">// As is typical elsewhere, pass the rest of the logic to a Node method.</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">sock_set_options</a>(sock, opts, err_code);</div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span>} <span class="comment">// Peer_socket::set_options()</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span> </div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">  309</a></span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">Peer_socket::options</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">opt</a>(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a>);</div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span>}</div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span> </div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">  314</a></span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">Peer_socket::info</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span>  <span class="comment">// We are in user thread U != W.</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span> </div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span>  <span class="comment">/* There are two cases.  If the socket is open (not S_CLOSED), then an m_node owns it and may</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment">   * change the stats we want to copy in its thread W at any time.  In this case we must copy it in</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="comment">   * thread W (which we do using a future and post(io_context&amp;), as in listen() and other places in</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span><span class="comment">   * Node).  In the socket is closed (S_CLOSED), then no m_node owns it, so there is no thread W</span></div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment">   * applicable to this socket anymore, and we can just copy the data in thread U != W. */</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span> </div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// Lock m_node; also it&#39;s a pre-condition for Node::sock_info().</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span> </div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a> sock = shared_from_this();</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span> </div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>  <span class="comment">// See which case it is.</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span>  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> dummy;</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(sock, &amp;dummy))</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>  {</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>    <span class="comment">// Socket is closed.  Done and done.  Return the final stats cached at S_CLOSED time.</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ac4c942e1bb6c4dc4b24251f294a2f92d">m_info_on_close</a>;</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>  }</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>  <span class="comment">// else m_node is valid.</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span> </div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>  <span class="comment">// Forward to Node, as is the general pattern for Peer_socket method implementations.</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>  lock.release(); <span class="comment">// Let go of the mutex (mutex is still LOCKED).</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a>-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">sock_info</a>(sock);</div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span>  <span class="comment">// No m_mutex.unlock(): Node::sock_info() MUST take care of it.</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span>} <span class="comment">// Peer_socket::info()</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span> </div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">  343</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">Peer_socket::max_block_size</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">opt</a>(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a>.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a>);</div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span>}</div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span> </div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a102b78eaac9c8add512238ec5f26fcfc">  348</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a102b78eaac9c8add512238ec5f26fcfc">Peer_socket::max_block_size_multiple</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; opt_val_ref,</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span>                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* inflate_pct_val_ptr)<span class="keyword"> const</span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>  <span class="comment">// Similar to opt() but specialized for this purpose.  Lock once to get both values.</span></div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Options_lock</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a">m_opts_mutex</a>);</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span> </div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a> = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a>.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a>;</div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inflate_pct = inflate_pct_val_ptr ? (*inflate_pct_val_ptr) : 0;</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span> </div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span>  <span class="comment">/* We want N&#39;s nearest multiple M of B such that M &gt;= N.  M = ceil(N/B) * B (no actual floating-point math involved).</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment">   *</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment">   * Oh, and N is opt_val_ref inflated by K%, or opt_val_ref * (100 + K)%. */</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceflow_1_1util.html#a6b7316b3ed6d89f54c91e17c2aab101e">util::ceil_div</a>(opt_val_ref * (100 + inflate_pct) / 100, <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a>)</div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span>         * <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a>;</div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span>}</div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span> </div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">  364</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">Peer_socket::rexmit_on</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">opt</a>(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a>.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360">m_st_rexmit_on</a>);</div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span>}</div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span> </div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">  369</a></span><span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">Peer_socket::remote_endpoint</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span>  <span class="comment">// Can&#39;t change; no locking needed.  Safe info even if S_CLOSED.</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a218ec098984b754b43940001f59ab787">m_remote_endpoint</a>;</div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span>}</div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span> </div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">  375</a></span><a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">Peer_socket::local_port</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span>  <span class="comment">// Can&#39;t change; no locking needed.  Safe (if outdated) info even if S_CLOSED.</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd">m_local_port</a>;</div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span>}</div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span> </div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">  381</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">Peer_socket::get_connect_metadata</a>(<span class="keyword">const</span> boost::asio::mutable_buffer&amp; buffer,</div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span>                                         <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)<span class="keyword"> const</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span>  <span class="keyword">using </span>std::memcpy;</div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span> </div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<span class="keywordtype">size_t</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">get_connect_metadata</a>, buffer, _1);</div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span>  <span class="comment">// ^-- Call ourselves and return if err_code is null.  If got to present line, err_code is not null.</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span> </div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span>  <span class="comment">// We are in user thread U != W.</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span> </div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a>); <span class="comment">// Lock m_serialized_metadata (it can be changed in sock_free_memory()).</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span> </div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">ensure_open</a>(err_code)) <span class="comment">// Ensure it&#39;s open; other m_serialized_metadata has been cleared.</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span>  {</div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span>  }</div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span>  <span class="comment">// else m_serialized_metadata is valid.</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span> </div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span>  err_code-&gt;clear();</div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = std::min(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686">m_serialized_metadata</a>.size(), buffer.size());</div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span>  <span class="keywordflow">if</span> (size != 0)</div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span>  {</div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span>    memcpy(buffer.data(), <a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686">m_serialized_metadata</a>.const_data(), size);</div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span>  }</div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span> </div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span>  <span class="keywordflow">return</span> size;</div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span>} <span class="comment">// Peer_socket::get_connect_metadata()</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span> </div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">  409</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">Peer_socket::ensure_open</a>(<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)<span class="keyword"> const</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(shared_from_this(), err_code);</div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span>}</div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span> </div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#acd100a3c02fad5d9e00fcbc1f645f116">  414</a></span>std::string <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#acd100a3c02fad5d9e00fcbc1f645f116">Peer_socket::bytes_blocks_str</a>(<span class="keywordtype">size_t</span> bytes)<span class="keyword"> const</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span> </div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span>  <span class="keyword">const</span> <span class="keyword">auto</span> block = <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a>();</div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span>  String_ostream os;</div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span>  os.os() &lt;&lt; bytes &lt;&lt; <span class="charliteral">&#39;~&#39;</span> &lt;&lt; (bytes / block);</div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span>  <span class="keywordflow">if</span> ((bytes % block) != 0)</div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span>  {</div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span>    os.os() &lt;&lt; <span class="charliteral">&#39;+&#39;</span>;</div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span>  }</div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span>  os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span>  <span class="keywordflow">return</span> os.str();</div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span>}</div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span> </div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno"><a class="line" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a28eb52fe9520497d02f6c0cd51a5fa9b">  430</a></span><a class="code hl_function" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a28eb52fe9520497d02f6c0cd51a5fa9b">Peer_socket::Sent_packet::Sent_packet</a>(<span class="keywordtype">bool</span> rexmit_on,</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span>                                      boost::shared_ptr&lt;Data_packet&gt; packet,</div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span>                                      <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Sent_when</a>&amp; sent_when) :</div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span>  m_size(packet-&gt;m_data.size()),</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>  m_sent_when({ sent_when }),</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>  m_acks_after_me(0),</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>  m_packet(<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> ? packet : boost::shared_ptr&lt;Data_packet&gt;()) <span class="comment">// Store packet only if we may have to rexmit later.</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span>{</div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span>  <span class="comment">// Nothing.</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>}</div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span> </div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno"><a class="line" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a9f0809d5dd7272e31f4111ee2be97330">  441</a></span><a class="code hl_function" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a9f0809d5dd7272e31f4111ee2be97330">Peer_socket::Received_packet::Received_packet</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>* src_data) :</div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>  m_size(size),</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span>  m_data(logger_ptr)</div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>{</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>  <span class="keywordflow">if</span> (src_data)</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>  {</div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span>    <span class="comment">// Retransmission is on: save *src_data for later reassembly.</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span>    assert(<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a7d0760b1dead081bdcf775fbca7f708b">m_size</a> == size); <span class="comment">// As promised in docs....</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span> </div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span>    <a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#ac3e88e37e53d2572f89c599e520e3e2a">m_data</a> = std::move(*src_data); <span class="comment">// O(1) operation -- *src_data is probably cleared.</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span>  }</div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span>}</div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span> </div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment">// Node implementations (dealing with individual Peer_sockets).</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span> </div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span><span class="comment">// Static initializations.</span></div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span> </div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span><span class="comment">// Per RFC 5681 (Reno Fast Recovery; used in other congestion control specifications as well to detect drops).</span></div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="keyword">const</span> <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">Peer_socket::Sent_packet::ack_count_t</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">Node::S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</a> = 2;</div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">Node::S_DEFAULT_CONN_METADATA</a> = 0; <span class="comment">// Keep in sync with doc get_connect_metadata() doc header.</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span> </div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment">// Implementations.</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span> </div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">  464</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">Node::handle_syn_ack_to_syn_sent</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id,</div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span>                                      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span>                                      boost::shared_ptr&lt;const Syn_ack_packet&gt; syn_ack)</div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span>{</div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span> </div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span>  <span class="comment">/* We&#39;d sent SYN and just got SYN_ACK.  Assuming their SYN is valid, our side of connection can</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="comment">   * move to ESTABLISHED state.  We can also complete the other side&#39;s connection by sending</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span><span class="comment">   * SYN_ACK_ACK. */</span></div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span> </div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread continuing active-connect of [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span>                <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; syn_ack-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span>                <span class="stringliteral">&quot;ISN [&quot;</span> &lt;&lt; syn_ack-&gt;m_init_seq_num &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span>                <span class="stringliteral">&quot;security token [&quot;</span> &lt;&lt; syn_ack-&gt;m_packed.m_security_token &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span> </div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span>  <span class="comment">// Send SYN_ACK_ACK to finish the handshake.</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span> </div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span>  async_low_lvl_syn_ack_ack_send(sock, syn_ack);</div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span>  <span class="comment">/* send will happen asynchronously, and the registered completion handler will execute in this</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment">   * thread when done (NO SOONER than this method finishes executing). */</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span> </div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span>  <span class="comment">// Handle the logical SYN part of their SYN_ACK.</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span> </div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span>  <span class="comment">// Save the start of the sequence number series based on their initial sequence number.</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span>  sock-&gt;m_rcv_init_seq_num = syn_ack-&gt;m_init_seq_num;</div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span>  sock-&gt;m_rcv_next_seq_num = sock-&gt;m_rcv_init_seq_num + 1;</div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span> </div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span>  <span class="comment">// Move ourselves to connected state.</span></div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span> </div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span>  <span class="comment">// Public state.</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span>  sock_set_state(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>);</div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>  <span class="comment">// Internal state.  SYN_SENT -&gt; ESTABLISHED.</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span>  sock_set_int_state(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>);</div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span> </div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span>  <span class="comment">// Got the acknowledgment to SYN, so cancel retransmits and the timeout for that SYN.</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span>  cancel_timers(sock);</div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span> </div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span>  <span class="comment">// Setup the Drop Timeout engine (m_snd_drop_timer).</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span>  setup_drop_timer(socket_id, sock);</div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span> </div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span>  <span class="comment">// Record initial rcv_wnd; it should be the entire size of the other side&#39;s Receive buffer.</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span>  sock-&gt;m_snd_remote_rcv_wnd = syn_ack-&gt;m_packed.m_rcv_wnd;</div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span> </div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span>  <span class="comment">/* Since sock is now connected and has an empty Send buffer, it is certainly now Writable.</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">   * Therefore we should soon inform anyone waiting on any Event_sets for sock to become Writable.</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment">   *</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment">   * Caveat: Similar to that in Node::handle_syn_ack_ack_to_syn_rcvd() at similar point in the</span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment">   * code. */</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span> </div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>  <span class="comment">// Accumulate the event into the Node store (note: not any Event_set yet).</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>  <span class="keywordflow">if</span> (m_sock_events[<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a>].insert(sock).second)</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span>  {</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>    <span class="comment">// Possibly inform the user for any applicable Event_sets right now.</span></div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>    event_set_all_check_delta(<span class="keyword">true</span>);</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>    <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="comment">     * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment">     * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span>  }</div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span>} <span class="comment">// Node::handle_syn_ack_to_syn_sent()</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span> </div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">  524</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">Node::handle_syn_ack_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span>                                         boost::shared_ptr&lt;const Syn_ack_packet&gt; syn_ack)</div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span>{</div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span> </div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span>  <span class="comment">/* We&#39;re ESTABLISHED but got a duplicate (valid) SYN_ACK again.  For reasons explained in</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="comment">   * handle_incoming() at the call to the current method, we simply give them a SYN_ACK_ACK again</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment">   * and continue like nothing happened. */</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span> </div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span>                <span class="stringliteral">&quot;In [&quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a> &lt;&lt; <span class="stringliteral">&quot;] state &quot;</span></div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span>                <span class="stringliteral">&quot;received duplicate [&quot;</span> &lt;&lt; syn_ack-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span>                <span class="stringliteral">&quot;ISN [&quot;</span> &lt;&lt; syn_ack-&gt;m_init_seq_num &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span>                <span class="stringliteral">&quot;security token [&quot;</span> &lt;&lt; syn_ack-&gt;m_packed.m_security_token &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span>                <span class="stringliteral">&quot;Could be from packet loss.&quot;</span>);</div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span> </div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span>  <span class="comment">// Everything has already been validated.</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span> </div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>  async_low_lvl_syn_ack_ack_send(sock, syn_ack);</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span>} <span class="comment">// Node::handle_syn_ack_to_established()</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span> </div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">  545</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">Node::handle_data_to_established</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id,</div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span>                                      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span>                                      boost::shared_ptr&lt;Data_packet&gt; packet,</div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span>                                      <span class="keywordtype">bool</span> syn_rcvd_qd_packet)</div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span>{</div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span>  <span class="comment">/* This is a complex method that does many things.  Therefore readability is hard to accomplish, as the logic</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="comment">   * makes sense when writing it, but the big picture is hard to see when reading it.  The necessary heavy commenting</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="comment">   * further increases the size and therefore (along that dimension) decreases readability.  For these reasons,</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment">   * many logically distinct parts were placed into helper methods -- not to increase code reuse but to help</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment">   * the aforementioned consideration. */</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span> </div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span> </div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span>  <span class="comment">/* Connection is open, and we got data from other side.  Note: For maintainability, this method features</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment">   * (and should continue to feature) mainly high-level flow control and method calls, as opposed to tons of lower-level</span></div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment">   * detail (this should be factored out into methods being called).</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment">   *</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span><span class="comment">   * Summary of below (assuming no misbehavior by other side; also ignoring that every action is categorized</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="comment">   * in sock-&gt;m_rcv_stats for statistical purposes):</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span><span class="comment">   *</span></div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment">   *   - Determine `dupe` (is packet a duplicate of previously received packet?) by checking against</span></div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment">   *     sock-&gt;m_rcv_{next_seq_num|packets_with_gaps}.  If so:</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span><span class="comment">   *     - (Op AAA) Acknowledge packet (ACK to other side).</span></div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment">   *     - Return (do not close connection).</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment">   *   - Determine `slide` (are packet&#39;s data the next expected [first -- by seq. # -- not-yet-received] data?)</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="comment">   *     by checking against sock-&gt;m_rcv_{next_seq_num|packets_with_gaps}.</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="comment">   *   - If retransmission is off:</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="comment">   *     - (Op ###) Pass packet&#39;s data to Receive buffer sock-&gt;m_rcv_buf!</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span><span class="comment">   *       - Except if that would overflow sock-&gt;m_rcv_buf, then return (do not close connection).</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="comment">   *     - (Op %%%) Inform the event subsystem that Receive buffer is readable!</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment">   *     - (Op AAA)</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment">   *     - If (!slide):</span></div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment">   *       - Save packet info (except packet-&gt;m_data itself!) in sock-&gt;m_rcv_packets_with_gaps.</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment">   *         - But if that overflows sock-&gt;m_rcv_packets_with_gaps, then also pretend</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment">   *           gap before start of sock-&gt;m_rcv_packets_with_gaps has all been filled: set `slide = true;`.</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment">   *           (This will cause below to pop sock-&gt;m_rcv_packets_with_gaps to not overflow.)</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment">   *     - If `slide`:</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment">   *       - (Op ***) Update sock-&gt;m_rcv_{next_seq_num|packets_with_gaps} (increment the former,</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment">   *         possibly pop-front contiguous packets from the other).</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment">   *   - Else, if retransmission is on:</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span><span class="comment">   *     - If `slide`:</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span><span class="comment">   *       - (Op ###)</span></div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span><span class="comment">   *       - (Op ***)</span></div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment">   *         - Plus, for each packet popped from sock-&gt;m_rcv_packets_with_gaps, in increasing seq. # order:</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment">   *           Pass packet&#39;s data to Receive buffer sock-&gt;m_rcv_buf!</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment">   *       - (Op %%%)</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment">   *     - Else if (!slide):</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment">   *       - Save packet info (including packet-&gt;m_data itself!) in sock-&gt;m_rcv_packets_with_gaps (reassembly queue).</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment">   *         - But if that WOULD overflow sock-&gt;m_rcv_packets_with_gaps, then don&#39;t;</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment">   *           and return (do not close connection).</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment">   *     - (Op AAA) */</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span> </div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>  <span class="comment">/* Set up some short-hand references to commonly used sock members.  This should also help</span></div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="comment">   * performance a little by skipping the shared_ptr dereference.  (Should be safe since sock</span></div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment">   * cannot get ref-counted down to zero in this method, unless there is an error, at which point</span></div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span><span class="comment">   * we return anyway.)  Just remember these are not simply local variables -- nor const references -- but refer</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span><span class="comment">   * to on-the-heap stuff! */</span></div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = packet-&gt;m_seq_num;</div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span> </div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>  <span class="keyword">auto</span>&amp; data = packet-&gt;m_data; <span class="comment">// NOT const, since we may well be _moving_ this into Receive buffer, etc.</span></div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>  assert(!data.empty()); <span class="comment">// This should have been verified immediately in handle_incoming().</span></div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span>  <span class="comment">// Save this before we possibly destroy `data`&#39;s contents below when _moving_ into Receive buffer, etc.</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> data_size = data.size();</div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span> </div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>  <span class="comment">// Register one packet with N bytes of data (not necessarily acceptable data).</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a6e40a6152711f5ee78275180612f71dd">total_data_packet</a>(data_size);</div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span> </div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span>  <span class="comment">// Before potential changes, log.</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span> </div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span>                 <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span>                 <span class="stringliteral">&quot;sequence number [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;]; data size [&quot;</span> &lt;&lt; data_size &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span>  <span class="comment">// Very verbose and CPU-intensive!</span></div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>  <a class="code hl_define" href="log_8hpp.html#a07561c1c3f16b6c2c7335a09e25298c9">FLOW_LOG_DATA</a>(<span class="stringliteral">&quot;Data [&quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceflow_1_1util.html#a16357344c21456b86b7de3085e2661a2">util::buffers_dump_string</a>(data.const_buffer(), <span class="stringliteral">&quot;&quot;</span>, <span class="keywordtype">size_t</span>(-1)) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span>  <span class="comment">// In below TRACE logging we will omit most of the above details, since they&#39;ll be already logged.</span></div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span> </div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span>  log_rcv_window(sock); <span class="comment">// Especially log this state.</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span> </div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span>  <span class="comment">/* Compute `dupe` and `slide[_size]`, bits of info that are key to how the incoming packet fits into the rcv window.</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="comment">   * Also, regardless of anything else we need to register N bytes worth of data in DATA packets via</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><span class="comment">   * one rcv_stats.&lt;...&gt;_data_packet(data_size); we can determine the &lt;...&gt; based on dupe, slide, or lack thereof. */</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span> </div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span>  <span class="comment">/* True will means it&#39;s a duplicate packet -- ACK but don&#39;t give to the user again.</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span><span class="comment">   * False will mean it&#39;s a new packet -- ACK and save to a buffer for eventual consumption (unless overflow). */</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span>  <span class="keywordtype">bool</span> dupe;</div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span>  <span class="comment">// Will mean this packet is the first (by seq. #) unreceived packet we want.  Only applies if !dupe.</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span>  <span class="keywordtype">bool</span> slide;</div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span>  <span class="comment">/* ^-- @todo Eliminate this; use slide_size == 0 to mean !slide? Less state is a good thing.</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="comment">   * Also, slide_size can be assumed to be data_size, except in one case below -- *never* via</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="comment">   * sock_categorize_data_to_established(); both of these improvements will lead to cleaner code. */</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span>  <span class="keywordtype">size_t</span> slide_size; <span class="comment">// If (slide), this will be how much to increment m_rcv_next_seq_num.</span></div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span> </div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> cat_result = sock_categorize_data_to_established(sock, packet, &amp;dupe, &amp;slide, &amp;slide_size);</div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span>  <span class="keywordflow">if</span> (cat_result)</div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span>  {</div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span>    <span class="comment">// Register one packet with N bytes of data (not acceptable due to error).</span></div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ab45ad2bb462371067b09ae4f97935a78">error_data_packet</a>(data_size);</div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span> </div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span>    <span class="comment">/* Close connection in our structures (inform user if necessary as well).  Pre-conditions</span></div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span><span class="comment">     * assumed by call: sock in m_socks and sock-&gt;state() == S_OPEN (yes, since m_int_state ==</span></div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span><span class="comment">     * S_ESTABLISHED); 3rd arg contains the reason for the close (yes).  This will empty the Send</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span><span class="comment">     * and Receive buffers.  That is OK, because this is the abrupt type of close (error). */</span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span>    rst_and_close_connection_immediately(socket_id, sock, cat_result, <span class="keyword">true</span>);</div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span>    <span class="comment">// ^-- defer_delta_check == true: for similar reason as in handle_syn_ack_ack_to_syn_rcvd().</span></div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span>  }</div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span> </div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span>  <span class="comment">// If we got here, no error so far; `dupe` and `slide` are both set properly.</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span> </div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span>  <span class="keywordflow">if</span> (dupe)</div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span>  {</div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span>    <span class="comment">/* It&#39;s a duplicate received packet.  We should still acknowledge every valid packet, even if</span></div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span><span class="comment">     * duplicate, since at least it helps the other side measure congestion.  Is it &quot;lying,&quot; since</span></div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span><span class="comment">     * we&#39;re throwing this dupe away?  No, because we DID receive it earlier; and in fact that</span></div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span><span class="comment">     * earlier packet&#39;s ACK packet may have itself gotten lost by the network.  (Example: A sends P</span></div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment">     * to B; A receives and responds with ACK of P; that&#39;s lost; A receives dupe of P and responds</span></div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment">     * with ACK; B receives that ACK.  Good.)  Anyway if the other side doesn&#39;t like it, it can just</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span><span class="comment">     * ignore it.</span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment">     *</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment">     * It is also important to ack a duplicate packet, if retransmission is enabled.  For example,</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="comment">     * sender may send packet X, and we&#39;ll ack it; but the ACK may be lost.  Then the sender will</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment">     * retransmit X thinking X was lost; if we don&#39;t ACK the retransmitted one, the sender will</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment">     * retransmit again, until it runs out of retransmissions and closes connection... all because</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment">     * of one lousy lost ACK. */</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span> </div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span>    <span class="comment">// Plenty of TRACE logging about duplicate packets above; and here is probably too verbose for an INFO; =&gt; no log.</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span> </div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span>    <span class="comment">// Register one packet with N bytes of data (not acceptable into Receive buffer but probably legal, just late).</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#af841e2009909b4166ee1f821e7054eff">late_or_dupe_data_packet</a>(data_size);</div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span> </div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>    <span class="comment">// Register one individual acknowledgment of N bytes of data (will go out but acks late DATA).</span></div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a67e90d9c299777769ad090b24ba060cf">late_or_dupe_to_send_ack_packet</a>(data_size);</div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span> </div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span>    <span class="comment">// ACK will happen asynchronously (not in this handler, and at best once UDP net-stack considers itself writable).</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span>    async_acknowledge_packet(sock, seq_num, packet-&gt;m_rexmit_id, data_size); <span class="comment">// rcv_stats kept inside.</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>  }</div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>  <span class="comment">// else if (!dupe), i.e. data to be saved in Receive buffer or reassembly queue (unless overflow).</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span> </div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>  <span class="comment">// Register one packet with N bytes of data (legal and acceptable into Receive buffer).</span></div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#aa44f429fb274ae4fad21efbc88aa9b95">good_data_packet</a>(data.size());</div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span> </div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span>  <span class="comment">/* Behavior is different at this point depending on whether retransmission is enabled or</span></div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span><span class="comment">   * disabled.  Many of the building blocks are the same and have been factored out into helpers. */</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span> </div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span>  {</div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span>    <span class="comment">/* No retransmission, so things are fairly simple.  Firstly any new received data go</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span><span class="comment">     * straight to Receive buffer (out of order or not). */</span></div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span> </div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span>    <span class="keywordflow">if</span> (!sock_data_to_rcv_buf_unless_overflow(sock, packet))</div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span>    {</div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span>      <span class="comment">/* Not so fast.  There&#39;s no space in the Receive buffer, so there&#39;s no choice except to drop the</span></div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span><span class="comment">       * packet despite all of the above.  Note that this means the packet was not &quot;received&quot; (and</span></div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span><span class="comment">       * we can&#39;t slide the window forward either).</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span><span class="comment">       *</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span><span class="comment">       * Should we RST/close?  Absolutely not.  The sender did nothing wrong (except maybe they suck</span></div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span><span class="comment">       * at detecting congestion caused by our user not reading the Receive buffer fast enough and</span></div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span><span class="comment">       * thus letting it fill up, or maybe they just suck at congestion control).  Our user is not</span></div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span><span class="comment">       * consuming the Receive buffer in time.  We drop packet and let chips fall where they may</span></div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span><span class="comment">       * (reliability measures will handle it).</span></div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span><span class="comment">       *</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span><span class="comment">       * Should we still acknowledge it?  No.  Dropping a packet at this late stage is still</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span><span class="comment">       * dropping a packet and indicates congestion of the network, of sorts; if we ACK it, the</span></div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span><span class="comment">       * other side will assume the packet is being delivered and won&#39;t slow down its packet</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span><span class="comment">       * onslaught.  So nothing else to. */</span></div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span>    }</div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span> </div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>    <span class="comment">/* DO NOT use `data` from this point forward -- it was just emptied by sock_data_to_rcv_buf_unless_overflow()!</span></div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span><span class="comment">     * data_size is fine. */</span></div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span> </div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span>    <span class="comment">/* Since sock now has a non-empty Receive buffer, it is certainly now Readable.  Handle implications</span></div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span><span class="comment">     * on relevant waiting Event_sets. */</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span>    sock_rcv_buf_now_readable(sock, syn_rcvd_qd_packet);</div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span> </div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span>    <span class="comment">// Successfully wrote to Receive buffer.  Can certainly acknowledge it at this point.</span></div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span> </div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span>    <span class="comment">// Register one individual acknowledgment of N bytes of data (will go out and acks new, acceptable DATA).</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a7f68edbb903370ec36fa2deac09288ee">good_to_send_ack_packet</a>(data_size);</div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span> </div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span>    <span class="comment">// ACK will happen asynchronously (not in this handler, and at best once UDP net-stack considers itself writable).</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span>    async_acknowledge_packet(sock, seq_num, 0, data_size); <span class="comment">// rcv_stats kept inside.</span></div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span> </div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span>    <span class="keywordflow">if</span> (!slide)</div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span>    {</div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span>      <span class="comment">/* !slide means new packet didn&#39;t resolve the first unreceived gap; hence by definition</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment">       * sock-&gt;m_rcv_packets_with_gaps must be updated. Due to certain overflow mechanisms, this may also</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment">       * cause the removal of part of the first gap, ironically! So pass in &amp;slide, etc.</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span><span class="comment">       *</span></div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span><span class="comment">       * Pass in data_size, since data.size() would run on an emptied `data` as noted above and be useless. */</span></div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span>      sock_track_new_data_after_gap_rexmit_off(sock, packet, data_size, &amp;slide, &amp;slide_size);</div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span> </div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span>      <span class="comment">// `slide` may now be true or not.</span></div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span>    }</div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span> </div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span>    <span class="comment">// `slide` may now be true or not.</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span> </div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span>    <span class="comment">/* Finally, update the window, since we&#39;ve received a new packet.  Maintain large invariant described in doc headers</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="comment">     * for Peer_socket::m_rcv_packets_with_gaps and related members. */</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span> </div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span>    <span class="keywordflow">if</span> (slide)</div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span>    {</div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span>      sock_slide_rcv_next_seq_num(sock, slide_size, <span class="keyword">false</span>);</div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span>    }</div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span>  } <span class="comment">// if (!rexmit_on)</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span>  <span class="keywordflow">else</span> <span class="comment">// if (rexmit_on)</span></div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span>  {</div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span>    <span class="comment">/* Retransmission is on, so we have to deal with the reassembly queue.  Namely if this packet</span></div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span><span class="comment">     * fills the gap between stuff already given to Receive buffer and the first packet in the</span></div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="comment">     * reassembly queue, then we should feed-to-user not just the new packet but also all contiguous packets</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="comment">     * at the front of the queue into Receive buffer.  If it does not fill it, then we have to add</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span><span class="comment">     * it to reassembly queue in the proper spot. */</span></div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span> </div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span>    <span class="keywordflow">if</span> (slide)</div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span>    {</div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span>      <span class="comment">// New packet filled at least part of the first gap.  So we should feed it to Receive buffer.</span></div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span> </div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span>      <span class="keywordflow">if</span> (!sock_data_to_rcv_buf_unless_overflow(sock, packet))</div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span>      {</div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span>        <span class="comment">/* Not so fast.  If there&#39;s no space in the Receive buffer, there&#39;s no choice except to drop the</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment">         * packet despite all of the above.  All comments from same spot in the no-retransmission</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment">         * code above apply (not repeating here). */</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span>      }</div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span> </div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span>      <span class="comment">/* DO NOT use `data` from this point forward -- it was just emptied by sock_data_to_rcv_buf_unless_overflow().</span></div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span><span class="comment">       * data_size is fine. */</span></div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span> </div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span>      <span class="comment">/* Now update the receive window structure.  Maintain invariants described in doc headers</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment">       * for m_rcv_packets_with_gaps and related members.  Additionally, since retransmission is</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment">       * on, if the new packet bridged gap to the first packet(s) in the reassembly queue, then</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">       * add their data to Receive buffer also (the `true` argument triggers this). */</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span> </div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span>      sock_slide_rcv_next_seq_num(sock, slide_size, <span class="keyword">true</span>);</div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span> </div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span>      <span class="comment">/* Since sock nsqow has a non-empty Receive buffer, it is certainly now Readable.  Handle implications</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment">       * on relevant waiting Event_sets. */</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span>      sock_rcv_buf_now_readable(sock, syn_rcvd_qd_packet);</div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span>    } <span class="comment">// if (slide)</span></div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sock_data_to_reassembly_q_unless_overflow(sock, packet)) <span class="comment">// &amp;&amp; (!slide)</span></div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span>    {</div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span>      <span class="comment">/* Out-of-order packet.  Couldn&#39;t feed to Receive buffer, so fed to reassembly queue (in sock_data_to_reass...()).</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span><span class="comment">       * However, if we&#39;re here, then that indicated we overflowed reassembly queue and decided to drop the packet</span></div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span><span class="comment">       * instead. Bail out; which essentially just means don&#39;t acknowledge it, as that would occur just below. */</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span>    }</div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span> </div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span>    <span class="comment">// Either fed to Receive buffer or reassembly queue.  Can certainly acknowledge it at this point.</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span> </div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span>    <span class="comment">// Register one individual acknowledgment of N bytes of data (will go out and acks new, acceptable DATA).</span></div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a7f68edbb903370ec36fa2deac09288ee">good_to_send_ack_packet</a>(data_size);</div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span> </div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span>    <span class="comment">// ACK will happen asynchronously (not in this handler, and at best once UDP net-stack considers itself writable).</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span>    async_acknowledge_packet(sock, seq_num, packet-&gt;m_rexmit_id, data_size); <span class="comment">// More rcv_stats kept inside.</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span>  } <span class="comment">// else if (rexmit_on)</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span> </div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span>  <span class="comment">// After changes, log.</span></div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span>  log_rcv_window(sock);</div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span>} <span class="comment">// Node::handle_data_to_established()</span></div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span> </div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">  810</a></span><a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">Node::sock_categorize_data_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span>                                                     boost::shared_ptr&lt;const Data_packet&gt; packet,</div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span>                                                     <span class="keywordtype">bool</span>* dupe, <span class="keywordtype">bool</span>* slide, <span class="keywordtype">size_t</span>* slide_size)</div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span>{</div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span>  assert(dupe &amp;&amp; slide &amp;&amp; slide_size);</div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span> </div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span>  <span class="comment">/* Note this is a helper to handle_data_to_established() to make it more manageable. See comments and</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span><span class="comment">   * flow in that caller first.</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span><span class="comment">   *</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment">   * Note: not dealing with rcv_stats, as it&#39;s less code (assuming 1 call to us anyway) to do it based on our result. */</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span> </div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span>  <span class="comment">// See comment in same spot in handle_data_to_established().</span></div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; rcv_next_seq_num = sock-&gt;m_rcv_next_seq_num;</div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Peer_socket::Recvd_pkt_map</a>&amp; rcv_packets_with_gaps = sock-&gt;m_rcv_packets_with_gaps;</div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span> </div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; data = packet-&gt;m_data;</div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = packet-&gt;m_seq_num;</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span> </div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span>  <span class="comment">// Get the sequence number just past the last datum in this packet.</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_end = seq_num;</div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span>  advance_seq_num(&amp;seq_num_end, data.size());</div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span> </div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span>  <span class="comment">// If false, all received packets are followed by all unreceived ones.  Otherwise there&#39;s at least 1 gap.</span></div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span>  <span class="keywordtype">bool</span> first_gap_exists;</div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span>  <span class="comment">// If true, then this is the sequence number of the first datum right after that first gap.</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_after_first_gap;</div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span>  rcv_get_first_gap_info(sock, &amp;first_gap_exists, &amp;seq_num_after_first_gap);</div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span> </div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span>  <span class="comment">// Validate the 1st sequence number in DATA against the ISN.</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span> </div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span>  <span class="keywordflow">if</span> (seq_num &lt;= sock-&gt;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#a5dc05d1f5deb71e1259c5d5aad1fcf84">m_rcv_init_seq_num</a>)</div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span>  {</div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span>    <span class="comment">/* Sequence number precedes or equals the original SYN&#39;s sequence number.  Either the other side</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span><span class="comment">     * is an a-hole, or somehow a socket_id was reused from a recent connection, which we do try to</span></div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span><span class="comment">     * avoid like the plague.  Therefore, send them an RST and abort connection.  If they send more</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span><span class="comment">     * data packets to this port (which is quite possible; many could already be on the way),</span></div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment">     * they&#39;ll get more RSTs still. */</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span> </div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span>    <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span>                     <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span>                     <span class="stringliteral">&quot;sequence number [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;]; data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span>                     <span class="stringliteral">&quot;sequence number precedes &quot;</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span>                     <span class="stringliteral">&quot;ISN [&quot;</span> &lt;&lt; sock-&gt;m_rcv_init_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span> </div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765">error::Code::S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</a>; <span class="comment">// Bad behavior from other side is fatal.</span></div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span>  }</div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span>  <span class="comment">// else if (seq_num &gt;= sock-&gt;m_rcv_init_seq_num)</span></div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span> </div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span>  <span class="keywordflow">if</span> (seq_num &lt; rcv_next_seq_num)</div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span>  {</div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>    <span class="comment">/* The packet claims to begin BEFORE the first gap (i.e., unreceived packet).  This may be a</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span><span class="comment">     * valid duplicate packet.  First, though, ensure it&#39;s not a &quot;straddling&quot; packet, i.e., that its</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span><span class="comment">     * last datum&#39;s sequence number is not past rcv_next_seq_num.  If it is, that would imply one</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span><span class="comment">     * sequence number&#39;s datum is in two packets that are not duplicates of each other which is illegal. */</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span> </div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>    <span class="keywordflow">if</span> (seq_num_end &gt; rcv_next_seq_num)</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span>    {</div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>      <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>      <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>                       <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>                       <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>                       <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>                       <span class="stringliteral">&quot;straddle first unreceived &quot;</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>                       <span class="stringliteral">&quot;sequence number [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span> </div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span>      <span class="comment">// Yep, it straddles the boundary.  Other side is behaving badly.  RST/close as above.</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span>      <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>;</div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span>    }</div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span>    <span class="comment">// else ([seq_num, end seq_num] is before the first unreceived packet sequence, a/k/a gap)</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span> </div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Duplicate packet before first unreceived sequence number [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span> </div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span>    *dupe = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span>    *slide = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>();</div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span>  } <span class="comment">// if (seq_num &lt; rcv_next_seq_num)</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span>  <span class="comment">// else if (seq_num &gt;= rcv_next_seq_num)</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span> </div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span>  <span class="comment">/* Packet claims to be in what TCP would call the receive window (somewhere at or after the</span></div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span><span class="comment">   * first gap).  Pin down in what part of that space it is, in order of increasing seq. #s. */</span></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span> </div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span>  <span class="comment">// First see if it&#39;s right at the start of the first gap.</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span> </div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span>  <span class="keywordflow">if</span> (seq_num == rcv_next_seq_num)</div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span>  {</div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span>    <span class="comment">/* Great.  It&#39;s at the start of the first gap, so we should be able to advance the window</span></div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span><span class="comment">     * (increment rcv_next_seq_num).  First check that it doesn&#39;t straddle the next received packet</span></div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="comment">     * after the gap, if any.  (Again, if it does that means one sequence number is inside 2</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="comment">     * packets that aren&#39;t dupes of each other, which is illegal.) */</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span>    <span class="keywordflow">if</span> (first_gap_exists &amp;&amp; (seq_num_end &gt; seq_num_after_first_gap))</div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span>    {</div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span>      <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span>      <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span>                       <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span>                       <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span>                       <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span>                       <span class="stringliteral">&quot;supposed gap-filling data &quot;</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span>                       <span class="stringliteral">&quot;straddle the boundary of packet [&quot;</span> &lt;&lt; seq_num_after_first_gap &lt;&lt; <span class="stringliteral">&quot;, ...).&quot;</span>);</div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span> </div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span>      <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>; <span class="comment">// As above.</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span>    }</div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span>    <span class="comment">// else legal -- can slide window to the right and save to Receive buffer.</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span> </div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Packet filled first [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;] unreceived sequence numbers &quot;</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span>                   <span class="stringliteral">&quot;starting with [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span> </div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span>    *dupe = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span>    *slide = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span>    *slide_size = size_t(seq_num_end - seq_num);</div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span>    assert(*slide_size == data.size());</div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>();</div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span>  }</div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span> </div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span>  <span class="comment">// else if:</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>  assert(seq_num &gt; rcv_next_seq_num);</div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span> </div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span>  *slide = <span class="keyword">false</span>; <span class="comment">// This much is certain, as we&#39;re not filling the first gap from the front.</span></div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span> </div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span>  <span class="comment">/* Packet doesn&#39;t fill that first gap.  It&#39;s somewhere after the start of the first gap.  Now</span></div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span><span class="comment">   * there are 3 possibilities:</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span><span class="comment">   *</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span><span class="comment">   *  -1- It&#39;s illegal: it straddles the boundary of one of the packets in m_rcv_packets_with_gaps,</span></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span><span class="comment">   *      meaning some sequence number is inside 2 non-identical packets.  RST/close as above.</span></div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span><span class="comment">   *</span></div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span><span class="comment">   *  -2- It is a duplicate (same starting sequence number and length) of one of the packets</span></div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span><span class="comment">   *      past the first gap (i.e., of the packets in rcv_packets_with_gaps).  Thus dupe =</span></div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span><span class="comment">   *      true (we should ACK but not save to Receive buffer).</span></div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span><span class="comment">   *</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span><span class="comment">   *  -3- It fits into one of the gaps; i.e. its sequence number range is either entirely</span></div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span><span class="comment">   *      before that of rcv_packets_with_gaps; entirely after it; or entirely before the</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span><span class="comment">   *      first sequence number of an element of rcv_packets_with_gaps AND entirely after the</span></div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span><span class="comment">   *      last sequence number of the preceding element of rcv_packets_with_gaps.  Thus we</span></div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span><span class="comment">   *      should ACK and save to Receive buffer.</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span><span class="comment">   *</span></div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span><span class="comment">   * Determine which one it is.</span></div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span><span class="comment">   *</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span><span class="comment">   * @todo Below technique is fun and all, but I now suspect the following might be simpler:</span></div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span><span class="comment">   * 1, is seq_num in rcv_packets_with_gaps already?  If so but different length, error; if so but</span></div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span><span class="comment">   * but same length, *dupe is true.  Otherwise: 2, insert a thing representing `packet` into rcv_packets_with_gaps</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span><span class="comment">   * as if for real; call inserted thing P.  3, check for straddling against right edge of prior(P), if any;</span></div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span><span class="comment">   * if so, error.  4, check for straddling against left edge of next(P), if any; if so, error.</span></div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span><span class="comment">   * 5, *dupe is false.  The problem?  It requires insertion, when this is supposed to not modify `packet` but only</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span><span class="comment">   * categorize it.  Can of course remove it at the end, but that&#39;s cheesy.  Can also modify our contract</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span><span class="comment">   * accordingly, but that reduces separation of concerns in caller&#39;s algorithm.  Also, possibly the resulting</span></div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span><span class="comment">   * algorithm might be easier to grok but not much shorter, if at all, anyway.  Finally, could leave the</span></div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span><span class="comment">   * straddling detection to later parts of the algorithm (again, changing our contract to be weaker though).</span></div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span><span class="comment">   * In any case, not a top concern; and in terms of performance I doubt it would differ much from below. */</span></div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span> </div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span>  <span class="comment">/* Find where we are compared to the various received packets past the first gap.</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span><span class="comment">   * This gets the first packet whose first sequence number is &gt;= seq_num.  There are 3 possibilities:</span></div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span><span class="comment">   * that is equal to seq_num, past seq_num, or there is no such packet.</span></div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span><span class="comment">   *</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span><span class="comment">   * Note that the lookup is O(log n) amortized, and then the subsequent checking is O(1).</span></div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span><span class="comment">   * This is one of the reasons to use a sorted map by seq. #. */</span></div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">Peer_socket::Recvd_pkt_const_iter</a> next_packet = rcv_packets_with_gaps.lower_bound(seq_num);</div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span> </div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span>  <span class="keywordflow">if</span> (next_packet == rcv_packets_with_gaps.end())</div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span>  {</div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span>    <span class="comment">/* There is no packet after ours, and there is no packet equal to ours.  Thus we&#39;ll just</span></div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span><span class="comment">     * insert our packet at the end.  Check, however, that there is no straddling (-1- above).</span></div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span><span class="comment">     * What packet&#39;s boundary can we straddle?  At least the last one (assuming there&#39;s a gap).  Its</span></div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span><span class="comment">     * last number may be &gt;= seq_num.  (Its first is guaranteed to be &lt; seq_num based on the</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span><span class="comment">     * above check.)  If we don&#39;t straddle that boundary, we can&#39;t straddle any other packet&#39;s boundary,</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span><span class="comment">     * since all other packets precede the last one, so just check the last one (if exists). */</span></div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span>    <span class="keywordflow">if</span> (first_gap_exists)</div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span>    {</div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span>      <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">Peer_socket::Recvd_pkt_const_iter</a> last_packet = prior(rcv_packets_with_gaps.end());</div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span>      <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_last_end;</div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span>      get_seq_num_range(last_packet, 0, &amp;seq_num_last_end);</div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span> </div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span>      <span class="keywordflow">if</span> (seq_num_last_end &gt; seq_num) <span class="comment">// (Corner case check: == means it contiguously precedes `packet`; no straddle.)</span></div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span>      {</div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span>        <span class="comment">// Yep, packet straddles boundary of last_packet.</span></div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span> </div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span>        <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span>        <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span>                         <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span>                         <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span>                         <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span>                         <span class="stringliteral">&quot;supposed middle gap-filling packet data &quot;</span></div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span>                         <span class="stringliteral">&quot;straddle the boundary of last packet [..., &quot;</span> &lt;&lt; seq_num_last_end &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span> </div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span>        <span class="comment">// Register one packet with N bytes of data (not acceptable due to error).</span></div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span>        rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ab45ad2bb462371067b09ae4f97935a78">error_data_packet</a>(data.size());</div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>; <span class="comment">// As above.</span></div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span>      }</div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span>      <span class="comment">// else OK, we&#39;re a new packet that happens to be the newest (by sequence number).</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span> </div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;New packet is newest packet after unreceived gap; &quot;</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span>                     <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span>                     <span class="stringliteral">&quot;first unreceived packet [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span>    }</div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span>    <span class="keywordflow">else</span> <span class="comment">// if (!first_gap_exists)</span></div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span>    {</div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span>      <span class="comment">// OK, we&#39;re a new packet that happens to be the packet that forms the first gap by being after that gap.</span></div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span> </div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;New packet forms gap; sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span>                     <span class="stringliteral">&quot;first unreceived packet [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span>    }</div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span> </div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span>    *dupe = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>();</div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span>  } <span class="comment">// if (next_packet does not exist)</span></div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span>  <span class="comment">// else if (next_packet exists at the same or later sequence number as seq_num)</span></div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span> </div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span>  <span class="comment">// Get the [range) of sequence numbers in the packet that starts at or after seq_num.</span></div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_next_start, seq_num_next_end;</div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span>  get_seq_num_range(next_packet, &amp;seq_num_next_start, &amp;seq_num_next_end);</div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span> </div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span>  <span class="keywordflow">if</span> (seq_num_next_start == seq_num)</div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span>  {</div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span>    <span class="comment">/* Our first datum has same sequence number as next_packet.  Thus it&#39;s a duplicate.</span></div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span><span class="comment">     * Check, however, that their last sequence numbers are also identical.  Otherwise, again,</span></div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span><span class="comment">     * one datum is in two different packets, which is illegal. */</span></div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span>    <span class="keywordflow">if</span> (seq_num_next_end != seq_num_end)</div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"> 1027</span>    {</div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span>      <span class="comment">// Yep, not a valid duplicate.</span></div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span> </div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span>      <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span>      <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span>                       <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span>                       <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span>                       <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span>                       <span class="stringliteral">&quot;do not match supposed &quot;</span></div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span>                       <span class="stringliteral">&quot;duplicate packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_next_end &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span> </div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span>      <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>; <span class="comment">// As above.</span></div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span>    }</div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"> 1041</span> </div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"> 1042</span>    <span class="comment">/* @todo With rexmit_on we can also/instead compare `data` against actual data payload in next_packet -- not just</span></div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"> 1043</span><span class="comment">     * the sequence numbers. With !rexmit_on, there&#39;s no need to store the payloads, as they&#39;re always fed directly</span></div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"> 1044</span><span class="comment">     * to user upon receipt, even out of order. */</span></div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"> 1045</span> </div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Duplicate packet after unreceived data; &quot;</span></div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"> 1047</span>                   <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span> </div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span>    *dupe = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>();</div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span>  } <span class="comment">// if (seq_num_next_start == seq_num)</span></div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span>  <span class="comment">// else if:</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span>  assert(seq_num_next_start &gt; seq_num); <span class="comment">// lower_bound() is not horrifically broken.</span></div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span> </div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span>  <span class="comment">// We&#39;ve eliminated all dupe possibilities above. It&#39;s either error or not, at this point.</span></div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span>  *dupe = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span> </div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span>  <span class="comment">/* Since next_packet starts after `packet`, the best outcome is that packet is entirely</span></div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span><span class="comment">   * before next_packet and entirely after prev_packet, where prev_packet == prior(next_packet) (if</span></div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span><span class="comment">   * such a thing exists).  So we must check that we don&#39;t straddle</span></div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span><span class="comment">   * either next_packet&#39;s starting boundary or prev_packet&#39;s ending boundary.  All other</span></div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"> 1062</span><span class="comment">   * preceding boundaries are straddled if and only if the prev_packet end is, and all</span></div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"> 1063</span><span class="comment">   * succeding boundaries iff next_packet start is. */</span></div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span> </div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span>  <span class="keywordflow">if</span> (seq_num_end &gt; seq_num_next_start) <span class="comment">// Corner case check: == means `packet` contiguously precedes next_packet.</span></div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span>  {</div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span>    <span class="comment">// Straddle one or more succeding packets.  RST/close as above.</span></div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span> </div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span>    <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span>                     <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span>                     <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span>                     <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span>                     <span class="stringliteral">&quot;supposed middle gap-filling packet data &quot;</span></div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span>                     <span class="stringliteral">&quot;straddle the left boundary of packet &quot;</span></div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"> 1076</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; seq_num_next_start &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_next_end &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"> 1077</span> </div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"> 1078</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>; <span class="comment">// Bad behavior is fatal to connection, as above.</span></div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"> 1079</span>  }</div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span>  <span class="comment">// else succeding packets OK. Check preceding packets.</span></div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span> </div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span>  <span class="keywordflow">if</span> (next_packet == rcv_packets_with_gaps.begin())</div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span>  {</div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;New packet partially fills first gap without sliding window; &quot;</span></div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span>                   <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span>                   <span class="stringliteral">&quot;first unreceived packet [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>(); <span class="comment">// There are none. We&#39;re good.</span></div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span>  }</div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span> </div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"> 1090</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">Peer_socket::Recvd_pkt_const_iter</a> prev_packet = prior(next_packet);</div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_prev_start, seq_num_prev_end;</div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"> 1092</span>  get_seq_num_range(prev_packet, &amp;seq_num_prev_start, &amp;seq_num_prev_end);</div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span> </div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span>  <span class="keywordflow">if</span> (seq_num_prev_end &gt; seq_num) <span class="comment">// Corner case check: == means prev_packet contiguously precedes `packet`.</span></div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span>  {</div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span>    <span class="comment">// Straddling one or more preceding packets.  RST/close as above.</span></div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span> </div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span>    <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span>                     <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span>                     <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span>                     <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span>                     <span class="stringliteral">&quot;supposed middle gap-filling packet data &quot;</span></div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span>                     <span class="stringliteral">&quot;straddle the right boundary of packet &quot;</span></div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"> 1105</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; seq_num_prev_start &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_prev_end &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"> 1106</span> </div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>; <span class="comment">// Bad behavior is fatal to connection, as above.</span></div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span>  }</div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span>  <span class="comment">// else preceding packets OK.</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span> </div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;New packet fills some middle gap; &quot;</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span>                 <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span>                 <span class="stringliteral">&quot;first unreceived packet [&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span> </div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span>  <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>();</div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span>} <span class="comment">// Node::sock_categorize_data_to_established()</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span> </div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45"> 1118</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">Node::sock_data_to_rcv_buf_unless_overflow</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span>                                                boost::shared_ptr&lt;Data_packet&gt; packet)</div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span>{</div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>;</div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span> </div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span>  <span class="comment">/* Note this is a helper to handle_data_to_established() to make it more manageable. See comments and</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span><span class="comment">   * flow in that caller first. */</span></div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span> </div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span>  <span class="comment">// See comment in same spot in handle_data_to_established().</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">Blob</a>&amp; data = packet-&gt;m_data; <span class="comment">// NOT const due to Socket_buffer::feed*().  See below.</span></div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span>  <span class="comment">// Save this before we possibly destroy data&#39;s contents below (for performance).</span></div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> data_size = data.size();</div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span> </div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span>  <span class="keywordtype">size_t</span> buf_size;</div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span>  {</div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span>    <span class="comment">// Receive Buffer can be consumed by user threads (not W) at the same time.  Must lock.</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span> </div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span>    <span class="comment">/* First we must check if block will fit into sock-&gt;m_rcv_buf.  Why not just use feed_buf_move()&#39;s</span></div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span><span class="comment">     * max_data_size argument?  Because that would allow to partially enqueue the block, if there&#39;s</span></div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span><span class="comment">     * space for some but not all of the block.  Since we can&#39;t partially ACK a packet, we have to</span></div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="comment">     * drop the whole thing in that case.</span></div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span><span class="comment">     *</span></div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment">     * Round up to a multiple of max-block-size to ensure we never fragment a max-block-size-sized</span></div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment">     * chunk of data when they&#39;re using unreliable mode!  Also apply the slack % to account for</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span><span class="comment">     * the fact that rcv_wnd sent to the other side may lag behind reality (the key is to NOT</span></div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span><span class="comment">     * apply the slack % when sending rcv_wnd, so that it is more conservative). */</span></div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span>    <span class="keywordflow">if</span> ((sock-&gt;m_rcv_buf.data_size() + data_size)</div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span>        &gt; sock-&gt;max_block_size_multiple(sock-&gt;m_opts.m_st_rcv_buf_max_size,</div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"> 1148</span>                                        &amp;sock-&gt;m_opts.m_st_rcv_buf_max_size_slack_percent))</div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"> 1149</span>    {</div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"> 1150</span>      <span class="comment">// Receive buffer overflow.</span></div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"> 1151</span> </div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span>      <span class="comment">// Register one packet of N bytes of acceptable data that we unfortunately have to drop due to buffer overflow.</span></div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span>      rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#aede48ce8c717e5e8f69accc4d8608613">good_data_dropped_buf_overflow_packet</a>(data_size);</div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span> </div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span>      <span class="comment">// Not an error but interesting.  Might be too verbose for INFO but what the hell.</span></div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span>                    <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span>                    <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; packet-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; (packet-&gt;m_seq_num + data_size) &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span>                    <span class="stringliteral">&quot;data size [&quot;</span> &lt;&lt; data_size &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span>                    <span class="stringliteral">&quot;dropping because Receive buffer full.&quot;</span>);</div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span>    }</div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span>    <span class="comment">// else can successfully write to Receive buffer (enough space for entire block).</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span> </div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span>    <span class="comment">/* Let&#39;s make data available to user!  This is a constant-time operation that MOVES</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span><span class="comment">     * packet.data&#39;s contents into m_rcv_buf (via swap).  That&#39;s why packet is Ptr and not</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span><span class="comment">     * Const_ptr.  Note that after that we no longer work with packet -- it&#39;s a goner; data.empty()</span></div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span><span class="comment">     * is true.</span></div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment">     *</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span><span class="comment">     * No need to provide max buffer size -- we already checked that&#39;s not an issue above. */</span></div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span> </div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> written =</div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span>      sock-&gt;m_rcv_buf.feed_buf_move(&amp;data, std::numeric_limits&lt;size_t&gt;::max());</div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span>    <span class="comment">// `data` is now empty.</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span>    assert(written == data_size);</div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"> 1178</span> </div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span>    buf_size = sock-&gt;m_rcv_buf.data_size();</div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span>  } <span class="comment">// lock(sock-&gt;m_mutex)</span></div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span> </div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span>  <span class="comment">// Register one packet of N bytes of acceptable data that we accepted -- did not drop.</span></div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a20f2fe00c0874f075fade075bb82e234">good_data_accepted_packet</a>(data_size);</div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span>  <span class="comment">// Register one packet of N bytes of acceptable data that we delivered to user.</span></div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a5cc77830ee793725a5bbc1e7660fb230">good_data_delivered_packet</a>(data_size);</div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span>  <span class="comment">// Register that the Receive buffer grew.</span></div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ac2753b3e8e3932593fed431771b1df80">buffer_fed</a>(buf_size);</div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span> </div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span>  <span class="comment">// They&#39;ve sent reasonable data -- so handle the implications on rcv_wnd recovery (if any).</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span>  receive_wnd_recovery_data_received(sock);</div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span> </div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span>} <span class="comment">// Node::sock_data_to_rcv_buf_unless_overflow()</span></div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span> </div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc"> 1195</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">Node::sock_rcv_buf_now_readable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> syn_rcvd_qd_packet)</div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span>{</div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span>  <span class="comment">/* We are told sock now has a non-empty Receive buffer and is thus Readable.  Therefore we</span></div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span><span class="comment">   * should soon inform anyone waiting on any Event_sets for sock to become Readable.</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment">   *</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><span class="comment">   * Caveat: Similar to that in Node::handle_syn_ack_ack_to_syn_rcvd() at similar point in the</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span><span class="comment">   * code.</span></div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span><span class="comment">   *</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span><span class="comment">   * Also: why do this outside the locked block that likely preceded this to actually write to the</span></div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span><span class="comment">   * Receive buffer?  Avoid possibility of deadlock, since there</span></div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span><span class="comment">   * are two mutexes at play: sock-&gt;m_mutex (locked in the likely Receive buffer</span></div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment">   * update and in event_set_all_check_delta()) and Event_set::m_mutex (which is locked in</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment">   * event_set_all_check_delta()).  Different mutexes should always be locked in the same order,</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span><span class="comment">   * and other threads lock in the sock-&gt;m_mutex/event_set-&gt;m_mutex order.</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span><span class="comment">   *</span></div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span><span class="comment">   * Finally: if this packet was not received in ESTABLISHED but rather in SYN_RCVD and saved</span></div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment">   * until ESTABLISHED, then we skip this (syn_rcvd_qd_packet).</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span><span class="comment">   * Why?  Answer: in this case the socket has not yet been</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span><span class="comment">   * given to the user (they need to call accept() or equivalent).  Therefore, they could not have</span></div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span><span class="comment">   * added it to an Event_set and thus are not interested in Readable status on it.  (For</span></div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span><span class="comment">   * background on this queueing, see handle_data_to_syn_rcvd(). */</span></div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span> </div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span>  <span class="comment">// Accumulate the event into the Node store (note: not any Event_set yet) (if received during ESTABLISHED).</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span>  <span class="keywordflow">if</span> ((!syn_rcvd_qd_packet) &amp;&amp;</div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span>      m_sock_events[<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">Event_set::Event_type::S_PEER_SOCKET_READABLE</a>].insert(sock).second)</div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span>  {</div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span>    <span class="comment">// Possibly inform the user for any applicable Event_sets right now.</span></div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span>    event_set_all_check_delta(<span class="keyword">true</span>);</div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span>    <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span><span class="comment">     * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="comment">     * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span>  }</div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span>} <span class="comment">// Node::sock_rcv_buf_now_readable()</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span> </div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43"> 1229</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">Node::sock_track_new_data_after_gap_rexmit_off</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span>                                                    boost::shared_ptr&lt;const Data_packet&gt; packet,</div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span>                                                    <span class="keywordtype">size_t</span> data_size,</div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span>                                                    <span class="keywordtype">bool</span>* slide, <span class="keywordtype">size_t</span>* slide_size)</div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span>{</div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span>  <span class="keyword">using </span>std::make_pair;</div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span> </div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span>  <span class="comment">/* Note this is a helper to handle_data_to_established() to make it more manageable.  See comments and</span></div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span><span class="comment">   * flow in that caller first. */</span></div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span> </div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span>  *slide = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span>  *slide_size = 0;</div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span> </div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span>  <span class="comment">// See comment in same spot in handle_data_to_established().</span></div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Peer_socket::Recvd_pkt_map</a>&amp; rcv_packets_with_gaps = sock-&gt;m_rcv_packets_with_gaps;</div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = packet-&gt;m_seq_num;</div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span> </div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span>  <span class="comment">/* Since we may increase rcv_packets_with_gaps size below, we may exceed the limit as described</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span><span class="comment">   * in m_rcv_packets_with_gaps doc header.  (The limit is due to memory concerns.)  Let&#39;s compute</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span><span class="comment">   * that limit. */</span></div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_packets_after_unrecvd_packet = sock_max_packets_after_unrecvd_packet(sock);</div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span> </div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span>  <span class="comment">/* A pre-condition is: The received packet is NOT the first (earliest) unreceived packet we&#39;re waiting</span></div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span><span class="comment">   * for; in other words it is not the packet at the start of the first gap.  So we should save</span></div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="comment">   * the packet into rcv_packets_with_gaps.  (This will elsewhere help us, at least, detect if this</span></div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span><span class="comment">   * packet comes in again [duplicate]. See sock_categorize_data_to_established().) */</span></div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span>  <span class="keyword">const</span> <span class="keyword">auto</span> insert_result =</div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span>    rcv_packets_with_gaps.insert</div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span>      (make_pair(seq_num,</div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span>                 <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Received_packet::Ptr</a>(<span class="keyword">new</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Peer_socket::Received_packet</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), data_size, 0))));</div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span>  <span class="comment">// m_rcv_reassembly_q_data_size untouched because !rexmit_on.</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span>  assert(!sock-&gt;rexmit_on());</div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span>  assert(insert_result.second); <span class="comment">// If was already there, there&#39;s some serious bug in above logic.</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span>  <span class="comment">// No other part of the invariant is violated, so that&#39;s it.</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span> </div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span>  <span class="keywordtype">bool</span> first_gap_exists;</div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span>  <span class="comment">// The sequence number of the first datum right after the first unreceived gap.</span></div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_after_first_gap;</div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span> </div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span>  rcv_get_first_gap_info(sock, &amp;first_gap_exists, &amp;seq_num_after_first_gap);</div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span>  assert(first_gap_exists);</div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span> </div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span>  <span class="comment">/* We would be done here, except we need to protect against rcv_packets_with_gaps growing too</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span><span class="comment">   * large.  This is explained in detail in the m_rcv_packets_with_gaps doc comment.  Long story</span></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span><span class="comment">   * short: if we exceed a certain length in this structure, pretend we have &quot;received&quot; the entire</span></div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span><span class="comment">   * first gap, which will allow us to slide the window forward and eliminate all the contiguous</span></div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span><span class="comment">   * received packets following this gap, of which there will be at least one</span></div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span><span class="comment">   * (rcv_packets_with_gaps.begin()), bringing the structure&#39;s size back to the limit. */</span></div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span> </div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span>  <span class="keywordflow">if</span> (rcv_packets_with_gaps.size() == max_packets_after_unrecvd_packet + 1)</div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span>  {</div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span>    <span class="comment">// Use these output knobs to reduce rcv_packets_with_gaps.size() after all to avoid overflow.</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span>    *slide = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span>    *slide_size = size_t(seq_num_after_first_gap - sock-&gt;m_rcv_next_seq_num);</div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span> </div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span>    <span class="comment">// Register unknown # of packets with N bytes of data, which we are assuming are dropped.</span></div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a31080df078b6408b60fab6f3d8396369">presumed_dropped_data</a>(data_size);</div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span> </div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span>    <span class="comment">// Not an error but interesting.  Might be too verbose for INFO but what the hell.</span></div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span>                  <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span>                  <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; packet-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; (packet-&gt;m_seq_num + data_size) &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span>                  <span class="stringliteral">&quot;exceeded max gapped packet list size [&quot;</span> &lt;&lt; max_packets_after_unrecvd_packet &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span>                  <span class="stringliteral">&quot;assuming Dropped; &quot;</span></div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span>                  <span class="stringliteral">&quot;will fake receiving all [&quot;</span> &lt;&lt; slide_size &lt;&lt; <span class="stringliteral">&quot;] sequence numbers in the first unreceived gap.&quot;</span>);</div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span>  }</div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span>  {</div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span>    <span class="comment">// Our logic shouldn&#39;t be allowing the max to be exceeded by more than 1 at any time; we &quot;wrist-slap&quot; it above at 1.</span></div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span>    assert(rcv_packets_with_gaps.size() &lt;= max_packets_after_unrecvd_packet);</div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span>  }</div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span>} <span class="comment">// Node::sock_track_new_data_after_gap_rexmit_off()</span></div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span> </div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95"> 1305</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">Node::sock_data_to_reassembly_q_unless_overflow</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span>                                                     boost::shared_ptr&lt;Data_packet&gt; packet)</div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span>{</div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span>  <span class="keyword">using </span>std::make_pair;</div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span> </div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span>  <span class="comment">/* Note this is a helper to handle_data_to_established() to make it more manageable. See comments and</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span><span class="comment">   * flow in that caller first. */</span></div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span> </div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Peer_socket::Recvd_pkt_map</a>&amp; rcv_packets_with_gaps = sock-&gt;m_rcv_packets_with_gaps;</div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = packet-&gt;m_seq_num;</div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span> </div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span>  <span class="keyword">auto</span>&amp; data = packet-&gt;m_data; <span class="comment">// NOT const due to the move into Received_packet; see below.</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span>  <span class="comment">// Save this before we possibly destroy data&#39;s contents below (for performance).</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> data_size = data.size();</div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span> </div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span>  <span class="comment">/* Since we will increase rcv_packets_with_gaps size below, we may exceed the limit as</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment">   * described in m_rcv_packets_with_gaps doc header.  (The limit is due to memory concerns.)</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span><span class="comment">   * Let&#39;s compute that limit. */</span></div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span>  <span class="keywordtype">size_t</span> max_packets_after_unrecvd_packet = sock_max_packets_after_unrecvd_packet(sock);</div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span> </div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span>  <span class="comment">/* Update: Actually, that limit is (as noted in the doc header for Peer_socket::m_rcv_packets_with_gaps, whose</span></div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span><span class="comment">   * growth we are constraining here) more of a formality, as in practice things like sender&#39;s CWND or</span></div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment">   * sender&#39;s following our rcv-wnd guidance should keep the size of this retranmission queue much lower than</span></div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="comment">   * the limit that was just computed.  However!  There IS a retransmission-enabled-exclusive limit we should</span></div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span><span class="comment">   * apply here, and it may at times be applied in practice, unlike what we just computed.  Namely, consider</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span><span class="comment">   * that if we receive N in-order, fully populated (up to max-block-size) DATA packets, and NxMBS exceeds</span></div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="comment">   * max-on-Receive-buffer, then indeed we will drop the overflowing portion and not put into Receive buffer;</span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span><span class="comment">   * but if we don&#39;t receive 1 in-order packet, get the next (N - 1) packets, and then finally get the one</span></div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="comment">   * missing DATA packet, then they will all be delivered to Receive buffer without a problem.  (The next in-order</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span><span class="comment">   * packet would indeed hit overflow, unless user dequeues some.  This only highlights the oddness.)</span></div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="comment">   * Why?  Because the above-computed limit is far higher than the equivalent max-on-Receive-buffer configuration</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span><span class="comment">   * (typically), so the reassembly queue would be loaded up with stuff without hitting any limit, and the</span></div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span><span class="comment">   * code that dequeues from reassembly queue into Receive buffer does not follow any overflow logic (nor can it,</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span><span class="comment">   * really, since by that point those DATA packets have long since been ACKed, and we do not renege ACKs).</span></div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span><span class="comment">   * Long story short, that is not good, and we should simply apply the max-on-Receive-buffer to not just</span></div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span><span class="comment">   * the Receive buffer but to this reassembly queue PLUS the Receive buffer.</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span><span class="comment">   *</span></div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span><span class="comment">   * Caution! This policy means the rcv-wnd advertisements to the other side must follow this policy too.</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span><span class="comment">   *</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span><span class="comment">   * OK, make the computation as described.  First compute the max-on-Receive-buffer, same as when actually computing</span></div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span><span class="comment">   * that when enqueueing that structure.  Then subtract how much of it we&#39;ve used in actual Receive buffer.</span></div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span><span class="comment">   * What remains is what&#39;s allowed for rcv_packets_with_gaps:</span></div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span><span class="comment">   *</span></div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="comment">   *   Rbufdata + Rqdata &lt;= Rbufmax &lt;==&gt; Rqdata &lt;= Rbufmax - Rbufdata = S.</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span><span class="comment">   *   S_blocks = floor(S / max-block-size).</span></div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span><span class="comment">   *   Ensure Rcurdata_blocks + 1 &lt;= S_blocks.</span></div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span><span class="comment">   *</span></div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span><span class="comment">   * This is about right but actually slightly oversimplified, because that limit assumes the data are packed</span></div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span><span class="comment">   * in max-block-sized packets except possibly the last one.  In reality the existing payload of the reassembly queue</span></div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span><span class="comment">   * may be not stored so efficiently (who knows how stuff got packetized or supplied by user or both?).  To compute</span></div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span><span class="comment">   * this quite carefully (maybe overkill, but I feel deterministically understood to be correct = a good thing), we</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span><span class="comment">   * model it as the queue already storing what it&#39;s storing; and we must allow a certain number of packets</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span><span class="comment">   * on top of that and no more; and the question is whether that&#39;s enough for the incoming 1 DATA packet.</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span><span class="comment">   * So then, we want this:</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment">   *</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span><span class="comment">   *   Ensure Rqcurdata_blocks + 1 &lt;= Rqcurdata_blocks + Sleft_blocks.</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span><span class="comment">   *   Sleft_blocks = # additional packets allowed by policy = floor(Sleft / max-block-size).</span></div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span><span class="comment">   *   Sleft = max(Rbufmax - Rqcurdata - Rbufdata, 0).</span></div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span><span class="comment">   *</span></div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span><span class="comment">   * So we&#39;re doctoring it: we know Rqcurdata_blocks = rcv_packets_with_gaps.size() are already used; so we will</span></div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span><span class="comment">   * allow some # of packets beyond that, and the question is what is that # according to our policy?  Well, it&#39;s just</span></div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span><span class="comment">   * the configured limit minus the used Receive buffer in bytes and minus the sum of rcv_packets_with_gaps&#39;s bytes.</span></div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span><span class="comment">   * Since we&#39;re using bytes there, that&#39;s the maximum possible accuracy, without any inefficiency being assumed to</span></div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span><span class="comment">   * not exist.  Note that we have Rqcurdata* being subtracted from Rqcurdata* on one side, and that may seem like</span></div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span><span class="comment">   * those should cancel each other out to zero, but no -- that was the case in the simpler model above, but the more</span></div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span><span class="comment">   * realistic one means those are (sligthly, potentially) different. */</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span>  <span class="keywordtype">size_t</span> max_packets_in_reassembly_q</div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span>    = sock-&gt;max_block_size_multiple(sock-&gt;m_opts.m_st_rcv_buf_max_size,</div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span>                                    &amp;sock-&gt;m_opts.m_st_rcv_buf_max_size_slack_percent);</div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span>  <span class="comment">// We have to momentarily lock sock due to access to sock-&gt;m_rcv_buf.</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span>  <span class="keywordtype">size_t</span> rcv_buf_size;</div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span>  {</div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock;</div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span>    rcv_buf_size = sock-&gt;m_rcv_buf.data_size(); <span class="comment">// This access requires locking.</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span>  }</div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span>  <a class="code hl_function" href="namespaceflow_1_1util.html#a34ed70fa4de81a4fdb9234bfb5a3a914">util::subtract_with_floor</a>(&amp;max_packets_in_reassembly_q, rcv_buf_size) &amp;&amp; <span class="comment">// [sic]</span></div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#a34ed70fa4de81a4fdb9234bfb5a3a914">util::subtract_with_floor</a>(&amp;max_packets_in_reassembly_q, sock-&gt;m_rcv_reassembly_q_data_size);</div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span>  <span class="comment">// Convert from bytes to max-block-sizes.  Note this is the floor of the division (so it is strict).</span></div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span>  max_packets_in_reassembly_q /= sock-&gt;max_block_size();</div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span>  <span class="comment">/* Okay, we have Sleft in blocks now; add this for direct comparison to the left side, which will be .size() + 1,</span></div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span><span class="comment">   * where the 1 is the incoming packet `packet`.  Full-circle, this is `Rqcurdata_blocks + Sleft_blocks` from</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span><span class="comment">   * the above big comment. */</span></div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span>  max_packets_in_reassembly_q += rcv_packets_with_gaps.size();</div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span> </div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span>  <span class="comment">// The final limit is the lower of the two limits; realistically we expect max_packets_in_reassembly_q to &quot;win.&quot;</span></div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span>  <span class="keywordflow">if</span> (max_packets_in_reassembly_q &lt; max_packets_after_unrecvd_packet)</div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span>  {</div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span>    max_packets_after_unrecvd_packet = max_packets_in_reassembly_q;</div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"> 1394</span>  }</div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span>  {</div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span>    <span class="comment">// Not an error but pretty weird configuration (but too verbose for INFO, if it really does occur).</span></div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Unexpected Receive buffer limits: safety net [&quot;</span> &lt;&lt; max_packets_after_unrecvd_packet &lt;&lt; <span class="stringliteral">&quot;] &lt;= &quot;</span></div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span>                   <span class="stringliteral">&quot;real limit [&quot;</span> &lt;&lt; max_packets_in_reassembly_q &lt;&lt; <span class="stringliteral">&quot;], but the opposite is typical.  &quot;</span></div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span>                   <span class="stringliteral">&quot;See details just below.&quot;</span>); <span class="comment">// See next log message.</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span>  }</div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span> </div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"> 1403</span>  <span class="keywordflow">if</span> (rcv_packets_with_gaps.size() + 1 &gt; max_packets_after_unrecvd_packet)</div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span>  {</div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span>    <span class="comment">/* Overflow.  Drop this new packet instead of queueing it.  Note that this is different</span></div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span><span class="comment">     * from the handling of the same situation in the no-retransmit case.  In that case, this</span></div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span><span class="comment">     * situation is probably more common under loss, since once a packet is considered Dropped by sender, it is NEVER</span></div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span><span class="comment">     * re-sent; thus Receiver eventually also considers it Dropped and (instead of dropping</span></div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span><span class="comment">     * the new packet, which would be a disastrous policy) simply pretends the gap has been</span></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span><span class="comment">     * filled, thus consolidating the front of rcv_packets_with_gaps. */</span></div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span> </div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span>    <span class="comment">// Register one packet of N bytes of acceptable data that we unfortunately have to drop due to overflow.</span></div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span>    rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a30706cd9e07511f17ec73f6af10926f2">good_data_dropped_reassembly_q_overflow_packet</a>(data_size);</div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span> </div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span>    <span class="comment">// This is an error, though not our fault.</span></div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"> 1417</span>                     <span class="stringliteral">&quot;Received [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span>                     <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; packet-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; (packet-&gt;m_seq_num + data_size) &lt;&lt; <span class="stringliteral">&quot;); &quot;</span></div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span>                     <span class="stringliteral">&quot;exceeded max gapped packet list size [&quot;</span> &lt;&lt; max_packets_after_unrecvd_packet &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span>                     <span class="stringliteral">&quot;dropping packet.&quot;</span>);</div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span>  }</div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span>  <span class="comment">// else we can insert into reassembly queue (priority queue by seq. #) rcv_packets_with_gaps.</span></div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span> </div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span>                 <span class="stringliteral">&quot;Enqueueing [&quot;</span> &lt;&lt; packet-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] payload onto reassembly queue with &quot;</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span>                 <span class="stringliteral">&quot;sequence numbers [&quot;</span> &lt;&lt; packet-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; (packet-&gt;m_seq_num + data_size) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span>                 <span class="stringliteral">&quot;of size [&quot;</span> &lt;&lt; data_size &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span>                 <span class="stringliteral">&quot;successfully fit into max gapped packet list size [&quot;</span> &lt;&lt; max_packets_after_unrecvd_packet &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span>                 <span class="stringliteral">&quot;could have fit [&quot;</span> &lt;&lt; (max_packets_after_unrecvd_packet - rcv_packets_with_gaps.size()) &lt;&lt; <span class="stringliteral">&quot;] more.&quot;</span>);</div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span> </div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span>  <span class="comment">// This decimates `data` but is constant time, much like the buffer enqueueing done elsewhere.</span></div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span>  <span class="keyword">const</span> <span class="keyword">auto</span> insert_result =</div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"> 1436</span>    rcv_packets_with_gaps.insert</div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span>      (make_pair(seq_num, <span class="comment">// Decimation occurs in here: ------------------v, hence the `&amp;`: -------------v.</span></div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span>                 <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Received_packet::Ptr</a>(<span class="keyword">new</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Peer_socket::Received_packet</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), data_size, &amp;data))));</div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span>  sock-&gt;m_rcv_reassembly_q_data_size += data_size;</div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span>  assert(insert_result.second); <span class="comment">// If was already there, there&#39;s some serious bug in above logic.</span></div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span>  <span class="comment">// No other part of the invariant is violated, so that&#39;s it.</span></div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span> </div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span>  <span class="comment">// DO NOT use `data` from this point forward -- it was just emptied by moving into the new Received_packet.</span></div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span> </div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span>  <span class="comment">// Register one packet of N bytes of acceptable data that we accepted -- did not drop.</span></div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a20f2fe00c0874f075fade075bb82e234">good_data_accepted_packet</a>(data_size);</div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span>  <span class="comment">// Register one packet of N bytes of acceptable data that we queued for reassembly -- not yet in Receive buffer.</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span>  rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ae2ed3438420d6f331549e2decb9f0556">good_data_first_qd_packet</a>(data_size);</div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span> </div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span>  <span class="comment">// They&#39;ve sent reasonable data -- so handle the implications on rcv_wnd recovery (if any).</span></div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span>  receive_wnd_recovery_data_received(sock);</div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span> </div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"> 1453</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"> 1454</span>} <span class="comment">// Node::sock_data_to_reassembly_q_unless_overflow()</span></div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span> </div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648"> 1456</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">Node::sock_slide_rcv_next_seq_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">size_t</span> slide_size, <span class="keywordtype">bool</span> reassembly_in_progress)</div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span>{</div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span>  <span class="comment">/* Note this is a helper to handle_data_to_established() to make it more manageable. See comments and</span></div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span><span class="comment">   * flow in that caller first. */</span></div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span> </div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span>  <span class="comment">// See comment in same spot in handle_data_to_established().</span></div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&amp; rcv_stats = sock-&gt;m_rcv_stats;</div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Peer_socket::Recvd_pkt_map</a>&amp; rcv_packets_with_gaps = sock-&gt;m_rcv_packets_with_gaps;</div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; rcv_next_seq_num = sock-&gt;m_rcv_next_seq_num;</div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span> </div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span>  <span class="comment">/* OK, caller determined that the front of the gap between rcv_next_seq_num and</span></div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span><span class="comment">   * seq_num_after_first_gap has been received.  Indeed mark this fact by sliding the former to a higher value,</span></div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span><span class="comment">   * indicating sliding right of the left edge of the receive window, in TCP terminology. */</span></div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span>  rcv_next_seq_num += slide_size; <span class="comment">// Use op+= over advance_seq_num(): slide_size is of Sequence_numbers, not bytes.</span></div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span> </div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;First unreceived packet pointer moved from &quot;</span></div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; (rcv_next_seq_num - slide_size) &lt;&lt; <span class="stringliteral">&quot;] to &quot;</span></div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span> </div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span>  <span class="comment">/* Now update the receive window structure.  Maintain invariant described in doc headers for</span></div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span><span class="comment">   * for m_rcv_packets_with_gaps and related members.  Additionally, IF retranmission-related</span></div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span><span class="comment">   * reassembly is in progress (presumably, because retransmission is enabled), and if the new packet bridged</span></div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span><span class="comment">   * gap to the first seq.-#-contiguous packet(s) in the reassembly queue, then add their data to Receive buffer</span></div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span><span class="comment">   * also. */</span></div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span> </div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span>  <span class="comment">// Start of range to delete.</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">Peer_socket::Recvd_pkt_iter</a> start_contig_it = rcv_packets_with_gaps.begin();</div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span>  <span class="comment">// End of range to delete (just past last element to delete).</span></div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">Peer_socket::Recvd_pkt_iter</a> end_contig_it;</div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span>  <span class="keywordtype">size_t</span> total_written = 0;</div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span> </div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span>  <span class="comment">// The following loop is O(n) worst case.</span></div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span>  <span class="keywordflow">for</span> (end_contig_it = start_contig_it;</div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span>       <span class="comment">/* Search until the infinite gap is found; or the first finite gap is found.</span></div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"> 1490</span><span class="comment">        * Note invariant at entry to each loop iteration: rcv_next_seq_num is seq. # just past last received</span></div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span><span class="comment">        * packet&#39;s data (so for contiguousness, it must equal the 1st seq. # in next packet). */</span></div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"> 1492</span>       (end_contig_it != rcv_packets_with_gaps.end()) &amp;&amp; (end_contig_it-&gt;first == rcv_next_seq_num);</div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"> 1493</span>       ++end_contig_it)</div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"> 1494</span>  {</div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"> 1495</span>    <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Peer_socket::Received_packet</a>&amp; rcvd_packet = *end_contig_it-&gt;second;</div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"> 1496</span> </div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span>    <span class="keywordflow">if</span> (reassembly_in_progress)</div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span>    {</div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span>      <span class="comment">/* Receive Buffer can be consumed by user threads (not W) at the same time.  Must lock.</span></div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span><span class="comment">       * @todo Probably possible to make the critical section smaller.</span></div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span><span class="comment">       *</span></div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"> 1502</span><span class="comment">       * Conversely, maybe it&#39;s better to lock around the entire while () loop, for potentially less</span></div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span><span class="comment">       * locking/unlocking while another thread is reading from buffer, which intuitively &quot;feels&quot; churn-y.</span></div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"> 1504</span><span class="comment">       * Arguments against: the loop may have 0 iterations, meaning the locking was a waste; also, locking</span></div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"> 1505</span><span class="comment">       * once per packet is no worse in aggregate than if we&#39;d received these packets in order without</span></div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"> 1506</span><span class="comment">       * needing reassembly -- and that&#39;s the much more typical state of affairs; so it&#39;s not like we&#39;re</span></div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"> 1507</span><span class="comment">       * adding some unusually excessive amount of locking/unlocking by locking once per packet during</span></div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"> 1508</span><span class="comment">       * reassembly. */</span></div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span>      <span class="keywordtype">size_t</span> written;</div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span>      <span class="keywordtype">size_t</span> buf_size;</div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span>      {</div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span>        <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span> </div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span>        <span class="comment">/* Reassemble!  This is constant-time.  Note we don&#39;t check for overflow here, but that&#39;s because we</span></div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span><span class="comment">         * checked for it cleverly in first enqueueing this in rcv_packets_with_gaps</span></div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"> 1516</span><span class="comment">         * (see sock_data_to_reassembly_q_unless_overflow()). */</span></div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"> 1517</span>        written = sock-&gt;m_rcv_buf.feed_buf_move(&amp;rcvd_packet.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#ac3e88e37e53d2572f89c599e520e3e2a">m_data</a>, std::numeric_limits&lt;size_t&gt;::max());</div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"> 1518</span>        <span class="comment">// rcvd_packet.m_data is now empty.</span></div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"> 1519</span>        buf_size = sock-&gt;m_rcv_buf.data_size();</div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span>      }</div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span>      total_written += written;</div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span> </div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span>      <span class="comment">// Similarly to when receiving a first-gap-filling (or just in-order, if there is no gap) DATA packet:</span></div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span>      rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a5cc77830ee793725a5bbc1e7660fb230">good_data_delivered_packet</a>(written);</div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span>      rcv_stats.<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ac2753b3e8e3932593fed431771b1df80">buffer_fed</a>(buf_size);</div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span> </div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span>      assert(written != 0);</div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"> 1528</span>    }</div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"> 1529</span> </div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"> 1530</span>    advance_seq_num(&amp;rcv_next_seq_num, rcvd_packet.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a7d0760b1dead081bdcf775fbca7f708b">m_size</a>);</div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"> 1531</span> </div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;First unreceived packet pointer moved again to &quot;</span></div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;]; packet subsumed by this move.&quot;</span>);</div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span>  } <span class="comment">// while (keep encountering contiguous packets)</span></div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span> </div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span>  <span class="comment">// The following, according to STL requirements, is O(k + log n), where k is # erased; thus O(n) worst case.</span></div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span>  rcv_packets_with_gaps.erase(start_contig_it, end_contig_it); <span class="comment">// Does nothing if end_contig_it == start_contig_it.</span></div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span>  sock-&gt;m_rcv_reassembly_q_data_size -= total_written;</div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span>} <span class="comment">// Node::sock_slide_rcv_next_seq_num()</span></div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"> 1540</span> </div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7"> 1541</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">Node::sock_max_packets_after_unrecvd_packet</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"> 1542</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"> 1543</span>  <span class="comment">/* The limit itself is not an option but rather computed from other options to be</span></div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"> 1544</span><span class="comment">   * more dynamic.  Let N be the desired max ratio of rcv_packets_with_gaps.size() * max-block-size</span></div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span><span class="comment">   * to the max Receive buffer size, expressed in percent.  Then the max</span></div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"> 1546</span><span class="comment">   * rcv_packets_with_gaps.size() value is N% * &lt;max Receive buffer size&gt; / max-block-size / 100%.</span></div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span><span class="comment">   * N is the option m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent. */</span></div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span>  <span class="keywordflow">return</span> uint64_t(sock-&gt;opt(sock-&gt;m_opts.m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent)) *</div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span>         uint64_t(sock-&gt;opt(sock-&gt;m_opts.m_st_rcv_buf_max_size)) /</div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span>         uint64_t(sock-&gt;max_block_size()) /</div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span>         100;</div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span>}</div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span> </div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc"> 1554</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">Node::rcv_get_first_gap_info</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock,</div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"> 1555</span>                                  <span class="keywordtype">bool</span>* first_gap_exists, <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_after_first_gap)</div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"> 1556</span>{</div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"> 1557</span>  <span class="comment">// If false, all received packets are followed by all unreceived ones.  Otherwise there&#39;s at least 1 gap.</span></div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"> 1558</span>  *first_gap_exists = !sock-&gt;m_rcv_packets_with_gaps.empty();</div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span>  <span class="comment">// If true, then this is the sequence number of the first datum right after that first gap.</span></div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span>  <span class="keywordflow">if</span> (*first_gap_exists)</div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span>  {</div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span>    *seq_num_after_first_gap = sock-&gt;m_rcv_packets_with_gaps.begin()-&gt;first;</div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span>  }</div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span>}</div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"> 1565</span> </div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6"> 1566</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">Node::async_acknowledge_packet</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rexmit_id,</div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"> 1567</span>                                    <span class="keywordtype">size_t</span> data_size)</div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"> 1568</span>{</div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"> 1569</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"> 1570</span> </div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span>  <span class="comment">// Plenty of info logged in caller, so don&#39;t re-log.</span></div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Accumulating for acknowledgment.&quot;</span>);</div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span> </div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span>  <span class="comment">// Register one packet with N bytes of data (not necessarily acceptable data).</span></div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span>  sock-&gt;m_rcv_stats.total_to_send_ack_packet(data_size);</div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span> </div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"> 1577</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> acks_pending_before_this = sock-&gt;m_rcv_pending_acks.size();</div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span> </div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"> 1579</span>  <span class="keyword">static_assert</span>(std::is_aggregate_v&lt;Peer_socket::Individual_ack&gt;,</div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"> 1580</span>                <span class="stringliteral">&quot;We want it to be direct-initializable.&quot;</span>);</div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"> 1581</span>  <span class="keyword">static_assert</span>((!std::is_copy_constructible_v&lt;Peer_socket::Individual_ack&gt;)</div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span>                  &amp;&amp; (!std::is_copy_assignable_v&lt;Peer_socket::Individual_ack&gt;),</div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span>                <span class="stringliteral">&quot;We want it to be noncopyable but rather passed-around via its ::Ptr.&quot;</span>);</div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span> </div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span>  <span class="comment">/* Just the starting sequence number sufficient to identify a single packet.  The time point saved</span></div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span><span class="comment">   * here is subtracted from time_now() at ACK send time, to compute the artificial delay introduced</span></div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span><span class="comment">   * by ACK delaying (explained just below).  This helps other side calculate a more accurate RTT by</span></div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span><span class="comment">   * substracting the ACK delay from its RTT measurement. */</span></div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span>  sock-&gt;m_rcv_pending_acks.push_back</div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"> 1590</span>    (<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#ad32d17739f7965eeeedfbeae5bfbc1a3">Peer_socket::Individual_ack::Ptr</a></div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"> 1591</span>       (<span class="keyword">new</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html">Peer_socket::Individual_ack</a>{ seq_num, rexmit_id, Fine_clock::now(), data_size }));</div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"> 1592</span> </div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span>  <span class="comment">/* m_rcv_pending_acks now stores at least one packet to acknowledge.  We can acknowledge it</span></div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span><span class="comment">   * immediately (modulo UDP layer availability of course).  However, suppose there is a fast stream</span></div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span><span class="comment">   * of packets coming in, such that several DATA packets were read in within one</span></div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span><span class="comment">   * low_lvl_recv_and_handle() call.  Then each DATA packet will result in one ACK packet.</span></div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span><span class="comment">   * This introduces a ton of overhead, as the header is quite large given that the payload is just</span></div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span><span class="comment">   * a Sequence_number.  Instead we would want to pack all the DATA packets&#39; acknowledgments into</span></div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span><span class="comment">   * one ACK packet (unless it overflows, in which case create more ACK packets as needed).  So we</span></div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span><span class="comment">   * only accumulate the individual acknowledgments here; we will possibly send the actual ACK(s) in</span></div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"> 1601</span><span class="comment">   * perform_accumulated_on_recv_tasks(), which runs at the end of low_lvl_recv_and_handle() (or its</span></div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"> 1602</span><span class="comment">   * bro, the async part of async_wait_latency_then_handle_incoming()).</span></div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"> 1603</span><span class="comment">   *</span></div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span><span class="comment">   * Caveat: The above is rock-solid if the different DATA packets being acked were contiguous to</span></div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span><span class="comment">   * each other chronologically.  What if there is another type of packet between some two of these</span></div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span><span class="comment">   * DATAs?  Well, it depends on what it is.  Ignoring the misbehaving/duplicate/whatever packets</span></div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span><span class="comment">   * (SYN, for example) -- which will just be discarded basically -- let&#39;s consider the</span></div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span><span class="comment">   * possibilities.  If the packet is ACK, then it is irrelevant; NetFlow (like TCP) is full-duplex</span></div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span><span class="comment">   * (actually more so, since there&#39;s no DATA+ACK piggy-backing), therefore the micro-ordering of</span></div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"> 1610</span><span class="comment">   * traffic in opposite directions is irrelevant.  If the packet is RST, then that means the socket</span></div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span><span class="comment">   * will get closed (no longer ESTABLISHED) before we get a chance to send any of the individual</span></div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span><span class="comment">   * acknowledgments.  However, that is more or less OK; if the other side sent RST, then they won&#39;t</span></div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"> 1613</span><span class="comment">   * accept any ACKs we may send them anyway.  The only other possibility has to with graceful close,</span></div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"> 1614</span><span class="comment">   * but that is not yet implemented.</span></div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"> 1615</span><span class="comment">   * @todo Revisit this when graceful close is implemented.  (Preliminary idea: force immediate ACK</span></div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"> 1616</span><span class="comment">   * handling when FIN/etc. detected?  Or something.) */</span></div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span> </div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span>  <span class="keywordflow">if</span> (m_socks_with_accumulated_pending_acks.insert(sock).second)</div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span>  {</div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span>    <span class="comment">/* First acknowledgment to be accumulated in this handler (low_lvl_recv_and_handle() or</span></div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span><span class="comment">     * async part of async_wait_latency_then_handle_incoming()).  So mark down whether at that time there were</span></div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span><span class="comment">     * already timer-delayed acknowledgments pending (and how many).  See</span></div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span><span class="comment">     * sock_perform_accumulated_on_recv_tasks() for details on delayed ACKs. */</span></div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span>    sock-&gt;m_rcv_pending_acks_size_at_recv_handler_start = acks_pending_before_this;</div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"> 1625</span>  }</div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"> 1626</span>  <span class="comment">// else already had registered pending acknowledgment in this handler.</span></div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"> 1627</span>} <span class="comment">// Node::async_acknowledge_packet()</span></div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"> 1628</span> </div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd"> 1629</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">Node::handle_accumulated_pending_acks</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span>{</div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span>  <span class="keyword">using </span>boost::chrono::microseconds;</div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span>  <span class="keyword">using </span>boost::chrono::duration_cast;</div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span> </div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"> 1637</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"> 1638</span> </div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"> 1639</span>  <span class="comment">// For background see Node::perform_accumulated_on_recv_tasks().</span></div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"> 1640</span> </div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span>  <span class="comment">// For brevity and speed:</span></div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span>  vector&lt;Peer_socket::Individual_ack::Ptr&gt;&amp; pending_acks = sock-&gt;m_rcv_pending_acks;</div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span> </div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>)</div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span>  {</div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span>    <span class="comment">// For example, we got DATA and then RST on the same socket almost simultaneously.</span></div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Was about to perform accumulated acknowledgment tasks on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] but skipping because &quot;</span></div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span>                   <span class="stringliteral">&quot;state is now [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span>  }</div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span> </div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span>  <span class="comment">// Check explicit pre-condition.</span></div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span>  assert(!pending_acks.empty());</div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span> </div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span>  <span class="comment">/* Deal with any accumulated acknowledgments.  Naively, we&#39;d simply call async_low_lvl_ack_send()</span></div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span><span class="comment">   * here, which would take pending_acks and bundle them up into as few as possible ACK</span></div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"> 1657</span><span class="comment">   * packets and send them off.</span></div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"> 1658</span><span class="comment">   *</span></div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"> 1659</span><span class="comment">   * However, we potentially instead use delayed ACKing as in typical TCP implementations (based on</span></div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"> 1660</span><span class="comment">   * various standard RFCs).  The idea is that a few DATA packets have come in around the same time,</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"> 1661</span><span class="comment">   * but not close enough to be handled in one receive handler.  So upon detecting the first DATA</span></div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span><span class="comment">   * packet in the steady state, start a timer; until it fires accumulate more packets in</span></div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span><span class="comment">   * pending_acks; and when it fires finally assemble and flush (send) the ACK(s).  Something else may trigger</span></div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span><span class="comment">   * the flushing of the ACK(s) ahead of this timer or even immediately.</span></div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span><span class="comment">   *</span></div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span><span class="comment">   * These are situations where we must short-circuit the timer and send the ACK(s)</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span><span class="comment">   * immediately:</span></div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span><span class="comment">   *</span></div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"> 1669</span><span class="comment">   *   1. From TCP (RFC 5681-4.2), which says that an ACK should be generated for at</span></div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"> 1670</span><span class="comment">   *      least every second full-sized (data size = MSS) incoming data segment.  The reasoning is</span></div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"> 1671</span><span class="comment">   *      two-fold: causing bursty sending by the receiver of the ACKs; and slowing down slow start</span></div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"> 1672</span><span class="comment">   *      in Reno (and others) congestion control.  The latter is not really a problem for us (since</span></div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"> 1673</span><span class="comment">   *      ACKs are not cumulative but selective and handled as such by our congestion control logic);</span></div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span><span class="comment">   *      but the former is definitely an easily demonstrable issue. @todo This paragraph is difficult</span></div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span><span class="comment">   *      to understand right now.  There might be 1 or more unintentional meaning inversions, wherein</span></div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span><span class="comment">   *      I mean to say X is good, but instead say X is bad, or vice vera, or at least it&#39;s unclear.  Research;</span></div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span><span class="comment">   *      rephrase.</span></div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span><span class="comment">   *</span></div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span><span class="comment">   *   2. Also from TCP (RFC 5681-3.2), which says that an ACK should be</span></div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span><span class="comment">   *      immediately generated upon detecting an out-of-order data segment.  This is to inform</span></div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span><span class="comment">   *      congestion control of any loss event as soon as possible (Fast Recovery algorithm).</span></div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span><span class="comment">   *</span></div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span><span class="comment">   * Note that TCP RFCs don&#39;t account for the implementation detail that several packets can be</span></div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span><span class="comment">   * received &quot;simultaneously&quot; (in one handler in our case), nor for selective ACKs (in this</span></div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span><span class="comment">   * context), so when they say we must send an ACK for every 2 incoming segments at least, we do</span></div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"> 1686</span><span class="comment">   * not take this literally.  Instead, we just say that if (here, after a full receive handler has</span></div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"> 1687</span><span class="comment">   * run) there are at least 2 full blocks&#39; worth of pending acknowledgments (there could be many</span></div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"> 1688</span><span class="comment">   * more in theory) and/or there&#39;s an out-of-order DATA packet, then we send immediate ACK(s), thus</span></div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"> 1689</span><span class="comment">   * following the spirit of the rules in the RFC.  The spirit of the rule is to short-circuit the</span></div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span><span class="comment">   * timer the moment at least 2 full packets can be acknowledged.</span></div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span><span class="comment">   *</span></div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span><span class="comment">   * We detect both of these situations below and act accordingly.  We also start the delayed ACK</span></div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span><span class="comment">   * timer, if necessary, otherwise.  Oh, and there&#39;s a mode to disable delayed ACKs.</span></div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span><span class="comment">   *</span></div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span><span class="comment">   * @todo We may also force immediate ACKing during graceful shutdown.  Revisit when graceful</span></div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span><span class="comment">   * shutdown is implemented.... */</span></div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span> </div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> delayed_ack_timer_period = sock-&gt;opt(sock-&gt;m_opts.m_st_delayed_ack_timer_period);</div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span> </div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span>  <span class="keywordtype">bool</span> force_ack = delayed_ack_timer_period == Fine_duration::zero(); <span class="comment">// Delayed ACKs disabled.</span></div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span> </div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span>  <span class="keywordflow">if</span> (force_ack)</div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span>  {</div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span>      (<span class="stringliteral">&quot;Delayed [ACK] feature disabled on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]; forcing immediate [ACK].  &quot;</span></div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span>       <span class="stringliteral">&quot;Receive window state: [&quot;</span> &lt;&lt; sock-&gt;m_rcv_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"> 1707</span>       <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; sock-&gt;m_rcv_packets_with_gaps.size() &lt;&lt; <span class="stringliteral">&quot;:{...}.&quot;</span>);</div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"> 1708</span>  }</div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"> 1709</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sock-&gt;m_rcv_packets_with_gaps.empty())</div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"> 1710</span>  {</div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span>    <span class="comment">/* Scan to see if there was an out-of-order DATA packet.  That is to say, have we received a</span></div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span><span class="comment">     * DATA packet -- i.e., have we queued a pending acknowledgment in this receive handler -- that</span></div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span><span class="comment">     * follows at least one unreceived packet in the sequence number space.</span></div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span><span class="comment">     *</span></div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"> 1715</span><span class="comment">     * There is a gap in the received sequence number space, so this is potentially possible.  Scan</span></div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span><span class="comment">     * only the DATA packets (acknowledgments) accumulated in THIS handler (since previous ones</span></div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span><span class="comment">     * have already been checked, and unreceived gaps can&#39;t just appear out of nowhere later).  If</span></div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span><span class="comment">     * any is past the first gap, it qualifies.  (The reverse is true.  If it&#39;s past any gap, it&#39;s</span></div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span><span class="comment">     * past the first gap.) */</span></div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span>    <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#a209d79e058d103c84fc10be84d492a8b">Peer_socket::Individual_ack::Const_ptr</a> ack;</div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ack_idx = sock-&gt;m_rcv_pending_acks_size_at_recv_handler_start;</div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"> 1722</span>         ack_idx != pending_acks.size(); ++ack_idx)</div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"> 1723</span>    {</div>
<div class="line"><a id="l01724" name="l01724"></a><span class="lineno"> 1724</span>      ack = pending_acks[ack_idx];</div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"> 1725</span>      <span class="keywordflow">if</span> (ack-&gt;m_seq_num &gt; sock-&gt;m_rcv_next_seq_num)</div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span>      {</div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span>        force_ack = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span>      }</div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span>    }</div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span> </div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span>    <span class="keywordflow">if</span> (force_ack)</div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span>    {</div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span>        (<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span>         <span class="stringliteral">&quot;received out-of-order packet [&quot;</span> &lt;&lt; ack-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, size &quot;</span> &lt;&lt; ack-&gt;m_data_size &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span>         <span class="stringliteral">&quot;rexmit &quot;</span> &lt;&lt; ack-&gt;m_rexmit_id &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span>         <span class="stringliteral">&quot;forcing immediate [ACK].  &quot;</span></div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span>         <span class="stringliteral">&quot;Receive window state: [&quot;</span> &lt;&lt; sock-&gt;m_rcv_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span>         <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; sock-&gt;m_rcv_packets_with_gaps.size() &lt;&lt; <span class="stringliteral">&quot;:{...}.&quot;</span>);</div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span>    }</div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"> 1742</span>  }</div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"> 1743</span>  <span class="keywordflow">if</span> (!force_ack)</div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"> 1744</span>  {</div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"> 1745</span>    <span class="comment">// No out-of-order stuff.  See if there are at least N * max-block-size bytes pending to be acknowledged.</span></div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"> 1746</span> </div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> limit <span class="comment">// Default 2.</span></div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span>      = sock-&gt;opt(sock-&gt;m_opts.m_st_max_full_blocks_before_ack_send) * sock-&gt;max_block_size();</div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span>    <span class="keywordtype">size_t</span> bytes = 0;</div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span>    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#a209d79e058d103c84fc10be84d492a8b">Peer_socket::Individual_ack::Const_ptr</a> ack : pending_acks)</div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span>    {</div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span>      bytes += ack-&gt;m_data_size;</div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span>      <span class="keywordflow">if</span> (bytes &gt;= limit)</div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span>      {</div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span>        force_ack = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span>      }</div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span>    }</div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"> 1759</span> </div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"> 1760</span>    <span class="keywordflow">if</span> (force_ack)</div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"> 1761</span>    {</div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"> 1762</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span>                     <span class="stringliteral">&quot;accumulated at least [&quot;</span> &lt;&lt; limit &lt;&lt; <span class="stringliteral">&quot;] bytes to acknowledge; &quot;</span></div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span>                     <span class="stringliteral">&quot;forcing immediate [ACK].&quot;</span>);</div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span>    }</div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span>  }</div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span> </div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span>  <span class="comment">// OK; force_ack is set finally.</span></div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span> </div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span>  <span class="keywordflow">if</span> (force_ack)</div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span>  {</div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span>    <span class="comment">/* Yep, must send ACK(s) now.  There are two possibilities.  One, a delayed ACK timer may</span></div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"> 1773</span><span class="comment">     * already be running.  If so, we should cancel it and send immediately.  If the cancel fails</span></div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"> 1774</span><span class="comment">     * (returns 0 tasks canceled), then it was already queued to fire very soon, so we should</span></div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"> 1775</span><span class="comment">     * just let the ACKing happen that way instead of sending immediately.</span></div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"> 1776</span><span class="comment">     *</span></div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"> 1777</span><span class="comment">     * Two, a timer is not running, so we shouldn&#39;t cancel and should just send immediately.</span></div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span><span class="comment">     *</span></div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span><span class="comment">     * How to determine if timer is currently running?  If</span></div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span><span class="comment">     * m_rcv_pending_acks_size_at_recv_handler_start == 0, then the timer was either never scheduled</span></div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span><span class="comment">     * (only scheduled when pending_acks.empty()) or was triggered and handled before the current</span></div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span><span class="comment">     * handler; therefore it is not running.  Otherwise, there were pending acks to send, yet they</span></div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"> 1783</span><span class="comment">     * were not sent by the end of the last handler, which means the timer must be running.</span></div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span><span class="comment">     *</span></div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span><span class="comment">     * (There may be some corner case I&#39;m not imagining such that the timer was running even while</span></div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span><span class="comment">     * m_rcv_pending_acks_size_at_recv_handler_start == 0, but even then the worst that will happen is</span></div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span><span class="comment">     * that we will perform the ACKing here, not cancel that wait, and that timer will</span></div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"> 1788</span><span class="comment">     * harmlessly expire with the timer handler doing nothing.) */</span></div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"> 1789</span> </div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"> 1790</span>    <span class="keywordflow">if</span> (sock-&gt;m_rcv_pending_acks_size_at_recv_handler_start != 0)</div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"> 1791</span>    {</div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span>                     <span class="stringliteral">&quot;canceling delayed [ACK] timer due to forcing &quot;</span></div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span>                     <span class="stringliteral">&quot;immediate [ACK]; would have fired &quot;</span></div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span>                     <span class="stringliteral">&quot;in [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(sock-&gt;m_rcv_delayed_ack_timer.expiry() - Fine_clock::now()) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span>                     <span class="stringliteral">&quot;from now.&quot;</span>);</div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span> </div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span>      <span class="keywordflow">if</span> (sock-&gt;m_rcv_delayed_ack_timer.cancel() == 0)</div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span>      {</div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span>        <span class="comment">/* Unlikely but legitimate; timer was queued to trigger very soon, so we could not</span></div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span><span class="comment">         * cancel it.  No problem -- just let the ACKing happen per timer.  Log INFO due to</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"> 1802</span><span class="comment">         * rarity of this situation. */</span></div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span>        <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span>                      <span class="stringliteral">&quot;tried to cancel delayed [ACK] timer while &quot;</span></div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span>                      <span class="stringliteral">&quot;forcing [ACK], but it was already just about to fire.&quot;</span>);</div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"> 1806</span>        force_ack = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"> 1807</span>      }</div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"> 1808</span>    } <span class="comment">// if (m_rcv_pending_acks_size_at_recv_handler_start != 0) [timer was running]</span></div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span> </div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span>    <span class="comment">// If still forcing immediate ACK, finally do it.</span></div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span>    <span class="keywordflow">if</span> (force_ack)</div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span>    {</div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span>      async_low_lvl_ack_send(sock);</div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span>      assert(pending_acks.empty());</div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span>    }</div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span>  } <span class="comment">// if (force_ack)</span></div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span>  <span class="keywordflow">else</span> <span class="comment">// if (!force_ack)</span></div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span>  {</div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span>    <span class="comment">/* There are pending individual acks but no reason to send them off right now.  The only</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span><span class="comment">     * remaining question is whether we need to schedule the delayed ACK timer to send them</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span><span class="comment">     * later.  That depends on whether the timer is already running.  If</span></div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span><span class="comment">     * m_rcv_pending_acks_size_at_recv_handler_start == 0, then the timer was either never scheduled</span></div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span><span class="comment">     * or was triggered and handled before the current handler; therefore it is not running.  So</span></div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"> 1824</span><span class="comment">     * in that case we should start it, as we&#39;ve just received our first ackable DATA since</span></div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"> 1825</span><span class="comment">     * we&#39;ve sent off our last ACK.  If m_rcv_pending_acks_size_at_recv_handler_start != 0, then the</span></div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"> 1826</span><span class="comment">     * timer must be running, because there were pending acks to send, yet they were not send by</span></div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span><span class="comment">     * the end of the last handler (which would have caused this very code to schedule the</span></div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span><span class="comment">     * timer).</span></div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span><span class="comment">     *</span></div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span><span class="comment">     * (There may be some corner case I&#39;m not imagining such that the timer was running even while</span></div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span><span class="comment">     * m_rcv_pending_acks_size_at_recv_handler_start == 0, but even then it can&#39;t possibly be set to</span></div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span><span class="comment">     * the right time [which is S_DELAYED_ACK_TIMER_PERIOD for now], so we need to re-set it</span></div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span><span class="comment">     * anyway.  [Re-setting the expiry time will cancel that running timer wait.  Even if that</span></div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span><span class="comment">     * somehow fails, the worst case is that the ACK(s) will be sent prematurely.]) */</span></div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span> </div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span>    <span class="keywordflow">if</span> (sock-&gt;m_rcv_pending_acks_size_at_recv_handler_start == 0)</div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"> 1837</span>    {</div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"> 1838</span>      <span class="comment">// First individual acknowledgment accumulated: start countdown to send the next batch of acknowledgments.</span></div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"> 1839</span> </div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"> 1840</span>      sock-&gt;m_rcv_delayed_ack_timer.expires_after(delayed_ack_timer_period);</div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span> </div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span>                     <span class="stringliteral">&quot;scheduled delayed [ACK] timer to fire &quot;</span></div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span>                     <span class="stringliteral">&quot;in [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(delayed_ack_timer_period) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span> </div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span>      <span class="comment">// When triggered or canceled, call this-&gt;async_low_lvl_ack_send(sock, &lt;error code&gt;).</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span>      sock-&gt;m_rcv_delayed_ack_timer.async_wait([<span class="keyword">this</span>, socket_id, sock](<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code)</div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"> 1848</span>      {</div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span>        async_low_lvl_ack_send(sock, sys_err_code);</div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span>      });</div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span>      <span class="comment">// ^-- defer_delta_check == false: for similar reason as in send_worker_check_state() calling send_worker().</span></div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"> 1852</span>    }</div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"> 1853</span>    <span class="comment">// else the timer is already started, so just accumulating onto pending_acks is enough.  Done.</span></div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"> 1854</span>  } <span class="comment">// if (!force_ack)</span></div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"> 1855</span> </div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span>  <span class="comment">// Register the current # of DATA packets to acknowledge.  Note that we&#39;re near the end of current handler.</span></div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"> 1857</span>  sock-&gt;m_rcv_stats.current_pending_to_ack_packets(pending_acks.size());</div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span>} <span class="comment">// Node::sock_perform_accumulated_on_recv_tasks()</span></div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span> </div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0"> 1860</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">Node::log_rcv_window</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <span class="keywordtype">bool</span> force_verbose_info_logging)<span class="keyword"> const</span></div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"> 1863</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span>  <span class="keyword">using </span>boost::algorithm::join;</div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span> </div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span>  <span class="comment">// We&#39;re in thread W.</span></div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"> 1867</span> </div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"> 1868</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"> 1869</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Peer_socket::Recvd_pkt_map</a>&amp; rcv_packets_with_gaps = sock-&gt;m_rcv_packets_with_gaps;</div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"> 1870</span> </div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span>  <span class="comment">// force_verbose_info_logging =&gt; log the most detail, as INFO (if INFO logging enabled).</span></div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span> </div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span>  <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span>  <span class="keywordflow">if</span> (((!logger_ptr) || (!logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))) &amp;&amp;</div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span>      (!(force_verbose_info_logging &amp;&amp; logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))))</div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"> 1876</span>  {</div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span>    <span class="comment">// Can&#39;t print entire In-flight data structure, but can print a summary, if TRACE enabled.</span></div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span>      (<span class="stringliteral">&quot;Receive window state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span>       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;m_rcv_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"> 1881</span>       <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; rcv_packets_with_gaps.size() &lt;&lt; <span class="stringliteral">&quot;:{...}.&quot;</span>);</div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"> 1882</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"> 1883</span>  }</div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"> 1884</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span> </div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span>  <span class="comment">/* Construct full printout of the packets we&#39;ve received past the first unreceived gap.</span></div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span><span class="comment">   *</span></div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span><span class="comment">   * Very verbose and slow!  Even so, if it gets beyond a certain size it&#39;s absurd, so skip some in</span></div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span><span class="comment">   * that case even though DATA logging is sanctioned.  (That amount of data cannot really be useful</span></div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span><span class="comment">   * in any case.) */</span></div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span> </div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span>  vector&lt;string&gt; pkt_strs;</div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"> 1893</span>  pkt_strs.reserve(rcv_packets_with_gaps.size());</div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span> </div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_TO_SHOW = 100;</div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"> 1896</span>  <span class="keywordtype">bool</span> skipped_some = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"> 1897</span>  <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"> 1898</span> </div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"> 1899</span>  <span class="keywordflow">for</span> (<a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">Peer_socket::Recvd_pkt_const_iter</a> pkt_it = rcv_packets_with_gaps.begin();</div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span>       pkt_it != rcv_packets_with_gaps.end();</div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"> 1901</span>       ++pkt_it)</div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span>  {</div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> last_iteration = (count == rcv_packets_with_gaps.size() - 1);</div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span> </div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span>    <span class="keywordflow">if</span> ((!skipped_some) &amp;&amp; (count &gt; MAX_TO_SHOW) &amp;&amp; (!last_iteration))</div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span>    {</div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span>      <span class="comment">// First packet past the limit we can print.  Start skipping mode.</span></div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"> 1908</span>      skipped_some = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span>      ++count;</div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span>    }</div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span>    <span class="comment">// else either we are in skipping more from before, or we are not in skipping mode.</span></div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span> </div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"> 1914</span>    <span class="keywordtype">string</span> pkt_str;</div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span> </div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"> 1916</span>    <span class="keywordflow">if</span> (skipped_some)</div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"> 1917</span>    {</div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"> 1918</span>      <span class="comment">// We are in skipping mode from before.</span></div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"> 1919</span>      <span class="keywordflow">if</span> (!last_iteration)</div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span>      {</div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span>        <span class="comment">// Since it&#39;s not the last iteration, skip: print nothing.</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"> 1922</span>        ++count;</div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span>      }</div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"> 1925</span>      <span class="comment">// else we are in skipping more from before, and this is the last iteration.  Print the placeholder.</span></div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span>      pkt_str = <span class="stringliteral">&quot;[...skipped...] &quot;</span>;</div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span>    }</div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"> 1928</span>    <span class="comment">// Either we are not in skipping mode (just print the thing) or we are and it&#39;s last iteration (also print it).</span></div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span> </div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"> 1930</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> start, end;</div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"> 1931</span>    get_seq_num_range(pkt_it, &amp;start, &amp;end);</div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"> 1932</span> </div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"> 1933</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#a8afd30c50bcd670d45442df49d1da484">util::ostream_op_to_string</a>(&amp;pkt_str, <span class="charliteral">&#39;[&#39;</span>, start, <span class="stringliteral">&quot;, &quot;</span>, end, <span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span>    pkt_strs.push_back(pkt_str);</div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span> </div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span>    ++count;</div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span>  } <span class="comment">// for (packets in rcv_packets_with_gaps)</span></div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span> </div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span>  <a class="code hl_define" href="log_8hpp.html#a5daa2b6d16edea74bb8bddc75f7fb801">FLOW_LOG_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span>    (force_verbose_info_logging ? <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a> : <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>,</div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span>     <span class="stringliteral">&quot;Receive window state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span>       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;m_rcv_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_rcv_next_seq_num &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span>       <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; rcv_packets_with_gaps.size() &lt;&lt; <span class="stringliteral">&quot;:{&quot;</span> &lt;&lt; join(pkt_strs, <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;}.&quot;</span>);</div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"> 1944</span>} <span class="comment">// Node::log_rcv_window()</span></div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"> 1945</span> </div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94"> 1946</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">Node::handle_ack_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"> 1947</span>                                     boost::shared_ptr&lt;const Ack_packet&gt; ack)</div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"> 1948</span>{</div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span> </div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span>  <span class="comment">/* packet is an ACK, so its payload consists of at least m_rcv_wnd (the current advertised Receive</span></div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span><span class="comment">   * buffer space on the receiver) and packet-&gt;m_rcv_acked_packets, which is basically a list of ZERO or</span></div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span><span class="comment">   * more sequence numbers, each of which represents a packet we&#39;d (hopefully) sent that the</span></div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span><span class="comment">   * receiver has received.  Naively we&#39;d just handle the window update and each individual ack here</span></div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span><span class="comment">   * in a loop, then inform congestion control, etc. etc.  However there is an optimization to make.</span></div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span><span class="comment">   * Suppose in the calling low_lvl_recv_and_handle() or async-part-of-async_wait_latency_then_handle_incoming()</span></div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span><span class="comment">   * there are several more ACKs for this socket sock that will be received. This may well happen in</span></div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span><span class="comment">   * high traffic; for instance the sender may have had too many individual acks for one ACK and</span></div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"> 1959</span><span class="comment">   * thus sent several; or maybe the UDP net-stack had a few packets ready by the time boost.asio was</span></div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"> 1960</span><span class="comment">   * free in thread W.  In this case, it is better to collect all the individuals acks in these</span></div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"> 1961</span><span class="comment">   * several ACKs, and then handle them all at the same time.  Why?  Answer: it will update our</span></div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"> 1962</span><span class="comment">   * sender state (what&#39;s ACKed, what&#39;s dropped) entirely in one go instead of doing it in two or</span></div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span><span class="comment">   * more steps.  Because congestion control activities (&quot;on drop event,&quot; &quot;on acknowledgment&quot;) are</span></div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span><span class="comment">   * performed after handling all the available acks, it gives a truer, simpler picture to the</span></div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span><span class="comment">   * congestion control module, when compared to giving it one picture and then almost instantly</span></div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span><span class="comment">   * giving it another. Another way to think of it is simply that since the different ACKs arrived</span></div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span><span class="comment">   * at the same time, and all an ACK is is a collection of individual acks that could fit into the</span></div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span><span class="comment">   * ACK packet, then conceptually this is no different from being one super-ACK with all the</span></div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span><span class="comment">   * individual acks contained in it.  Therefore it is at least not worse.</span></div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span><span class="comment">   *</span></div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span><span class="comment">   * (In addition, m_rcv_wnd also affects the decision on whether to send more data over the wire,</span></div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span><span class="comment">   * as can_send() is part of that same algorithm.)</span></div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"> 1973</span><span class="comment">   *</span></div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span><span class="comment">   * Caveat: The above is rock-solid if the different ACKs being combined were contiguous to each</span></div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span><span class="comment">   * other chronologically.  What if there is another type of packet between some two of these ACKs?</span></div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span><span class="comment">   * Well, it depends on what it is.  Ignoring the misbehaving/duplicate/whatever packets (SYN, for</span></div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span><span class="comment">   * example) -- which will just be discarded basically -- let&#39;s consider the possibilities.  If</span></div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span><span class="comment">   * the packet is DATA, then it is irrelevant; NetFlow (like TCP) is full-duplex (actually more so,</span></div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span><span class="comment">   * since there&#39;s no DATA+ACK piggy-backing), therefore the micro-ordering of traffic in opposite</span></div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"> 1980</span><span class="comment">   * directions is irrelevant.  If the packet is RST, then that means the socket will get closed (no</span></div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span><span class="comment">   * longer ESTABLISHED) before we get a chance to process any of the individual acknowledgments.</span></div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span><span class="comment">   * However, that is more or less OK; if the other side sent RST, then they won&#39;t accept any</span></div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span><span class="comment">   * further data we may send after processing the acknowledgments anyway.  The only other</span></div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"> 1984</span><span class="comment">   * possibility has to with graceful close, but that is not yet implemented.</span></div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"> 1985</span><span class="comment">   * @todo Revisit this when graceful close is implemented.  (Preliminary idea: accumulate DATA and</span></div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"> 1986</span><span class="comment">   * FIN/etc. packets and always handle them after handling ACKs.  Then the DATA/FIN stream will not</span></div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"> 1987</span><span class="comment">   * have a chance to disrupt (by initiating closing the connection) the ACK handling, while the ACK</span></div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span><span class="comment">   * handling should have no bearing on the DATA/FIN stream.)</span></div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span><span class="comment">   *</span></div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span><span class="comment">   * So, let&#39;s accumulate the individual acks in packet-&gt;m_rcv_acked_packets into a big</span></div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span><span class="comment">   * sock-&gt;m_rcv_acked_packets to be handled from perform_accumulated_on_recv_tasks() at the end of the</span></div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span><span class="comment">   * current handler.  Similarly save m_rcv_wnd into sock-&gt;m_pending_rcv_wnd.  To let that method</span></div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"> 1993</span><span class="comment">   * know sock has a new m_pending_rcv_wnd and possibly non-empty sock-&gt;m_rcv_acked_packets, insert sock</span></div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"> 1994</span><span class="comment">   * into m_socks_with_accumulated_acks. */</span></div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"> 1995</span> </div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"> 1996</span>  <span class="comment">/* Note: We&#39;re not setting the actual sock-&gt;m_snd_remote_rcv_wnd until</span></div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"> 1997</span><span class="comment">   * perform_accumulated_on_recv_tasks().</span></div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"> 1998</span><span class="comment">   *</span></div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span><span class="comment">   * Also note: the latest ACK to arrive in this receive handler will contain the most up-to-date</span></div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span><span class="comment">   * rcv_wnd value (previous ones are overwritten by this). */</span></div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"> 2001</span>  sock-&gt;m_snd_pending_rcv_wnd = ack-&gt;m_rcv_wnd;</div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span> </div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"> 2003</span>  <span class="comment">// It&#39;s a (ref-counted) pointer copy. Note there may be 0 elements there, if it&#39;s just an m_rcv_wnd update alone.</span></div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"> 2004</span>  sock-&gt;m_rcv_acked_packets.insert(sock-&gt;m_rcv_acked_packets.end(), <span class="comment">// Append.</span></div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"> 2005</span>                                   ack-&gt;m_rcv_acked_packets.begin(), ack-&gt;m_rcv_acked_packets.end());</div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"> 2006</span>  m_socks_with_accumulated_acks.insert(sock); <span class="comment">// May already be in there.</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"> 2007</span> </div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span>                 <span class="stringliteral">&quot;Received and accumulated [&quot;</span> &lt;&lt; ack-&gt;m_type_ostream_manip &lt;&lt; <span class="stringliteral">&quot;] with &quot;</span></div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; ack-&gt;m_rcv_acked_packets.size() &lt;&lt; <span class="stringliteral">&quot;] individual acknowledgments &quot;</span></div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span>                 <span class="stringliteral">&quot;and rcv_wnd = [&quot;</span> &lt;&lt; ack-&gt;m_rcv_wnd &lt;&lt; <span class="stringliteral">&quot;]; total for this socket in this &quot;</span></div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"> 2012</span>                 <span class="stringliteral">&quot;receive handler is [&quot;</span> &lt;&lt; sock-&gt;m_rcv_acked_packets.size() &lt;&lt; <span class="stringliteral">&quot;] individual acknowledgments.&quot;</span>);</div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"> 2013</span> </div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"> 2014</span>  sock-&gt;m_snd_stats.received_low_lvl_ack_packet(ack-&gt;m_rcv_acked_packets.empty());</div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"> 2015</span>} <span class="comment">// Node::handle_ack_to_established()</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span> </div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006"> 2017</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">Node::handle_accumulated_acks</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span>{</div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span>  <span class="keyword">using </span>std::min;</div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"> 2021</span>  <span class="keyword">using </span>boost::tuple;</div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"> 2022</span>  <span class="keyword">using </span>boost::unordered_set;</div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"> 2023</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"> 2024</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span>  <span class="keyword">using </span>boost::chrono::seconds;</div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span> </div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span>  <span class="comment">/* This is a complex method that does many things.  Therefore readability is hard to accomplish, as the logic</span></div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span><span class="comment">   * makes sense when writing it, but the big picture is hard to see when reading it.  The necessary heavy commenting</span></div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span><span class="comment">   * further increases the size and therefore (along that dimension) decreases readability.  For these reasons,</span></div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"> 2030</span><span class="comment">   * many logically distinct parts were placed into helper methods -- not to increase code reuse but to help</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"> 2031</span><span class="comment">   * the aforementioned consideration. */</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"> 2032</span> </div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"> 2033</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span> </div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span>  log_accumulated_acks(sock);</div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"> 2036</span>  <span class="comment">// Below TRACE messages omit most of the just-logged detail, since it&#39;s already logged now.</span></div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span> </div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span>  <span class="keyword">using </span>Acks = vector&lt;Ack_packet::Individual_ack::Ptr&gt;;</div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"> 2040</span>  Acks&amp; acked_packets = sock-&gt;m_rcv_acked_packets;</div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"> 2041</span>  <span class="comment">/* To not put already-handled acknowledgments up for handling again in the next run of this method</span></div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"> 2042</span><span class="comment">   * (which would be wrong), we must clear acked_packets before exiting this method.  To be safe,</span></div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"> 2043</span><span class="comment">   * make sure acked_packets.clear() runs no matter how this method exits. */</span></div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#ab22fd89e165a9e6deaa174bc0dfdc8de">util::Auto_cleanup</a> cleanup = <a class="code hl_function" href="namespaceflow_1_1util.html#a09a032f8e1e77a3afc0b7df115a773e1">util::setup_auto_cleanup</a>([&amp;]() { acked_packets.clear(); });</div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span> </div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span>  <span class="comment">/* Handle all the acknowledgments we&#39;ve received in this receive handler.  Background on the</span></div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"> 2047</span><span class="comment">   * accumulation tactic is in handle_ack_to_established().  As explained in that method, some</span></div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span><span class="comment">   * packet between the first and last ACK received in this handler may have changed state away from</span></div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span><span class="comment">   * ESTABLISHED.  For example, there could have been an RST.  Check for that. */</span></div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"> 2050</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>)</div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"> 2051</span>  {</div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"> 2052</span>    <span class="comment">// Rare/interesting enough for INFO.</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"> 2053</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span>                  <span class="stringliteral">&quot;Accumulated [ACK] packets with [&quot;</span> &lt;&lt; acked_packets.size() &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span>                  <span class="stringliteral">&quot;individual acknowledgments, but state is now [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;]; ignoring ACKs forever.&quot;</span>);</div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span>  }</div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span>  <span class="comment">// else OK.  Handle the accumulated acknowledgments.</span></div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"> 2059</span>  assert(sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>);</div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"> 2060</span> </div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"> 2061</span>  <span class="comment">/* The individual acknowledgments are (sequence number, ACK delay in unit X, retransmission ID)</span></div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"> 2062</span><span class="comment">   * triples, where the latter is always zero unless retransmission is enabled.  Let&#39;s handle each</span></div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span><span class="comment">   * one by updating m_snd_flying_pkts* (i.e., removing that packet from m_snd_flying_pkts*) and</span></div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span><span class="comment">   * informing congestion control.  Before continuing reading the method please look at the large</span></div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span><span class="comment">   * comments for Peer_socket::m_snd_flying_pkts_by_{sent_when|seq_num} (drawing a diagram might also help).</span></div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span><span class="comment">   *</span></div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span><span class="comment">   * Before continuing, quick discussion of corner cases:</span></div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"> 2068</span><span class="comment">   *</span></div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"> 2069</span><span class="comment">   * Any two given such triples may have equal sequence number/retransmission ID entries.  This</span></div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"> 2070</span><span class="comment">   * means that during the last ACK delay timer or boost.asio handler, while accumulating the</span></div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"> 2071</span><span class="comment">   * acknowledgments for this ACK packet, the receiver received the same packet twice (duplicate).</span></div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span><span class="comment">   * (This can happen due to network misbehavior; and due to ACK loss and other conditions when</span></div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span><span class="comment">   * retransmits are enabled.)  Call 2 such packets P1 and P2, where P1 was received first and thus</span></div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span><span class="comment">   * appears earlier in acked_packets.  How do we handle this?</span></div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"> 2075</span><span class="comment">   *</span></div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span><span class="comment">   * Suppose instead of being in the same ACK, P1 and P2 were in different ACKs that arrived in that</span></div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"> 2077</span><span class="comment">   * order, P1 and P2 (something that certainly could happen depending on how the delayed ACK timer</span></div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"> 2078</span><span class="comment">   * works out).  That situation is basically the same (except that if they&#39;re in one ACK there&#39;s</span></div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"> 2079</span><span class="comment">   * the added guarantee that we KNOW what P1 is acknowledging arrived to the receiver before</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"> 2080</span><span class="comment">   * what P2 was acknowledging did, which is even more solid knowledge).  Therefore, it makes sense</span></div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span><span class="comment">   * to simply handle each acknowledgment in the ACK in the order they&#39;re listed in acked_packets.</span></div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span><span class="comment">   * The 2nd, 3rd, etc. occurrence will thus be treated the same way as if it arrived in a later</span></div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span><span class="comment">   * ACK. */</span></div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span> </div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span>  <span class="comment">/* Congestion control: First see introduction to this topic in class Congestion_control_strategy</span></div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"> 2086</span><span class="comment">   * doc header.  Then resume here.</span></div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"> 2087</span><span class="comment">   *</span></div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"> 2088</span><span class="comment">   * Since information stored in ACKs is of paramount importance to how congestion control views the</span></div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"> 2089</span><span class="comment">   * pipe, congestion control is very relevant in this method: this method is the main (but not</span></div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span><span class="comment">   * only) source of events for m_snd_cong_ctl.</span></div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span><span class="comment">   *</span></div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span><span class="comment">   * These ACK-based events are of interest to m_snd_cong_ctl:</span></div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span><span class="comment">   *</span></div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"> 2094</span><span class="comment">   *   - on_acks(N, M): N bytes in M packets have just been converted from In-flight to</span></div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span><span class="comment">   *     Acknowledged.  Note that these packets have NOT been previously Acknowledged or considered</span></div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"> 2096</span><span class="comment">   *     Dropped (they are In-flight just before the ACK).</span></div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"> 2097</span><span class="comment">   *     - This should also be immediately preceded with M on_individual_ack(N&#39;, T, CWND) events, where N&#39;</span></div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"> 2098</span><span class="comment">   *       is the # of bytes in the individual acked packet; and T is the RTT of the packet, and CWND is the</span></div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"> 2099</span><span class="comment">   *       # of bytes in cwnd that was used when the acked data pkt was sent.</span></div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span><span class="comment">   *       In the rest of the discussion I omit this event, as it can be thought of as part of</span></div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span><span class="comment">   *       on_acks() for purposes of the discussion.</span></div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"> 2102</span><span class="comment">   *   - on_loss_event(N&#39;, M&#39;): N&#39; bytes in M&#39; packets have just been converted from In-flight to</span></div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span><span class="comment">   *     Dropped.</span></div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span><span class="comment">   *</span></div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span><span class="comment">   * The basic idea is to determine which of these events are implied by the acks passed to this</span></div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"> 2106</span><span class="comment">   * method, inform m_snd_cong_ctl, and then check if the new m_snd_cong_ctl-&gt;congestion_window_bytes()</span></div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"> 2107</span><span class="comment">   * value (a/k/a CWND) -- if it has changed -- allows us to now send more bytes (if we have any).</span></div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"> 2108</span><span class="comment">   *</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"> 2109</span><span class="comment">   * An important decision (and one sadly not very explicitly exposed [perhaps as an exercise to the</span></div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span><span class="comment">   * reader, or to avoid being too rigid] in the various TCP RFCs) is how to group these events and</span></div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span><span class="comment">   * in what order.  In other words, do we call on_acks(N, 1) for each acknowledged packet?  Do we</span></div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span><span class="comment">   * then check for drops and call on_loss_event(N&#39;, M&#39;) immediately, or wait to process all acked</span></div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span><span class="comment">   * packets first?</span></div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span><span class="comment">   *</span></div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"> 2115</span><span class="comment">   * The answer we choose is simple.  First, scan all individual (i.e., for each sent packet) acks</span></div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"> 2116</span><span class="comment">   * given to us and update m_snd_flying_pkts_by_seq_num (the &quot;scoreboard&quot;).  While doing so keep track of</span></div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"> 2117</span><span class="comment">   * the cumulative N and M.  Having done that, we will also expose zero or more In-flight packets</span></div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"> 2118</span><span class="comment">   * as Dropped.  (In this method, a given packet is exposed as Dropped if the total number of</span></div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span><span class="comment">   * acknowledged packets AFTER that packet exceeds a constant like 2.  So basically if the acks we</span></div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span><span class="comment">   * process here make that counter exceed that limit for a given packet P, P is Dropped and removed</span></div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span><span class="comment">   * from m_snd_flying_pkts_by_seq_num.)  So after the ack scanning phase, tally up all packets now</span></div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span><span class="comment">   * considered Dropped, which gives us N&#39; and M&#39;.</span></div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span><span class="comment">   *</span></div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"> 2124</span><span class="comment">   * Finally, call on_loss_event(N&#39;, M&#39;) (assuming N&#39; and M&#39; are not zero).  And then call</span></div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"> 2125</span><span class="comment">   * on_acks(M, N) (assuming N and M are not zero).</span></div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"> 2126</span><span class="comment">   *</span></div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"> 2127</span><span class="comment">   * Let&#39;s justify this.  First, assume it&#39;s correct to tally these things up and then just</span></div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span><span class="comment">   * call each method once.  Is the &quot;report loss, report acks&quot; order right?  Yes.  Intuitively,</span></div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span><span class="comment">   * m_snd_cong_ctl wants to know about events in the chronological order they occur.  While the Drop(s)</span></div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span><span class="comment">   * are detected at the same time as the Ack(s), the actual packet dropping INFERRED from the</span></div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span><span class="comment">   * Ack(s) occurred in the past; we&#39;re only deducing it now.  The received Acks are in fact for</span></div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span><span class="comment">   * packets AFTER the now-Dropped packets.  Hence this is the right order.</span></div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"> 2133</span><span class="comment">   *</span></div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"> 2134</span><span class="comment">   * Now the only remaining thing is to justify combining the ack and drop events in one (each).  For</span></div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"> 2135</span><span class="comment">   * acknowledgments, it&#39;s straightforward: so far, most Congestion_control_strategy modules</span></div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"> 2136</span><span class="comment">   * don&#39;t need to know about each individual ack, so for simplicity/efficiency we can just combine</span></div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span><span class="comment">   * them.  (However, some algorithms do need it; e.g., FAST would need it; still, many don&#39;t.</span></div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span><span class="comment">   * Other modules, like Send_bandwidth_estimator, may also care about individual acks.)</span></div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span><span class="comment">   *</span></div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span><span class="comment">   * What about the drop events?  Why combine all the drops into one?  Should we include all the</span></div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span><span class="comment">   * drops into the one?  To answer, I use as a reference DCCP CCID 2 RFC 4341 (standards track)</span></div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span><span class="comment">   * which describes a protocol similar to ours and implies the following model.  Basically, over</span></div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"> 2143</span><span class="comment">   * time, the pipe experiences a series of 0 or more congestion events (more accurately loss</span></div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"> 2144</span><span class="comment">   * events).  Two loss events cannot overlap in this implied model.  Thus any given Dropped packet</span></div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"> 2145</span><span class="comment">   * belongs to exactly one loss event.  Here is how the RFC (section 5) more or less formally</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"> 2146</span><span class="comment">   * defines whether 2 packets belong to one event: &quot;As in TCP, two losses [...] are considered part</span></div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span><span class="comment">   * of a single congestion event when the second packet was sent before the loss [...] of the first</span></div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"> 2148</span><span class="comment">   * packet was detected.&quot;  Presumably the text also assumes that the &quot;second&quot; packet was</span></div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span><span class="comment">   * found to be dropped either at the same or later time as the &quot;first&quot; packet was found to be</span></div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span><span class="comment">   * dropped (otherwise the text makes no sense, as the very earliest Dropped packet would be in the</span></div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span><span class="comment">   * same congestion event as the very last Dropped packed in a very long session).  Let&#39;s build an</span></div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"> 2152</span><span class="comment">   * algorithm inductively based on this definition.</span></div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"> 2153</span><span class="comment">   *</span></div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"> 2154</span><span class="comment">   * At first there are no loss events.  We get a group of acks which render another group of</span></div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"> 2155</span><span class="comment">   * packets P1, P2, ... (in order of increasing sequence number) Dropped.  Certainly P1 is in a</span></div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span><span class="comment">   * loss event; call it L1.  P2 was found to be dropped at the same or later time as P1; and it was</span></div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span><span class="comment">   * obviously sent before L1 was detected (which was NOW; call it T1).  So P2 is in loss event L1.</span></div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span><span class="comment">   * Similarly, so is P3, P4, ....  Now let&#39;s say some time passes and we get more acks and thus</span></div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span><span class="comment">   * dropped packets P7, P8, P9, ....  Suppose P7 was sent before T1 (but found Dropped at T2 &gt; T1),</span></div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"> 2160</span><span class="comment">   * which is quite possible (e.g., T2 could be just after T1).  Then by the above definition P7 is</span></div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"> 2161</span><span class="comment">   * in loss event L1 (no new loss event).  P8 could be in the same situation.  In fact, all Dropped</span></div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"> 2162</span><span class="comment">   * packets from this ack group may be in L1.  Suppose, conversely, that P9 was sent AFTER T1.  By</span></div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"> 2163</span><span class="comment">   * the above definition, it is part of a new loss event L2, detected at T2.  Now P10, is certainly</span></div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"> 2164</span><span class="comment">   * in L2 as well, since it was sent before T2, obviously.  Thus we can, for each Dropped packet P,</span></div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span><span class="comment">   * determine whether it&#39;s part of the preceding loss event or part of a new one.</span></div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"> 2166</span><span class="comment">   *</span></div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span><span class="comment">   * Intuitively, it makes sense as well.  If, say, we got 5 dropped packets at the same time, and</span></div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span><span class="comment">   * informed Congestion_control_classic (Reno) with 5 calls to on_loss_event(), then CWND would get</span></div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span><span class="comment">   * halved 5 times!  Intuitively that&#39;s not right (and way too conservative).  More likely the 5</span></div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"> 2170</span><span class="comment">   * packets belong to the same congestion or loss event, so CWND should only be halved once.  Then</span></div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"> 2171</span><span class="comment">   * the only question is how to group packets into separate loss events.  The above algorithm,</span></div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"> 2172</span><span class="comment">   * roughly speaking, considers two packets as part of the same loss event if they&#39;re within an RTT</span></div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"> 2173</span><span class="comment">   * of each other (indeed RFC 4341 says one can use the SRTT to approximate the above algorithm,</span></div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span><span class="comment">   * although we choose to use the exact definition instead).</span></div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span><span class="comment">   *</span></div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span><span class="comment">   * Therefore the final algorithm is justified and is as follows:</span></div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span><span class="comment">   *</span></div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span><span class="comment">   *   0. Before the current method is ever called, set time stamp m_snd_last_loss_event_when =</span></div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span><span class="comment">   *      -infinity.</span></div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"> 2180</span><span class="comment">   *   1. Scan all acknowledgments, updating m_snd_flying_pkts* and m_snd_flying_bytes.</span></div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"> 2181</span><span class="comment">   *      Keep track of total acknowledgment stats (bytes and packets). (Inform side modules like</span></div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"> 2182</span><span class="comment">   *      Send_bandwidth_estimator with any required individual ack info like RTTs.)</span></div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"> 2183</span><span class="comment">   *      Ignore acks of packets not in m_snd_flying_pkts* (not In-flight).</span></div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span><span class="comment">   *   2. Tally up which packets are exposed as Dropped by the above m_snd_flying_pkts* updates.</span></div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span><span class="comment">   *      Keep track of total loss stats (bytes and packets).  However, when doing the latter ignore</span></div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"> 2186</span><span class="comment">   *      any packet P for which P.m_sent_when &lt; m_snd_last_loss_event_when.</span></div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span><span class="comment">   *   3. If at least 1 packet exposed as Dropped in step 2, call</span></div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span><span class="comment">   *      m_snd_cong_ctl-&gt;on_loss_event(...stats...); and set m_snd_last_loss_event_when to the current time,</span></div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span><span class="comment">   *      marking this the start of a new loss event.</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span><span class="comment">   *   4. If at least 1 packet exposed as Acknowledged in step 1, call</span></div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span><span class="comment">   *      m_snd_cong_ctl-&gt;on_acks(...stats...). */</span></div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"> 2192</span> </div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"> 2193</span>  <span class="comment">// Set up work state and save certain &quot;before&quot; values.</span></div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"> 2194</span> </div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"> 2195</span>  <span class="comment">// For RTT at least.  Use steady, high-res clock.  Use one coherent value for entire method to simulate simultaneity.</span></div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> time_now = Fine_clock::now();</div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span> </div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"> 2198</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span>  <span class="keyword">auto</span>&amp; snd_stats = sock-&gt;m_snd_stats;</div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"> 2202</span>  <span class="comment">/* These guys are only stored in Peer_socket (instead of creating locally here) for a bit of performance.  Reuse now.</span></div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"> 2203</span><span class="comment">   * Note that clear() is a very fast operation; it will essentially just set the internal element count to 0. */</span></div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"> 2204</span>  <span class="keyword">auto</span>&amp; pkts_marked_to_drop = sock-&gt;m_snd_temp_pkts_marked_to_drop;</div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"> 2205</span>  pkts_marked_to_drop.clear();</div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span> </div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span>  <span class="comment">// To check, at the end, whether we&#39;ve changed can_send() false =&gt; true.</span></div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> could_send_before_acks = can_send(sock);</div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span>  <span class="comment">// To check, at the end, whether we&#39;ve changed snd_deqable() false =&gt; true.</span></div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> had_rexmit_data_before_acks = !sock-&gt;m_snd_rexmit_q.empty();</div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span> </div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"> 2212</span>  <span class="comment">/* Includes each order number (unique packet ID) for which the packet was acknowledged.</span></div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"> 2213</span><span class="comment">   * Used for Drop_timer events to register at the bottom; and also to feed the priority queue high_ack_count_q</span></div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"> 2214</span><span class="comment">   * (explained below in detail). */</span></div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"> 2215</span>  unordered_set&lt;Peer_socket::order_num_t&gt; flying_now_acked_pkts;</div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span> </div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span>  <span class="comment">// These are the N, M arguments to on_acks() described just above in big comment.</span></div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span>  <span class="keywordtype">size_t</span> clean_acked_bytes = 0;</div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span>  <span class="keywordtype">size_t</span> clean_acked_packets = 0;</div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span> </div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"> 2221</span>  <span class="comment">/* The are the individual T, N&#39; (RTT, acked_bytes, sent_cwnd_bytes) arguments to pass to on_individual_ack() described</span></div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"> 2222</span><span class="comment">   * just above in big comment.  We will be accumulating these across all the acks in the loop below. */</span></div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"> 2223</span>  <span class="keyword">using </span>Clean_acked_packet = tuple&lt;Fine_duration, size_t, size_t&gt;;</div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"> 2224</span>  vector&lt;Clean_acked_packet&gt; clean_acked_packet_events;</div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span>  clean_acked_packet_events.reserve(min(acked_packets.size(), snd_flying_pkts_by_when.size())); <span class="comment">// Small optimization.</span></div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span> </div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span>  <span class="comment">/* Handle each acknowledgment in the order that the corresponding packet was received by other</span></div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span><span class="comment">   * side (earliest to latest) per above discussion. */</span></div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack : acked_packets)</div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"> 2230</span>  {</div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"> 2231</span>    <span class="comment">/* Use helper to classify this individual ack as one of the following:</span></div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"> 2232</span><span class="comment">     *   - Malformed/illegal. =&gt; error_ack is true. Else:</span></div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"> 2233</span><span class="comment">     *   - Legal but referring to an already-acknowledged packet, or arriving too late. =&gt; dupe_or_late is true.</span></div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span><span class="comment">     *     - The packet being acknowledged is unknown. =&gt; flying_pkt_it == past_oldest() (a/k/a end()).</span></div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span><span class="comment">     *     - The packet being acknowledged is known. =&gt; flying_pkt_it points to that acked packet.</span></div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span><span class="comment">     *   - Legal and acking a not-yet-acked packet, arriving in time. =&gt; dupe_or_late is false.</span></div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"> 2237</span><span class="comment">     *                                                                =&gt; flying_pkt_it points to that acked packet.</span></div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span><span class="comment">     * Note: The helper takes care of snd_stats updating, closing socket on error, and relevant logging. */</span></div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"> 2239</span> </div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"> 2240</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> flying_pkt_it;</div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"> 2241</span>    <span class="keywordtype">bool</span> dupe_or_late;</div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"> 2242</span> </div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> error_ack = !categorize_individual_ack(socket_id, sock, ack, &amp;dupe_or_late, &amp;flying_pkt_it);</div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span>    <span class="keywordflow">if</span> (error_ack)</div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span>    {</div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span>      <span class="keywordflow">return</span>; <span class="comment">// Fatal error for entire socket (malformed ack, etc.).  Socket is closed; all logged; bail out now.</span></div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span>    }</div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"> 2248</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"> 2249</span> </div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"> 2250</span>    <span class="comment">// Note these may never be initialized.</span></div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"> 2251</span>    <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> round_trip_time;</div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span>    <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> flying_pkt;</div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a>* sent_when;</div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span> </div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span>    <span class="comment">// Compute RTT, assuming we ID&#39;ed the original DATA.  (RTT logged even if we still throw away the ack just below.)</span></div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span>    <span class="keywordflow">if</span> (flying_pkt_it != snd_flying_pkts_by_when.past_oldest())</div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"> 2257</span>    {</div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"> 2258</span>      <span class="comment">// Use helper to compute RTT and, as a side effect, get `Sent_when* sent_when` set to point to appriate structure.</span></div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"> 2259</span>      flying_pkt = flying_pkt_it-&gt;second;</div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"> 2260</span>      round_trip_time = compute_rtt_on_ack(flying_pkt, time_now, ack, &amp;sent_when); <span class="comment">// It logs details.</span></div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span>    } <span class="comment">// Done computing (if possible) RTT and logging it.</span></div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span> </div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span>    <span class="keywordflow">if</span> (dupe_or_late)</div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span>    {</div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"> 2265</span>      <span class="keywordflow">continue</span>; <span class="comment">// Do NOT return!  There may well be valid individual acks after it.  All logged; get out now.</span></div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"> 2266</span>    }</div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"> 2267</span> </div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"> 2268</span>    <span class="comment">// else it&#39;s an in-time acking of DATA packet that has not yet been acked (is considered In-flight)!</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"> 2269</span>    assert(!dupe_or_late);</div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"> 2270</span>    <span class="comment">// The following is guaranteed by helper above, since !dupe_or_late. Hence, also, flying_pkt, sent_when, RTT set.</span></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"> 2271</span>    assert(flying_pkt_it != snd_flying_pkts_by_when.past_oldest());</div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"> 2272</span>    assert(flying_pkt);</div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"> 2273</span> </div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"> 2274</span>    <span class="comment">// Update SRTT, etc.</span></div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"> 2275</span>    new_round_trip_time_sample(sock, round_trip_time);</div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"> 2276</span> </div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"> 2277</span>    <span class="comment">/* Similarly, inform congestion control (see big comment at top of method).  Some strategies</span></div>
<div class="line"><a id="l02278" name="l02278"></a><span class="lineno"> 2278</span><span class="comment">     * use individual acks to gauge the pipe&#39;s properties.  Save the info to</span></div>
<div class="line"><a id="l02279" name="l02279"></a><span class="lineno"> 2279</span><span class="comment">     * later call on_individual_ack().  Why not just call</span></div>
<div class="line"><a id="l02280" name="l02280"></a><span class="lineno"> 2280</span><span class="comment">     * it here?  Answer: Congestion_control_strategy interface specifies that</span></div>
<div class="line"><a id="l02281" name="l02281"></a><span class="lineno"> 2281</span><span class="comment">     * on_individual_ack() must be called AFTER on_loss_event() (which can only be called once</span></div>
<div class="line"><a id="l02282" name="l02282"></a><span class="lineno"> 2282</span><span class="comment">     * we&#39;ve fully updated snd_flying_pkts, thus handled all acks).  It also specifies that</span></div>
<div class="line"><a id="l02283" name="l02283"></a><span class="lineno"> 2283</span><span class="comment">     * snd_flying_pkts must be updated to reflect the handled ack.  So we have no choice but</span></div>
<div class="line"><a id="l02284" name="l02284"></a><span class="lineno"> 2284</span><span class="comment">     * to save it.  (@todo Performance?) */</span></div>
<div class="line"><a id="l02285" name="l02285"></a><span class="lineno"> 2285</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> bytes_acked = flying_pkt-&gt;m_size;</div>
<div class="line"><a id="l02286" name="l02286"></a><span class="lineno"> 2286</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> cwnd_bytes = sent_when-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#abc5bf2e627dad5d2dcfb0324853b37f7">m_sent_cwnd_bytes</a>;</div>
<div class="line"><a id="l02287" name="l02287"></a><span class="lineno"> 2287</span>    clean_acked_packet_events.emplace_back(round_trip_time, bytes_acked, cwnd_bytes);</div>
<div class="line"><a id="l02288" name="l02288"></a><span class="lineno"> 2288</span> </div>
<div class="line"><a id="l02289" name="l02289"></a><span class="lineno"> 2289</span>    <span class="comment">// Maintain invariant.  Packet acknowledged, so remove from In-flight packet list and related structures.</span></div>
<div class="line"><a id="l02290" name="l02290"></a><span class="lineno"> 2290</span>    snd_flying_pkts_erase_one(sock, flying_pkt_it);</div>
<div class="line"><a id="l02291" name="l02291"></a><span class="lineno"> 2291</span> </div>
<div class="line"><a id="l02292" name="l02292"></a><span class="lineno"> 2292</span>    <span class="comment">// Bona fide In-flight-&gt;Acknowledged data; accumulate to inform congestion control below.</span></div>
<div class="line"><a id="l02293" name="l02293"></a><span class="lineno"> 2293</span>    clean_acked_bytes += bytes_acked;</div>
<div class="line"><a id="l02294" name="l02294"></a><span class="lineno"> 2294</span>    ++clean_acked_packets;</div>
<div class="line"><a id="l02295" name="l02295"></a><span class="lineno"> 2295</span> </div>
<div class="line"><a id="l02296" name="l02296"></a><span class="lineno"> 2296</span>    <span class="comment">/* If we got here, then it is in fact what we consider a valid acknowledgment of packet</span></div>
<div class="line"><a id="l02297" name="l02297"></a><span class="lineno"> 2297</span><span class="comment">     * sent at time sent_when.  Therefore, we should increment m_acks_after_me for any packet that has NOT</span></div>
<div class="line"><a id="l02298" name="l02298"></a><span class="lineno"> 2298</span><span class="comment">     * been acknowledged that was sent earlier than sent_when.  (Later we&#39;d consider Dropped any</span></div>
<div class="line"><a id="l02299" name="l02299"></a><span class="lineno"> 2299</span><span class="comment">     * packets for which this value is too high, as in TCP Fast Recovery/Retransmit.)  Note that if</span></div>
<div class="line"><a id="l02300" name="l02300"></a><span class="lineno"> 2300</span><span class="comment">     * retransmission is off, that&#39;s the same as all packets with a lower first sequence number.</span></div>
<div class="line"><a id="l02301" name="l02301"></a><span class="lineno"> 2301</span><span class="comment">     * However if retransmission is on, then a packet may have a lower sequence number but be sent</span></div>
<div class="line"><a id="l02302" name="l02302"></a><span class="lineno"> 2302</span><span class="comment">     * later.  Thus we use sent_when and not seq_num.</span></div>
<div class="line"><a id="l02303" name="l02303"></a><span class="lineno"> 2303</span><span class="comment">     *</span></div>
<div class="line"><a id="l02304" name="l02304"></a><span class="lineno"> 2304</span><span class="comment">     * Naively, we could just have a for () loop here to increment all such data members.  However</span></div>
<div class="line"><a id="l02305" name="l02305"></a><span class="lineno"> 2305</span><span class="comment">     * that&#39;s inefficient -- order O(k * n), where k = acked_packets.size() and n =</span></div>
<div class="line"><a id="l02306" name="l02306"></a><span class="lineno"> 2306</span><span class="comment">     * snd_flying_pkts*.size(), in the worst case.  Moreover, some of the Sent_packet structs in</span></div>
<div class="line"><a id="l02307" name="l02307"></a><span class="lineno"> 2307</span><span class="comment">     * which we increment m_acks_after_me may be acknowledged and thus erased from snd_flying_pkts*</span></div>
<div class="line"><a id="l02308" name="l02308"></a><span class="lineno"> 2308</span><span class="comment">     * in subsequent iterations of the for () loop we are in, wasting that work.</span></div>
<div class="line"><a id="l02309" name="l02309"></a><span class="lineno"> 2309</span><span class="comment">     *</span></div>
<div class="line"><a id="l02310" name="l02310"></a><span class="lineno"> 2310</span><span class="comment">     * So instead we count the individual acks in a hash map that maps sent_when to the number of</span></div>
<div class="line"><a id="l02311" name="l02311"></a><span class="lineno"> 2311</span><span class="comment">     * times (in this ACK) that sequence number&#39;s packet was validly acknowledged.  This is O(k)</span></div>
<div class="line"><a id="l02312" name="l02312"></a><span class="lineno"> 2312</span><span class="comment">     * amortized total.  Then elsewhere we use that hash map to more efficiently update m_acks_after_me</span></div>
<div class="line"><a id="l02313" name="l02313"></a><span class="lineno"> 2313</span><span class="comment">     * where appropriate.  In addition, this hash map is used to register certain Drop_timer</span></div>
<div class="line"><a id="l02314" name="l02314"></a><span class="lineno"> 2314</span><span class="comment">     * at the end of the method. */</span></div>
<div class="line"><a id="l02315" name="l02315"></a><span class="lineno"> 2315</span> </div>
<div class="line"><a id="l02316" name="l02316"></a><span class="lineno"> 2316</span>    <span class="comment">/* Note that we track these by &quot;order number&quot;; each sent packet (no matter if retransmitted or</span></div>
<div class="line"><a id="l02317" name="l02317"></a><span class="lineno"> 2317</span><span class="comment">     * not) gets a unique order number, higher than all previous.  Since no two packets will have</span></div>
<div class="line"><a id="l02318" name="l02318"></a><span class="lineno"> 2318</span><span class="comment">     * the same order number, we keep a set of order numbers. */</span></div>
<div class="line"><a id="l02319" name="l02319"></a><span class="lineno"> 2319</span>    flying_now_acked_pkts.insert(sent_when-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">m_order_num</a>);</div>
<div class="line"><a id="l02320" name="l02320"></a><span class="lineno"> 2320</span>  } <span class="comment">// for (all acked_packets)</span></div>
<div class="line"><a id="l02321" name="l02321"></a><span class="lineno"> 2321</span> </div>
<div class="line"><a id="l02322" name="l02322"></a><span class="lineno"> 2322</span>  <span class="comment">/* snd_flying_pkts* is updated w/r/t removing the In-flight-now-acked packets.  Now, realize that</span></div>
<div class="line"><a id="l02323" name="l02323"></a><span class="lineno"> 2323</span><span class="comment">   * for a given packet P still In-flight, if packets sent BEFORE it have just become acked, intuitively</span></div>
<div class="line"><a id="l02324" name="l02324"></a><span class="lineno"> 2324</span><span class="comment">   * it raises the probability P has been lost and should be considered Dropped.  In fact, as explained in</span></div>
<div class="line"><a id="l02325" name="l02325"></a><span class="lineno"> 2325</span><span class="comment">   * helper categorize_pkts_as_dropped_on_acks(), if one finds the latest-sent such packet P, then all</span></div>
<div class="line"><a id="l02326" name="l02326"></a><span class="lineno"> 2326</span><span class="comment">   * packets sent before it should all be dropped as well.  So, let&#39;s find this latest-sent P: */</span></div>
<div class="line"><a id="l02327" name="l02327"></a><span class="lineno"> 2327</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> last_dropped_pkt_it</div>
<div class="line"><a id="l02328" name="l02328"></a><span class="lineno"> 2328</span>    = categorize_pkts_as_dropped_on_acks(sock, flying_now_acked_pkts);</div>
<div class="line"><a id="l02329" name="l02329"></a><span class="lineno"> 2329</span> </div>
<div class="line"><a id="l02330" name="l02330"></a><span class="lineno"> 2330</span>  <span class="comment">/* OK, so P and all In-flight packets sent before it must be dropped.  This helper takes all the actions</span></div>
<div class="line"><a id="l02331" name="l02331"></a><span class="lineno"> 2331</span><span class="comment">   * necessary (or at least records data we use to take such actions below) w/r/t all those packets.</span></div>
<div class="line"><a id="l02332" name="l02332"></a><span class="lineno"> 2332</span><span class="comment">   * Namely: erases them from snd_flying_pkts*; accumulates packet and bytes counts to do with these</span></div>
<div class="line"><a id="l02333" name="l02333"></a><span class="lineno"> 2333</span><span class="comment">   * dropped packets; saves the packet IDs from Drop timer purposes into pkts_marked_to_drop. */</span></div>
<div class="line"><a id="l02334" name="l02334"></a><span class="lineno"> 2334</span>  <span class="keywordtype">size_t</span> dropped_pkts;</div>
<div class="line"><a id="l02335" name="l02335"></a><span class="lineno"> 2335</span>  <span class="keywordtype">size_t</span> dropped_bytes;</div>
<div class="line"><a id="l02336" name="l02336"></a><span class="lineno"> 2336</span>  <span class="keywordtype">size_t</span> cong_ctl_dropped_bytes;</div>
<div class="line"><a id="l02337" name="l02337"></a><span class="lineno"> 2337</span>  <span class="keywordtype">size_t</span> cong_ctl_dropped_pkts;</div>
<div class="line"><a id="l02338" name="l02338"></a><span class="lineno"> 2338</span>  <span class="keywordflow">if</span> (!drop_pkts_on_acks(sock, last_dropped_pkt_it,</div>
<div class="line"><a id="l02339" name="l02339"></a><span class="lineno"> 2339</span>                         &amp;cong_ctl_dropped_pkts, &amp;cong_ctl_dropped_bytes,</div>
<div class="line"><a id="l02340" name="l02340"></a><span class="lineno"> 2340</span>                         &amp;dropped_pkts, &amp;dropped_bytes, &amp;pkts_marked_to_drop))</div>
<div class="line"><a id="l02341" name="l02341"></a><span class="lineno"> 2341</span>  {</div>
<div class="line"><a id="l02342" name="l02342"></a><span class="lineno"> 2342</span>    <span class="keywordflow">return</span>; <span class="comment">// Already closed/logged/etc. (too many retransmissions probably).</span></div>
<div class="line"><a id="l02343" name="l02343"></a><span class="lineno"> 2343</span>  }</div>
<div class="line"><a id="l02344" name="l02344"></a><span class="lineno"> 2344</span> </div>
<div class="line"><a id="l02345" name="l02345"></a><span class="lineno"> 2345</span>  <span class="comment">// As long promised since the top of this method, let congestion control (and B/W estimator) know what happened!</span></div>
<div class="line"><a id="l02346" name="l02346"></a><span class="lineno"> 2346</span> </div>
<div class="line"><a id="l02347" name="l02347"></a><span class="lineno"> 2347</span>  <span class="comment">/* Bandwidth estimation: It can be useful to estimate the available outgoing bandwidth (available</span></div>
<div class="line"><a id="l02348" name="l02348"></a><span class="lineno"> 2348</span><span class="comment">   * meaning the total bandwidth of the empty pipe minus any other traffic other than this</span></div>
<div class="line"><a id="l02349" name="l02349"></a><span class="lineno"> 2349</span><span class="comment">   * connection [NetFlow or otherwise] currently occupying this pipe).  Mostly it&#39;s useful for certain</span></div>
<div class="line"><a id="l02350" name="l02350"></a><span class="lineno"> 2350</span><span class="comment">   * congestion control strategies like Congestion_control_classic_with_bandwidth_est, but it may be</span></div>
<div class="line"><a id="l02351" name="l02351"></a><span class="lineno"> 2351</span><span class="comment">   * good information to have if only for the user&#39;s general information.  Therefore we keep an</span></div>
<div class="line"><a id="l02352" name="l02352"></a><span class="lineno"> 2352</span><span class="comment">   * independent m_snd_bandwidth_estimator regardless of the congestion control strategy in use.</span></div>
<div class="line"><a id="l02353" name="l02353"></a><span class="lineno"> 2353</span><span class="comment">   * Like Congestion_control_strategy, it updates its state based on events.  It currently cares</span></div>
<div class="line"><a id="l02354" name="l02354"></a><span class="lineno"> 2354</span><span class="comment">   * about at least one event: on_acks(N), where N is the number of bytes acknowledged.  This is</span></div>
<div class="line"><a id="l02355" name="l02355"></a><span class="lineno"> 2355</span><span class="comment">   * very similar to the on_acks(N, M) event for congestion control (see above).  None of the other</span></div>
<div class="line"><a id="l02356" name="l02356"></a><span class="lineno"> 2356</span><span class="comment">   * aspects of the above discussion (such as loss events) apply to m_snd_bandwidth_estimator. */</span></div>
<div class="line"><a id="l02357" name="l02357"></a><span class="lineno"> 2357</span> </div>
<div class="line"><a id="l02358" name="l02358"></a><span class="lineno"> 2358</span>  <span class="comment">// Note that the order is as required by Congestion_control_strategy() API: loss, individual acks, consolidated acks.</span></div>
<div class="line"><a id="l02359" name="l02359"></a><span class="lineno"> 2359</span> </div>
<div class="line"><a id="l02360" name="l02360"></a><span class="lineno"> 2360</span>  <span class="comment">// Report loss event info to congestion control.</span></div>
<div class="line"><a id="l02361" name="l02361"></a><span class="lineno"> 2361</span>  <span class="keywordflow">if</span> (dropped_pkts != 0)</div>
<div class="line"><a id="l02362" name="l02362"></a><span class="lineno"> 2362</span>  {</div>
<div class="line"><a id="l02363" name="l02363"></a><span class="lineno"> 2363</span>    <span class="comment">// @todo Might be too verbose to keep it as INFO!</span></div>
<div class="line"><a id="l02364" name="l02364"></a><span class="lineno"> 2364</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02365" name="l02365"></a><span class="lineno"> 2365</span>                  <span class="stringliteral">&quot;Considering Dropped: [&quot;</span> &lt;&lt; dropped_bytes &lt;&lt; <span class="stringliteral">&quot;] bytes = [&quot;</span> &lt;&lt; dropped_pkts &lt;&lt; <span class="stringliteral">&quot;] packets.&quot;</span>);</div>
<div class="line"><a id="l02366" name="l02366"></a><span class="lineno"> 2366</span> </div>
<div class="line"><a id="l02367" name="l02367"></a><span class="lineno"> 2367</span>    <span class="keywordflow">if</span> (cong_ctl_dropped_pkts != 0) <span class="comment">// Again, cong_ctl_dropped_pkts != dropped_pkts, potentially.</span></div>
<div class="line"><a id="l02368" name="l02368"></a><span class="lineno"> 2368</span>    {</div>
<div class="line"><a id="l02369" name="l02369"></a><span class="lineno"> 2369</span>      <span class="comment">// New loss event!</span></div>
<div class="line"><a id="l02370" name="l02370"></a><span class="lineno"> 2370</span>      assert(cong_ctl_dropped_bytes != 0); <span class="comment">// Empty blocks not allowed (should have been eliminated by now).</span></div>
<div class="line"><a id="l02371" name="l02371"></a><span class="lineno"> 2371</span> </div>
<div class="line"><a id="l02372" name="l02372"></a><span class="lineno"> 2372</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;cong_ctl [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] update: loss event: &quot;</span></div>
<div class="line"><a id="l02373" name="l02373"></a><span class="lineno"> 2373</span>                    <span class="stringliteral">&quot;Dropped [&quot;</span> &lt;&lt; cong_ctl_dropped_bytes &lt;&lt; <span class="stringliteral">&quot;] bytes &quot;</span></div>
<div class="line"><a id="l02374" name="l02374"></a><span class="lineno"> 2374</span>                    <span class="stringliteral">&quot;= [&quot;</span> &lt;&lt; cong_ctl_dropped_pkts &lt;&lt; <span class="stringliteral">&quot;] packets.&quot;</span>);</div>
<div class="line"><a id="l02375" name="l02375"></a><span class="lineno"> 2375</span> </div>
<div class="line"><a id="l02376" name="l02376"></a><span class="lineno"> 2376</span>      sock-&gt;m_snd_cong_ctl-&gt;on_loss_event(cong_ctl_dropped_bytes, cong_ctl_dropped_pkts);</div>
<div class="line"><a id="l02377" name="l02377"></a><span class="lineno"> 2377</span>      sock-&gt;m_snd_last_loss_event_when = Fine_clock::now();</div>
<div class="line"><a id="l02378" name="l02378"></a><span class="lineno"> 2378</span> </div>
<div class="line"><a id="l02379" name="l02379"></a><span class="lineno"> 2379</span>      <span class="comment">// As a silver lining, we probably got some nice new acknowledgments following that drop.</span></div>
<div class="line"><a id="l02380" name="l02380"></a><span class="lineno"> 2380</span>    }</div>
<div class="line"><a id="l02381" name="l02381"></a><span class="lineno"> 2381</span>  }</div>
<div class="line"><a id="l02382" name="l02382"></a><span class="lineno"> 2382</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l02383" name="l02383"></a><span class="lineno"> 2383</span>  {</div>
<div class="line"><a id="l02384" name="l02384"></a><span class="lineno"> 2384</span>    assert(dropped_pkts == 0);</div>
<div class="line"><a id="l02385" name="l02385"></a><span class="lineno"> 2385</span>    assert(cong_ctl_dropped_pkts == 0);</div>
<div class="line"><a id="l02386" name="l02386"></a><span class="lineno"> 2386</span>  }</div>
<div class="line"><a id="l02387" name="l02387"></a><span class="lineno"> 2387</span> </div>
<div class="line"><a id="l02388" name="l02388"></a><span class="lineno"> 2388</span>  <span class="keywordflow">if</span> (clean_acked_packets != 0)</div>
<div class="line"><a id="l02389" name="l02389"></a><span class="lineno"> 2389</span>  {</div>
<div class="line"><a id="l02390" name="l02390"></a><span class="lineno"> 2390</span>    assert(clean_acked_bytes != 0); <span class="comment">// Empty blocks not allowed (should have been eliminated by now).</span></div>
<div class="line"><a id="l02391" name="l02391"></a><span class="lineno"> 2391</span>    assert(!clean_acked_packet_events.empty());</div>
<div class="line"><a id="l02392" name="l02392"></a><span class="lineno"> 2392</span> </div>
<div class="line"><a id="l02393" name="l02393"></a><span class="lineno"> 2393</span>    <span class="comment">// Report individual (clean) acks to congestion control.</span></div>
<div class="line"><a id="l02394" name="l02394"></a><span class="lineno"> 2394</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [rtt, bytes, cwnd_bytes] : clean_acked_packet_events)</div>
<div class="line"><a id="l02395" name="l02395"></a><span class="lineno"> 2395</span>    {</div>
<div class="line"><a id="l02396" name="l02396"></a><span class="lineno"> 2396</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;cong_ctl [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] update: clean individual acknowledgment: &quot;</span></div>
<div class="line"><a id="l02397" name="l02397"></a><span class="lineno"> 2397</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(bytes) &lt;&lt; <span class="stringliteral">&quot;] with RTT [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(rtt) &lt;&lt;</div>
<div class="line"><a id="l02398" name="l02398"></a><span class="lineno"> 2398</span>                     <span class="stringliteral">&quot;] and sent_cwnd_bytes [&quot;</span> &lt;&lt; cwnd_bytes &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02399" name="l02399"></a><span class="lineno"> 2399</span> </div>
<div class="line"><a id="l02400" name="l02400"></a><span class="lineno"> 2400</span>      sock-&gt;m_snd_cong_ctl-&gt;on_individual_ack(rtt, bytes, cwnd_bytes);</div>
<div class="line"><a id="l02401" name="l02401"></a><span class="lineno"> 2401</span>    }</div>
<div class="line"><a id="l02402" name="l02402"></a><span class="lineno"> 2402</span> </div>
<div class="line"><a id="l02403" name="l02403"></a><span class="lineno"> 2403</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;cong_ctl/bw_est [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] update: clean acknowledgments: &quot;</span></div>
<div class="line"><a id="l02404" name="l02404"></a><span class="lineno"> 2404</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(clean_acked_bytes) &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span></div>
<div class="line"><a id="l02405" name="l02405"></a><span class="lineno"> 2405</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; clean_acked_packets &lt;&lt; <span class="stringliteral">&quot;] packets.&quot;</span>);</div>
<div class="line"><a id="l02406" name="l02406"></a><span class="lineno"> 2406</span> </div>
<div class="line"><a id="l02407" name="l02407"></a><span class="lineno"> 2407</span>    <span class="comment">// Report the totality of (clean) acks to congestion control and bandwidth estimator.</span></div>
<div class="line"><a id="l02408" name="l02408"></a><span class="lineno"> 2408</span>    sock-&gt;m_snd_bandwidth_estimator-&gt;on_acks(clean_acked_bytes);</div>
<div class="line"><a id="l02409" name="l02409"></a><span class="lineno"> 2409</span>    sock-&gt;m_snd_cong_ctl-&gt;on_acks(clean_acked_bytes, clean_acked_packets);</div>
<div class="line"><a id="l02410" name="l02410"></a><span class="lineno"> 2410</span>  }</div>
<div class="line"><a id="l02411" name="l02411"></a><span class="lineno"> 2411</span> </div>
<div class="line"><a id="l02412" name="l02412"></a><span class="lineno"> 2412</span>  <span class="comment">/* For debugging it can be useful to log socket state right after loss and handling everything.</span></div>
<div class="line"><a id="l02413" name="l02413"></a><span class="lineno"> 2413</span><span class="comment">   * Do so but only if the last time we so logged was some time ago; this is a CPU-intensive</span></div>
<div class="line"><a id="l02414" name="l02414"></a><span class="lineno"> 2414</span><span class="comment">   * operation.</span></div>
<div class="line"><a id="l02415" name="l02415"></a><span class="lineno"> 2415</span><span class="comment">   *</span></div>
<div class="line"><a id="l02416" name="l02416"></a><span class="lineno"> 2416</span><span class="comment">   * Also, register dropped data in snd_stats. */</span></div>
<div class="line"><a id="l02417" name="l02417"></a><span class="lineno"> 2417</span>  <span class="keywordflow">if</span> (dropped_pkts != 0)</div>
<div class="line"><a id="l02418" name="l02418"></a><span class="lineno"> 2418</span>  {</div>
<div class="line"><a id="l02419" name="l02419"></a><span class="lineno"> 2419</span>    <span class="comment">// Register that we have convered N bytes over M packets from In-flight to Acknowledged.</span></div>
<div class="line"><a id="l02420" name="l02420"></a><span class="lineno"> 2420</span>    snd_stats.dropped_data(dropped_bytes, dropped_pkts);</div>
<div class="line"><a id="l02421" name="l02421"></a><span class="lineno"> 2421</span> </div>
<div class="line"><a id="l02422" name="l02422"></a><span class="lineno"> 2422</span>    <span class="keyword">const</span> seconds MIN_TIME_BETWEEN_LOGS(1);</div>
<div class="line"><a id="l02423" name="l02423"></a><span class="lineno"> 2423</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> since_last_loss_sock_log = Fine_clock::now() - m_last_loss_sock_log_when;</div>
<div class="line"><a id="l02424" name="l02424"></a><span class="lineno"> 2424</span> </div>
<div class="line"><a id="l02425" name="l02425"></a><span class="lineno"> 2425</span>    <span class="keywordflow">if</span> (since_last_loss_sock_log &gt; MIN_TIME_BETWEEN_LOGS)</div>
<div class="line"><a id="l02426" name="l02426"></a><span class="lineno"> 2426</span>    {</div>
<div class="line"><a id="l02427" name="l02427"></a><span class="lineno"> 2427</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Will log socket state on loss, because last such loss-driven logging was &quot;</span></div>
<div class="line"><a id="l02428" name="l02428"></a><span class="lineno"> 2428</span>                    <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(since_last_loss_sock_log) &lt;&lt; <span class="stringliteral">&quot; &gt;&quot;</span></div>
<div class="line"><a id="l02429" name="l02429"></a><span class="lineno"> 2429</span>                    <span class="stringliteral">&quot; &quot;</span> &lt;&lt; MIN_TIME_BETWEEN_LOGS &lt;&lt; <span class="stringliteral">&quot;] ago.&quot;</span>);</div>
<div class="line"><a id="l02430" name="l02430"></a><span class="lineno"> 2430</span>      sock_log_detail(sock);</div>
<div class="line"><a id="l02431" name="l02431"></a><span class="lineno"> 2431</span>      m_last_loss_sock_log_when = Fine_clock::now();</div>
<div class="line"><a id="l02432" name="l02432"></a><span class="lineno"> 2432</span>    }</div>
<div class="line"><a id="l02433" name="l02433"></a><span class="lineno"> 2433</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l02434" name="l02434"></a><span class="lineno"> 2434</span>    {</div>
<div class="line"><a id="l02435" name="l02435"></a><span class="lineno"> 2435</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Will NOT log socket state on loss, because last such loss-driven logging was &quot;</span></div>
<div class="line"><a id="l02436" name="l02436"></a><span class="lineno"> 2436</span>                    <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(since_last_loss_sock_log) &lt;&lt; <span class="stringliteral">&quot; &lt;=&quot;</span></div>
<div class="line"><a id="l02437" name="l02437"></a><span class="lineno"> 2437</span>                    <span class="stringliteral">&quot; &quot;</span> &lt;&lt; MIN_TIME_BETWEEN_LOGS &lt;&lt; <span class="stringliteral">&quot;] ago.&quot;</span>);</div>
<div class="line"><a id="l02438" name="l02438"></a><span class="lineno"> 2438</span>    }</div>
<div class="line"><a id="l02439" name="l02439"></a><span class="lineno"> 2439</span>  }</div>
<div class="line"><a id="l02440" name="l02440"></a><span class="lineno"> 2440</span> </div>
<div class="line"><a id="l02441" name="l02441"></a><span class="lineno"> 2441</span>  <span class="comment">// Log the send window state after the above changes (if at least TRACE enabled).</span></div>
<div class="line"><a id="l02442" name="l02442"></a><span class="lineno"> 2442</span>  log_snd_window(sock);</div>
<div class="line"><a id="l02443" name="l02443"></a><span class="lineno"> 2443</span> </div>
<div class="line"><a id="l02444" name="l02444"></a><span class="lineno"> 2444</span>  <span class="comment">/* Handle possible effect of above activities on the Drop Timer.  (It may get disabled or restarted anew.)</span></div>
<div class="line"><a id="l02445" name="l02445"></a><span class="lineno"> 2445</span><span class="comment">   * Why not just do this right when we erase the associated packets from snd_flying_pkts*?  Answer: We don&#39;t want to</span></div>
<div class="line"><a id="l02446" name="l02446"></a><span class="lineno"> 2446</span><span class="comment">   * trigger disruptive behavior like possibly retransmitting everything in the middle of all that accounting</span></div>
<div class="line"><a id="l02447" name="l02447"></a><span class="lineno"> 2447</span><span class="comment">   * which is not yet complete.  Now it&#39;s complete, so it&#39;s the right time to handle this.</span></div>
<div class="line"><a id="l02448" name="l02448"></a><span class="lineno"> 2448</span><span class="comment">   *</span></div>
<div class="line"><a id="l02449" name="l02449"></a><span class="lineno"> 2449</span><span class="comment">   * Recall that snd_flying_pkts* have been updated and no longer contain the associated packets&#39; info. */</span></div>
<div class="line"><a id="l02450" name="l02450"></a><span class="lineno"> 2450</span> </div>
<div class="line"><a id="l02451" name="l02451"></a><span class="lineno"> 2451</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Drop_timer::Ptr</a> drop_timer = sock-&gt;m_snd_drop_timer;</div>
<div class="line"><a id="l02452" name="l02452"></a><span class="lineno"> 2452</span>  drop_timer-&gt;start_contemporaneous_events();</div>
<div class="line"><a id="l02453" name="l02453"></a><span class="lineno"> 2453</span> </div>
<div class="line"><a id="l02454" name="l02454"></a><span class="lineno"> 2454</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pkt_order_num : flying_now_acked_pkts)</div>
<div class="line"><a id="l02455" name="l02455"></a><span class="lineno"> 2455</span>  {</div>
<div class="line"><a id="l02456" name="l02456"></a><span class="lineno"> 2456</span>    drop_timer-&gt;on_ack(pkt_order_num);</div>
<div class="line"><a id="l02457" name="l02457"></a><span class="lineno"> 2457</span>    drop_timer-&gt;on_packet_no_longer_in_flight(pkt_order_num);</div>
<div class="line"><a id="l02458" name="l02458"></a><span class="lineno"> 2458</span>  }</div>
<div class="line"><a id="l02459" name="l02459"></a><span class="lineno"> 2459</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pkt_order_num : pkts_marked_to_drop)</div>
<div class="line"><a id="l02460" name="l02460"></a><span class="lineno"> 2460</span>  {</div>
<div class="line"><a id="l02461" name="l02461"></a><span class="lineno"> 2461</span>    drop_timer-&gt;on_packet_no_longer_in_flight(pkt_order_num);</div>
<div class="line"><a id="l02462" name="l02462"></a><span class="lineno"> 2462</span>  }</div>
<div class="line"><a id="l02463" name="l02463"></a><span class="lineno"> 2463</span> </div>
<div class="line"><a id="l02464" name="l02464"></a><span class="lineno"> 2464</span>  drop_timer-&gt;end_contemporaneous_events();</div>
<div class="line"><a id="l02465" name="l02465"></a><span class="lineno"> 2465</span> </div>
<div class="line"><a id="l02466" name="l02466"></a><span class="lineno"> 2466</span>  <span class="comment">/* As avertised, handle the rcv_wnd update: the latest ACK we are handling here contains the</span></div>
<div class="line"><a id="l02467" name="l02467"></a><span class="lineno"> 2467</span><span class="comment">   * latest info about the Receive buffer space on the other side that is available. */</span></div>
<div class="line"><a id="l02468" name="l02468"></a><span class="lineno"> 2468</span>  <span class="keywordflow">if</span> (sock-&gt;m_snd_pending_rcv_wnd != sock-&gt;m_snd_remote_rcv_wnd)</div>
<div class="line"><a id="l02469" name="l02469"></a><span class="lineno"> 2469</span>  {</div>
<div class="line"><a id="l02470" name="l02470"></a><span class="lineno"> 2470</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Other side advertised &quot;</span></div>
<div class="line"><a id="l02471" name="l02471"></a><span class="lineno"> 2471</span>                   <span class="stringliteral">&quot;rcv_wnd change [&quot;</span> &lt;&lt; sock-&gt;m_snd_remote_rcv_wnd &lt;&lt; <span class="stringliteral">&quot;] =&gt; [&quot;</span> &lt;&lt; sock-&gt;m_snd_pending_rcv_wnd &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02472" name="l02472"></a><span class="lineno"> 2472</span>    sock-&gt;m_snd_remote_rcv_wnd = sock-&gt;m_snd_pending_rcv_wnd;</div>
<div class="line"><a id="l02473" name="l02473"></a><span class="lineno"> 2473</span>    <span class="comment">/* Why have this intermediate m_snd_pending_rcv_wnd thing at all then?  Answer: can_send(),</span></div>
<div class="line"><a id="l02474" name="l02474"></a><span class="lineno"> 2474</span><span class="comment">     * checked at the start of this method and saved into could_send_before_acks, uses the &quot;before</span></div>
<div class="line"><a id="l02475" name="l02475"></a><span class="lineno"> 2475</span><span class="comment">     * handling the ACKs&quot; state, which should not yet include the receive window update.  Then</span></div>
<div class="line"><a id="l02476" name="l02476"></a><span class="lineno"> 2476</span><span class="comment">     * since we update m_snd_remote_rcv_wnd after that is computed, but before can_send() is</span></div>
<div class="line"><a id="l02477" name="l02477"></a><span class="lineno"> 2477</span><span class="comment">     * re-checked just below, we are able to see if the ACKs have changed can_send() from false to</span></div>
<div class="line"><a id="l02478" name="l02478"></a><span class="lineno"> 2478</span><span class="comment">     * true. */</span></div>
<div class="line"><a id="l02479" name="l02479"></a><span class="lineno"> 2479</span> </div>
<div class="line"><a id="l02480" name="l02480"></a><span class="lineno"> 2480</span>    <span class="comment">/* Register whether after this window update, if we had a packet to send and no data In-flight,</span></div>
<div class="line"><a id="l02481" name="l02481"></a><span class="lineno"> 2481</span><span class="comment">     * we would be able to send at least one full DATA packet or not (i.e., can_send() would return</span></div>
<div class="line"><a id="l02482" name="l02482"></a><span class="lineno"> 2482</span><span class="comment">     * true). That is, register whether Receive window is ~0. */</span></div>
<div class="line"><a id="l02483" name="l02483"></a><span class="lineno"> 2483</span>    sock-&gt;m_snd_stats.updated_rcv_wnd(sock-&gt;m_snd_remote_rcv_wnd &lt; sock-&gt;max_block_size());</div>
<div class="line"><a id="l02484" name="l02484"></a><span class="lineno"> 2484</span>  }</div>
<div class="line"><a id="l02485" name="l02485"></a><span class="lineno"> 2485</span> </div>
<div class="line"><a id="l02486" name="l02486"></a><span class="lineno"> 2486</span>  <span class="comment">/* We&#39;ve received ACKs and thus have quite likely reduced the number of bytes we</span></div>
<div class="line"><a id="l02487" name="l02487"></a><span class="lineno"> 2487</span><span class="comment">   * consider In-flight.  Moreover we may have increased CWND.  Moreover we may have added packets</span></div>
<div class="line"><a id="l02488" name="l02488"></a><span class="lineno"> 2488</span><span class="comment">   * to retransmit queue (if retransmission is on).  Moreover we may have increased m_snd_remote_rcv_wnd.</span></div>
<div class="line"><a id="l02489" name="l02489"></a><span class="lineno"> 2489</span><span class="comment">   * Therefore can_send() may now return true while at the beginning of the method it returned</span></div>
<div class="line"><a id="l02490" name="l02490"></a><span class="lineno"> 2490</span><span class="comment">   * false; and similarly for snd_deqable().  So have send_worker() check and send more if possible.</span></div>
<div class="line"><a id="l02491" name="l02491"></a><span class="lineno"> 2491</span><span class="comment">   * See Node::send() for discussion of overall strategy on this topic. */</span></div>
<div class="line"><a id="l02492" name="l02492"></a><span class="lineno"> 2492</span>  <span class="keywordflow">if</span> ((!could_send_before_acks) || (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> &amp;&amp; (!had_rexmit_data_before_acks)))</div>
<div class="line"><a id="l02493" name="l02493"></a><span class="lineno"> 2493</span>  {</div>
<div class="line"><a id="l02494" name="l02494"></a><span class="lineno"> 2494</span>    send_worker(sock, <span class="keyword">true</span>);</div>
<div class="line"><a id="l02495" name="l02495"></a><span class="lineno"> 2495</span>    <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l02496" name="l02496"></a><span class="lineno"> 2496</span><span class="comment">     * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l02497" name="l02497"></a><span class="lineno"> 2497</span><span class="comment">     * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l02498" name="l02498"></a><span class="lineno"> 2498</span>  }</div>
<div class="line"><a id="l02499" name="l02499"></a><span class="lineno"> 2499</span>} <span class="comment">// Node::handle_accumulated_acks()</span></div>
<div class="line"><a id="l02500" name="l02500"></a><span class="lineno"> 2500</span> </div>
<div class="line"><a id="l02501" name="l02501"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e"> 2501</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">Node::categorize_individual_ack</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02502" name="l02502"></a><span class="lineno"> 2502</span>                                     <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack,</div>
<div class="line"><a id="l02503" name="l02503"></a><span class="lineno"> 2503</span>                                     <span class="keywordtype">bool</span>* dupe_or_late, <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>* acked_pkt_it)</div>
<div class="line"><a id="l02504" name="l02504"></a><span class="lineno"> 2504</span>{</div>
<div class="line"><a id="l02505" name="l02505"></a><span class="lineno"> 2505</span>  assert(dupe_or_late);</div>
<div class="line"><a id="l02506" name="l02506"></a><span class="lineno"> 2506</span>  assert(acked_pkt_it);</div>
<div class="line"><a id="l02507" name="l02507"></a><span class="lineno"> 2507</span> </div>
<div class="line"><a id="l02508" name="l02508"></a><span class="lineno"> 2508</span>  <span class="comment">/* This helper of handle_accumulated_acks() exists to make the latter method briefer/readable, not for code reuse</span></div>
<div class="line"><a id="l02509" name="l02509"></a><span class="lineno"> 2509</span><span class="comment">   * as of this writing. It figures out whether the given individual ack is invalid, valid but duplicate/late, or</span></div>
<div class="line"><a id="l02510" name="l02510"></a><span class="lineno"> 2510</span><span class="comment">   * valid and on-time. Results go into the return value and *dupe_or_late and *acked_pkt_it. */</span></div>
<div class="line"><a id="l02511" name="l02511"></a><span class="lineno"> 2511</span> </div>
<div class="line"><a id="l02512" name="l02512"></a><span class="lineno"> 2512</span>  <span class="comment">/* Now to discuss what happens when an ACK is received, with a seemingly valid sequence number</span></div>
<div class="line"><a id="l02513" name="l02513"></a><span class="lineno"> 2513</span><span class="comment">   * (i.e., in [m_snd_init_seq_num + 1, m_snd_next_seq_num - 1] range) -- but the corresponding</span></div>
<div class="line"><a id="l02514" name="l02514"></a><span class="lineno"> 2514</span><span class="comment">   * packet is not in m_snd_flying_pkts_by_seq_num.  What does this mean?  One, unlikely, possibility is</span></div>
<div class="line"><a id="l02515" name="l02515"></a><span class="lineno"> 2515</span><span class="comment">   * that it&#39;s a fake/wrong acknowledgment, not pertaining to any packet we&#39;d sent but in the range</span></div>
<div class="line"><a id="l02516" name="l02516"></a><span class="lineno"> 2516</span><span class="comment">   * of sequence numbers we did send (in other words, the sequence number is in the right range but</span></div>
<div class="line"><a id="l02517" name="l02517"></a><span class="lineno"> 2517</span><span class="comment">   * doesn&#39;t correspond to a first sequence number of a packet we&#39;d really sent).  Unfortunately we</span></div>
<div class="line"><a id="l02518" name="l02518"></a><span class="lineno"> 2518</span><span class="comment">   * have no way to detect that fully, since it&#39;s not in m_snd_flying_pkts_by_seq_num, and that&#39;s basically the only</span></div>
<div class="line"><a id="l02519" name="l02519"></a><span class="lineno"> 2519</span><span class="comment">   * place we store packet boundaries of sent packets.  Suppose we eliminate that possibility.</span></div>
<div class="line"><a id="l02520" name="l02520"></a><span class="lineno"> 2520</span><span class="comment">   *</span></div>
<div class="line"><a id="l02521" name="l02521"></a><span class="lineno"> 2521</span><span class="comment">   * Then the only remaining possibility is that this acknowledgment is a duplicate of a previous</span></div>
<div class="line"><a id="l02522" name="l02522"></a><span class="lineno"> 2522</span><span class="comment">   * one, which had caused us to remove that packet from m_snd_flying_pkts_by_seq_num.  So, how DO we handle</span></div>
<div class="line"><a id="l02523" name="l02523"></a><span class="lineno"> 2523</span><span class="comment">   * a duplicate acknowledgment?  We already know they got packet, as we&#39;ve already measured RTT</span></div>
<div class="line"><a id="l02524" name="l02524"></a><span class="lineno"> 2524</span><span class="comment">   * from the previous copy of this ack, so there&#39;s nothing useful for us.  Conclusion: ignore</span></div>
<div class="line"><a id="l02525" name="l02525"></a><span class="lineno"> 2525</span><span class="comment">   * duplicate acknowledgments.</span></div>
<div class="line"><a id="l02526" name="l02526"></a><span class="lineno"> 2526</span><span class="comment">   *</span></div>
<div class="line"><a id="l02527" name="l02527"></a><span class="lineno"> 2527</span><span class="comment">   * Note that the above discussion pertains to a dupe ack where both the sequence number and the</span></div>
<div class="line"><a id="l02528" name="l02528"></a><span class="lineno"> 2528</span><span class="comment">   * retransmission ID are the same as a previous one.  If the retransmission ID is different (only</span></div>
<div class="line"><a id="l02529" name="l02529"></a><span class="lineno"> 2529</span><span class="comment">   * legal when retransmission is enabled), that&#39;s a different situation -- the acknowledgment is</span></div>
<div class="line"><a id="l02530" name="l02530"></a><span class="lineno"> 2530</span><span class="comment">   * not duplicate but rather acknowledging a different send attempt for the same-numbered packet.</span></div>
<div class="line"><a id="l02531" name="l02531"></a><span class="lineno"> 2531</span><span class="comment">   * That is less of a corner case and is handled below explicitly.</span></div>
<div class="line"><a id="l02532" name="l02532"></a><span class="lineno"> 2532</span><span class="comment">   *</span></div>
<div class="line"><a id="l02533" name="l02533"></a><span class="lineno"> 2533</span><span class="comment">   * Sent, unacknowledged packets are eventually considered Dropped.  In terms of our data structures</span></div>
<div class="line"><a id="l02534" name="l02534"></a><span class="lineno"> 2534</span><span class="comment">   * they are handled just like acknowledged ones.  Therefore, an acknowledgment of such a Dropped</span></div>
<div class="line"><a id="l02535" name="l02535"></a><span class="lineno"> 2535</span><span class="comment">   * packet may arrive.  This is a &quot;late&quot; acknowledgment.  It is treated just like a duplicate</span></div>
<div class="line"><a id="l02536" name="l02536"></a><span class="lineno"> 2536</span><span class="comment">   * acknowledgment (in fact, there is no way to tell them apart).  (Note that a packet is still</span></div>
<div class="line"><a id="l02537" name="l02537"></a><span class="lineno"> 2537</span><span class="comment">   * considered Dropped even if retransmission is on -- it&#39;s just that in that case it&#39;s also queued</span></div>
<div class="line"><a id="l02538" name="l02538"></a><span class="lineno"> 2538</span><span class="comment">   * on the retransmission queue to be re-sent when possible.)</span></div>
<div class="line"><a id="l02539" name="l02539"></a><span class="lineno"> 2539</span><span class="comment">   *</span></div>
<div class="line"><a id="l02540" name="l02540"></a><span class="lineno"> 2540</span><span class="comment">   * Another caveat is that two acknowledgments that are duplicates of each other can get</span></div>
<div class="line"><a id="l02541" name="l02541"></a><span class="lineno"> 2541</span><span class="comment">   * mis-ordered and thus arrive in opposite order.  Thus the one with the longer one-way time would</span></div>
<div class="line"><a id="l02542" name="l02542"></a><span class="lineno"> 2542</span><span class="comment">   * yield the higher RTT, while the shorter one would get ignored.  However, RTT measurement is an</span></div>
<div class="line"><a id="l02543" name="l02543"></a><span class="lineno"> 2543</span><span class="comment">   * art, not a science, so this is acceptable.</span></div>
<div class="line"><a id="l02544" name="l02544"></a><span class="lineno"> 2544</span><span class="comment">   *</span></div>
<div class="line"><a id="l02545" name="l02545"></a><span class="lineno"> 2545</span><span class="comment">   * @todo Acknowledgments themselves could actually be identified with something other other</span></div>
<div class="line"><a id="l02546" name="l02546"></a><span class="lineno"> 2546</span><span class="comment">   * than sequence numbers and retransmission IDs; e.g., with reflected sender time stamps.  Then</span></div>
<div class="line"><a id="l02547" name="l02547"></a><span class="lineno"> 2547</span><span class="comment">   * one could do fancier stuff... but let&#39;s not overdo it for now. */</span></div>
<div class="line"><a id="l02548" name="l02548"></a><span class="lineno"> 2548</span> </div>
<div class="line"><a id="l02549" name="l02549"></a><span class="lineno"> 2549</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l02550" name="l02550"></a><span class="lineno"> 2550</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l02551" name="l02551"></a><span class="lineno"> 2551</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l02552" name="l02552"></a><span class="lineno"> 2552</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_seq = sock-&gt;m_snd_flying_pkts_by_seq_num;</div>
<div class="line"><a id="l02553" name="l02553"></a><span class="lineno"> 2553</span>  <span class="keyword">auto</span>&amp; snd_stats = sock-&gt;m_snd_stats;</div>
<div class="line"><a id="l02554" name="l02554"></a><span class="lineno"> 2554</span> </div>
<div class="line"><a id="l02555" name="l02555"></a><span class="lineno"> 2555</span>  <span class="comment">// First sequence number in acknowledged packet.</span></div>
<div class="line"><a id="l02556" name="l02556"></a><span class="lineno"> 2556</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = ack-&gt;m_seq_num;</div>
<div class="line"><a id="l02557" name="l02557"></a><span class="lineno"> 2557</span>  <span class="comment">// Retransmission ID (0 = first attempt, 1 = 1st retransmission, 2 = 2nd, ...).</span></div>
<div class="line"><a id="l02558" name="l02558"></a><span class="lineno"> 2558</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rexmit_id = ack-&gt;m_rexmit_id;</div>
<div class="line"><a id="l02559" name="l02559"></a><span class="lineno"> 2559</span>  assert(<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> || (rexmit_id == 0)); <span class="comment">// Should be guaranteed by deserialization.</span></div>
<div class="line"><a id="l02560" name="l02560"></a><span class="lineno"> 2560</span> </div>
<div class="line"><a id="l02561" name="l02561"></a><span class="lineno"> 2561</span>  <span class="comment">// Register one individual acknowledgment of unknown # of bytes of data (may or may not be acceptable).</span></div>
<div class="line"><a id="l02562" name="l02562"></a><span class="lineno"> 2562</span>  snd_stats.received_ack();</div>
<div class="line"><a id="l02563" name="l02563"></a><span class="lineno"> 2563</span> </div>
<div class="line"><a id="l02564" name="l02564"></a><span class="lineno"> 2564</span>  <span class="comment">/* Ensure it&#39;s within the range of sequence numbers we&#39;ve already sent.</span></div>
<div class="line"><a id="l02565" name="l02565"></a><span class="lineno"> 2565</span><span class="comment">   * Note that this doesn&#39;t really guarantee its validity.  It could be in that range but still</span></div>
<div class="line"><a id="l02566" name="l02566"></a><span class="lineno"> 2566</span><span class="comment">   * not correspond to any packet we&#39;d actually sent.  We try to detect that below. */</span></div>
<div class="line"><a id="l02567" name="l02567"></a><span class="lineno"> 2567</span> </div>
<div class="line"><a id="l02568" name="l02568"></a><span class="lineno"> 2568</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceflow_1_1util.html#a733448fee07c2a77e343a3f1590ff82e">util::in_open_open_range</a>(sock-&gt;m_snd_init_seq_num, seq_num, sock-&gt;m_snd_next_seq_num))</div>
<div class="line"><a id="l02569" name="l02569"></a><span class="lineno"> 2569</span>  {</div>
<div class="line"><a id="l02570" name="l02570"></a><span class="lineno"> 2570</span>    <span class="comment">/* Either the other side is an a-hole, or somehow a socket_id was reused from a recent</span></div>
<div class="line"><a id="l02571" name="l02571"></a><span class="lineno"> 2571</span><span class="comment">     * connection, which we do try to avoid like the plague.  Therefore, send them an RST and</span></div>
<div class="line"><a id="l02572" name="l02572"></a><span class="lineno"> 2572</span><span class="comment">     * abort connection.  If they send more data packets to this port (which is quite possible;</span></div>
<div class="line"><a id="l02573" name="l02573"></a><span class="lineno"> 2573</span><span class="comment">     * many could already be on the way), they&#39;ll get more RSTs still. */</span></div>
<div class="line"><a id="l02574" name="l02574"></a><span class="lineno"> 2574</span> </div>
<div class="line"><a id="l02575" name="l02575"></a><span class="lineno"> 2575</span>    <span class="comment">// Interesting/rare enough to log a WARNING.</span></div>
<div class="line"><a id="l02576" name="l02576"></a><span class="lineno"> 2576</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02577" name="l02577"></a><span class="lineno"> 2577</span>                     <span class="stringliteral">&quot;Received [ACK]; &quot;</span></div>
<div class="line"><a id="l02578" name="l02578"></a><span class="lineno"> 2578</span>                     <span class="stringliteral">&quot;acknowledgment [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) is outside (ISN, snd_next) &quot;</span></div>
<div class="line"><a id="l02579" name="l02579"></a><span class="lineno"> 2579</span>                     <span class="stringliteral">&quot;range (&quot;</span> &lt;&lt; sock-&gt;m_snd_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_snd_next_seq_num &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l02580" name="l02580"></a><span class="lineno"> 2580</span> </div>
<div class="line"><a id="l02581" name="l02581"></a><span class="lineno"> 2581</span>    <span class="comment">// Register one individual acknowledgment of unknown # of bytes of data (not acceptable due to error).</span></div>
<div class="line"><a id="l02582" name="l02582"></a><span class="lineno"> 2582</span>    snd_stats.error_ack();</div>
<div class="line"><a id="l02583" name="l02583"></a><span class="lineno"> 2583</span> </div>
<div class="line"><a id="l02584" name="l02584"></a><span class="lineno"> 2584</span>    <span class="comment">/* Close connection in our structures (inform user if necessary as well).  Pre-conditions</span></div>
<div class="line"><a id="l02585" name="l02585"></a><span class="lineno"> 2585</span><span class="comment">     * assumed by call: sock in m_socks and sock-&gt;state() == S_OPEN (yes, since m_int_state ==</span></div>
<div class="line"><a id="l02586" name="l02586"></a><span class="lineno"> 2586</span><span class="comment">     * S_ESTABLISHED); 3rd arg contains the reason for the close (yes).  This will empty the Send</span></div>
<div class="line"><a id="l02587" name="l02587"></a><span class="lineno"> 2587</span><span class="comment">     * and Receive buffers.  That is OK, because this is the abrupt type of close (error). */</span></div>
<div class="line"><a id="l02588" name="l02588"></a><span class="lineno"> 2588</span>    rst_and_close_connection_immediately(socket_id, sock,</div>
<div class="line"><a id="l02589" name="l02589"></a><span class="lineno"> 2589</span>                                         <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765">error::Code::S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</a>, <span class="keyword">true</span>);</div>
<div class="line"><a id="l02590" name="l02590"></a><span class="lineno"> 2590</span>    <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l02591" name="l02591"></a><span class="lineno"> 2591</span><span class="comment">     * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l02592" name="l02592"></a><span class="lineno"> 2592</span><span class="comment">     * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l02593" name="l02593"></a><span class="lineno"> 2593</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Other out-params are meaningless.</span></div>
<div class="line"><a id="l02594" name="l02594"></a><span class="lineno"> 2594</span>  }</div>
<div class="line"><a id="l02595" name="l02595"></a><span class="lineno"> 2595</span>  <span class="comment">// else within sane range.</span></div>
<div class="line"><a id="l02596" name="l02596"></a><span class="lineno"> 2596</span> </div>
<div class="line"><a id="l02597" name="l02597"></a><span class="lineno"> 2597</span>  <span class="comment">// Check if the sequence number matches that of one of the packets we&#39;ve sent and want acnowledged.</span></div>
<div class="line"><a id="l02598" name="l02598"></a><span class="lineno"> 2598</span>  *acked_pkt_it = snd_flying_pkts_by_when.find(seq_num);</div>
<div class="line"><a id="l02599" name="l02599"></a><span class="lineno"> 2599</span>  <span class="keywordflow">if</span> (*acked_pkt_it == snd_flying_pkts_by_when.past_oldest()) <span class="comment">// A/k/a end().</span></div>
<div class="line"><a id="l02600" name="l02600"></a><span class="lineno"> 2600</span>  {</div>
<div class="line"><a id="l02601" name="l02601"></a><span class="lineno"> 2601</span>    <span class="comment">/* No such packet.  Assuming no foul play/dumbassery, it&#39;s probably a duplicate acknowledgment</span></div>
<div class="line"><a id="l02602" name="l02602"></a><span class="lineno"> 2602</span><span class="comment">     * (i.e., we&#39;ve already sent and got the ack, removing that packet from snd_flying_pkts*)</span></div>
<div class="line"><a id="l02603" name="l02603"></a><span class="lineno"> 2603</span><span class="comment">     * or a late acknowledgment (i.e., we&#39;ve already sent and eventually considered Dropped the</span></div>
<div class="line"><a id="l02604" name="l02604"></a><span class="lineno"> 2604</span><span class="comment">     * the packet, removing it from snd_flying_pkts*).</span></div>
<div class="line"><a id="l02605" name="l02605"></a><span class="lineno"> 2605</span><span class="comment">     *</span></div>
<div class="line"><a id="l02606" name="l02606"></a><span class="lineno"> 2606</span><span class="comment">     * There is a corner case if retransmission is on.  Suppose we sent packet P, consider it</span></div>
<div class="line"><a id="l02607" name="l02607"></a><span class="lineno"> 2607</span><span class="comment">     * Dropped (removing it from snd_flying_pkts*), and thus we place it on retransmission</span></div>
<div class="line"><a id="l02608" name="l02608"></a><span class="lineno"> 2608</span><span class="comment">     * queue.  Suppose there is not enough CWND space to send it right away, so while it&#39;s pending</span></div>
<div class="line"><a id="l02609" name="l02609"></a><span class="lineno"> 2609</span><span class="comment">     * on that queue, we now get a late ack for it.  Ideally in this case we&#39;d remember it was in</span></div>
<div class="line"><a id="l02610" name="l02610"></a><span class="lineno"> 2610</span><span class="comment">     * retransmission queue, remove it from there, and basically act as if we hadn&#39;t removed it</span></div>
<div class="line"><a id="l02611" name="l02611"></a><span class="lineno"> 2611</span><span class="comment">     * from snd_flying_pkts* and got the ack for it.  Instead we&#39;re just going to ignore this</span></div>
<div class="line"><a id="l02612" name="l02612"></a><span class="lineno"> 2612</span><span class="comment">     * information and needlessly retransmit.  So why do this?  Answer: It is troublesome to</span></div>
<div class="line"><a id="l02613" name="l02613"></a><span class="lineno"> 2613</span><span class="comment">     * design and code this.  The part where we wouldn&#39;t retransmit it is fairly straightforward</span></div>
<div class="line"><a id="l02614" name="l02614"></a><span class="lineno"> 2614</span><span class="comment">     * and is a nice @todo.  However acting as if it was normally ACKed after all is complex; for</span></div>
<div class="line"><a id="l02615" name="l02615"></a><span class="lineno"> 2615</span><span class="comment">     * instance, since we thought it was Dropped, we already informed m_cong_ctl of the loss event</span></div>
<div class="line"><a id="l02616" name="l02616"></a><span class="lineno"> 2616</span><span class="comment">     * -- how can we undo that in a clean way?  It does not seem worth it.  Again, checking</span></div>
<div class="line"><a id="l02617" name="l02617"></a><span class="lineno"> 2617</span><span class="comment">     * and updating the retransmission queue, though, is a nice @todo (but would ideally need fast</span></div>
<div class="line"><a id="l02618" name="l02618"></a><span class="lineno"> 2618</span><span class="comment">     * lookup into that linked list so not totally trivial).</span></div>
<div class="line"><a id="l02619" name="l02619"></a><span class="lineno"> 2619</span><span class="comment">     *</span></div>
<div class="line"><a id="l02620" name="l02620"></a><span class="lineno"> 2620</span><span class="comment">     * So, let&#39;s say that the concession described in the previous paragraph is OK.</span></div>
<div class="line"><a id="l02621" name="l02621"></a><span class="lineno"> 2621</span><span class="comment">     *</span></div>
<div class="line"><a id="l02622" name="l02622"></a><span class="lineno"> 2622</span><span class="comment">     * Could also be invalid.  We only know seq_num (one boundary of packet), so how do we detect</span></div>
<div class="line"><a id="l02623" name="l02623"></a><span class="lineno"> 2623</span><span class="comment">     * it&#39;s invalid?  One case where we know it&#39;s invalid is if this left boundary happens to be</span></div>
<div class="line"><a id="l02624" name="l02624"></a><span class="lineno"> 2624</span><span class="comment">     * straddled by a sequence number range in an element of snd_flying_pkts_by_seq.  That would mean</span></div>
<div class="line"><a id="l02625" name="l02625"></a><span class="lineno"> 2625</span><span class="comment">     * that the same sequence number is in two different packets, which is in no way legal.</span></div>
<div class="line"><a id="l02626" name="l02626"></a><span class="lineno"> 2626</span><span class="comment">     * Example: we sent [5, 10), then received ACK with [7, ...).  7 is inside [5, 10) and is</span></div>
<div class="line"><a id="l02627" name="l02627"></a><span class="lineno"> 2627</span><span class="comment">     * thus illegal. */</span></div>
<div class="line"><a id="l02628" name="l02628"></a><span class="lineno"> 2628</span> </div>
<div class="line"><a id="l02629" name="l02629"></a><span class="lineno"> 2629</span>    <span class="comment">/* Here&#39;s the technique we use.  snd_flying_pkts_by_seq.upper_bound(S) gets the first packet</span></div>
<div class="line"><a id="l02630" name="l02630"></a><span class="lineno"> 2630</span><span class="comment">     * [U1, U2) such that U1 &gt; S.  Let prev(P) denote the packet preceding P in</span></div>
<div class="line"><a id="l02631" name="l02631"></a><span class="lineno"> 2631</span><span class="comment">     * snd_flying_pkts_by_seq; let prev([U1, U2)) = [L1, L2).  Note that [U1, U2) may not exist</span></div>
<div class="line"><a id="l02632" name="l02632"></a><span class="lineno"> 2632</span><span class="comment">     * -- i.e., nothing after S is in the map.  If so, [U1, U2) == snd_flying_pkts_by_seq.end().  Even</span></div>
<div class="line"><a id="l02633" name="l02633"></a><span class="lineno"> 2633</span><span class="comment">     * in that case [L1, L2) = prev([U1, U2)) MAY still exist; it is the last element of</span></div>
<div class="line"><a id="l02634" name="l02634"></a><span class="lineno"> 2634</span><span class="comment">     * snd_flying_pkts_by_seq in that situation.</span></div>
<div class="line"><a id="l02635" name="l02635"></a><span class="lineno"> 2635</span><span class="comment">     *</span></div>
<div class="line"><a id="l02636" name="l02636"></a><span class="lineno"> 2636</span><span class="comment">     * Given that, here are all the situations that mean P is straddled by a packet:</span></div>
<div class="line"><a id="l02637" name="l02637"></a><span class="lineno"> 2637</span><span class="comment">     *</span></div>
<div class="line"><a id="l02638" name="l02638"></a><span class="lineno"> 2638</span><span class="comment">     * - S inside [U1, U2) or any packet after it.</span></div>
<div class="line"><a id="l02639" name="l02639"></a><span class="lineno"> 2639</span><span class="comment">     *   - Impossible.  U1 &gt; S by definition; so S is not inside any packet at U1 or later.</span></div>
<div class="line"><a id="l02640" name="l02640"></a><span class="lineno"> 2640</span><span class="comment">     * - S inside [L1, L2).</span></div>
<div class="line"><a id="l02641" name="l02641"></a><span class="lineno"> 2641</span><span class="comment">     *   - Possible.  We know S &gt; L1, since otherwise S &lt;= L1, which means we can&#39;t be inside this</span></div>
<div class="line"><a id="l02642" name="l02642"></a><span class="lineno"> 2642</span><span class="comment">     *     if (and we are), or snd_flying_pkts_by_seq.upper_bound(S) == [L1, L2) (not true, since</span></div>
<div class="line"><a id="l02643" name="l02643"></a><span class="lineno"> 2643</span><span class="comment">     *     snd_flying_pkts_by_seq.upper_bound(S) == [U1, U2), which != [L1, L2)).  So, since S &gt; L1,</span></div>
<div class="line"><a id="l02644" name="l02644"></a><span class="lineno"> 2644</span><span class="comment">     *     we must check for S &lt; L2.  If true, S is straddled.</span></div>
<div class="line"><a id="l02645" name="l02645"></a><span class="lineno"> 2645</span><span class="comment">     * - S inside some packet [K1, K2) before [L1, L2).</span></div>
<div class="line"><a id="l02646" name="l02646"></a><span class="lineno"> 2646</span><span class="comment">     *   - Impossible.  Suppose S is inside [K1, K2) immediately preceding [L1, L2).  Then</span></div>
<div class="line"><a id="l02647" name="l02647"></a><span class="lineno"> 2647</span><span class="comment">     *     snd_flying_pkts_by_seq.upper_bound(S) == [L1, L2).  But we already know</span></div>
<div class="line"><a id="l02648" name="l02648"></a><span class="lineno"> 2648</span><span class="comment">     *     snd_flying_pkts_by_seq.upper_bound(S) == [U1, U2) (which != [L1, L2)).  So that&#39;s</span></div>
<div class="line"><a id="l02649" name="l02649"></a><span class="lineno"> 2649</span><span class="comment">     *     impossible.  Repeat this logic for all packets [K1, K2) preceding [L1, L2) to show that</span></div>
<div class="line"><a id="l02650" name="l02650"></a><span class="lineno"> 2650</span><span class="comment">     *     it can&#39;t be straddled by any of those either.</span></div>
<div class="line"><a id="l02651" name="l02651"></a><span class="lineno"> 2651</span><span class="comment">     *</span></div>
<div class="line"><a id="l02652" name="l02652"></a><span class="lineno"> 2652</span><span class="comment">     * Therefore, S is straddled by a packet if and only if:</span></div>
<div class="line"><a id="l02653" name="l02653"></a><span class="lineno"> 2653</span><span class="comment">     *   - prev(snd_flying_pkts_by_seq.upper_bound(S)) exists; call it [L1, L2); and</span></div>
<div class="line"><a id="l02654" name="l02654"></a><span class="lineno"> 2654</span><span class="comment">     *   - S &lt; L2.</span></div>
<div class="line"><a id="l02655" name="l02655"></a><span class="lineno"> 2655</span><span class="comment">     *</span></div>
<div class="line"><a id="l02656" name="l02656"></a><span class="lineno"> 2656</span><span class="comment">     * This can be further restated as:</span></div>
<div class="line"><a id="l02657" name="l02657"></a><span class="lineno"> 2657</span><span class="comment">     *   - snd_flying_pkts_by_seq.upper_bound(S) != snd_flying_pkts_by_seq.begin(); and</span></div>
<div class="line"><a id="l02658" name="l02658"></a><span class="lineno"> 2658</span><span class="comment">     *   - (letting [L1, L2) = prev(snd_flying_pkts_by_seq.upper_bound(S)))</span></div>
<div class="line"><a id="l02659" name="l02659"></a><span class="lineno"> 2659</span><span class="comment">     *     S &lt; L2.</span></div>
<div class="line"><a id="l02660" name="l02660"></a><span class="lineno"> 2660</span><span class="comment">     *</span></div>
<div class="line"><a id="l02661" name="l02661"></a><span class="lineno"> 2661</span><span class="comment">     * So check for that. */</span></div>
<div class="line"><a id="l02662" name="l02662"></a><span class="lineno"> 2662</span> </div>
<div class="line"><a id="l02663" name="l02663"></a><span class="lineno"> 2663</span>    <span class="comment">// Find U.</span></div>
<div class="line"><a id="l02664" name="l02664"></a><span class="lineno"> 2664</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">Peer_socket::Sent_pkt_ordered_by_seq_const_iter</a> pkt_it = snd_flying_pkts_by_seq.upper_bound(seq_num);</div>
<div class="line"><a id="l02665" name="l02665"></a><span class="lineno"> 2665</span>    <span class="comment">// Check that prev(U) exists.</span></div>
<div class="line"><a id="l02666" name="l02666"></a><span class="lineno"> 2666</span>    <span class="keywordflow">if</span> (pkt_it != snd_flying_pkts_by_seq.begin())</div>
<div class="line"><a id="l02667" name="l02667"></a><span class="lineno"> 2667</span>    {</div>
<div class="line"><a id="l02668" name="l02668"></a><span class="lineno"> 2668</span>      <span class="comment">// prev(U) = L exists.  Compute L.</span></div>
<div class="line"><a id="l02669" name="l02669"></a><span class="lineno"> 2669</span>      --pkt_it;</div>
<div class="line"><a id="l02670" name="l02670"></a><span class="lineno"> 2670</span>      <span class="comment">// Compute [L1, L2), and check for straddling: S &lt; L2.  pkt_it-&gt;second points into snd_flying_pkts_by_when.</span></div>
<div class="line"><a id="l02671" name="l02671"></a><span class="lineno"> 2671</span>      <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> l1, l2;</div>
<div class="line"><a id="l02672" name="l02672"></a><span class="lineno"> 2672</span>      get_seq_num_range(pkt_it-&gt;second, &amp;l1, &amp;l2);</div>
<div class="line"><a id="l02673" name="l02673"></a><span class="lineno"> 2673</span> </div>
<div class="line"><a id="l02674" name="l02674"></a><span class="lineno"> 2674</span>      assert(l1 &lt; seq_num); <span class="comment">// Sanity-check of upper_bound().</span></div>
<div class="line"><a id="l02675" name="l02675"></a><span class="lineno"> 2675</span>      <span class="keywordflow">if</span> (seq_num &lt; l2)</div>
<div class="line"><a id="l02676" name="l02676"></a><span class="lineno"> 2676</span>      {</div>
<div class="line"><a id="l02677" name="l02677"></a><span class="lineno"> 2677</span>        <span class="comment">// Straddles.  Other side is sending us bad stuff.  As above, warn and RST/close.</span></div>
<div class="line"><a id="l02678" name="l02678"></a><span class="lineno"> 2678</span> </div>
<div class="line"><a id="l02679" name="l02679"></a><span class="lineno"> 2679</span>        <span class="comment">// Register one individual acknowledgment of unknown # of bytes of data (not acceptable due to error).</span></div>
<div class="line"><a id="l02680" name="l02680"></a><span class="lineno"> 2680</span>        snd_stats.error_ack();</div>
<div class="line"><a id="l02681" name="l02681"></a><span class="lineno"> 2681</span> </div>
<div class="line"><a id="l02682" name="l02682"></a><span class="lineno"> 2682</span>        <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02683" name="l02683"></a><span class="lineno"> 2683</span>                         <span class="stringliteral">&quot;Received [ACK]; &quot;</span></div>
<div class="line"><a id="l02684" name="l02684"></a><span class="lineno"> 2684</span>                         <span class="stringliteral">&quot;acknowledgment [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) is at least partially inside &quot;</span></div>
<div class="line"><a id="l02685" name="l02685"></a><span class="lineno"> 2685</span>                         <span class="stringliteral">&quot;packet [&quot;</span> &lt;&lt; l1 &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; l2 &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>);</div>
<div class="line"><a id="l02686" name="l02686"></a><span class="lineno"> 2686</span>        rst_and_close_connection_immediately(socket_id, sock, <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>, <span class="keyword">true</span>);</div>
<div class="line"><a id="l02687" name="l02687"></a><span class="lineno"> 2687</span>        <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l02688" name="l02688"></a><span class="lineno"> 2688</span><span class="comment">         * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l02689" name="l02689"></a><span class="lineno"> 2689</span><span class="comment">         * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l02690" name="l02690"></a><span class="lineno"> 2690</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Other out-params are meaningless.</span></div>
<div class="line"><a id="l02691" name="l02691"></a><span class="lineno"> 2691</span>      }</div>
<div class="line"><a id="l02692" name="l02692"></a><span class="lineno"> 2692</span>      <span class="comment">// else if (seq_num &gt;= l2) { It&#39;s past [L1, L2); does not straddle. }</span></div>
<div class="line"><a id="l02693" name="l02693"></a><span class="lineno"> 2693</span>    }</div>
<div class="line"><a id="l02694" name="l02694"></a><span class="lineno"> 2694</span>    <span class="comment">// else { Legit because there is no packet L that could possibly straddle seq_num. }</span></div>
<div class="line"><a id="l02695" name="l02695"></a><span class="lineno"> 2695</span> </div>
<div class="line"><a id="l02696" name="l02696"></a><span class="lineno"> 2696</span>    <span class="comment">/* OK, so NOW do we know it&#39;s a duplicate/late acknowledgment?  Well, no.  Suppose we sent packet</span></div>
<div class="line"><a id="l02697" name="l02697"></a><span class="lineno"> 2697</span><span class="comment">     * [5, 10) and get ACK with [5, ...).  That&#39;s fine.  So we erase [5, 10) from</span></div>
<div class="line"><a id="l02698" name="l02698"></a><span class="lineno"> 2698</span><span class="comment">     * snd_flying_pkts_by_seq.  Now say we get ACK with [7, ...).  Well, that&#39;s in the</span></div>
<div class="line"><a id="l02699" name="l02699"></a><span class="lineno"> 2699</span><span class="comment">     * [m_snd_next_seq_num, m_snd_next_seq_num) range certainly; and it doesn&#39;t get straddled by</span></div>
<div class="line"><a id="l02700" name="l02700"></a><span class="lineno"> 2700</span><span class="comment">     * any member of snd_flying_pkts_by_seq.  Yet it&#39;s certainly invalid: we never sent (and could&#39;ve</span></div>
<div class="line"><a id="l02701" name="l02701"></a><span class="lineno"> 2701</span><span class="comment">     * never sent) [7, ...).  We can&#39;t know that, however, since [5, 10) is gone from</span></div>
<div class="line"><a id="l02702" name="l02702"></a><span class="lineno"> 2702</span><span class="comment">     * snd_flying_pkts_by_seq.  Is this OK?  More or less, yes.  What do we do with a duplicate/late</span></div>
<div class="line"><a id="l02703" name="l02703"></a><span class="lineno"> 2703</span><span class="comment">     * acknowledgment just below?  We log and ignore it.  That doesn&#39;t seem harmful.  NORMALLY</span></div>
<div class="line"><a id="l02704" name="l02704"></a><span class="lineno"> 2704</span><span class="comment">     * when something is invalid we&#39;d RST and close connection, but here we can&#39;t know we should</span></div>
<div class="line"><a id="l02705" name="l02705"></a><span class="lineno"> 2705</span><span class="comment">     * do that; however ignoring it still seems fine and better than doggedly inventing data</span></div>
<div class="line"><a id="l02706" name="l02706"></a><span class="lineno"> 2706</span><span class="comment">     * structures to detect this corner case.</span></div>
<div class="line"><a id="l02707" name="l02707"></a><span class="lineno"> 2707</span><span class="comment">     *</span></div>
<div class="line"><a id="l02708" name="l02708"></a><span class="lineno"> 2708</span><span class="comment">     * What about m_snd_cong_ctl?  Should we report this in m_snd_cong_ctl-&gt;on_acks()?</span></div>
<div class="line"><a id="l02709" name="l02709"></a><span class="lineno"> 2709</span><span class="comment">     * No.  on_acks() specifically documents that it wants info on</span></div>
<div class="line"><a id="l02710" name="l02710"></a><span class="lineno"> 2710</span><span class="comment">     * In-flight-&gt;Acknowledged acknowledgments, not duplicates.  (Briefly,</span></div>
<div class="line"><a id="l02711" name="l02711"></a><span class="lineno"> 2711</span><span class="comment">     * that&#39;s because it&#39;s measuring sent data in the pipe; acknowledgment duplication has unclear</span></div>
<div class="line"><a id="l02712" name="l02712"></a><span class="lineno"> 2712</span><span class="comment">     * implications about what it&#39;s acknowledging; it is unlikely that it represents more pipe</span></div>
<div class="line"><a id="l02713" name="l02713"></a><span class="lineno"> 2713</span><span class="comment">     * being available than if only one acknolwedgment had been received.  In any case this should</span></div>
<div class="line"><a id="l02714" name="l02714"></a><span class="lineno"> 2714</span><span class="comment">     * hopefully be pretty rare and thus not too significant either way.)</span></div>
<div class="line"><a id="l02715" name="l02715"></a><span class="lineno"> 2715</span><span class="comment">     *</span></div>
<div class="line"><a id="l02716" name="l02716"></a><span class="lineno"> 2716</span><span class="comment">     * Same reasoning for not counting it in m_snd_bandwidth_estimator-&gt;on_acks(). */</span></div>
<div class="line"><a id="l02717" name="l02717"></a><span class="lineno"> 2717</span> </div>
<div class="line"><a id="l02718" name="l02718"></a><span class="lineno"> 2718</span>    <span class="comment">// Per above discussion, ignore duplicate (or maybe invalid, but we can&#39;t know/assume that) acknowledgment.</span></div>
<div class="line"><a id="l02719" name="l02719"></a><span class="lineno"> 2719</span> </div>
<div class="line"><a id="l02720" name="l02720"></a><span class="lineno"> 2720</span>    <span class="comment">// Register one individual acknowledgment of unknown # of bytes of data (late, dupe, or maybe invalid).</span></div>
<div class="line"><a id="l02721" name="l02721"></a><span class="lineno"> 2721</span>    snd_stats.late_or_dupe_ack();</div>
<div class="line"><a id="l02722" name="l02722"></a><span class="lineno"> 2722</span> </div>
<div class="line"><a id="l02723" name="l02723"></a><span class="lineno"> 2723</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02724" name="l02724"></a><span class="lineno"> 2724</span>                  <span class="stringliteral">&quot;Acknowledged packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) is duplicate or late (or invalid).  &quot;</span></div>
<div class="line"><a id="l02725" name="l02725"></a><span class="lineno"> 2725</span>                  <span class="stringliteral">&quot;RTT unknown.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02726" name="l02726"></a><span class="lineno"> 2726</span> </div>
<div class="line"><a id="l02727" name="l02727"></a><span class="lineno"> 2727</span>    <span class="comment">// Ensure out-params indicating a dupe/late ack such that the packet being acked is not known.</span></div>
<div class="line"><a id="l02728" name="l02728"></a><span class="lineno"> 2728</span>    *dupe_or_late = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02729" name="l02729"></a><span class="lineno"> 2729</span>    assert(*acked_pkt_it == snd_flying_pkts_by_when.past_oldest()); <span class="comment">// A/k/a end().</span></div>
<div class="line"><a id="l02730" name="l02730"></a><span class="lineno"> 2730</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02731" name="l02731"></a><span class="lineno"> 2731</span>  } <span class="comment">// if (seq_num is not in snd_flying_pkts*) // i.e., duplicate/late acknowledgment with unknown acked packet.</span></div>
<div class="line"><a id="l02732" name="l02732"></a><span class="lineno"> 2732</span>  <span class="comment">// else if (seq_num IS in snd_flying_pkts*): *acked_pkt_it points to snd_flying_pkts_by_when[seq_num].</span></div>
<div class="line"><a id="l02733" name="l02733"></a><span class="lineno"> 2733</span>  assert(*acked_pkt_it != snd_flying_pkts_by_when.past_oldest());</div>
<div class="line"><a id="l02734" name="l02734"></a><span class="lineno"> 2734</span> </div>
<div class="line"><a id="l02735" name="l02735"></a><span class="lineno"> 2735</span>  <span class="comment">// It&#39;s an ack of sequence number we&#39;d sent, but if retransmission is on it may not be of the one we LAST sent.</span></div>
<div class="line"><a id="l02736" name="l02736"></a><span class="lineno"> 2736</span> </div>
<div class="line"><a id="l02737" name="l02737"></a><span class="lineno"> 2737</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Peer_socket::Sent_packet</a>&amp; acked_pkt = *((*acked_pkt_it)-&gt;second);</div>
<div class="line"><a id="l02738" name="l02738"></a><span class="lineno"> 2738</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> acked_rexmit_id = <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> ? acked_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a704afa0007b8354ad78acad64d029ecf">m_packet</a>-&gt;m_rexmit_id : 0;</div>
<div class="line"><a id="l02739" name="l02739"></a><span class="lineno"> 2739</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_end; <span class="comment">// Get sequence number just past last datum in packet.</span></div>
<div class="line"><a id="l02740" name="l02740"></a><span class="lineno"> 2740</span>  get_seq_num_range(*acked_pkt_it, 0, &amp;seq_num_end);</div>
<div class="line"><a id="l02741" name="l02741"></a><span class="lineno"> 2741</span> </div>
<div class="line"><a id="l02742" name="l02742"></a><span class="lineno"> 2742</span>  <span class="comment">// Note that both rexmit_id and acked_rexmit_id are guaranteed 0 at this point if !rexmit_on.</span></div>
<div class="line"><a id="l02743" name="l02743"></a><span class="lineno"> 2743</span> </div>
<div class="line"><a id="l02744" name="l02744"></a><span class="lineno"> 2744</span>  <span class="keywordflow">if</span> (rexmit_id &gt; acked_rexmit_id)</div>
<div class="line"><a id="l02745" name="l02745"></a><span class="lineno"> 2745</span>  {</div>
<div class="line"><a id="l02746" name="l02746"></a><span class="lineno"> 2746</span>    <span class="comment">// This is entirely illegal.  Can&#39;t acknowledge a packet copy we hadn&#39;t sent yet.</span></div>
<div class="line"><a id="l02747" name="l02747"></a><span class="lineno"> 2747</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02748" name="l02748"></a><span class="lineno"> 2748</span>                     <span class="stringliteral">&quot;Acknowledged packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l02749" name="l02749"></a><span class="lineno"> 2749</span>                     <span class="stringliteral">&quot;rexmit_id [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(rexmit_id) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02750" name="l02750"></a><span class="lineno"> 2750</span>                     <span class="stringliteral">&quot;exceeds highest sent rexmit_id [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(acked_rexmit_id) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02751" name="l02751"></a><span class="lineno"> 2751</span>    rst_and_close_connection_immediately(socket_id, sock, <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a>, <span class="keyword">true</span>);</div>
<div class="line"><a id="l02752" name="l02752"></a><span class="lineno"> 2752</span>    <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l02753" name="l02753"></a><span class="lineno"> 2753</span><span class="comment">     * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l02754" name="l02754"></a><span class="lineno"> 2754</span><span class="comment">     * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l02755" name="l02755"></a><span class="lineno"> 2755</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Other out-params are meaningless.</span></div>
<div class="line"><a id="l02756" name="l02756"></a><span class="lineno"> 2756</span>  }</div>
<div class="line"><a id="l02757" name="l02757"></a><span class="lineno"> 2757</span>  <span class="comment">// else if (rexmit_id &lt;= acked_rexmit_id)</span></div>
<div class="line"><a id="l02758" name="l02758"></a><span class="lineno"> 2758</span> </div>
<div class="line"><a id="l02759" name="l02759"></a><span class="lineno"> 2759</span>  <span class="keywordflow">if</span> (rexmit_id != acked_rexmit_id)</div>
<div class="line"><a id="l02760" name="l02760"></a><span class="lineno"> 2760</span>  {</div>
<div class="line"><a id="l02761" name="l02761"></a><span class="lineno"> 2761</span>    assert(rexmit_id &lt; acked_rexmit_id);</div>
<div class="line"><a id="l02762" name="l02762"></a><span class="lineno"> 2762</span> </div>
<div class="line"><a id="l02763" name="l02763"></a><span class="lineno"> 2763</span>    <span class="comment">/* This is legal: it&#39;s possible we had sent packet P, considered it Dropped, retransmitted it</span></div>
<div class="line"><a id="l02764" name="l02764"></a><span class="lineno"> 2764</span><span class="comment">     * (thus incrementing rexmit_id), and have now received a late acknowledgment of the</span></div>
<div class="line"><a id="l02765" name="l02765"></a><span class="lineno"> 2765</span><span class="comment">     * PREVIOUS attempt to send P (before retransmission).  We could actually consider this</span></div>
<div class="line"><a id="l02766" name="l02766"></a><span class="lineno"> 2766</span><span class="comment">     * entirely equivalent to simply getting the last attempt acked.  In fact I specifically kept</span></div>
<div class="line"><a id="l02767" name="l02767"></a><span class="lineno"> 2767</span><span class="comment">     * an array for m_sent_when, so that we can even compute accurate RTT.  Yet, at least for now,</span></div>
<div class="line"><a id="l02768" name="l02768"></a><span class="lineno"> 2768</span><span class="comment">     * I am going to ignore such an acknowledgment.  Reasons:</span></div>
<div class="line"><a id="l02769" name="l02769"></a><span class="lineno"> 2769</span><span class="comment">     *</span></div>
<div class="line"><a id="l02770" name="l02770"></a><span class="lineno"> 2770</span><span class="comment">     *   - The RTT may be an outlier affected by some random event; we considered it Dropped, so</span></div>
<div class="line"><a id="l02771" name="l02771"></a><span class="lineno"> 2771</span><span class="comment">     *     if those heuristics are generally sound, getting a late ack is suspicious.</span></div>
<div class="line"><a id="l02772" name="l02772"></a><span class="lineno"> 2772</span><span class="comment">     *</span></div>
<div class="line"><a id="l02773" name="l02773"></a><span class="lineno"> 2773</span><span class="comment">     *   - Suppose I do take the RTT and report to congestion control, use for SRTT computation,</span></div>
<div class="line"><a id="l02774" name="l02774"></a><span class="lineno"> 2774</span><span class="comment">     *     and remove from snd_flying_pkts*.  I&#39;ve in effect recorded a loss but then also</span></div>
<div class="line"><a id="l02775" name="l02775"></a><span class="lineno"> 2775</span><span class="comment">     *     reported a successful retransmission, even though the ack is not for the retransmission</span></div>
<div class="line"><a id="l02776" name="l02776"></a><span class="lineno"> 2776</span><span class="comment">     *     but more like a correction on the original loss.  That&#39;s potentially fine, but chances</span></div>
<div class="line"><a id="l02777" name="l02777"></a><span class="lineno"> 2777</span><span class="comment">     *     are I will soon receive the ack for the latest transmission, which is what I was really</span></div>
<div class="line"><a id="l02778" name="l02778"></a><span class="lineno"> 2778</span><span class="comment">     *     expecting.  That one will now be considered a late ack and will be ignored, even though</span></div>
<div class="line"><a id="l02779" name="l02779"></a><span class="lineno"> 2779</span><span class="comment">     *     that RTT is actually probably more accurate, since chances are it arrived before the</span></div>
<div class="line"><a id="l02780" name="l02780"></a><span class="lineno"> 2780</span><span class="comment">     *     retransmission would&#39;ve been considered Dropped as well.  So, basically, we&#39;re kind of</span></div>
<div class="line"><a id="l02781" name="l02781"></a><span class="lineno"> 2781</span><span class="comment">     *     trying to use the &quot;two wrongs make a right&quot; philosophy, which seems messy.</span></div>
<div class="line"><a id="l02782" name="l02782"></a><span class="lineno"> 2782</span><span class="comment">     *</span></div>
<div class="line"><a id="l02783" name="l02783"></a><span class="lineno"> 2783</span><span class="comment">     *   - Earlier in the method, I mentioned that if we detect P as dropped and queue it for</span></div>
<div class="line"><a id="l02784" name="l02784"></a><span class="lineno"> 2784</span><span class="comment">     *     retransmission but get P acked *before* we get a chance to retransmit, then we consider</span></div>
<div class="line"><a id="l02785" name="l02785"></a><span class="lineno"> 2785</span><span class="comment">     *     that ack as late and ignore it (and will still retransmit P).  The reasons for that are</span></div>
<div class="line"><a id="l02786" name="l02786"></a><span class="lineno"> 2786</span><span class="comment">     *     given in that comment.  However, given that we made that decision, it would seem</span></div>
<div class="line"><a id="l02787" name="l02787"></a><span class="lineno"> 2787</span><span class="comment">     *     strange to follow a different philosophy just because we did happen to get to</span></div>
<div class="line"><a id="l02788" name="l02788"></a><span class="lineno"> 2788</span><span class="comment">     *     retransmit P.  That would be inconsistent.</span></div>
<div class="line"><a id="l02789" name="l02789"></a><span class="lineno"> 2789</span><span class="comment">     *</span></div>
<div class="line"><a id="l02790" name="l02790"></a><span class="lineno"> 2790</span><span class="comment">     *   - Keeping it in perspective, it should be fairly rare that a packet we considered Dropped</span></div>
<div class="line"><a id="l02791" name="l02791"></a><span class="lineno"> 2791</span><span class="comment">     *     is acked after all.  So it is perhaps not worth the trouble to go crazy about this</span></div>
<div class="line"><a id="l02792" name="l02792"></a><span class="lineno"> 2792</span><span class="comment">     *     corner case.</span></div>
<div class="line"><a id="l02793" name="l02793"></a><span class="lineno"> 2793</span><span class="comment">     *</span></div>
<div class="line"><a id="l02794" name="l02794"></a><span class="lineno"> 2794</span><span class="comment">     * Nevertheless, a @todo would be to experimentally measure the effect of this policy and</span></div>
<div class="line"><a id="l02795" name="l02795"></a><span class="lineno"> 2795</span><span class="comment">     * decide whether it is sound.  In that case also consider the aforementioned &quot;P is acked</span></div>
<div class="line"><a id="l02796" name="l02796"></a><span class="lineno"> 2796</span><span class="comment">     * after queued for retransmission but before retransmitted&quot; corner case. */</span></div>
<div class="line"><a id="l02797" name="l02797"></a><span class="lineno"> 2797</span> </div>
<div class="line"><a id="l02798" name="l02798"></a><span class="lineno"> 2798</span>    <span class="comment">// Register one individual acknowledgment of unknown # of bytes of data (late).</span></div>
<div class="line"><a id="l02799" name="l02799"></a><span class="lineno"> 2799</span>    snd_stats.late_or_dupe_ack();</div>
<div class="line"><a id="l02800" name="l02800"></a><span class="lineno"> 2800</span> </div>
<div class="line"><a id="l02801" name="l02801"></a><span class="lineno"> 2801</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02802" name="l02802"></a><span class="lineno"> 2802</span>                  <span class="stringliteral">&quot;Acknowledged packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l02803" name="l02803"></a><span class="lineno"> 2803</span>                  <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; acked_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e">m_sent_when</a>[rexmit_id].m_order_num &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02804" name="l02804"></a><span class="lineno"> 2804</span>                  <span class="stringliteral">&quot;rexmit_id [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(rexmit_id) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02805" name="l02805"></a><span class="lineno"> 2805</span>                  <span class="stringliteral">&quot;is less than highest sent [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(acked_rexmit_id) &lt;&lt; <span class="stringliteral">&quot;].  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02806" name="l02806"></a><span class="lineno"> 2806</span> </div>
<div class="line"><a id="l02807" name="l02807"></a><span class="lineno"> 2807</span>    <span class="comment">// Ensure out-params indicating a dupe/late ack of a specific known sent packet.</span></div>
<div class="line"><a id="l02808" name="l02808"></a><span class="lineno"> 2808</span>    *dupe_or_late = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02809" name="l02809"></a><span class="lineno"> 2809</span>    assert(*acked_pkt_it != snd_flying_pkts_by_when.past_oldest()); <span class="comment">// A/k/a end().</span></div>
<div class="line"><a id="l02810" name="l02810"></a><span class="lineno"> 2810</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02811" name="l02811"></a><span class="lineno"> 2811</span>  }</div>
<div class="line"><a id="l02812" name="l02812"></a><span class="lineno"> 2812</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02813" name="l02813"></a><span class="lineno"> 2813</span>  assert(rexmit_id == acked_rexmit_id);</div>
<div class="line"><a id="l02814" name="l02814"></a><span class="lineno"> 2814</span> </div>
<div class="line"><a id="l02815" name="l02815"></a><span class="lineno"> 2815</span>  <span class="comment">// Do not log this mainstream case; only the exceptions above.  RTT will probably be logged separately.</span></div>
<div class="line"><a id="l02816" name="l02816"></a><span class="lineno"> 2816</span> </div>
<div class="line"><a id="l02817" name="l02817"></a><span class="lineno"> 2817</span>  <span class="comment">// Register one individual acknowledgment of N bytes of data (converts from In-flight to Acknowledged).</span></div>
<div class="line"><a id="l02818" name="l02818"></a><span class="lineno"> 2818</span>  snd_stats.good_ack(acked_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a5b5762a1effba90f631c06ad76f9774b">m_size</a>);</div>
<div class="line"><a id="l02819" name="l02819"></a><span class="lineno"> 2819</span> </div>
<div class="line"><a id="l02820" name="l02820"></a><span class="lineno"> 2820</span>  <span class="comment">// Ensure out-params indicating an in-time, first ack of a specific known sent packet.</span></div>
<div class="line"><a id="l02821" name="l02821"></a><span class="lineno"> 2821</span>  *dupe_or_late = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02822" name="l02822"></a><span class="lineno"> 2822</span>  assert(*acked_pkt_it != snd_flying_pkts_by_when.past_oldest()); <span class="comment">// A/k/a end().</span></div>
<div class="line"><a id="l02823" name="l02823"></a><span class="lineno"> 2823</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02824" name="l02824"></a><span class="lineno"> 2824</span>} <span class="comment">// Node::categorize_individual_ack()</span></div>
<div class="line"><a id="l02825" name="l02825"></a><span class="lineno"> 2825</span> </div>
<div class="line"><a id="l02826" name="l02826"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b"> 2826</a></span><a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">Node::compute_rtt_on_ack</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> flying_pkt,</div>
<div class="line"><a id="l02827" name="l02827"></a><span class="lineno"> 2827</span>                                       <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; time_now,</div>
<div class="line"><a id="l02828" name="l02828"></a><span class="lineno"> 2828</span>                                       <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack,</div>
<div class="line"><a id="l02829" name="l02829"></a><span class="lineno"> 2829</span>                                       <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a>** sent_when)<span class="keyword"> const</span></div>
<div class="line"><a id="l02830" name="l02830"></a><span class="lineno"> 2830</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02831" name="l02831"></a><span class="lineno"> 2831</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l02832" name="l02832"></a><span class="lineno"> 2832</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l02833" name="l02833"></a><span class="lineno"> 2833</span> </div>
<div class="line"><a id="l02834" name="l02834"></a><span class="lineno"> 2834</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> round_trip_time;</div>
<div class="line"><a id="l02835" name="l02835"></a><span class="lineno"> 2835</span> </div>
<div class="line"><a id="l02836" name="l02836"></a><span class="lineno"> 2836</span>  <span class="comment">/* This helper of handle_accumulated_acks() exists to make the latter method briefer/readable, not for code reuse</span></div>
<div class="line"><a id="l02837" name="l02837"></a><span class="lineno"> 2837</span><span class="comment">   * as of this writing.  It computes the RTT implied by the given individual ack and also returns the Sent_when</span></div>
<div class="line"><a id="l02838" name="l02838"></a><span class="lineno"> 2838</span><span class="comment">   * (which contains info on when the original packet was sent) structure as an out-param. */</span></div>
<div class="line"><a id="l02839" name="l02839"></a><span class="lineno"> 2839</span> </div>
<div class="line"><a id="l02840" name="l02840"></a><span class="lineno"> 2840</span>  <span class="comment">/* RTT subtleties:</span></div>
<div class="line"><a id="l02841" name="l02841"></a><span class="lineno"> 2841</span><span class="comment">   *</span></div>
<div class="line"><a id="l02842" name="l02842"></a><span class="lineno"> 2842</span><span class="comment">   * How long did the other side, upon receiving the acked packet, wait before sending this</span></div>
<div class="line"><a id="l02843" name="l02843"></a><span class="lineno"> 2843</span><span class="comment">   * containing ACK with that individual acknowledgment?  Why do we care?  For RTT.  Why do we</span></div>
<div class="line"><a id="l02844" name="l02844"></a><span class="lineno"> 2844</span><span class="comment">   * want RTT?  To measure how long it takes for a sent packet to reach the receiver (one-way trip</span></div>
<div class="line"><a id="l02845" name="l02845"></a><span class="lineno"> 2845</span><span class="comment">   * time, or OWTT).  Since mesuring OWTT is quite hard/impossible due to lack of absolute clock</span></div>
<div class="line"><a id="l02846" name="l02846"></a><span class="lineno"> 2846</span><span class="comment">   * synchronization between us and the receiver, RTT/2 is used as the next best way to get OWTT.</span></div>
<div class="line"><a id="l02847" name="l02847"></a><span class="lineno"> 2847</span><span class="comment">   * We can measure RTT by subtracting our recorded packet send time from the current time (ACK</span></div>
<div class="line"><a id="l02848" name="l02848"></a><span class="lineno"> 2848</span><span class="comment">   * receipt time).  However, the ACK delay introduced by the receiver to reduce ACK overhead has</span></div>
<div class="line"><a id="l02849" name="l02849"></a><span class="lineno"> 2849</span><span class="comment">   * nothing to do with OWTT; it just (randomly, from the other side&#39;s point of view) inflates the RTT.</span></div>
<div class="line"><a id="l02850" name="l02850"></a><span class="lineno"> 2850</span><span class="comment">   * Thus we subtract the ACK delay from the RTT to get the actual RTT we use for congestion control, etc. */</span></div>
<div class="line"><a id="l02851" name="l02851"></a><span class="lineno"> 2851</span> </div>
<div class="line"><a id="l02852" name="l02852"></a><span class="lineno"> 2852</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rexmit_id = ack-&gt;m_rexmit_id;</div>
<div class="line"><a id="l02853" name="l02853"></a><span class="lineno"> 2853</span>  <span class="comment">// Get the RTT for the transmission attempt that is actually being acknowledged (always 0 if retransmission off).</span></div>
<div class="line"><a id="l02854" name="l02854"></a><span class="lineno"> 2854</span>  *sent_when = &amp;(flying_pkt-&gt;m_sent_when[rexmit_id]);</div>
<div class="line"><a id="l02855" name="l02855"></a><span class="lineno"> 2855</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> order_num = (*sent_when)-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">m_order_num</a>;</div>
<div class="line"><a id="l02856" name="l02856"></a><span class="lineno"> 2856</span> </div>
<div class="line"><a id="l02857" name="l02857"></a><span class="lineno"> 2857</span>  <span class="comment">/* ?second-resolution value (ack_delay) subtracted from max-resolution values.  If ack_delay is</span></div>
<div class="line"><a id="l02858" name="l02858"></a><span class="lineno"> 2858</span><span class="comment">   * also in the max-resolution time unit, then there is no loss of precision.  Otherwise we lose</span></div>
<div class="line"><a id="l02859" name="l02859"></a><span class="lineno"> 2859</span><span class="comment">   * precision by subtracting a number with fewer significant digits from one with more</span></div>
<div class="line"><a id="l02860" name="l02860"></a><span class="lineno"> 2860</span><span class="comment">   * significant digits.  So Ack_delay_time_unit should ideally be Fine_duration, for precise RTT</span></div>
<div class="line"><a id="l02861" name="l02861"></a><span class="lineno"> 2861</span><span class="comment">   * values (especially for queueing delay-based congestion control algorithms); however that</span></div>
<div class="line"><a id="l02862" name="l02862"></a><span class="lineno"> 2862</span><span class="comment">   * decision is discussed elsewhere (Low_lvl_packet). */</span></div>
<div class="line"><a id="l02863" name="l02863"></a><span class="lineno"> 2863</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; ack_delay = ack-&gt;m_delay;</div>
<div class="line"><a id="l02864" name="l02864"></a><span class="lineno"> 2864</span>  round_trip_time = time_now - (*sent_when)-&gt;m_sent_time - ack_delay;</div>
<div class="line"><a id="l02865" name="l02865"></a><span class="lineno"> 2865</span> </div>
<div class="line"><a id="l02866" name="l02866"></a><span class="lineno"> 2866</span>  <span class="keywordflow">if</span> (round_trip_time.count() &lt; 0)</div>
<div class="line"><a id="l02867" name="l02867"></a><span class="lineno"> 2867</span>  {</div>
<div class="line"><a id="l02868" name="l02868"></a><span class="lineno"> 2868</span>    <span class="comment">/* Because this combines measurements on both sides, and each may have some error (plus or</span></div>
<div class="line"><a id="l02869" name="l02869"></a><span class="lineno"> 2869</span><span class="comment">     * minus a few hundred microseconds, possibly), and the result can be quite close to zero in</span></div>
<div class="line"><a id="l02870" name="l02870"></a><span class="lineno"> 2870</span><span class="comment">     * extremely low-latency situations, this may come out to be negative.  So assume zero and</span></div>
<div class="line"><a id="l02871" name="l02871"></a><span class="lineno"> 2871</span><span class="comment">     * log a TRACE message at most.</span></div>
<div class="line"><a id="l02872" name="l02872"></a><span class="lineno"> 2872</span><span class="comment">     *</span></div>
<div class="line"><a id="l02873" name="l02873"></a><span class="lineno"> 2873</span><span class="comment">     * @todo Should we put also a ceiling on the RTT?</span></div>
<div class="line"><a id="l02874" name="l02874"></a><span class="lineno"> 2874</span><span class="comment">     * @todo For the floor, maybe it&#39;s better to use a higher guess than zero? */</span></div>
<div class="line"><a id="l02875" name="l02875"></a><span class="lineno"> 2875</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Acknowledged packet [&quot;</span> &lt;&lt; ack-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) &quot;</span></div>
<div class="line"><a id="l02876" name="l02876"></a><span class="lineno"> 2876</span>                   <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; order_num &lt;&lt; <span class="stringliteral">&quot;] has negative &quot;</span></div>
<div class="line"><a id="l02877" name="l02877"></a><span class="lineno"> 2877</span>                   <span class="stringliteral">&quot;RTT [&quot;</span> &lt;&lt; round_trip_time &lt;&lt; <span class="stringliteral">&quot;]; assuming zero.  &quot;</span></div>
<div class="line"><a id="l02878" name="l02878"></a><span class="lineno"> 2878</span>                   <span class="stringliteral">&quot;Sent at [&quot;</span> &lt;&lt; (*sent_when)-&gt;m_sent_time &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l02879" name="l02879"></a><span class="lineno"> 2879</span>                   <span class="stringliteral">&quot;received at [&quot;</span> &lt;&lt; time_now &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l02880" name="l02880"></a><span class="lineno"> 2880</span>                   <span class="stringliteral">&quot;receiver-reported ACK delay [&quot;</span> &lt;&lt; ack_delay &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02881" name="l02881"></a><span class="lineno"> 2881</span>    round_trip_time = Fine_duration::zero();</div>
<div class="line"><a id="l02882" name="l02882"></a><span class="lineno"> 2882</span>  }</div>
<div class="line"><a id="l02883" name="l02883"></a><span class="lineno"> 2883</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Acknowledged packet [&quot;</span> &lt;&lt; ack-&gt;m_seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) &quot;</span></div>
<div class="line"><a id="l02884" name="l02884"></a><span class="lineno"> 2884</span>                 <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; order_num &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02885" name="l02885"></a><span class="lineno"> 2885</span>                 <span class="stringliteral">&quot;has RTT [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(round_trip_time) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02886" name="l02886"></a><span class="lineno"> 2886</span>                 <span class="stringliteral">&quot;(ACK delay [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(ack_delay) &lt;&lt; <span class="stringliteral">&quot;]).&quot;</span>);</div>
<div class="line"><a id="l02887" name="l02887"></a><span class="lineno"> 2887</span> </div>
<div class="line"><a id="l02888" name="l02888"></a><span class="lineno"> 2888</span>  <span class="keywordflow">return</span> round_trip_time;</div>
<div class="line"><a id="l02889" name="l02889"></a><span class="lineno"> 2889</span>} <span class="comment">// Node::compute_rtt_on_ack()</span></div>
<div class="line"><a id="l02890" name="l02890"></a><span class="lineno"> 2890</span> </div>
<div class="line"><a id="l02891" name="l02891"></a><span class="lineno"> 2891</span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a></div>
<div class="line"><a id="l02892" name="l02892"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60"> 2892</a></span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">Node::categorize_pkts_as_dropped_on_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02893" name="l02893"></a><span class="lineno"> 2893</span>                                           <span class="keyword">const</span> boost::unordered_set&lt;Peer_socket::order_num_t&gt;&amp; flying_now_acked_pkts)</div>
<div class="line"><a id="l02894" name="l02894"></a><span class="lineno"> 2894</span>{</div>
<div class="line"><a id="l02895" name="l02895"></a><span class="lineno"> 2895</span>  <span class="keyword">using </span>std::priority_queue;</div>
<div class="line"><a id="l02896" name="l02896"></a><span class="lineno"> 2896</span> </div>
<div class="line"><a id="l02897" name="l02897"></a><span class="lineno"> 2897</span>  <span class="comment">/* This helper of handle_accumulated_acks() exists to make the latter method briefer/readable, not for code reuse</span></div>
<div class="line"><a id="l02898" name="l02898"></a><span class="lineno"> 2898</span><span class="comment">   * as of this writing. The background is that once a set of individual acks has been processed in the sense that</span></div>
<div class="line"><a id="l02899" name="l02899"></a><span class="lineno"> 2899</span><span class="comment">   * sock-&gt;m_snd_flying_pkts* (which tracks In-flight outbound DATA packets) has been updated by removing the</span></div>
<div class="line"><a id="l02900" name="l02900"></a><span class="lineno"> 2900</span><span class="comment">   * acked packets (they are no longer In-flight), it&#39;s time to also recategorize certain further In-flight</span></div>
<div class="line"><a id="l02901" name="l02901"></a><span class="lineno"> 2901</span><span class="comment">   * packets as Dropped -- the intuition being that once N packets sent LATER than a given packet P have been</span></div>
<div class="line"><a id="l02902" name="l02902"></a><span class="lineno"> 2902</span><span class="comment">   * acked, it&#39;s highly probable that P has been Dropped by the network. This method determines the packets to drop</span></div>
<div class="line"><a id="l02903" name="l02903"></a><span class="lineno"> 2903</span><span class="comment">   * in that fashion.</span></div>
<div class="line"><a id="l02904" name="l02904"></a><span class="lineno"> 2904</span><span class="comment">   *</span></div>
<div class="line"><a id="l02905" name="l02905"></a><span class="lineno"> 2905</span><span class="comment">   * Now, as explained below, when ack set S causes packet set P&#39; to be Dropped, this (possibly null) set P&#39;</span></div>
<div class="line"><a id="l02906" name="l02906"></a><span class="lineno"> 2906</span><span class="comment">   * always has the following form: there is some particular packet P which is the most-recently-sent one</span></div>
<div class="line"><a id="l02907" name="l02907"></a><span class="lineno"> 2907</span><span class="comment">   * that is in P&#39;; and therefore ALL other In-flight packets sent before P must be dropped too and also are in P&#39;.</span></div>
<div class="line"><a id="l02908" name="l02908"></a><span class="lineno"> 2908</span><span class="comment">   * Thus P is necessary/sufficient to specify P&#39;.  Thus this method simply finds and returns a thing pointing to P. */</span></div>
<div class="line"><a id="l02909" name="l02909"></a><span class="lineno"> 2909</span> </div>
<div class="line"><a id="l02910" name="l02910"></a><span class="lineno"> 2910</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l02911" name="l02911"></a><span class="lineno"> 2911</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l02912" name="l02912"></a><span class="lineno"> 2912</span> </div>
<div class="line"><a id="l02913" name="l02913"></a><span class="lineno"> 2913</span>  <span class="comment">/* OK, snd_flying_pkts* has been updated, in that we&#39;ve removed any Sent_packet entries</span></div>
<div class="line"><a id="l02914" name="l02914"></a><span class="lineno"> 2914</span><span class="comment">   * corresponding to valid acknolwedgments in this ACK.  As promised elsewhere we should also update</span></div>
<div class="line"><a id="l02915" name="l02915"></a><span class="lineno"> 2915</span><span class="comment">   * the remaining Sent_packets&#39; m_acks_after_me entries and erase any Sent_packets that we consider</span></div>
<div class="line"><a id="l02916" name="l02916"></a><span class="lineno"> 2916</span><span class="comment">   * Dropped due to too high m_acks_after_me values.  (As in TCP Fast Retransmit/Recovery, an</span></div>
<div class="line"><a id="l02917" name="l02917"></a><span class="lineno"> 2917</span><span class="comment">   * unacknowledged packet is considered Dropped based on the heuristic that a few packets with</span></div>
<div class="line"><a id="l02918" name="l02918"></a><span class="lineno"> 2918</span><span class="comment">   * higher sequence numbers have been acknowledged.  Except since we have Sent_when, that should be</span></div>
<div class="line"><a id="l02919" name="l02919"></a><span class="lineno"> 2919</span><span class="comment">   * even better than using sequence number ordering as TCP would.)</span></div>
<div class="line"><a id="l02920" name="l02920"></a><span class="lineno"> 2920</span><span class="comment">   *</span></div>
<div class="line"><a id="l02921" name="l02921"></a><span class="lineno"> 2921</span><span class="comment">   * (Warning: below and nearby, I make pseudo-code-y leaps, such as saying flying_now_acked_pkts stores</span></div>
<div class="line"><a id="l02922" name="l02922"></a><span class="lineno"> 2922</span><span class="comment">   * Sent_whens when really it stores order_nums; just bear with me by trusting that it makes the logic</span></div>
<div class="line"><a id="l02923" name="l02923"></a><span class="lineno"> 2923</span><span class="comment">   * easier to explain, and that the actual structure in code is sufficiently</span></div>
<div class="line"><a id="l02924" name="l02924"></a><span class="lineno"> 2924</span><span class="comment">   * similar to the wording here to not make a salient difference in practice.)</span></div>
<div class="line"><a id="l02925" name="l02925"></a><span class="lineno"> 2925</span><span class="comment">   *</span></div>
<div class="line"><a id="l02926" name="l02926"></a><span class="lineno"> 2926</span><span class="comment">   * Consider the two structures we have now.  snd_flying_pkts_by_when (call</span></div>
<div class="line"><a id="l02927" name="l02927"></a><span class="lineno"> 2927</span><span class="comment">   * it F) is a collection of Sent_packets, each with Sent_packet::m_acks_after_me, ordered by decreasing</span></div>
<div class="line"><a id="l02928" name="l02928"></a><span class="lineno"> 2928</span><span class="comment">   * Sent_when.  flying_now_acked_pkts (call it C) is an unordered collection that contains each Sent_when</span></div>
<div class="line"><a id="l02929" name="l02929"></a><span class="lineno"> 2929</span><span class="comment">   * (i.e., reference to a send-packet attempt) that has been ACKed.  That is, flying_now_acked_pkts tells us</span></div>
<div class="line"><a id="l02930" name="l02930"></a><span class="lineno"> 2930</span><span class="comment">   * by Sent_when which exact send attempts from the past are acknowledged in this set of accumulated acks.</span></div>
<div class="line"><a id="l02931" name="l02931"></a><span class="lineno"> 2931</span><span class="comment">   *</span></div>
<div class="line"><a id="l02932" name="l02932"></a><span class="lineno"> 2932</span><span class="comment">   * Even less formally -- just for sanity&#39;s sake -- F are In-flight packets; C are just-acked packets that were</span></div>
<div class="line"><a id="l02933" name="l02933"></a><span class="lineno"> 2933</span><span class="comment">   * very recently in F.  C may be interleaved among F if viewed in increasing Sent_when order:</span></div>
<div class="line"><a id="l02934" name="l02934"></a><span class="lineno"> 2934</span><span class="comment">   * e.g., [ F F F F C F C F C C ] (where F represents a still-In-flight send attempt, or an F element;</span></div>
<div class="line"><a id="l02935" name="l02935"></a><span class="lineno"> 2935</span><span class="comment">   * C a just-acked send attempt, thus a C element; and the order is from earlier/lower Sent_when to</span></div>
<div class="line"><a id="l02936" name="l02936"></a><span class="lineno"> 2936</span><span class="comment">   * later/higher Sent_when).</span></div>
<div class="line"><a id="l02937" name="l02937"></a><span class="lineno"> 2937</span><span class="comment">   *</span></div>
<div class="line"><a id="l02938" name="l02938"></a><span class="lineno"> 2938</span><span class="comment">   * Note that, conceptually, the key sets (Sent_when values) in F and C are disjoint,</span></div>
<div class="line"><a id="l02939" name="l02939"></a><span class="lineno"> 2939</span><span class="comment">   * since each send attempt has a unique Sent_when value (because it at least consists of a unique m_order_num).</span></div>
<div class="line"><a id="l02940" name="l02940"></a><span class="lineno"> 2940</span><span class="comment">   * How do we correctly yet efficiently increment m_acks_after_me (call it A) for each</span></div>
<div class="line"><a id="l02941" name="l02941"></a><span class="lineno"> 2941</span><span class="comment">   * element in F to represent the new ackage?  First observe that if F[t].A is incremented by N, then</span></div>
<div class="line"><a id="l02942" name="l02942"></a><span class="lineno"> 2942</span><span class="comment">   * F[prev(t)].A should be incremented by N PLUS the number of acks for all packets sent at times in range</span></div>
<div class="line"><a id="l02943" name="l02943"></a><span class="lineno"> 2943</span><span class="comment">   * (prev(t), t), where prev(t) is the element of C with the next lower (ealier) Sent_when.</span></div>
<div class="line"><a id="l02944" name="l02944"></a><span class="lineno"> 2944</span><span class="comment">   * Consider the example scoreboard above, [ F F F F C F# C F* C C ].  F*.A is incremented by 2, because</span></div>
<div class="line"><a id="l02945" name="l02945"></a><span class="lineno"> 2945</span><span class="comment">   * plainly there are two Cs after it.  Therefore, the preceding F, which is F#,</span></div>
<div class="line"><a id="l02946" name="l02946"></a><span class="lineno"> 2946</span><span class="comment">   * is also incremented by 2; plus another 1, because there is another C (recall, simply another acknowledgment)</span></div>
<div class="line"><a id="l02947" name="l02947"></a><span class="lineno"> 2947</span><span class="comment">   * between F# and F*.  And so it goes for all the Fs.  Side/sanity note: The range is (prev[t], t), not</span></div>
<div class="line"><a id="l02948" name="l02948"></a><span class="lineno"> 2948</span><span class="comment">   * [prev(t), t), simply because F and C are disjoint; and prev(t) by definition is in F (hence not in C, hence</span></div>
<div class="line"><a id="l02949" name="l02949"></a><span class="lineno"> 2949</span><span class="comment">   * no ack for that seq. #).</span></div>
<div class="line"><a id="l02950" name="l02950"></a><span class="lineno"> 2950</span><span class="comment">   *</span></div>
<div class="line"><a id="l02951" name="l02951"></a><span class="lineno"> 2951</span><span class="comment">   * This suggests a simple inductive algorithm, wherein the latest F element&#39;s F[t].A is incremented by I, which</span></div>
<div class="line"><a id="l02952" name="l02952"></a><span class="lineno"> 2952</span><span class="comment">   * is the count of C elements with Sent_when &gt; t; memorize I; now for each progressively older F[t],</span></div>
<div class="line"><a id="l02953" name="l02953"></a><span class="lineno"> 2953</span><span class="comment">   * count C elements in (t, next(t)) and increment F[T].A by I += &lt;that count&gt;.  Repeat until all Fs incremented.</span></div>
<div class="line"><a id="l02954" name="l02954"></a><span class="lineno"> 2954</span><span class="comment">   * Ultimately I = # of new valid, acknowledgments.  (Recall: scoreboard cannot begin with any Cs, [C C ... ], as</span></div>
<div class="line"><a id="l02955" name="l02955"></a><span class="lineno"> 2955</span><span class="comment">   * such a C would be acking a non-In-flight send attempt, so a dupe, and we specifically eliminate dupes from</span></div>
<div class="line"><a id="l02956" name="l02956"></a><span class="lineno"> 2956</span><span class="comment">   * consideration before inserting into C.)  So that&#39;s O(F.size()) increment operations.</span></div>
<div class="line"><a id="l02957" name="l02957"></a><span class="lineno"> 2957</span><span class="comment">   *</span></div>
<div class="line"><a id="l02958" name="l02958"></a><span class="lineno"> 2958</span><span class="comment">   * OK, but how do we get this &quot;count of acks between t and next(t)&quot;?  Let t be the last element of</span></div>
<div class="line"><a id="l02959" name="l02959"></a><span class="lineno"> 2959</span><span class="comment">   * F.  For it, that count is the count of all keys &gt; t in C (i.e., the total # of acks for all</span></div>
<div class="line"><a id="l02960" name="l02960"></a><span class="lineno"> 2960</span><span class="comment">   * packets sent after t).  Let the lowest such key (Sent_when value) be `s`. Now let t&#39; = prev(t) as before.</span></div>
<div class="line"><a id="l02961" name="l02961"></a><span class="lineno"> 2961</span><span class="comment">   * For t&#39;, the count of acks sent in (t&#39;, t) is the count of all elements in C with keys</span></div>
<div class="line"><a id="l02962" name="l02962"></a><span class="lineno"> 2962</span><span class="comment">   * in (s&#39;, s), where s&#39; is again the lowest key &gt; t&#39;. Having counted that, set s = s, and repeat for each key t&#39; of F.</span></div>
<div class="line"><a id="l02963" name="l02963"></a><span class="lineno"> 2963</span><span class="comment">   *</span></div>
<div class="line"><a id="l02964" name="l02964"></a><span class="lineno"> 2964</span><span class="comment">   * Of course, for that to be practical, C would need to be sorted by Sent_when.  Since in reality it&#39;s not sorted,</span></div>
<div class="line"><a id="l02965" name="l02965"></a><span class="lineno"> 2965</span><span class="comment">   * we could first sort it in O(k log k) operations, worst-case, k = C.size().  More convenient, however, is to</span></div>
<div class="line"><a id="l02966" name="l02966"></a><span class="lineno"> 2966</span><span class="comment">   * construct a priority queue (heap) from C; then keep popping the Sent_whens down to and</span></div>
<div class="line"><a id="l02967" name="l02967"></a><span class="lineno"> 2967</span><span class="comment">   * including s at each step.  That&#39;s O(k) to make the heap and O(k log k) total time spent</span></div>
<div class="line"><a id="l02968" name="l02968"></a><span class="lineno"> 2968</span><span class="comment">   * popping it.</span></div>
<div class="line"><a id="l02969" name="l02969"></a><span class="lineno"> 2969</span><span class="comment">   *</span></div>
<div class="line"><a id="l02970" name="l02970"></a><span class="lineno"> 2970</span><span class="comment">   * The above explanation strikes me as somewhat cryptic, but hopefully the code will clarify it; I was just</span></div>
<div class="line"><a id="l02971" name="l02971"></a><span class="lineno"> 2971</span><span class="comment">   * trying to explain why the code works. */</span></div>
<div class="line"><a id="l02972" name="l02972"></a><span class="lineno"> 2972</span> </div>
<div class="line"><a id="l02973" name="l02973"></a><span class="lineno"> 2973</span>  <span class="comment">/* Make heap out of flying_now_acked_pkts; top()/pop() will return the element with the highest (latest) Sent_when.</span></div>
<div class="line"><a id="l02974" name="l02974"></a><span class="lineno"> 2974</span><span class="comment">   * Just store the Sent_when values directly in the heap; std::pair::operator&lt;() will do</span></div>
<div class="line"><a id="l02975" name="l02975"></a><span class="lineno"> 2975</span><span class="comment">   * the right thing since no element&#39;s Sent_when equals another element&#39;s Sent_when (they were</span></div>
<div class="line"><a id="l02976" name="l02976"></a><span class="lineno"> 2976</span><span class="comment">   * stored in a uniquely-keyed dictionary in the first place).</span></div>
<div class="line"><a id="l02977" name="l02977"></a><span class="lineno"> 2977</span><span class="comment">   *</span></div>
<div class="line"><a id="l02978" name="l02978"></a><span class="lineno"> 2978</span><span class="comment">   * Let cur_sent_pkt be the element of snd_flying_pkts_by_sent_when we&#39;re currently</span></div>
<div class="line"><a id="l02979" name="l02979"></a><span class="lineno"> 2979</span><span class="comment">   * considering, and it starts at F.newest() and progresses accordingly through F.</span></div>
<div class="line"><a id="l02980" name="l02980"></a><span class="lineno"> 2980</span><span class="comment">   * Then, invariant: high_ack_count_q contains the acks for all send attempts P where</span></div>
<div class="line"><a id="l02981" name="l02981"></a><span class="lineno"> 2981</span><span class="comment">   * P.m_sent_when &lt; cur_sent_pkt.m_sent_when. In particular, P.m_sent_when.top &lt; cur_sent_pkt.m_sent_when. */</span></div>
<div class="line"><a id="l02982" name="l02982"></a><span class="lineno"> 2982</span>  priority_queue&lt;Peer_socket::order_num_t&gt;</div>
<div class="line"><a id="l02983" name="l02983"></a><span class="lineno"> 2983</span>    high_ack_count_q(flying_now_acked_pkts.begin(), flying_now_acked_pkts.end());</div>
<div class="line"><a id="l02984" name="l02984"></a><span class="lineno"> 2984</span> </div>
<div class="line"><a id="l02985" name="l02985"></a><span class="lineno"> 2985</span>  <span class="comment">// Invariant: this will be the m_acks_after_me increment applied to the just-considered packet in snd_flying_pkts*.</span></div>
<div class="line"><a id="l02986" name="l02986"></a><span class="lineno"> 2986</span>  <span class="keyword">using </span>ack_count_t = <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">Peer_socket::Sent_packet::ack_count_t</a>;</div>
<div class="line"><a id="l02987" name="l02987"></a><span class="lineno"> 2987</span>  ack_count_t ack_increment_after_me = 0;</div>
<div class="line"><a id="l02988" name="l02988"></a><span class="lineno"> 2988</span> </div>
<div class="line"><a id="l02989" name="l02989"></a><span class="lineno"> 2989</span>  <span class="comment">// As explained above, start with the first (latest send time) unacked packet and go forward (earlier and earlier).</span></div>
<div class="line"><a id="l02990" name="l02990"></a><span class="lineno"> 2990</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> last_dropped_pkt_it;</div>
<div class="line"><a id="l02991" name="l02991"></a><span class="lineno"> 2991</span>  <span class="keywordflow">for</span> (last_dropped_pkt_it = snd_flying_pkts_by_when.newest();</div>
<div class="line"><a id="l02992" name="l02992"></a><span class="lineno"> 2992</span>       last_dropped_pkt_it != snd_flying_pkts_by_when.past_oldest();</div>
<div class="line"><a id="l02993" name="l02993"></a><span class="lineno"> 2993</span>       ++last_dropped_pkt_it) <span class="comment">// Up to k repetitions.</span></div>
<div class="line"><a id="l02994" name="l02994"></a><span class="lineno"> 2994</span>  {</div>
<div class="line"><a id="l02995" name="l02995"></a><span class="lineno"> 2995</span>    <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Peer_socket::Sent_packet</a>&amp; cur_sent_pkt = *(last_dropped_pkt_it-&gt;second);</div>
<div class="line"><a id="l02996" name="l02996"></a><span class="lineno"> 2996</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a>&amp; cur_pkt_sent_when = cur_sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e">m_sent_when</a>.back();</div>
<div class="line"><a id="l02997" name="l02997"></a><span class="lineno"> 2997</span> </div>
<div class="line"><a id="l02998" name="l02998"></a><span class="lineno"> 2998</span>    <span class="comment">/* We will increment cur_sent_pkt.m_acks_after_me by ack_increment_after_me + X, where X is</span></div>
<div class="line"><a id="l02999" name="l02999"></a><span class="lineno"> 2999</span><span class="comment">     * the total number of acks for packets with send times between cur_pkt_sent_when and the</span></div>
<div class="line"><a id="l03000" name="l03000"></a><span class="lineno"> 3000</span><span class="comment">     * cur_pkt_sent_when in the last loop iteration (or infinity if this is the first loop</span></div>
<div class="line"><a id="l03001" name="l03001"></a><span class="lineno"> 3001</span><span class="comment">     * iteration).  The high_ack_count_q invariant we maintain is that high_ack_count_q holds the</span></div>
<div class="line"><a id="l03002" name="l03002"></a><span class="lineno"> 3002</span><span class="comment">     * ack counts for all packets with Sent_when values EXCEPT those &gt;= the previous</span></div>
<div class="line"><a id="l03003" name="l03003"></a><span class="lineno"> 3003</span><span class="comment">     * iteration&#39;s cur_pkt_sent_when.  Therefore, we need only find all elements of high_ack_count_q</span></div>
<div class="line"><a id="l03004" name="l03004"></a><span class="lineno"> 3004</span><span class="comment">     * whose Sent_whens are &gt; our cur_pkt_sent_when.  Since high_ack_count_q.top() is always the ack</span></div>
<div class="line"><a id="l03005" name="l03005"></a><span class="lineno"> 3005</span><span class="comment">     * count with the highest sent_when in that structure (priority queue), we just pop and sum</span></div>
<div class="line"><a id="l03006" name="l03006"></a><span class="lineno"> 3006</span><span class="comment">     * until high_ack_count_q.top() &lt; cur_pkt_sent_when. */</span></div>
<div class="line"><a id="l03007" name="l03007"></a><span class="lineno"> 3007</span> </div>
<div class="line"><a id="l03008" name="l03008"></a><span class="lineno"> 3008</span>    <span class="comment">// We&#39;ve just assigned cur_sent_pkt, breaking invariant; pop until it holds again.</span></div>
<div class="line"><a id="l03009" name="l03009"></a><span class="lineno"> 3009</span>    <span class="keywordflow">while</span> ((!high_ack_count_q.empty()) &amp;&amp;</div>
<div class="line"><a id="l03010" name="l03010"></a><span class="lineno"> 3010</span>           <span class="comment">// Compare order numbers -- they are always unique.</span></div>
<div class="line"><a id="l03011" name="l03011"></a><span class="lineno"> 3011</span>           (high_ack_count_q.top() &gt; cur_pkt_sent_when.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">m_order_num</a>))</div>
<div class="line"><a id="l03012" name="l03012"></a><span class="lineno"> 3012</span>    {</div>
<div class="line"><a id="l03013" name="l03013"></a><span class="lineno"> 3013</span>      <span class="comment">// Found acked packet with sent_when &gt; cur_pkt_sent_when (but &lt; previous iteration&#39;s cur_pkt_sent_when).</span></div>
<div class="line"><a id="l03014" name="l03014"></a><span class="lineno"> 3014</span>      ++ack_increment_after_me; <span class="comment">// So add that packet&#39;s ack.</span></div>
<div class="line"><a id="l03015" name="l03015"></a><span class="lineno"> 3015</span> </div>
<div class="line"><a id="l03016" name="l03016"></a><span class="lineno"> 3016</span>      <span class="comment">// And remove it, bringing the next highest entry to the top.  O(log k).</span></div>
<div class="line"><a id="l03017" name="l03017"></a><span class="lineno"> 3017</span>      high_ack_count_q.pop(); <span class="comment">// Note this maintains the invariant that defines high_ack_count_q.</span></div>
<div class="line"><a id="l03018" name="l03018"></a><span class="lineno"> 3018</span>    }</div>
<div class="line"><a id="l03019" name="l03019"></a><span class="lineno"> 3019</span>    <span class="comment">// Note we&#39;ve maintained the invariant defining ack_increment_after_me.</span></div>
<div class="line"><a id="l03020" name="l03020"></a><span class="lineno"> 3020</span> </div>
<div class="line"><a id="l03021" name="l03021"></a><span class="lineno"> 3021</span>    <span class="comment">// Hence this many more acks for packets after us have occurred within this ack set.</span></div>
<div class="line"><a id="l03022" name="l03022"></a><span class="lineno"> 3022</span>    cur_sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa">m_acks_after_me</a> += ack_increment_after_me;</div>
<div class="line"><a id="l03023" name="l03023"></a><span class="lineno"> 3023</span> </div>
<div class="line"><a id="l03024" name="l03024"></a><span class="lineno"> 3024</span>    <span class="keywordflow">if</span> (cur_sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa">m_acks_after_me</a> &gt; S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED)</div>
<div class="line"><a id="l03025" name="l03025"></a><span class="lineno"> 3025</span>    {</div>
<div class="line"><a id="l03026" name="l03026"></a><span class="lineno"> 3026</span>      <span class="comment">/* Ah ha!  For this packet we&#39;ve exceeded the limit -- we will consider it Dropped.  What</span></div>
<div class="line"><a id="l03027" name="l03027"></a><span class="lineno"> 3027</span><span class="comment">       * about the next (meaning, earlier-sent) unacknowledged packets?  Observe that packets with</span></div>
<div class="line"><a id="l03028" name="l03028"></a><span class="lineno"> 3028</span><span class="comment">       * earlier send times MUST (if we were to continue the loop in this manner) end up with</span></div>
<div class="line"><a id="l03029" name="l03029"></a><span class="lineno"> 3029</span><span class="comment">       * equal or larger cur_sent_pkt.m_acks_after_me.  (Intuitively: any acknowledgment after</span></div>
<div class="line"><a id="l03030" name="l03030"></a><span class="lineno"> 3030</span><span class="comment">       * packet P is also after any packet preceding P in the sent_when ordering.)  Therefore, we</span></div>
<div class="line"><a id="l03031" name="l03031"></a><span class="lineno"> 3031</span><span class="comment">       * can break out of the loop and consider Dropped ALL packets from last_dropped_pkt_it to</span></div>
<div class="line"><a id="l03032" name="l03032"></a><span class="lineno"> 3032</span><span class="comment">       * snd_flying_pkts_by_when.past_oldest().  Yay! */</span></div>
<div class="line"><a id="l03033" name="l03033"></a><span class="lineno"> 3033</span> </div>
<div class="line"><a id="l03034" name="l03034"></a><span class="lineno"> 3034</span>      <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l03035" name="l03035"></a><span class="lineno"> 3035</span>      <span class="keywordflow">if</span> (logger_ptr &amp;&amp; logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))</div>
<div class="line"><a id="l03036" name="l03036"></a><span class="lineno"> 3036</span>      {</div>
<div class="line"><a id="l03037" name="l03037"></a><span class="lineno"> 3037</span>        <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> cur_pkt_seq_num, cur_pkt_seq_num_end;</div>
<div class="line"><a id="l03038" name="l03038"></a><span class="lineno"> 3038</span>        get_seq_num_range(last_dropped_pkt_it, &amp;cur_pkt_seq_num, &amp;cur_pkt_seq_num_end);</div>
<div class="line"><a id="l03039" name="l03039"></a><span class="lineno"> 3039</span> </div>
<div class="line"><a id="l03040" name="l03040"></a><span class="lineno"> 3040</span>        <a class="code hl_define" href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03041" name="l03041"></a><span class="lineno"> 3041</span>          (<span class="stringliteral">&quot;Unacknowledged packet [&quot;</span> &lt;&lt; cur_pkt_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; cur_pkt_seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03042" name="l03042"></a><span class="lineno"> 3042</span>           <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; cur_pkt_sent_when.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">m_order_num</a> &lt;&lt; <span class="stringliteral">&quot;] has &quot;</span></div>
<div class="line"><a id="l03043" name="l03043"></a><span class="lineno"> 3043</span>           <span class="stringliteral">&quot;had [&quot;</span> &lt;&lt; cur_sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa">m_acks_after_me</a> &lt;&lt; <span class="stringliteral">&quot;] acknowledgments &quot;</span></div>
<div class="line"><a id="l03044" name="l03044"></a><span class="lineno"> 3044</span>           <span class="stringliteral">&quot;for later packets; considering it and &quot;</span></div>
<div class="line"><a id="l03045" name="l03045"></a><span class="lineno"> 3045</span>           <span class="stringliteral">&quot;all unacknowledged packets sent earlier as Dropped.&quot;</span>);</div>
<div class="line"><a id="l03046" name="l03046"></a><span class="lineno"> 3046</span>      }</div>
<div class="line"><a id="l03047" name="l03047"></a><span class="lineno"> 3047</span> </div>
<div class="line"><a id="l03048" name="l03048"></a><span class="lineno"> 3048</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l03049" name="l03049"></a><span class="lineno"> 3049</span>    }</div>
<div class="line"><a id="l03050" name="l03050"></a><span class="lineno"> 3050</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03051" name="l03051"></a><span class="lineno"> 3051</span> </div>
<div class="line"><a id="l03052" name="l03052"></a><span class="lineno"> 3052</span>    <span class="comment">// ack_increment_after_me and high_ack_count_q invariants hold, so the next iteration can proceed.</span></div>
<div class="line"><a id="l03053" name="l03053"></a><span class="lineno"> 3053</span>  } <span class="comment">// for (all elements in snd_flying_pkts_by_when, in decreasing m_sent_when order: newest -&gt; oldest)</span></div>
<div class="line"><a id="l03054" name="l03054"></a><span class="lineno"> 3054</span> </div>
<div class="line"><a id="l03055" name="l03055"></a><span class="lineno"> 3055</span>  <span class="keywordflow">return</span> last_dropped_pkt_it;</div>
<div class="line"><a id="l03056" name="l03056"></a><span class="lineno"> 3056</span>} <span class="comment">// Node::categorize_pkts_as_dropped_on_acks()</span></div>
<div class="line"><a id="l03057" name="l03057"></a><span class="lineno"> 3057</span> </div>
<div class="line"><a id="l03058" name="l03058"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a"> 3058</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">Node::drop_pkts_on_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03059" name="l03059"></a><span class="lineno"> 3059</span>                             <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; last_dropped_pkt_it,</div>
<div class="line"><a id="l03060" name="l03060"></a><span class="lineno"> 3060</span>                             <span class="keywordtype">size_t</span>* cong_ctl_dropped_pkts, <span class="keywordtype">size_t</span>* cong_ctl_dropped_bytes,</div>
<div class="line"><a id="l03061" name="l03061"></a><span class="lineno"> 3061</span>                             <span class="keywordtype">size_t</span>* dropped_pkts, <span class="keywordtype">size_t</span>* dropped_bytes,</div>
<div class="line"><a id="l03062" name="l03062"></a><span class="lineno"> 3062</span>                             std::vector&lt;Peer_socket::order_num_t&gt;* pkts_marked_to_drop)</div>
<div class="line"><a id="l03063" name="l03063"></a><span class="lineno"> 3063</span>{</div>
<div class="line"><a id="l03064" name="l03064"></a><span class="lineno"> 3064</span>  <span class="comment">// using boost::next; // Still ambiguous for some reason (in clang at least).</span></div>
<div class="line"><a id="l03065" name="l03065"></a><span class="lineno"> 3065</span> </div>
<div class="line"><a id="l03066" name="l03066"></a><span class="lineno"> 3066</span>  <span class="comment">/* This helper of handle_accumulated_acks() exists to make the latter method briefer/readable, not for code reuse</span></div>
<div class="line"><a id="l03067" name="l03067"></a><span class="lineno"> 3067</span><span class="comment">   * as of this writing. The background is that once a set of individual acks has been processed in the sense that</span></div>
<div class="line"><a id="l03068" name="l03068"></a><span class="lineno"> 3068</span><span class="comment">   * sock-&gt;m_snd_flying_pkts* (which tracks In-flight outbound DATA packets) has been updated by removing the</span></div>
<div class="line"><a id="l03069" name="l03069"></a><span class="lineno"> 3069</span><span class="comment">   * acked packets (they are no longer In-flight), it&#39;s time to also recategorize certain further In-flight</span></div>
<div class="line"><a id="l03070" name="l03070"></a><span class="lineno"> 3070</span><span class="comment">   * packets as Dropped -- the intuition being that once N packets sent LATER than a given packet P have been</span></div>
<div class="line"><a id="l03071" name="l03071"></a><span class="lineno"> 3071</span><span class="comment">   * acked, it&#39;s highly probable that P has been Dropped by the network. This method does that (dropping</span></div>
<div class="line"><a id="l03072" name="l03072"></a><span class="lineno"> 3072</span><span class="comment">   * all such packets P) and certain related tasks such as tracking the associated loss event(s) for congestion</span></div>
<div class="line"><a id="l03073" name="l03073"></a><span class="lineno"> 3073</span><span class="comment">   * control.</span></div>
<div class="line"><a id="l03074" name="l03074"></a><span class="lineno"> 3074</span><span class="comment">   *</span></div>
<div class="line"><a id="l03075" name="l03075"></a><span class="lineno"> 3075</span><span class="comment">   * Now, as explained elsewhere, when ack set S causes packet set P&#39; to be Dropped, this (possibly null) set P&#39;</span></div>
<div class="line"><a id="l03076" name="l03076"></a><span class="lineno"> 3076</span><span class="comment">   * always has the following form: there is some particular packet P which is the most-recently-sent one</span></div>
<div class="line"><a id="l03077" name="l03077"></a><span class="lineno"> 3077</span><span class="comment">   * that is in P&#39;; and therefore ALL other In-flight packets sent before P must be dropped too and also are in P&#39;.</span></div>
<div class="line"><a id="l03078" name="l03078"></a><span class="lineno"> 3078</span><span class="comment">   * Thus P is necessary/sufficient to specify P&#39;.  last_droppped_pkt_it argument points to P&#39; and is determined</span></div>
<div class="line"><a id="l03079" name="l03079"></a><span class="lineno"> 3079</span><span class="comment">   * elsewhere and used by this helper. */</span></div>
<div class="line"><a id="l03080" name="l03080"></a><span class="lineno"> 3080</span> </div>
<div class="line"><a id="l03081" name="l03081"></a><span class="lineno"> 3081</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l03082" name="l03082"></a><span class="lineno"> 3082</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l03083" name="l03083"></a><span class="lineno"> 3083</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l03084" name="l03084"></a><span class="lineno"> 3084</span>  <span class="keyword">auto</span>&amp; snd_stats = sock-&gt;m_snd_stats;</div>
<div class="line"><a id="l03085" name="l03085"></a><span class="lineno"> 3085</span> </div>
<div class="line"><a id="l03086" name="l03086"></a><span class="lineno"> 3086</span>  <span class="comment">/* Pre-condition: all elements starting with (inclusive) last_dropped_pkt_it (within</span></div>
<div class="line"><a id="l03087" name="l03087"></a><span class="lineno"> 3087</span><span class="comment">   * snd_flying_pkts_by_when) should be considered Dropped.  If last_dropped_pkt_it ==</span></div>
<div class="line"><a id="l03088" name="l03088"></a><span class="lineno"> 3088</span><span class="comment">   * snd_flying_pkts_by_when.past_oldest() a/k/a end(), then none should be considered</span></div>
<div class="line"><a id="l03089" name="l03089"></a><span class="lineno"> 3089</span><span class="comment">   * Dropped (i.e., no m_acks_after_me became high enough).</span></div>
<div class="line"><a id="l03090" name="l03090"></a><span class="lineno"> 3090</span><span class="comment">   *</span></div>
<div class="line"><a id="l03091" name="l03091"></a><span class="lineno"> 3091</span><span class="comment">   * Given that, we have a number of tasks remaining:</span></div>
<div class="line"><a id="l03092" name="l03092"></a><span class="lineno"> 3092</span><span class="comment">   *</span></div>
<div class="line"><a id="l03093" name="l03093"></a><span class="lineno"> 3093</span><span class="comment">   *   1. Count the total # of packets and bytes now considered Dropped and pass this to congestion control.</span></div>
<div class="line"><a id="l03094" name="l03094"></a><span class="lineno"> 3094</span><span class="comment">   *      Omit those packets/bytes heuristically determined to belong to a loss event detected in an earlier</span></div>
<div class="line"><a id="l03095" name="l03095"></a><span class="lineno"> 3095</span><span class="comment">   *      call, namely those for which m_sent_when &lt; m_snd_last_loss_event_when.</span></div>
<div class="line"><a id="l03096" name="l03096"></a><span class="lineno"> 3096</span><span class="comment">   *   2. (If retransmission is enabled) Queue those Dropped packets for retransmission in retransmission queue.</span></div>
<div class="line"><a id="l03097" name="l03097"></a><span class="lineno"> 3097</span><span class="comment">   *   3. Erase the Dropped packets from snd_flying_packets*.</span></div>
<div class="line"><a id="l03098" name="l03098"></a><span class="lineno"> 3098</span><span class="comment">   *</span></div>
<div class="line"><a id="l03099" name="l03099"></a><span class="lineno"> 3099</span><span class="comment">   * For (non-asymptotic) performance, ideally we want to traverse snd_flying_pkts_by_when just once,</span></div>
<div class="line"><a id="l03100" name="l03100"></a><span class="lineno"> 3100</span><span class="comment">   * computing what&#39;s needed for these. Drilling down a bit:</span></div>
<div class="line"><a id="l03101" name="l03101"></a><span class="lineno"> 3101</span><span class="comment">   *</span></div>
<div class="line"><a id="l03102" name="l03102"></a><span class="lineno"> 3102</span><span class="comment">   * (2) and (3) are simple and involve walking over the Dropped range that has been computed (pre-condition above)</span></div>
<div class="line"><a id="l03103" name="l03103"></a><span class="lineno"> 3103</span><span class="comment">   * and adding-elsewhere or erasing those elements, respectively, though (2) must be done in chronological order</span></div>
<div class="line"><a id="l03104" name="l03104"></a><span class="lineno"> 3104</span><span class="comment">   * (increasing Sent_when).</span></div>
<div class="line"><a id="l03105" name="l03105"></a><span class="lineno"> 3105</span><span class="comment">   *</span></div>
<div class="line"><a id="l03106" name="l03106"></a><span class="lineno"> 3106</span><span class="comment">   * (1) is a matter of walking in anti-chronological (decreasing Sent_when) order over that same range, until</span></div>
<div class="line"><a id="l03107" name="l03107"></a><span class="lineno"> 3107</span><span class="comment">   * a certain Sent_when threshold is found, and stopping there.</span></div>
<div class="line"><a id="l03108" name="l03108"></a><span class="lineno"> 3108</span><span class="comment">   *</span></div>
<div class="line"><a id="l03109" name="l03109"></a><span class="lineno"> 3109</span><span class="comment">   * Thus, the kitchen-sink algorithm emerges: walk through Dropped range in decreasing Sent_when order, so</span></div>
<div class="line"><a id="l03110" name="l03110"></a><span class="lineno"> 3110</span><span class="comment">   * from last_dropped_pkt_it along snd_flying_pkts_by_when.  Accumulate bytes/packets for (1), but stop</span></div>
<div class="line"><a id="l03111" name="l03111"></a><span class="lineno"> 3111</span><span class="comment">   * accumulating once m_snd_last_loss_event_when is reached w/r/t m_sent_when.  Erase from snd_flying_pkts*</span></div>
<div class="line"><a id="l03112" name="l03112"></a><span class="lineno"> 3112</span><span class="comment">   * (carefully, since we are walking along one of them), for (3).  And add to the retransmission queue, but in</span></div>
<div class="line"><a id="l03113" name="l03113"></a><span class="lineno"> 3113</span><span class="comment">   * reverse order versus the walking order, for (2). */</span></div>
<div class="line"><a id="l03114" name="l03114"></a><span class="lineno"> 3114</span> </div>
<div class="line"><a id="l03115" name="l03115"></a><span class="lineno"> 3115</span>  *dropped_pkts = snd_flying_pkts_by_when.size(); <span class="comment">// We will just compute the final value by subtracting &quot;after.&quot;</span></div>
<div class="line"><a id="l03116" name="l03116"></a><span class="lineno"> 3116</span>  *dropped_bytes = sock-&gt;m_snd_flying_bytes; <span class="comment">// Ditto.</span></div>
<div class="line"><a id="l03117" name="l03117"></a><span class="lineno"> 3117</span> </div>
<div class="line"><a id="l03118" name="l03118"></a><span class="lineno"> 3118</span>  *cong_ctl_dropped_bytes = 0;</div>
<div class="line"><a id="l03119" name="l03119"></a><span class="lineno"> 3119</span>  *cong_ctl_dropped_pkts = 0;</div>
<div class="line"><a id="l03120" name="l03120"></a><span class="lineno"> 3120</span>  <span class="keywordtype">bool</span> loss_event_finished = <span class="keyword">false</span>;</div>
<div class="line"><a id="l03121" name="l03121"></a><span class="lineno"> 3121</span> </div>
<div class="line"><a id="l03122" name="l03122"></a><span class="lineno"> 3122</span>  <span class="comment">/* We want to add to retransmission queue (if retransmission is on).  We also want to traverse</span></div>
<div class="line"><a id="l03123" name="l03123"></a><span class="lineno"> 3123</span><span class="comment">   * snd_flying_pkts_by_when in forward newest-&gt;oldest order (for convenience and also to efficiently compute</span></div>
<div class="line"><a id="l03124" name="l03124"></a><span class="lineno"> 3124</span><span class="comment">   * cong_ctl_dropped_*).  However we want to retransmit in reverse order (oldest-&gt;newest).  So we</span></div>
<div class="line"><a id="l03125" name="l03125"></a><span class="lineno"> 3125</span><span class="comment">   * put the packets to retransmit in the latter order into snd_rexmit_q, at the end of the latter.</span></div>
<div class="line"><a id="l03126" name="l03126"></a><span class="lineno"> 3126</span><span class="comment">   * So, if it was [ABC], and we dropped [DEF], then we want to insert to yield [ABCFED] (ABC-&gt;ABCFED).</span></div>
<div class="line"><a id="l03127" name="l03127"></a><span class="lineno"> 3127</span><span class="comment">   * list&lt;&gt;::insert(it, v) will insert `v` before *it and return iterator to just-inserted element.</span></div>
<div class="line"><a id="l03128" name="l03128"></a><span class="lineno"> 3128</span><span class="comment">   * So we can memorize the latter and pass it in as `it` in the next insert(), rinse, repeat.</span></div>
<div class="line"><a id="l03129" name="l03129"></a><span class="lineno"> 3129</span><span class="comment">   * In the above example: ABC-&gt;ABC(D)-&gt;ABC(E)D-&gt;ABC(F)ED. // () is inserted element.</span></div>
<div class="line"><a id="l03130" name="l03130"></a><span class="lineno"> 3130</span><span class="comment">   *                          ^     ^       ^        // ^ is &quot;fulcrum&quot;: insertion point for insertion following next -&gt;.</span></div>
<div class="line"><a id="l03131" name="l03131"></a><span class="lineno"> 3131</span><span class="comment">   *</span></div>
<div class="line"><a id="l03132" name="l03132"></a><span class="lineno"> 3132</span><span class="comment">   * snd_rexmit_q_fulcrum_it, the insertion point, is so named due to being the &quot;fulcrum&quot; between the old and</span></div>
<div class="line"><a id="l03133" name="l03133"></a><span class="lineno"> 3133</span><span class="comment">   * new parts of snd_rexmit_q.  History: Used to use a local new list&lt;&gt; here which would be spliced onto</span></div>
<div class="line"><a id="l03134" name="l03134"></a><span class="lineno"> 3134</span><span class="comment">   * the real queue at the end; but IMO this is more elegant (and probably a bit speedier). */</span></div>
<div class="line"><a id="l03135" name="l03135"></a><span class="lineno"> 3135</span>  <span class="keyword">auto</span>&amp; snd_rexmit_q = sock-&gt;m_snd_rexmit_q;</div>
<div class="line"><a id="l03136" name="l03136"></a><span class="lineno"> 3136</span>  <span class="keyword">decltype</span>(sock-&gt;m_snd_rexmit_q)::iterator snd_rexmit_q_fulcrum_it = snd_rexmit_q.end();</div>
<div class="line"><a id="l03137" name="l03137"></a><span class="lineno"> 3137</span> </div>
<div class="line"><a id="l03138" name="l03138"></a><span class="lineno"> 3138</span>  <span class="comment">// We are to fill this up, so it should not have anything yet.</span></div>
<div class="line"><a id="l03139" name="l03139"></a><span class="lineno"> 3139</span>  assert(pkts_marked_to_drop-&gt;empty());</div>
<div class="line"><a id="l03140" name="l03140"></a><span class="lineno"> 3140</span> </div>
<div class="line"><a id="l03141" name="l03141"></a><span class="lineno"> 3141</span>  <span class="keyword">auto</span> pkt_it = last_dropped_pkt_it;</div>
<div class="line"><a id="l03142" name="l03142"></a><span class="lineno"> 3142</span>  <span class="keywordflow">while</span> (pkt_it != snd_flying_pkts_by_when.past_oldest())</div>
<div class="line"><a id="l03143" name="l03143"></a><span class="lineno"> 3143</span>  {</div>
<div class="line"><a id="l03144" name="l03144"></a><span class="lineno"> 3144</span>    <span class="comment">// We can&#39;t just ++pkt_it later on, because we are going to erase() at pkt_it soon, invalidating it.</span></div>
<div class="line"><a id="l03145" name="l03145"></a><span class="lineno"> 3145</span>    <span class="keyword">auto</span> next_pkt_it = boost::next(pkt_it);</div>
<div class="line"><a id="l03146" name="l03146"></a><span class="lineno"> 3146</span>    <span class="comment">// Now see end of loop body.</span></div>
<div class="line"><a id="l03147" name="l03147"></a><span class="lineno"> 3147</span> </div>
<div class="line"><a id="l03148" name="l03148"></a><span class="lineno"> 3148</span>    <span class="comment">// Accumulate stuff for passing into congestion control at the end.</span></div>
<div class="line"><a id="l03149" name="l03149"></a><span class="lineno"> 3149</span> </div>
<div class="line"><a id="l03150" name="l03150"></a><span class="lineno"> 3150</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> sent_pkt = pkt_it-&gt;second;</div>
<div class="line"><a id="l03151" name="l03151"></a><span class="lineno"> 3151</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a>&amp; sent_when = sent_pkt-&gt;m_sent_when.back();</div>
<div class="line"><a id="l03152" name="l03152"></a><span class="lineno"> 3152</span> </div>
<div class="line"><a id="l03153" name="l03153"></a><span class="lineno"> 3153</span>    <span class="keywordflow">if</span> (!loss_event_finished)</div>
<div class="line"><a id="l03154" name="l03154"></a><span class="lineno"> 3154</span>    {</div>
<div class="line"><a id="l03155" name="l03155"></a><span class="lineno"> 3155</span>      <span class="keywordflow">if</span> (<span class="comment">// This is part of a new loss event if: There has been no loss event before this...</span></div>
<div class="line"><a id="l03156" name="l03156"></a><span class="lineno"> 3156</span>          (sock-&gt;m_snd_last_loss_event_when != <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>())</div>
<div class="line"><a id="l03157" name="l03157"></a><span class="lineno"> 3157</span>          <span class="comment">// ...OR there has, but this packet was sent after that event was detected.</span></div>
<div class="line"><a id="l03158" name="l03158"></a><span class="lineno"> 3158</span>          &amp;&amp; (sent_when.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#ad513e58f4eb611c3a91d96df26f53f2c">m_sent_time</a> &lt; sock-&gt;m_snd_last_loss_event_when))</div>
<div class="line"><a id="l03159" name="l03159"></a><span class="lineno"> 3159</span>      {</div>
<div class="line"><a id="l03160" name="l03160"></a><span class="lineno"> 3160</span>        <span class="comment">/* This is the first packet encountered to be part of a previous loss event.  If</span></div>
<div class="line"><a id="l03161" name="l03161"></a><span class="lineno"> 3161</span><span class="comment">         * retransmission is off, this will also cause the loop to exit. */</span></div>
<div class="line"><a id="l03162" name="l03162"></a><span class="lineno"> 3162</span>        loss_event_finished = <span class="keyword">true</span>;</div>
<div class="line"><a id="l03163" name="l03163"></a><span class="lineno"> 3163</span>      }</div>
<div class="line"><a id="l03164" name="l03164"></a><span class="lineno"> 3164</span>      <span class="keywordflow">else</span></div>
<div class="line"><a id="l03165" name="l03165"></a><span class="lineno"> 3165</span>      {</div>
<div class="line"><a id="l03166" name="l03166"></a><span class="lineno"> 3166</span>        <span class="comment">// Only got here if this packet and all Dropped packets after it are part of a new loss event.</span></div>
<div class="line"><a id="l03167" name="l03167"></a><span class="lineno"> 3167</span>        *cong_ctl_dropped_bytes += sent_pkt-&gt;m_size;</div>
<div class="line"><a id="l03168" name="l03168"></a><span class="lineno"> 3168</span>        ++(*cong_ctl_dropped_pkts);</div>
<div class="line"><a id="l03169" name="l03169"></a><span class="lineno"> 3169</span>      }</div>
<div class="line"><a id="l03170" name="l03170"></a><span class="lineno"> 3170</span>    }</div>
<div class="line"><a id="l03171" name="l03171"></a><span class="lineno"> 3171</span>    <span class="comment">// else { Already found end of new loss event, if any, so no need to keep looking for it. }</span></div>
<div class="line"><a id="l03172" name="l03172"></a><span class="lineno"> 3172</span> </div>
<div class="line"><a id="l03173" name="l03173"></a><span class="lineno"> 3173</span>    <span class="comment">// Add to retransmission queue if applicable.</span></div>
<div class="line"><a id="l03174" name="l03174"></a><span class="lineno"> 3174</span> </div>
<div class="line"><a id="l03175" name="l03175"></a><span class="lineno"> 3175</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l03176" name="l03176"></a><span class="lineno"> 3176</span>    {</div>
<div class="line"><a id="l03177" name="l03177"></a><span class="lineno"> 3177</span>      <span class="keywordflow">if</span> (!ok_to_rexmit_or_close(sock, pkt_it, <span class="keyword">true</span>)) <span class="comment">// Ensure not too many retransmissions already.</span></div>
<div class="line"><a id="l03178" name="l03178"></a><span class="lineno"> 3178</span>      <span class="comment">/* ^-- defer_delta_check == true: because the only way to get to this method is from</span></div>
<div class="line"><a id="l03179" name="l03179"></a><span class="lineno"> 3179</span><span class="comment">       * async_low_lvl_recv(), which will perform event_set_all_check_delta(false) at the end of itself,</span></div>
<div class="line"><a id="l03180" name="l03180"></a><span class="lineno"> 3180</span><span class="comment">       * before the boost.asio handler exits.  See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l03181" name="l03181"></a><span class="lineno"> 3181</span>      {</div>
<div class="line"><a id="l03182" name="l03182"></a><span class="lineno"> 3182</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Already closed/logged/etc.</span></div>
<div class="line"><a id="l03183" name="l03183"></a><span class="lineno"> 3183</span>      }</div>
<div class="line"><a id="l03184" name="l03184"></a><span class="lineno"> 3184</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l03185" name="l03185"></a><span class="lineno"> 3185</span> </div>
<div class="line"><a id="l03186" name="l03186"></a><span class="lineno"> 3186</span>      <span class="comment">/* Save a ref-counted pointer (to what includes packet data) in retransmission queue.  We&#39;ll soon remove such</span></div>
<div class="line"><a id="l03187" name="l03187"></a><span class="lineno"> 3187</span><span class="comment">       * a pointer from snd_flying_pkts*, lowering the ref-count again.  In other words, we are moving the sent-packet</span></div>
<div class="line"><a id="l03188" name="l03188"></a><span class="lineno"> 3188</span><span class="comment">       * object from snd_flying_pkts* to snd_rexmit_q (Dropped -&gt; In-flight).</span></div>
<div class="line"><a id="l03189" name="l03189"></a><span class="lineno"> 3189</span><span class="comment">       *</span></div>
<div class="line"><a id="l03190" name="l03190"></a><span class="lineno"> 3190</span><span class="comment">       * Insert at the same position each time to ultimately arrange them in the reversed order that we want. */</span></div>
<div class="line"><a id="l03191" name="l03191"></a><span class="lineno"> 3191</span>      snd_rexmit_q_fulcrum_it = snd_rexmit_q.insert(snd_rexmit_q_fulcrum_it, sent_pkt);</div>
<div class="line"><a id="l03192" name="l03192"></a><span class="lineno"> 3192</span>      ++sock-&gt;m_snd_rexmit_q_size;</div>
<div class="line"><a id="l03193" name="l03193"></a><span class="lineno"> 3193</span>    }</div>
<div class="line"><a id="l03194" name="l03194"></a><span class="lineno"> 3194</span> </div>
<div class="line"><a id="l03195" name="l03195"></a><span class="lineno"> 3195</span>    <span class="comment">/* Finally, we can erase it from snd_flying_pkts* and adjust snd_flying_bytes.</span></div>
<div class="line"><a id="l03196" name="l03196"></a><span class="lineno"> 3196</span><span class="comment">     * Will NOT invalidate other iterators into snd_flying_pkts_by_when.</span></div>
<div class="line"><a id="l03197" name="l03197"></a><span class="lineno"> 3197</span><span class="comment">     *</span></div>
<div class="line"><a id="l03198" name="l03198"></a><span class="lineno"> 3198</span><span class="comment">     * Also, save in pkts-&gt;pkts_marked_to_drop as advertised. */</span></div>
<div class="line"><a id="l03199" name="l03199"></a><span class="lineno"> 3199</span> </div>
<div class="line"><a id="l03200" name="l03200"></a><span class="lineno"> 3200</span>    <span class="keyword">static_assert</span></div>
<div class="line"><a id="l03201" name="l03201"></a><span class="lineno"> 3201</span>      (!<a class="code hl_class" href="classflow_1_1util_1_1Container__traits.html">util::Container_traits&lt;Peer_socket::Sent_pkt_by_sent_when_map&gt;::S_CHANGE_INVALIDATES_ITERATORS</a>,</div>
<div class="line"><a id="l03202" name="l03202"></a><span class="lineno"> 3202</span>       <span class="stringliteral">&quot;Scoreboard must not get otherwise changed when a packet is erased.&quot;</span>);</div>
<div class="line"><a id="l03203" name="l03203"></a><span class="lineno"> 3203</span>    pkts_marked_to_drop-&gt;push_back(sent_when.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">m_order_num</a>);</div>
<div class="line"><a id="l03204" name="l03204"></a><span class="lineno"> 3204</span>    snd_flying_pkts_erase_one(sock, pkt_it);</div>
<div class="line"><a id="l03205" name="l03205"></a><span class="lineno"> 3205</span> </div>
<div class="line"><a id="l03206" name="l03206"></a><span class="lineno"> 3206</span>    pkt_it = next_pkt_it;</div>
<div class="line"><a id="l03207" name="l03207"></a><span class="lineno"> 3207</span>  } <span class="comment">// while (pkt_it != snd_flying_pkts_by_when.past_oldest())</span></div>
<div class="line"><a id="l03208" name="l03208"></a><span class="lineno"> 3208</span> </div>
<div class="line"><a id="l03209" name="l03209"></a><span class="lineno"> 3209</span>  <span class="comment">// Includes ALL Dropped packets (not just ones from new loss event, if any), so != cong_ctl_dropped_pkts.</span></div>
<div class="line"><a id="l03210" name="l03210"></a><span class="lineno"> 3210</span>  *dropped_pkts -= snd_flying_pkts_by_when.size(); <span class="comment">// Subtract &quot;after&quot; from &quot;before&quot; to get dropped count.</span></div>
<div class="line"><a id="l03211" name="l03211"></a><span class="lineno"> 3211</span>  *dropped_bytes -= sock-&gt;m_snd_flying_bytes; <span class="comment">// Similar.</span></div>
<div class="line"><a id="l03212" name="l03212"></a><span class="lineno"> 3212</span> </div>
<div class="line"><a id="l03213" name="l03213"></a><span class="lineno"> 3213</span>  <span class="keywordflow">if</span> (*cong_ctl_dropped_pkts != 0)</div>
<div class="line"><a id="l03214" name="l03214"></a><span class="lineno"> 3214</span>  {</div>
<div class="line"><a id="l03215" name="l03215"></a><span class="lineno"> 3215</span>    <span class="comment">// Register that we&#39;ve detected a NEW loss event (not the same as dropped_data() -- see that elsewhere).</span></div>
<div class="line"><a id="l03216" name="l03216"></a><span class="lineno"> 3216</span>    snd_stats.loss_event();</div>
<div class="line"><a id="l03217" name="l03217"></a><span class="lineno"> 3217</span>  }</div>
<div class="line"><a id="l03218" name="l03218"></a><span class="lineno"> 3218</span> </div>
<div class="line"><a id="l03219" name="l03219"></a><span class="lineno"> 3219</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03220" name="l03220"></a><span class="lineno"> 3220</span>} <span class="comment">// Node::drop_pkts_on_acks()</span></div>
<div class="line"><a id="l03221" name="l03221"></a><span class="lineno"> 3221</span> </div>
<div class="line"><a id="l03222" name="l03222"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7"> 3222</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">Node::log_accumulated_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l03223" name="l03223"></a><span class="lineno"> 3223</span><span class="keyword"></span>{</div>
<div class="line"><a id="l03224" name="l03224"></a><span class="lineno"> 3224</span>  <span class="keyword">using </span>boost::algorithm::join;</div>
<div class="line"><a id="l03225" name="l03225"></a><span class="lineno"> 3225</span>  <span class="keyword">using </span>boost::chrono::symbol_format;</div>
<div class="line"><a id="l03226" name="l03226"></a><span class="lineno"> 3226</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l03227" name="l03227"></a><span class="lineno"> 3227</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l03228" name="l03228"></a><span class="lineno"> 3228</span>  <span class="keyword">using </span>std::transform;</div>
<div class="line"><a id="l03229" name="l03229"></a><span class="lineno"> 3229</span>  <span class="keyword">using </span>std::ostream;</div>
<div class="line"><a id="l03230" name="l03230"></a><span class="lineno"> 3230</span> </div>
<div class="line"><a id="l03231" name="l03231"></a><span class="lineno"> 3231</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l03232" name="l03232"></a><span class="lineno"> 3232</span> </div>
<div class="line"><a id="l03233" name="l03233"></a><span class="lineno"> 3233</span>  <span class="comment">// This helper of handle_accumulated_acks() just logs the individual acks about to be processed.</span></div>
<div class="line"><a id="l03234" name="l03234"></a><span class="lineno"> 3234</span> </div>
<div class="line"><a id="l03235" name="l03235"></a><span class="lineno"> 3235</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l03236" name="l03236"></a><span class="lineno"> 3236</span>  <span class="keyword">using </span>Ack = <a class="code hl_struct" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html">Ack_packet::Individual_ack</a>;</div>
<div class="line"><a id="l03237" name="l03237"></a><span class="lineno"> 3237</span>  <span class="keyword">using </span>Acks = vector&lt;Ack::Ptr&gt;;</div>
<div class="line"><a id="l03238" name="l03238"></a><span class="lineno"> 3238</span>  <span class="keyword">const</span> Acks&amp; acked_packets = sock-&gt;m_rcv_acked_packets;</div>
<div class="line"><a id="l03239" name="l03239"></a><span class="lineno"> 3239</span> </div>
<div class="line"><a id="l03240" name="l03240"></a><span class="lineno"> 3240</span>  <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l03241" name="l03241"></a><span class="lineno"> 3241</span>  <span class="keywordflow">if</span> (logger_ptr &amp;&amp; logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>())) <span class="comment">// Very verbose and slow!</span></div>
<div class="line"><a id="l03242" name="l03242"></a><span class="lineno"> 3242</span>  {</div>
<div class="line"><a id="l03243" name="l03243"></a><span class="lineno"> 3243</span>    <span class="comment">// Prepare serialization of m_rcv_acked_packets for TRACE logging; quite verbose and slow!</span></div>
<div class="line"><a id="l03244" name="l03244"></a><span class="lineno"> 3244</span>    vector&lt;string&gt; ack_strs(acked_packets.size());</div>
<div class="line"><a id="l03245" name="l03245"></a><span class="lineno"> 3245</span>    transform(acked_packets.begin(), acked_packets.end(), ack_strs.begin(),</div>
<div class="line"><a id="l03246" name="l03246"></a><span class="lineno"> 3246</span>              [](Ack::Const_ptr ack) -&gt; <span class="keywordtype">string</span></div>
<div class="line"><a id="l03247" name="l03247"></a><span class="lineno"> 3247</span>    {</div>
<div class="line"><a id="l03248" name="l03248"></a><span class="lineno"> 3248</span>      return util::ostream_op_string(<span class="stringliteral">&#39;[&#39;</span>, ack-&gt;m_seq_num, <span class="stringliteral">&quot;, &quot;</span>, int(ack-&gt;m_rexmit_id), <span class="stringliteral">&quot;, &quot;</span>,</div>
<div class="line"><a id="l03249" name="l03249"></a><span class="lineno"> 3249</span>                                     symbol_format,</div>
<div class="line"><a id="l03250" name="l03250"></a><span class="lineno"> 3250</span>                                     ack-&gt;m_delay, <span class="stringliteral">&#39;]&#39;</span>); <span class="comment">// &quot;ns,&quot; not &quot;nanoseconds.&quot;</span></div>
<div class="line"><a id="l03251" name="l03251"></a><span class="lineno"> 3251</span>    });</div>
<div class="line"><a id="l03252" name="l03252"></a><span class="lineno"> 3252</span>    <span class="keyword">const</span> <span class="keywordtype">string</span> ack_str = join(ack_strs, <span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"><a id="l03253" name="l03253"></a><span class="lineno"> 3253</span> </div>
<div class="line"><a id="l03254" name="l03254"></a><span class="lineno"> 3254</span>    <a class="code hl_define" href="log_8hpp.html#a9aa1d91ba9eb26345d4b83588ac489cb">FLOW_LOG_DATA_WITHOUT_CHECKING</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l03255" name="l03255"></a><span class="lineno"> 3255</span>                                   <span class="stringliteral">&quot;Accumulated [ACK] packets with &quot;</span></div>
<div class="line"><a id="l03256" name="l03256"></a><span class="lineno"> 3256</span>                                   <span class="stringliteral">&quot;acknowledgments [seq_num, rexmit_id, delay]: &quot;</span></div>
<div class="line"><a id="l03257" name="l03257"></a><span class="lineno"> 3257</span>                                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; ack_str &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03258" name="l03258"></a><span class="lineno"> 3258</span>  } <span class="comment">// if (DATA)</span></div>
<div class="line"><a id="l03259" name="l03259"></a><span class="lineno"> 3259</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03260" name="l03260"></a><span class="lineno"> 3260</span>  {</div>
<div class="line"><a id="l03261" name="l03261"></a><span class="lineno"> 3261</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;NetFlow worker thread working on [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l03262" name="l03262"></a><span class="lineno"> 3262</span>                   <span class="stringliteral">&quot;Accumulated [ACK] packets with &quot;</span></div>
<div class="line"><a id="l03263" name="l03263"></a><span class="lineno"> 3263</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; acked_packets.size() &lt;&lt; <span class="stringliteral">&quot;] individual acknowledgments.&quot;</span>);</div>
<div class="line"><a id="l03264" name="l03264"></a><span class="lineno"> 3264</span>  }</div>
<div class="line"><a id="l03265" name="l03265"></a><span class="lineno"> 3265</span> </div>
<div class="line"><a id="l03266" name="l03266"></a><span class="lineno"> 3266</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>)</div>
<div class="line"><a id="l03267" name="l03267"></a><span class="lineno"> 3267</span>  {</div>
<div class="line"><a id="l03268" name="l03268"></a><span class="lineno"> 3268</span>    log_snd_window(sock);</div>
<div class="line"><a id="l03269" name="l03269"></a><span class="lineno"> 3269</span>  }</div>
<div class="line"><a id="l03270" name="l03270"></a><span class="lineno"> 3270</span>  <span class="comment">// else { Why is this possible?  Answer: See handle_accumulated_acks() for explanation near similar check. }</span></div>
<div class="line"><a id="l03271" name="l03271"></a><span class="lineno"> 3271</span>} <span class="comment">// Node::log_accumulated_acks()</span></div>
<div class="line"><a id="l03272" name="l03272"></a><span class="lineno"> 3272</span> </div>
<div class="line"><a id="l03273" name="l03273"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670"> 3273</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">Node::drop_timer_action</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> drop_all_packets)</div>
<div class="line"><a id="l03274" name="l03274"></a><span class="lineno"> 3274</span>{</div>
<div class="line"><a id="l03275" name="l03275"></a><span class="lineno"> 3275</span>  <span class="keyword">using </span>std::list;</div>
<div class="line"><a id="l03276" name="l03276"></a><span class="lineno"> 3276</span>  <span class="keyword">using </span>boost::prior;</div>
<div class="line"><a id="l03277" name="l03277"></a><span class="lineno"> 3277</span> </div>
<div class="line"><a id="l03278" name="l03278"></a><span class="lineno"> 3278</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l03279" name="l03279"></a><span class="lineno"> 3279</span> </div>
<div class="line"><a id="l03280" name="l03280"></a><span class="lineno"> 3280</span>  <span class="comment">// Since we call m_snd_drop_timer-&gt;done() when exiting ESTABLISHED, this should hold.</span></div>
<div class="line"><a id="l03281" name="l03281"></a><span class="lineno"> 3281</span>  assert(sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>);</div>
<div class="line"><a id="l03282" name="l03282"></a><span class="lineno"> 3282</span> </div>
<div class="line"><a id="l03283" name="l03283"></a><span class="lineno"> 3283</span>  <span class="comment">// For brevity and a bit of speed:</span></div>
<div class="line"><a id="l03284" name="l03284"></a><span class="lineno"> 3284</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l03285" name="l03285"></a><span class="lineno"> 3285</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_seq = sock-&gt;m_snd_flying_pkts_by_seq_num;</div>
<div class="line"><a id="l03286" name="l03286"></a><span class="lineno"> 3286</span> </div>
<div class="line"><a id="l03287" name="l03287"></a><span class="lineno"> 3287</span>  <span class="comment">// Timer must not be running if there are no In-flight packets.  Thus it should not have fired.</span></div>
<div class="line"><a id="l03288" name="l03288"></a><span class="lineno"> 3288</span>  assert(!snd_flying_pkts_by_when.empty());</div>
<div class="line"><a id="l03289" name="l03289"></a><span class="lineno"> 3289</span> </div>
<div class="line"><a id="l03290" name="l03290"></a><span class="lineno"> 3290</span>  <span class="comment">/* Drop Timer fired and is telling us to consider Dropped some packets.  If drop_all_packets, then</span></div>
<div class="line"><a id="l03291" name="l03291"></a><span class="lineno"> 3291</span><span class="comment">   * it&#39;s all of them.  Otherwise it&#39;s just the earliest unacknowledged packet</span></div>
<div class="line"><a id="l03292" name="l03292"></a><span class="lineno"> 3292</span><span class="comment">   * (m_snd_flying_pkts_by_sent_when.begin()). */</span></div>
<div class="line"><a id="l03293" name="l03293"></a><span class="lineno"> 3293</span> </div>
<div class="line"><a id="l03294" name="l03294"></a><span class="lineno"> 3294</span>  <span class="comment">// Log details of the In-flight packets before we change things.</span></div>
<div class="line"><a id="l03295" name="l03295"></a><span class="lineno"> 3295</span>  log_snd_window(sock);</div>
<div class="line"><a id="l03296" name="l03296"></a><span class="lineno"> 3296</span> </div>
<div class="line"><a id="l03297" name="l03297"></a><span class="lineno"> 3297</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l03298" name="l03298"></a><span class="lineno"> 3298</span>  <span class="comment">// To check, at the end, whether we&#39;ve changed can_send() false =&gt; true.</span></div>
<div class="line"><a id="l03299" name="l03299"></a><span class="lineno"> 3299</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> could_send_before_drops = can_send(sock);</div>
<div class="line"><a id="l03300" name="l03300"></a><span class="lineno"> 3300</span>  <span class="comment">// To check, at the end, whether we&#39;ve changed snd_deqable() false =&gt; true.</span></div>
<div class="line"><a id="l03301" name="l03301"></a><span class="lineno"> 3301</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> had_rexmit_data_before_drops = !sock-&gt;m_snd_rexmit_q.empty();</div>
<div class="line"><a id="l03302" name="l03302"></a><span class="lineno"> 3302</span>  <span class="comment">// Will store ID of the one packet to drop; reserved value 0 will mean ALL packets are dropped.</span></div>
<div class="line"><a id="l03303" name="l03303"></a><span class="lineno"> 3303</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> packet_marked_to_drop_or_drop_all;</div>
<div class="line"><a id="l03304" name="l03304"></a><span class="lineno"> 3304</span> </div>
<div class="line"><a id="l03305" name="l03305"></a><span class="lineno"> 3305</span>  <span class="comment">// Used below for congestion control.</span></div>
<div class="line"><a id="l03306" name="l03306"></a><span class="lineno"> 3306</span>  <span class="keywordtype">size_t</span> cong_ctl_dropped_bytes = 0;</div>
<div class="line"><a id="l03307" name="l03307"></a><span class="lineno"> 3307</span>  <span class="keywordtype">size_t</span> cong_ctl_dropped_pkts = 0;</div>
<div class="line"><a id="l03308" name="l03308"></a><span class="lineno"> 3308</span> </div>
<div class="line"><a id="l03309" name="l03309"></a><span class="lineno"> 3309</span>  <span class="keywordflow">if</span> (drop_all_packets)</div>
<div class="line"><a id="l03310" name="l03310"></a><span class="lineno"> 3310</span>  {</div>
<div class="line"><a id="l03311" name="l03311"></a><span class="lineno"> 3311</span>    cong_ctl_dropped_bytes = sock-&gt;m_snd_flying_bytes;</div>
<div class="line"><a id="l03312" name="l03312"></a><span class="lineno"> 3312</span>    cong_ctl_dropped_pkts = snd_flying_pkts_by_when.size();</div>
<div class="line"><a id="l03313" name="l03313"></a><span class="lineno"> 3313</span> </div>
<div class="line"><a id="l03314" name="l03314"></a><span class="lineno"> 3314</span>    <span class="comment">// Queue them for retransmission, to be sent as soon as CWND provides enough space (could even be immediately).</span></div>
<div class="line"><a id="l03315" name="l03315"></a><span class="lineno"> 3315</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l03316" name="l03316"></a><span class="lineno"> 3316</span>    {</div>
<div class="line"><a id="l03317" name="l03317"></a><span class="lineno"> 3317</span>      <span class="comment">// Order is from earliest-sent to latest-sent (retransmission in the same order as transmission).</span></div>
<div class="line"><a id="l03318" name="l03318"></a><span class="lineno"> 3318</span>      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Peer_socket::Sent_pkt_by_sent_when_map::Reverse_iterator</a> pkt_it = snd_flying_pkts_by_when.oldest();</div>
<div class="line"><a id="l03319" name="l03319"></a><span class="lineno"> 3319</span>           pkt_it != snd_flying_pkts_by_when.past_newest();</div>
<div class="line"><a id="l03320" name="l03320"></a><span class="lineno"> 3320</span>           ++pkt_it)</div>
<div class="line"><a id="l03321" name="l03321"></a><span class="lineno"> 3321</span>      {</div>
<div class="line"><a id="l03322" name="l03322"></a><span class="lineno"> 3322</span>        <span class="comment">// The forward iterator F pointing to same list element as reverse iterator R is prior(R.base()). Google it.</span></div>
<div class="line"><a id="l03323" name="l03323"></a><span class="lineno"> 3323</span>        <span class="keywordflow">if</span> (!ok_to_rexmit_or_close(sock, prior(pkt_it.base()), <span class="keyword">false</span>)) <span class="comment">// Ensure not too many retransmissions already.</span></div>
<div class="line"><a id="l03324" name="l03324"></a><span class="lineno"> 3324</span>        <span class="comment">/* ^-- defer_delta_check == false: because we were invoked from a timer event.  Therefore, we will NOT perform</span></div>
<div class="line"><a id="l03325" name="l03325"></a><span class="lineno"> 3325</span><span class="comment">         * event_set_all_check_delta(false) before the boost.asio handler exits.  Therefore boost.asio</span></div>
<div class="line"><a id="l03326" name="l03326"></a><span class="lineno"> 3326</span><span class="comment">         * may sleep (block) before event_set_all_check_delta(false).  Therefore that would delay</span></div>
<div class="line"><a id="l03327" name="l03327"></a><span class="lineno"> 3327</span><span class="comment">         * delivery of the event to the user.  Therefore force the delta check immediately.  See</span></div>
<div class="line"><a id="l03328" name="l03328"></a><span class="lineno"> 3328</span><span class="comment">         * Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l03329" name="l03329"></a><span class="lineno"> 3329</span>        {</div>
<div class="line"><a id="l03330" name="l03330"></a><span class="lineno"> 3330</span>          <span class="keywordflow">return</span>; <span class="comment">// Already closed/logged/etc.</span></div>
<div class="line"><a id="l03331" name="l03331"></a><span class="lineno"> 3331</span>        }</div>
<div class="line"><a id="l03332" name="l03332"></a><span class="lineno"> 3332</span>        <span class="comment">// else</span></div>
<div class="line"><a id="l03333" name="l03333"></a><span class="lineno"> 3333</span> </div>
<div class="line"><a id="l03334" name="l03334"></a><span class="lineno"> 3334</span>        sock-&gt;m_snd_rexmit_q.push_back(pkt_it-&gt;second); <span class="comment">// Only a ref-counted pointer copy (constant time).</span></div>
<div class="line"><a id="l03335" name="l03335"></a><span class="lineno"> 3335</span>      }</div>
<div class="line"><a id="l03336" name="l03336"></a><span class="lineno"> 3336</span>      sock-&gt;m_snd_rexmit_q_size += cong_ctl_dropped_pkts;</div>
<div class="line"><a id="l03337" name="l03337"></a><span class="lineno"> 3337</span>    }</div>
<div class="line"><a id="l03338" name="l03338"></a><span class="lineno"> 3338</span>    <span class="comment">// else { Just drop it. }</span></div>
<div class="line"><a id="l03339" name="l03339"></a><span class="lineno"> 3339</span> </div>
<div class="line"><a id="l03340" name="l03340"></a><span class="lineno"> 3340</span>    <span class="comment">// Update our image of the pipe.  For efficiency we use clear() instead of doing it one-by-one above.</span></div>
<div class="line"><a id="l03341" name="l03341"></a><span class="lineno"> 3341</span> </div>
<div class="line"><a id="l03342" name="l03342"></a><span class="lineno"> 3342</span>    <span class="comment">// Update byte count.</span></div>
<div class="line"><a id="l03343" name="l03343"></a><span class="lineno"> 3343</span>    snd_flying_pkts_updated(sock, snd_flying_pkts_by_when.newest(), snd_flying_pkts_by_when.past_oldest(), <span class="keyword">false</span>);</div>
<div class="line"><a id="l03344" name="l03344"></a><span class="lineno"> 3344</span>    snd_flying_pkts_by_when.clear();</div>
<div class="line"><a id="l03345" name="l03345"></a><span class="lineno"> 3345</span>    snd_flying_pkts_by_seq.clear();</div>
<div class="line"><a id="l03346" name="l03346"></a><span class="lineno"> 3346</span> </div>
<div class="line"><a id="l03347" name="l03347"></a><span class="lineno"> 3347</span>    packet_marked_to_drop_or_drop_all = 0; <span class="comment">// Means drop all.</span></div>
<div class="line"><a id="l03348" name="l03348"></a><span class="lineno"> 3348</span>  }</div>
<div class="line"><a id="l03349" name="l03349"></a><span class="lineno"> 3349</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03350" name="l03350"></a><span class="lineno"> 3350</span>  {</div>
<div class="line"><a id="l03351" name="l03351"></a><span class="lineno"> 3351</span>    <span class="comment">// Get the packet that was sent before all the others.</span></div>
<div class="line"><a id="l03352" name="l03352"></a><span class="lineno"> 3352</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; oldest_pkt_it = prior(snd_flying_pkts_by_when.past_oldest());</div>
<div class="line"><a id="l03353" name="l03353"></a><span class="lineno"> 3353</span>    <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> oldest_pkt = oldest_pkt_it-&gt;second;</div>
<div class="line"><a id="l03354" name="l03354"></a><span class="lineno"> 3354</span> </div>
<div class="line"><a id="l03355" name="l03355"></a><span class="lineno"> 3355</span>    cong_ctl_dropped_bytes = oldest_pkt-&gt;m_size;</div>
<div class="line"><a id="l03356" name="l03356"></a><span class="lineno"> 3356</span>    cong_ctl_dropped_pkts = 1;</div>
<div class="line"><a id="l03357" name="l03357"></a><span class="lineno"> 3357</span> </div>
<div class="line"><a id="l03358" name="l03358"></a><span class="lineno"> 3358</span>    <span class="comment">// Queue it for retransmission, to be sent as soon as CWND provides enough space (could even be immediately).</span></div>
<div class="line"><a id="l03359" name="l03359"></a><span class="lineno"> 3359</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l03360" name="l03360"></a><span class="lineno"> 3360</span>    {</div>
<div class="line"><a id="l03361" name="l03361"></a><span class="lineno"> 3361</span>      <span class="keywordflow">if</span> (!ok_to_rexmit_or_close(sock, oldest_pkt_it, <span class="keyword">false</span>)) <span class="comment">// Ensure not too many retransmissions already.</span></div>
<div class="line"><a id="l03362" name="l03362"></a><span class="lineno"> 3362</span>      <span class="comment">// ^-- false &lt;= Same as comment above.</span></div>
<div class="line"><a id="l03363" name="l03363"></a><span class="lineno"> 3363</span>      {</div>
<div class="line"><a id="l03364" name="l03364"></a><span class="lineno"> 3364</span>        <span class="keywordflow">return</span>; <span class="comment">// Already closed/logged/etc.</span></div>
<div class="line"><a id="l03365" name="l03365"></a><span class="lineno"> 3365</span>      }</div>
<div class="line"><a id="l03366" name="l03366"></a><span class="lineno"> 3366</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l03367" name="l03367"></a><span class="lineno"> 3367</span> </div>
<div class="line"><a id="l03368" name="l03368"></a><span class="lineno"> 3368</span>      sock-&gt;m_snd_rexmit_q.push_back(oldest_pkt); <span class="comment">// Only a ref-counted pointer copy (constant time).</span></div>
<div class="line"><a id="l03369" name="l03369"></a><span class="lineno"> 3369</span>      ++sock-&gt;m_snd_rexmit_q_size;</div>
<div class="line"><a id="l03370" name="l03370"></a><span class="lineno"> 3370</span>    }</div>
<div class="line"><a id="l03371" name="l03371"></a><span class="lineno"> 3371</span>    <span class="comment">// else { Just drop it. }</span></div>
<div class="line"><a id="l03372" name="l03372"></a><span class="lineno"> 3372</span> </div>
<div class="line"><a id="l03373" name="l03373"></a><span class="lineno"> 3373</span>    <span class="comment">// Remember it short-term for the Drop_timer consolidated book-keeping below...</span></div>
<div class="line"><a id="l03374" name="l03374"></a><span class="lineno"> 3374</span>    packet_marked_to_drop_or_drop_all = oldest_pkt-&gt;m_sent_when.back().m_order_num;</div>
<div class="line"><a id="l03375" name="l03375"></a><span class="lineno"> 3375</span> </div>
<div class="line"><a id="l03376" name="l03376"></a><span class="lineno"> 3376</span>    <span class="comment">// ...and in fact mark that packet Dropped (update our image of the pipe).</span></div>
<div class="line"><a id="l03377" name="l03377"></a><span class="lineno"> 3377</span>    snd_flying_pkts_erase_one(sock, oldest_pkt_it);</div>
<div class="line"><a id="l03378" name="l03378"></a><span class="lineno"> 3378</span>  }</div>
<div class="line"><a id="l03379" name="l03379"></a><span class="lineno"> 3379</span> </div>
<div class="line"><a id="l03380" name="l03380"></a><span class="lineno"> 3380</span>  <span class="comment">/* Deal with congestion control.  For introduction to the general topic see the large comment</span></div>
<div class="line"><a id="l03381" name="l03381"></a><span class="lineno"> 3381</span><span class="comment">   * near the top of handle_accumulated_acks().</span></div>
<div class="line"><a id="l03382" name="l03382"></a><span class="lineno"> 3382</span><span class="comment">   *</span></div>
<div class="line"><a id="l03383" name="l03383"></a><span class="lineno"> 3383</span><span class="comment">   * Since a Drop Timeout implies a large loss event, the congestion control module must be</span></div>
<div class="line"><a id="l03384" name="l03384"></a><span class="lineno"> 3384</span><span class="comment">   * informed.  It may adjust the congestion window (used in can_send() and controlling how many</span></div>
<div class="line"><a id="l03385" name="l03385"></a><span class="lineno"> 3385</span><span class="comment">   * packets we are allowed to have In-flight at a time), probably downward.</span></div>
<div class="line"><a id="l03386" name="l03386"></a><span class="lineno"> 3386</span><span class="comment">   *</span></div>
<div class="line"><a id="l03387" name="l03387"></a><span class="lineno"> 3387</span><span class="comment">   * Also, this is a new loss event.  Why?  (For detailed explanation of what a loss event is, and</span></div>
<div class="line"><a id="l03388" name="l03388"></a><span class="lineno"> 3388</span><span class="comment">   * how we keep track of them, see that large comment in handle_accumulated_acks().  It</span></div>
<div class="line"><a id="l03389" name="l03389"></a><span class="lineno"> 3389</span><span class="comment">   * may be required to understand the rest of this paragraph.)  Certainly this Drop is part of some</span></div>
<div class="line"><a id="l03390" name="l03390"></a><span class="lineno"> 3390</span><span class="comment">   * loss event by definition, but is it a new loss event, or merely the previous one (if such</span></div>
<div class="line"><a id="l03391" name="l03391"></a><span class="lineno"> 3391</span><span class="comment">   * exists)?  Well, a Drop Timeout is, in practice, at least 1 second (which is likely 4 times a</span></div>
<div class="line"><a id="l03392" name="l03392"></a><span class="lineno"> 3392</span><span class="comment">   * pretty large RTT of 250 msec) and can also be estimated to be 3 * SRTT.  In other words it is</span></div>
<div class="line"><a id="l03393" name="l03393"></a><span class="lineno"> 3393</span><span class="comment">   * probably much larger than SRTT, and certainly is at least a little larger than SRTT.  Therefore</span></div>
<div class="line"><a id="l03394" name="l03394"></a><span class="lineno"> 3394</span><span class="comment">   * most likely any packet(s) Dropped by this DTO were sent after the last loss event (if any) was</span></div>
<div class="line"><a id="l03395" name="l03395"></a><span class="lineno"> 3395</span><span class="comment">   * detected.  Hence this DTO event is a new loss event.  We could explicitly check for this, but</span></div>
<div class="line"><a id="l03396" name="l03396"></a><span class="lineno"> 3396</span><span class="comment">   * it seems unnecessarily complex and intuitively unnecessary.</span></div>
<div class="line"><a id="l03397" name="l03397"></a><span class="lineno"> 3397</span><span class="comment">   *</span></div>
<div class="line"><a id="l03398" name="l03398"></a><span class="lineno"> 3398</span><span class="comment">   * Per handle_accumulated_acks(), when a new loss event is seen, m_snd_last_loss_event_when</span></div>
<div class="line"><a id="l03399" name="l03399"></a><span class="lineno"> 3399</span><span class="comment">   * is set to NOW. */</span></div>
<div class="line"><a id="l03400" name="l03400"></a><span class="lineno"> 3400</span> </div>
<div class="line"><a id="l03401" name="l03401"></a><span class="lineno"> 3401</span>  <span class="comment">// @todo Arguable if it should be INFO or TRACE.  We&#39;ll see.</span></div>
<div class="line"><a id="l03402" name="l03402"></a><span class="lineno"> 3402</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;cong_ctl [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] update: Drop Timeout event: &quot;</span></div>
<div class="line"><a id="l03403" name="l03403"></a><span class="lineno"> 3403</span>                <span class="stringliteral">&quot;Dropped [&quot;</span> &lt;&lt; cong_ctl_dropped_bytes &lt;&lt; <span class="stringliteral">&quot;] bytes = [&quot;</span> &lt;&lt; cong_ctl_dropped_pkts &lt;&lt; <span class="stringliteral">&quot;] packets.&quot;</span>);</div>
<div class="line"><a id="l03404" name="l03404"></a><span class="lineno"> 3404</span> </div>
<div class="line"><a id="l03405" name="l03405"></a><span class="lineno"> 3405</span>  <span class="comment">// MUST call this after, not before, updating m_snd_flying_{packets|bytes} per method doc.</span></div>
<div class="line"><a id="l03406" name="l03406"></a><span class="lineno"> 3406</span>  sock-&gt;m_snd_cong_ctl-&gt;on_drop_timeout(cong_ctl_dropped_bytes, cong_ctl_dropped_pkts);</div>
<div class="line"><a id="l03407" name="l03407"></a><span class="lineno"> 3407</span>  sock-&gt;m_snd_last_loss_event_when = Fine_clock::now();</div>
<div class="line"><a id="l03408" name="l03408"></a><span class="lineno"> 3408</span> </div>
<div class="line"><a id="l03409" name="l03409"></a><span class="lineno"> 3409</span>  <span class="comment">// Register that there was a timeout, and that bytes were converted from In-flight to Dropped.</span></div>
<div class="line"><a id="l03410" name="l03410"></a><span class="lineno"> 3410</span>  sock-&gt;m_snd_stats.drop_timeout();</div>
<div class="line"><a id="l03411" name="l03411"></a><span class="lineno"> 3411</span>  sock-&gt;m_snd_stats.dropped_data(cong_ctl_dropped_bytes, cong_ctl_dropped_pkts);</div>
<div class="line"><a id="l03412" name="l03412"></a><span class="lineno"> 3412</span> </div>
<div class="line"><a id="l03413" name="l03413"></a><span class="lineno"> 3413</span>  <span class="comment">// Now log the &quot;after.&quot;</span></div>
<div class="line"><a id="l03414" name="l03414"></a><span class="lineno"> 3414</span>  log_snd_window(sock);</div>
<div class="line"><a id="l03415" name="l03415"></a><span class="lineno"> 3415</span> </div>
<div class="line"><a id="l03416" name="l03416"></a><span class="lineno"> 3416</span>  <span class="comment">// Since we&#39;ve changed snd_flying_pkts*, Drop_timer events have occurred. Cleanly handle them all in one go.</span></div>
<div class="line"><a id="l03417" name="l03417"></a><span class="lineno"> 3417</span> </div>
<div class="line"><a id="l03418" name="l03418"></a><span class="lineno"> 3418</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Drop_timer::Ptr</a> drop_timer = sock-&gt;m_snd_drop_timer;</div>
<div class="line"><a id="l03419" name="l03419"></a><span class="lineno"> 3419</span>  drop_timer-&gt;start_contemporaneous_events();</div>
<div class="line"><a id="l03420" name="l03420"></a><span class="lineno"> 3420</span> </div>
<div class="line"><a id="l03421" name="l03421"></a><span class="lineno"> 3421</span>  <span class="comment">/* Handle possible effect of above activities on the Drop Timer.  (It may get disabled or restarted anew.)</span></div>
<div class="line"><a id="l03422" name="l03422"></a><span class="lineno"> 3422</span><span class="comment">   * Why not just do this right when we erase the associated packets from snd_flying_pkts*? We don&#39;t want to</span></div>
<div class="line"><a id="l03423" name="l03423"></a><span class="lineno"> 3423</span><span class="comment">   * trigger disruptive behavior like possibly retransmitting everything in the middle of all that accounting</span></div>
<div class="line"><a id="l03424" name="l03424"></a><span class="lineno"> 3424</span><span class="comment">   * which is not yet complete.  Now it&#39;s complete, so it&#39;s the right time to handle this.</span></div>
<div class="line"><a id="l03425" name="l03425"></a><span class="lineno"> 3425</span><span class="comment">   *</span></div>
<div class="line"><a id="l03426" name="l03426"></a><span class="lineno"> 3426</span><span class="comment">   * Recall that snd_flying_pkts* have been updated and no longer contain the associated packet(s)&#39;s info. */</span></div>
<div class="line"><a id="l03427" name="l03427"></a><span class="lineno"> 3427</span>  <span class="keywordflow">if</span> (packet_marked_to_drop_or_drop_all == 0)</div>
<div class="line"><a id="l03428" name="l03428"></a><span class="lineno"> 3428</span>  {</div>
<div class="line"><a id="l03429" name="l03429"></a><span class="lineno"> 3429</span>    <span class="comment">// Note that this is equivalent to calling ...packet_no_longer_in_flight(P) for all P -- just faster.</span></div>
<div class="line"><a id="l03430" name="l03430"></a><span class="lineno"> 3430</span>    drop_timer-&gt;on_no_packets_in_flight_any_longer();</div>
<div class="line"><a id="l03431" name="l03431"></a><span class="lineno"> 3431</span>  }</div>
<div class="line"><a id="l03432" name="l03432"></a><span class="lineno"> 3432</span>  <span class="keywordflow">else</span> <span class="comment">// if (packet_marked_to_drop_or_drop_all refers to, in fact, a specific packet)</span></div>
<div class="line"><a id="l03433" name="l03433"></a><span class="lineno"> 3433</span>  {</div>
<div class="line"><a id="l03434" name="l03434"></a><span class="lineno"> 3434</span>    drop_timer-&gt;on_packet_no_longer_in_flight(packet_marked_to_drop_or_drop_all);</div>
<div class="line"><a id="l03435" name="l03435"></a><span class="lineno"> 3435</span>    <span class="comment">/* Could also call on_no_packets_in_flight_any_longer() if now none is In-flight, but performance-wise that&#39;d</span></div>
<div class="line"><a id="l03436" name="l03436"></a><span class="lineno"> 3436</span><span class="comment">     * be the same; ...packet_no_longer_in_flight() will check the same condition anyway. So don&#39;t bother. */</span></div>
<div class="line"><a id="l03437" name="l03437"></a><span class="lineno"> 3437</span>  }</div>
<div class="line"><a id="l03438" name="l03438"></a><span class="lineno"> 3438</span> </div>
<div class="line"><a id="l03439" name="l03439"></a><span class="lineno"> 3439</span>  drop_timer-&gt;end_contemporaneous_events();</div>
<div class="line"><a id="l03440" name="l03440"></a><span class="lineno"> 3440</span> </div>
<div class="line"><a id="l03441" name="l03441"></a><span class="lineno"> 3441</span>  <span class="comment">/* We&#39;ve definitely reduced the number of packets we consider In-flight.  We may also have added</span></div>
<div class="line"><a id="l03442" name="l03442"></a><span class="lineno"> 3442</span><span class="comment">   * packets to retransmission queue (if retransmission is on).  Therefore can_send() may now return</span></div>
<div class="line"><a id="l03443" name="l03443"></a><span class="lineno"> 3443</span><span class="comment">   * true while at the beginning of the method it returned false; snd_deqable() may now return true</span></div>
<div class="line"><a id="l03444" name="l03444"></a><span class="lineno"> 3444</span><span class="comment">   * similarly.  So have send_worker() check and send more if possible.  See Node::send() for</span></div>
<div class="line"><a id="l03445" name="l03445"></a><span class="lineno"> 3445</span><span class="comment">   * discussion of overall strategy on this topic. */</span></div>
<div class="line"><a id="l03446" name="l03446"></a><span class="lineno"> 3446</span>  <span class="keywordflow">if</span> ((!could_send_before_drops) || (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> &amp;&amp; (!had_rexmit_data_before_drops)))</div>
<div class="line"><a id="l03447" name="l03447"></a><span class="lineno"> 3447</span>  {</div>
<div class="line"><a id="l03448" name="l03448"></a><span class="lineno"> 3448</span>    send_worker(sock, <span class="keyword">false</span>);</div>
<div class="line"><a id="l03449" name="l03449"></a><span class="lineno"> 3449</span>    <span class="comment">// ^-- defer_delta_check == false: for similar reason as in send_worker_check_state() calling send_worker().</span></div>
<div class="line"><a id="l03450" name="l03450"></a><span class="lineno"> 3450</span>  }</div>
<div class="line"><a id="l03451" name="l03451"></a><span class="lineno"> 3451</span>} <span class="comment">// Node::drop_timer_action()</span></div>
<div class="line"><a id="l03452" name="l03452"></a><span class="lineno"> 3452</span> </div>
<div class="line"><a id="l03453" name="l03453"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b"> 3453</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">Node::new_round_trip_time_sample</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> round_trip_time)</div>
<div class="line"><a id="l03454" name="l03454"></a><span class="lineno"> 3454</span>{</div>
<div class="line"><a id="l03455" name="l03455"></a><span class="lineno"> 3455</span>  <span class="keyword">using </span>std::min;</div>
<div class="line"><a id="l03456" name="l03456"></a><span class="lineno"> 3456</span>  <span class="keyword">using </span>std::max;</div>
<div class="line"><a id="l03457" name="l03457"></a><span class="lineno"> 3457</span>  <span class="keyword">using </span>boost::ratio;</div>
<div class="line"><a id="l03458" name="l03458"></a><span class="lineno"> 3458</span>  <span class="keyword">using </span>boost::ratio_subtract;</div>
<div class="line"><a id="l03459" name="l03459"></a><span class="lineno"> 3459</span>  <span class="keyword">using </span>boost::ratio_string;</div>
<div class="line"><a id="l03460" name="l03460"></a><span class="lineno"> 3460</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l03461" name="l03461"></a><span class="lineno"> 3461</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l03462" name="l03462"></a><span class="lineno"> 3462</span>  <span class="keyword">using </span>boost::chrono::microseconds;</div>
<div class="line"><a id="l03463" name="l03463"></a><span class="lineno"> 3463</span>  <span class="keyword">using </span>boost::chrono::seconds;</div>
<div class="line"><a id="l03464" name="l03464"></a><span class="lineno"> 3464</span> </div>
<div class="line"><a id="l03465" name="l03465"></a><span class="lineno"> 3465</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l03466" name="l03466"></a><span class="lineno"> 3466</span> </div>
<div class="line"><a id="l03467" name="l03467"></a><span class="lineno"> 3467</span>  <span class="comment">// For brevity and a bit of speed:</span></div>
<div class="line"><a id="l03468" name="l03468"></a><span class="lineno"> 3468</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; srtt = sock-&gt;m_snd_smoothed_round_trip_time;</div>
<div class="line"><a id="l03469" name="l03469"></a><span class="lineno"> 3469</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; rtt_var = sock-&gt;m_round_trip_time_variance;</div>
<div class="line"><a id="l03470" name="l03470"></a><span class="lineno"> 3470</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; dto = sock-&gt;m_snd_drop_timeout;</div>
<div class="line"><a id="l03471" name="l03471"></a><span class="lineno"> 3471</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; rtt = round_trip_time;</div>
<div class="line"><a id="l03472" name="l03472"></a><span class="lineno"> 3472</span> </div>
<div class="line"><a id="l03473" name="l03473"></a><span class="lineno"> 3473</span>  <span class="comment">/* An ACK has supplied the given round_trip_time for a specific packet.  We are to update the</span></div>
<div class="line"><a id="l03474" name="l03474"></a><span class="lineno"> 3474</span><span class="comment">   * smoothed RTT for the socket which is an estimate for the smooth &quot;current&quot; RTT for the socket.</span></div>
<div class="line"><a id="l03475" name="l03475"></a><span class="lineno"> 3475</span><span class="comment">   * Use RFC 6298 algorithm for SRTT calculation.</span></div>
<div class="line"><a id="l03476" name="l03476"></a><span class="lineno"> 3476</span><span class="comment">   *</span></div>
<div class="line"><a id="l03477" name="l03477"></a><span class="lineno"> 3477</span><span class="comment">   * RFC 6298 specifies the formula in &quot;seconds.&quot;  Of course it need not be seconds; it can be any</span></div>
<div class="line"><a id="l03478" name="l03478"></a><span class="lineno"> 3478</span><span class="comment">   * unit.  We leave the unit we use unspecified, except to say that we will use the unit of</span></div>
<div class="line"><a id="l03479" name="l03479"></a><span class="lineno"> 3479</span><span class="comment">   * Fine_duration, which is the duration type of Fine_clock, which is the highest-resolution clock</span></div>
<div class="line"><a id="l03480" name="l03480"></a><span class="lineno"> 3480</span><span class="comment">   * available in the OS/hardware.  Since, where possible, we keep using Fine_duration without</span></div>
<div class="line"><a id="l03481" name="l03481"></a><span class="lineno"> 3481</span><span class="comment">   * truncation to compute round_trip_time, assuming we don&#39;t introduce any unit conversions</span></div>
<div class="line"><a id="l03482" name="l03482"></a><span class="lineno"> 3482</span><span class="comment">   * (truncations, roundings) in the below code, the SRTT will maintain those units as well.</span></div>
<div class="line"><a id="l03483" name="l03483"></a><span class="lineno"> 3483</span><span class="comment">   * boost::chrono::duration will specifically cause compile failures if we don&#39;t explicitly specify</span></div>
<div class="line"><a id="l03484" name="l03484"></a><span class="lineno"> 3484</span><span class="comment">   * every truncation-inducing operation (duration_cast&lt;&gt;, round&lt;&gt;, etc.).</span></div>
<div class="line"><a id="l03485" name="l03485"></a><span class="lineno"> 3485</span><span class="comment">   *</span></div>
<div class="line"><a id="l03486" name="l03486"></a><span class="lineno"> 3486</span><span class="comment">   * BTW, this &quot;unspecified&quot; unit is probably nanoseconds.</span></div>
<div class="line"><a id="l03487" name="l03487"></a><span class="lineno"> 3487</span><span class="comment">   *</span></div>
<div class="line"><a id="l03488" name="l03488"></a><span class="lineno"> 3488</span><span class="comment">   * Note that the units used do NOT guarantee any particular clock granularity.  E.g., I can give</span></div>
<div class="line"><a id="l03489" name="l03489"></a><span class="lineno"> 3489</span><span class="comment">   * you the time in milliseconds, but if I always say it in multiples of 1000 milliseconds, then I</span></div>
<div class="line"><a id="l03490" name="l03490"></a><span class="lineno"> 3490</span><span class="comment">   * may be working with milliseconds, but the resolution is 1 sec. */</span></div>
<div class="line"><a id="l03491" name="l03491"></a><span class="lineno"> 3491</span> </div>
<div class="line"><a id="l03492" name="l03492"></a><span class="lineno"> 3492</span>  <span class="keywordflow">if</span> (srtt == Fine_duration::zero())</div>
<div class="line"><a id="l03493" name="l03493"></a><span class="lineno"> 3493</span>  {</div>
<div class="line"><a id="l03494" name="l03494"></a><span class="lineno"> 3494</span>    <span class="comment">// First RTT measurement; initialize according to algorithm.</span></div>
<div class="line"><a id="l03495" name="l03495"></a><span class="lineno"> 3495</span>    srtt = rtt;</div>
<div class="line"><a id="l03496" name="l03496"></a><span class="lineno"> 3496</span>    rtt_var = rtt / 2;</div>
<div class="line"><a id="l03497" name="l03497"></a><span class="lineno"> 3497</span> </div>
<div class="line"><a id="l03498" name="l03498"></a><span class="lineno"> 3498</span>    <span class="comment">// Truncate results to millisecond representation for readability.</span></div>
<div class="line"><a id="l03499" name="l03499"></a><span class="lineno"> 3499</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;First SRTT calculation for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l03500" name="l03500"></a><span class="lineno"> 3500</span>                   <span class="stringliteral">&quot;srtt = [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(srtt) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; srtt &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03501" name="l03501"></a><span class="lineno"> 3501</span>                   <span class="stringliteral">&quot;rtt_var = [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(rtt_var) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; rtt_var &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03502" name="l03502"></a><span class="lineno"> 3502</span>                   <span class="stringliteral">&quot;rtt = [&quot;</span> &lt;&lt; rtt &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03503" name="l03503"></a><span class="lineno"> 3503</span>  }</div>
<div class="line"><a id="l03504" name="l03504"></a><span class="lineno"> 3504</span>  <span class="keywordflow">else</span> <span class="comment">// if (SRTT was defined before this sample.)</span></div>
<div class="line"><a id="l03505" name="l03505"></a><span class="lineno"> 3505</span>  {</div>
<div class="line"><a id="l03506" name="l03506"></a><span class="lineno"> 3506</span>    <span class="comment">// Subsequent RTT measurements.</span></div>
<div class="line"><a id="l03507" name="l03507"></a><span class="lineno"> 3507</span> </div>
<div class="line"><a id="l03508" name="l03508"></a><span class="lineno"> 3508</span>    <span class="comment">// @todo Per last paragraph of RFC 6298-5, we MAY want to clear srtt/rtt_var afer multiple RTOs or maybe idleness.</span></div>
<div class="line"><a id="l03509" name="l03509"></a><span class="lineno"> 3509</span>    <span class="comment">// (RTO = Retransmission Timeout, though we call it a Drop Timeout more accurately [we don&#39;t necessarily</span></div>
<div class="line"><a id="l03510" name="l03510"></a><span class="lineno"> 3510</span>    <span class="comment">// retransmit on loss in NetFlow, unlike TCP].)</span></div>
<div class="line"><a id="l03511" name="l03511"></a><span class="lineno"> 3511</span> </div>
<div class="line"><a id="l03512" name="l03512"></a><span class="lineno"> 3512</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> prev_srtt = srtt;</div>
<div class="line"><a id="l03513" name="l03513"></a><span class="lineno"> 3513</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> prev_rtt_var = rtt_var;</div>
<div class="line"><a id="l03514" name="l03514"></a><span class="lineno"> 3514</span> </div>
<div class="line"><a id="l03515" name="l03515"></a><span class="lineno"> 3515</span>    <span class="comment">/* Reason I used ratio&lt;&gt; instead of floating point constants: I don&#39;t want to use floating</span></div>
<div class="line"><a id="l03516" name="l03516"></a><span class="lineno"> 3516</span><span class="comment">     * points in production code that much.  I don&#39;t necessarily trust it for consistent behavior across platforms...</span></div>
<div class="line"><a id="l03517" name="l03517"></a><span class="lineno"> 3517</span><span class="comment">     * and in general I just find integers more predictable/easier to reason about in most contexts of net_flow.</span></div>
<div class="line"><a id="l03518" name="l03518"></a><span class="lineno"> 3518</span><span class="comment">     * Reason I used ratio&lt;&gt; instead of just having separate integer constants for numerators and</span></div>
<div class="line"><a id="l03519" name="l03519"></a><span class="lineno"> 3519</span><span class="comment">     * denominators: I&#39;d rather have ratio&lt;&gt; do the arithmetic for me (at compile time to boot!). */</span></div>
<div class="line"><a id="l03520" name="l03520"></a><span class="lineno"> 3520</span>    <span class="keyword">using </span>Alpha = ratio&lt;1, 8&gt;; <span class="comment">// 1/8, per RFC.</span></div>
<div class="line"><a id="l03521" name="l03521"></a><span class="lineno"> 3521</span>    <span class="keyword">using </span>One_minus_alpha = ratio_subtract&lt;ratio&lt;1&gt;, Alpha&gt;;</div>
<div class="line"><a id="l03522" name="l03522"></a><span class="lineno"> 3522</span>    <span class="keyword">using </span>Beta = ratio&lt;1, 4&gt;; <span class="comment">// 1/4, per RFC.</span></div>
<div class="line"><a id="l03523" name="l03523"></a><span class="lineno"> 3523</span>    <span class="keyword">using </span>One_minus_beta = ratio_subtract&lt;ratio&lt;1&gt;, Beta&gt;;</div>
<div class="line"><a id="l03524" name="l03524"></a><span class="lineno"> 3524</span>    <span class="comment">// Now I can use X::num and X::den, such that X is the ratio X::num/X::den.</span></div>
<div class="line"><a id="l03525" name="l03525"></a><span class="lineno"> 3525</span> </div>
<div class="line"><a id="l03526" name="l03526"></a><span class="lineno"> 3526</span>    <span class="comment">// Compute |srtt - rtt|.</span></div>
<div class="line"><a id="l03527" name="l03527"></a><span class="lineno"> 3527</span>    <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> abs_srtt_minus_rtt = srtt - rtt;</div>
<div class="line"><a id="l03528" name="l03528"></a><span class="lineno"> 3528</span>    <span class="keywordflow">if</span> (abs_srtt_minus_rtt.count() &lt; 0)</div>
<div class="line"><a id="l03529" name="l03529"></a><span class="lineno"> 3529</span>    {</div>
<div class="line"><a id="l03530" name="l03530"></a><span class="lineno"> 3530</span>      abs_srtt_minus_rtt = -abs_srtt_minus_rtt;</div>
<div class="line"><a id="l03531" name="l03531"></a><span class="lineno"> 3531</span>    }</div>
<div class="line"><a id="l03532" name="l03532"></a><span class="lineno"> 3532</span> </div>
<div class="line"><a id="l03533" name="l03533"></a><span class="lineno"> 3533</span>    <span class="comment">// Update the results per RFC.</span></div>
<div class="line"><a id="l03534" name="l03534"></a><span class="lineno"> 3534</span>    rtt_var</div>
<div class="line"><a id="l03535" name="l03535"></a><span class="lineno"> 3535</span>      = rtt_var * One_minus_beta::num / One_minus_beta::den</div>
<div class="line"><a id="l03536" name="l03536"></a><span class="lineno"> 3536</span>        + abs_srtt_minus_rtt * Beta::num / Beta::den;</div>
<div class="line"><a id="l03537" name="l03537"></a><span class="lineno"> 3537</span>    srtt</div>
<div class="line"><a id="l03538" name="l03538"></a><span class="lineno"> 3538</span>      = srtt * One_minus_alpha::num / One_minus_alpha::den</div>
<div class="line"><a id="l03539" name="l03539"></a><span class="lineno"> 3539</span>        + rtt * Alpha::num / Alpha::den;</div>
<div class="line"><a id="l03540" name="l03540"></a><span class="lineno"> 3540</span> </div>
<div class="line"><a id="l03541" name="l03541"></a><span class="lineno"> 3541</span>    <span class="comment">// Truncate results to millisecond representation for readability.</span></div>
<div class="line"><a id="l03542" name="l03542"></a><span class="lineno"> 3542</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Next SRTT calculation for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l03543" name="l03543"></a><span class="lineno"> 3543</span>                   <span class="stringliteral">&quot;srtt = [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(srtt) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; srtt &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03544" name="l03544"></a><span class="lineno"> 3544</span>                   <span class="stringliteral">&quot;rtt_var = [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(rtt_var) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; rtt_var &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03545" name="l03545"></a><span class="lineno"> 3545</span>                   <span class="stringliteral">&quot;rtt = [&quot;</span> &lt;&lt; rtt &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03546" name="l03546"></a><span class="lineno"> 3546</span>                   <span class="stringliteral">&quot;prev_srtt = [&quot;</span> &lt;&lt; prev_srtt &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03547" name="l03547"></a><span class="lineno"> 3547</span>                   <span class="stringliteral">&quot;prev_rtt_var = [&quot;</span> &lt;&lt; prev_rtt_var &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03548" name="l03548"></a><span class="lineno"> 3548</span>                   <span class="stringliteral">&quot;alpha = &quot;</span> &lt;&lt; (ratio_string&lt;Alpha, char&gt;::prefix()) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span></div>
<div class="line"><a id="l03549" name="l03549"></a><span class="lineno"> 3549</span>                   <span class="stringliteral">&quot;(1 - alpha) = &quot;</span> &lt;&lt; (ratio_string&lt;One_minus_alpha, char&gt;::prefix()) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span></div>
<div class="line"><a id="l03550" name="l03550"></a><span class="lineno"> 3550</span>                   <span class="stringliteral">&quot;beta = &quot;</span> &lt;&lt; (ratio_string&lt;Beta, char&gt;::prefix()) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span></div>
<div class="line"><a id="l03551" name="l03551"></a><span class="lineno"> 3551</span>                   <span class="stringliteral">&quot;(1 - beta) = &quot;</span> &lt;&lt; (ratio_string&lt;One_minus_beta, char&gt;::prefix()) &lt;&lt; <span class="stringliteral">&quot;; &quot;</span></div>
<div class="line"><a id="l03552" name="l03552"></a><span class="lineno"> 3552</span>                   <span class="stringliteral">&quot;|srtt - rtt| = [&quot;</span> &lt;&lt; abs_srtt_minus_rtt &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03553" name="l03553"></a><span class="lineno"> 3553</span>  } <span class="comment">// else if (SRTT was defined before this sample)</span></div>
<div class="line"><a id="l03554" name="l03554"></a><span class="lineno"> 3554</span> </div>
<div class="line"><a id="l03555" name="l03555"></a><span class="lineno"> 3555</span>  <span class="comment">/* Now compute Drop Timeout (DTO), similar to TCP&#39;s RTO (Retransmission Timeout): the minimum</span></div>
<div class="line"><a id="l03556" name="l03556"></a><span class="lineno"> 3556</span><span class="comment">   * amount of time we give an In-flight packet to get Acknowledged before considering it Dropped.</span></div>
<div class="line"><a id="l03557" name="l03557"></a><span class="lineno"> 3557</span><span class="comment">   * Again we use RFC 6298 for DTO computation.</span></div>
<div class="line"><a id="l03558" name="l03558"></a><span class="lineno"> 3558</span><span class="comment">   *</span></div>
<div class="line"><a id="l03559" name="l03559"></a><span class="lineno"> 3559</span><span class="comment">   * The formula is DTO = srtt + max(G, K * rtt_var), where K = 4 and G is the &quot;clock</span></div>
<div class="line"><a id="l03560" name="l03560"></a><span class="lineno"> 3560</span><span class="comment">   * granularity.&quot;  Additionally, we are to put a floor of 1 second on DTO.  Finally, we are allowed</span></div>
<div class="line"><a id="l03561" name="l03561"></a><span class="lineno"> 3561</span><span class="comment">   * to put a ceiling on DTO, as long as that ceiling is at least 60 seconds.</span></div>
<div class="line"><a id="l03562" name="l03562"></a><span class="lineno"> 3562</span><span class="comment">   *</span></div>
<div class="line"><a id="l03563" name="l03563"></a><span class="lineno"> 3563</span><span class="comment">   * G plays an important part in the RTO caclulation algorithm, so we must know it.  So what is it?</span></div>
<div class="line"><a id="l03564" name="l03564"></a><span class="lineno"> 3564</span><span class="comment">   * We don&#39;t know.  We do however have a reasonably conservative upper bound; boost.timer</span></div>
<div class="line"><a id="l03565" name="l03565"></a><span class="lineno"> 3565</span><span class="comment">   * documentation lists some popular OS+CPU combinations and notes that for none of them does</span></div>
<div class="line"><a id="l03566" name="l03566"></a><span class="lineno"> 3566</span><span class="comment">   * high_resolution_timer exceed 5 microseconds.  Therefore, let us pick the exceedingly</span></div>
<div class="line"><a id="l03567" name="l03567"></a><span class="lineno"> 3567</span><span class="comment">   * conservative G = 500 microseconds = 1/2 milliseconds. */</span></div>
<div class="line"><a id="l03568" name="l03568"></a><span class="lineno"> 3568</span> </div>
<div class="line"><a id="l03569" name="l03569"></a><span class="lineno"> 3569</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> clock_resolution_at_least = microseconds(500);</div>
<div class="line"><a id="l03570" name="l03570"></a><span class="lineno"> 3570</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> floor = seconds(1);</div>
<div class="line"><a id="l03571" name="l03571"></a><span class="lineno"> 3571</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> ceiling = sock-&gt;opt(sock-&gt;m_opts.m_dyn_drop_timeout_ceiling);</div>
<div class="line"><a id="l03572" name="l03572"></a><span class="lineno"> 3572</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 4;</div>
<div class="line"><a id="l03573" name="l03573"></a><span class="lineno"> 3573</span> </div>
<div class="line"><a id="l03574" name="l03574"></a><span class="lineno"> 3574</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> prev_dto = dto;</div>
<div class="line"><a id="l03575" name="l03575"></a><span class="lineno"> 3575</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> rtt_var_k = rtt_var * k;</div>
<div class="line"><a id="l03576" name="l03576"></a><span class="lineno"> 3576</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> srtt_plus_var_term = srtt + max(clock_resolution_at_least, rtt_var_k);</div>
<div class="line"><a id="l03577" name="l03577"></a><span class="lineno"> 3577</span>  dto = max(srtt_plus_var_term, floor);</div>
<div class="line"><a id="l03578" name="l03578"></a><span class="lineno"> 3578</span>  dto = min(dto, ceiling);</div>
<div class="line"><a id="l03579" name="l03579"></a><span class="lineno"> 3579</span> </div>
<div class="line"><a id="l03580" name="l03580"></a><span class="lineno"> 3580</span>  <span class="comment">// Truncate results to millisecond representation for readability.</span></div>
<div class="line"><a id="l03581" name="l03581"></a><span class="lineno"> 3581</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Drop Timeout (DTO) calculation: &quot;</span></div>
<div class="line"><a id="l03582" name="l03582"></a><span class="lineno"> 3582</span>                 <span class="stringliteral">&quot;dto = [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(dto) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; dto &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03583" name="l03583"></a><span class="lineno"> 3583</span>                 <span class="stringliteral">&quot;rtt_var * k = [&quot;</span> &lt;&lt; rtt_var_k &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03584" name="l03584"></a><span class="lineno"> 3584</span>                 <span class="stringliteral">&quot;srtt + max(G, rtt_var * k) = [&quot;</span> &lt;&lt; srtt_plus_var_term &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03585" name="l03585"></a><span class="lineno"> 3585</span>                 <span class="stringliteral">&quot;k = [&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03586" name="l03586"></a><span class="lineno"> 3586</span>                 <span class="stringliteral">&quot;floor = [&quot;</span> &lt;&lt; floor &lt;&lt; <span class="stringliteral">&quot;]; ceiling = [&quot;</span> &lt;&lt; ceiling &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03587" name="l03587"></a><span class="lineno"> 3587</span>                 <span class="stringliteral">&quot;clock_resolution = [&quot;</span> &lt;&lt; clock_resolution_at_least &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03588" name="l03588"></a><span class="lineno"> 3588</span>                 <span class="stringliteral">&quot;prev_dto = [&quot;</span> &lt;&lt; prev_dto &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03589" name="l03589"></a><span class="lineno"> 3589</span>} <span class="comment">// void Node::new_round_trip_time_sample()</span></div>
<div class="line"><a id="l03590" name="l03590"></a><span class="lineno"> 3590</span> </div>
<div class="line"><a id="l03591" name="l03591"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa"> 3591</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">Node::log_snd_window</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <span class="keywordtype">bool</span> force_verbose_info_logging)<span class="keyword"> const</span></div>
<div class="line"><a id="l03592" name="l03592"></a><span class="lineno"> 3592</span><span class="keyword"></span>{</div>
<div class="line"><a id="l03593" name="l03593"></a><span class="lineno"> 3593</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l03594" name="l03594"></a><span class="lineno"> 3594</span>  <span class="keyword">using </span>std::list;</div>
<div class="line"><a id="l03595" name="l03595"></a><span class="lineno"> 3595</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l03596" name="l03596"></a><span class="lineno"> 3596</span>  <span class="keyword">using </span>boost::algorithm::join;</div>
<div class="line"><a id="l03597" name="l03597"></a><span class="lineno"> 3597</span>  <span class="keyword">using </span>boost::prior;</div>
<div class="line"><a id="l03598" name="l03598"></a><span class="lineno"> 3598</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l03599" name="l03599"></a><span class="lineno"> 3599</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l03600" name="l03600"></a><span class="lineno"> 3600</span> </div>
<div class="line"><a id="l03601" name="l03601"></a><span class="lineno"> 3601</span>  <span class="comment">// We&#39;re in thread W.</span></div>
<div class="line"><a id="l03602" name="l03602"></a><span class="lineno"> 3602</span> </div>
<div class="line"><a id="l03603" name="l03603"></a><span class="lineno"> 3603</span>  <span class="comment">// For brevity and a little speed:</span></div>
<div class="line"><a id="l03604" name="l03604"></a><span class="lineno"> 3604</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; snd_flying_pkts_by_seq = sock-&gt;m_snd_flying_pkts_by_seq_num;</div>
<div class="line"><a id="l03605" name="l03605"></a><span class="lineno"> 3605</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l03606" name="l03606"></a><span class="lineno"> 3606</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_flying_pkts = snd_flying_pkts_by_seq.size();</div>
<div class="line"><a id="l03607" name="l03607"></a><span class="lineno"> 3607</span> </div>
<div class="line"><a id="l03608" name="l03608"></a><span class="lineno"> 3608</span>  <span class="comment">// force_verbose_info_logging =&gt; log the most detail, as INFO (if INFO logging enabled).</span></div>
<div class="line"><a id="l03609" name="l03609"></a><span class="lineno"> 3609</span> </div>
<div class="line"><a id="l03610" name="l03610"></a><span class="lineno"> 3610</span>  <span class="keywordflow">if</span> (snd_flying_pkts_by_seq.empty())</div>
<div class="line"><a id="l03611" name="l03611"></a><span class="lineno"> 3611</span>  {</div>
<div class="line"><a id="l03612" name="l03612"></a><span class="lineno"> 3612</span>    <span class="comment">// No In-flight packets, so this is brief enough for TRACE as opposed to DATA.</span></div>
<div class="line"><a id="l03613" name="l03613"></a><span class="lineno"> 3613</span>    <a class="code hl_define" href="log_8hpp.html#a692bbadd8b5c3e9cef7a0bbea1915e66">FLOW_LOG_WITH_CHECKING</a>(force_verbose_info_logging ? <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a> : <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>,</div>
<div class="line"><a id="l03614" name="l03614"></a><span class="lineno"> 3614</span>                           <span class="stringliteral">&quot;Send window state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: cong_wnd &quot;</span></div>
<div class="line"><a id="l03615" name="l03615"></a><span class="lineno"> 3615</span>                             <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(sock-&gt;m_snd_cong_ctl-&gt;congestion_window_bytes()) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03616" name="l03616"></a><span class="lineno"> 3616</span>                             <span class="stringliteral">&quot;sent+acked/dropped &quot;</span></div>
<div class="line"><a id="l03617" name="l03617"></a><span class="lineno"> 3617</span>                             <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;m_snd_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sock-&gt;m_snd_next_seq_num &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03618" name="l03618"></a><span class="lineno"> 3618</span>                             <span class="stringliteral">&quot;unsent [&quot;</span> &lt;&lt; sock-&gt;m_snd_next_seq_num &lt;&lt; <span class="stringliteral">&quot;, ...).&quot;</span>);</div>
<div class="line"><a id="l03619" name="l03619"></a><span class="lineno"> 3619</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03620" name="l03620"></a><span class="lineno"> 3620</span>  }</div>
<div class="line"><a id="l03621" name="l03621"></a><span class="lineno"> 3621</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03622" name="l03622"></a><span class="lineno"> 3622</span> </div>
<div class="line"><a id="l03623" name="l03623"></a><span class="lineno"> 3623</span>  <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l03624" name="l03624"></a><span class="lineno"> 3624</span>  <span class="keywordflow">if</span> (((!logger_ptr) || (!logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))) &amp;&amp;</div>
<div class="line"><a id="l03625" name="l03625"></a><span class="lineno"> 3625</span>      (!(force_verbose_info_logging &amp;&amp; logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))))</div>
<div class="line"><a id="l03626" name="l03626"></a><span class="lineno"> 3626</span>  {</div>
<div class="line"><a id="l03627" name="l03627"></a><span class="lineno"> 3627</span>    <span class="comment">// Can&#39;t print entire In-flight data structure, but can print a summary, if TRACE enabled.</span></div>
<div class="line"><a id="l03628" name="l03628"></a><span class="lineno"> 3628</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div>
<div class="line"><a id="l03629" name="l03629"></a><span class="lineno"> 3629</span>      (<span class="stringliteral">&quot;Send window state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: cong_wnd &quot;</span></div>
<div class="line"><a id="l03630" name="l03630"></a><span class="lineno"> 3630</span>       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(sock-&gt;m_snd_cong_ctl-&gt;congestion_window_bytes()) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03631" name="l03631"></a><span class="lineno"> 3631</span>       <span class="stringliteral">&quot;sent+acked/dropped [&quot;</span> &lt;&lt; sock-&gt;m_snd_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; snd_flying_pkts_by_seq.begin()-&gt;first &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03632" name="l03632"></a><span class="lineno"> 3632</span>       <span class="stringliteral">&quot;in-flight [&quot;</span> &lt;&lt; sock-&gt;m_snd_flying_bytes &lt;&lt; <span class="stringliteral">&quot;] bytes: &quot;</span> &lt;&lt; num_flying_pkts &lt;&lt; <span class="stringliteral">&quot;:{...} &quot;</span></div>
<div class="line"><a id="l03633" name="l03633"></a><span class="lineno"> 3633</span>       <span class="stringliteral">&quot;unsent [&quot;</span> &lt;&lt; sock-&gt;m_snd_next_seq_num &lt;&lt; <span class="stringliteral">&quot;, ...).&quot;</span>);</div>
<div class="line"><a id="l03634" name="l03634"></a><span class="lineno"> 3634</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03635" name="l03635"></a><span class="lineno"> 3635</span>  }</div>
<div class="line"><a id="l03636" name="l03636"></a><span class="lineno"> 3636</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03637" name="l03637"></a><span class="lineno"> 3637</span> </div>
<div class="line"><a id="l03638" name="l03638"></a><span class="lineno"> 3638</span>  <span class="comment">// Very verbose and slow!</span></div>
<div class="line"><a id="l03639" name="l03639"></a><span class="lineno"> 3639</span> </div>
<div class="line"><a id="l03640" name="l03640"></a><span class="lineno"> 3640</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l03641" name="l03641"></a><span class="lineno"> 3641</span> </div>
<div class="line"><a id="l03642" name="l03642"></a><span class="lineno"> 3642</span>  vector&lt;string&gt; pkt_strs;</div>
<div class="line"><a id="l03643" name="l03643"></a><span class="lineno"> 3643</span>  pkt_strs.reserve(num_flying_pkts);</div>
<div class="line"><a id="l03644" name="l03644"></a><span class="lineno"> 3644</span>  <span class="keywordflow">for</span> (<a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">Peer_socket::Sent_pkt_ordered_by_seq_const_iter</a> pkt_it_it = snd_flying_pkts_by_seq.begin();</div>
<div class="line"><a id="l03645" name="l03645"></a><span class="lineno"> 3645</span>       pkt_it_it != snd_flying_pkts_by_seq.end();</div>
<div class="line"><a id="l03646" name="l03646"></a><span class="lineno"> 3646</span>       ++pkt_it_it)</div>
<div class="line"><a id="l03647" name="l03647"></a><span class="lineno"> 3647</span>  {</div>
<div class="line"><a id="l03648" name="l03648"></a><span class="lineno"> 3648</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> start, end;</div>
<div class="line"><a id="l03649" name="l03649"></a><span class="lineno"> 3649</span>    get_seq_num_range(pkt_it_it-&gt;second, &amp;start, &amp;end);</div>
<div class="line"><a id="l03650" name="l03650"></a><span class="lineno"> 3650</span> </div>
<div class="line"><a id="l03651" name="l03651"></a><span class="lineno"> 3651</span>    <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> sent_pkt = pkt_it_it-&gt;second-&gt;second;</div>
<div class="line"><a id="l03652" name="l03652"></a><span class="lineno"> 3652</span> </div>
<div class="line"><a id="l03653" name="l03653"></a><span class="lineno"> 3653</span>    String_ostream pkt_str_os;</div>
<div class="line"><a id="l03654" name="l03654"></a><span class="lineno"> 3654</span>    pkt_str_os.os() &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; start;</div>
<div class="line"><a id="l03655" name="l03655"></a><span class="lineno"> 3655</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l03656" name="l03656"></a><span class="lineno"> 3656</span>    {</div>
<div class="line"><a id="l03657" name="l03657"></a><span class="lineno"> 3657</span>      pkt_str_os.os() &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; int(sent_pkt-&gt;m_packet-&gt;m_rexmit_id) &lt;&lt; <span class="charliteral">&#39;/&#39;</span> &lt;&lt; sent_pkt-&gt;m_sent_when.back().m_order_num</div>
<div class="line"><a id="l03658" name="l03658"></a><span class="lineno"> 3658</span>                      &lt;&lt; <span class="stringliteral">&quot;], &quot;</span>;</div>
<div class="line"><a id="l03659" name="l03659"></a><span class="lineno"> 3659</span>    }</div>
<div class="line"><a id="l03660" name="l03660"></a><span class="lineno"> 3660</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l03661" name="l03661"></a><span class="lineno"> 3661</span>    {</div>
<div class="line"><a id="l03662" name="l03662"></a><span class="lineno"> 3662</span>      pkt_str_os.os() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a id="l03663" name="l03663"></a><span class="lineno"> 3663</span>    }</div>
<div class="line"><a id="l03664" name="l03664"></a><span class="lineno"> 3664</span>    pkt_str_os.os() &lt;&lt; end &lt;&lt; <span class="stringliteral">&quot;)&lt;&quot;</span> &lt;&lt; sent_pkt-&gt;m_acks_after_me &lt;&lt; <span class="stringliteral">&quot;acks&quot;</span> &lt;&lt; flush;</div>
<div class="line"><a id="l03665" name="l03665"></a><span class="lineno"> 3665</span> </div>
<div class="line"><a id="l03666" name="l03666"></a><span class="lineno"> 3666</span>    pkt_strs.push_back(pkt_str_os.str());</div>
<div class="line"><a id="l03667" name="l03667"></a><span class="lineno"> 3667</span>  }</div>
<div class="line"><a id="l03668" name="l03668"></a><span class="lineno"> 3668</span> </div>
<div class="line"><a id="l03669" name="l03669"></a><span class="lineno"> 3669</span>  <a class="code hl_define" href="log_8hpp.html#a5daa2b6d16edea74bb8bddc75f7fb801">FLOW_LOG_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03670" name="l03670"></a><span class="lineno"> 3670</span>    (force_verbose_info_logging ? <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a> : <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>,</div>
<div class="line"><a id="l03671" name="l03671"></a><span class="lineno"> 3671</span>     <span class="stringliteral">&quot;Send window state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: cong_wnd &quot;</span></div>
<div class="line"><a id="l03672" name="l03672"></a><span class="lineno"> 3672</span>       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(sock-&gt;m_snd_cong_ctl-&gt;congestion_window_bytes()) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03673" name="l03673"></a><span class="lineno"> 3673</span>       <span class="stringliteral">&quot;sent+acked/dropped [&quot;</span> &lt;&lt; sock-&gt;m_snd_init_seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; snd_flying_pkts_by_seq.begin()-&gt;first &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03674" name="l03674"></a><span class="lineno"> 3674</span>       <span class="stringliteral">&quot;in-flight &quot;</span></div>
<div class="line"><a id="l03675" name="l03675"></a><span class="lineno"> 3675</span>       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;m_snd_flying_bytes &lt;&lt; <span class="stringliteral">&quot;] bytes: &quot;</span> &lt;&lt; num_flying_pkts &lt;&lt; <span class="stringliteral">&quot;:{&quot;</span> &lt;&lt; join(pkt_strs, <span class="stringliteral">&quot; &quot;</span>) &lt;&lt;</div>
<div class="line"><a id="l03676" name="l03676"></a><span class="lineno"> 3676</span>       <span class="stringliteral">&quot;} unsent [&quot;</span> &lt;&lt; sock-&gt;m_snd_next_seq_num &lt;&lt; <span class="stringliteral">&quot;, ...).&quot;</span>);</div>
<div class="line"><a id="l03677" name="l03677"></a><span class="lineno"> 3677</span> </div>
<div class="line"><a id="l03678" name="l03678"></a><span class="lineno"> 3678</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a>)</div>
<div class="line"><a id="l03679" name="l03679"></a><span class="lineno"> 3679</span>  {</div>
<div class="line"><a id="l03680" name="l03680"></a><span class="lineno"> 3680</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03681" name="l03681"></a><span class="lineno"> 3681</span>  }</div>
<div class="line"><a id="l03682" name="l03682"></a><span class="lineno"> 3682</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03683" name="l03683"></a><span class="lineno"> 3683</span> </div>
<div class="line"><a id="l03684" name="l03684"></a><span class="lineno"> 3684</span>  <span class="comment">// Since retransmission is on, also useful to show the packets sorted by when they were sent.</span></div>
<div class="line"><a id="l03685" name="l03685"></a><span class="lineno"> 3685</span> </div>
<div class="line"><a id="l03686" name="l03686"></a><span class="lineno"> 3686</span>  vector&lt;string&gt; pkt_strs_time;</div>
<div class="line"><a id="l03687" name="l03687"></a><span class="lineno"> 3687</span>  pkt_strs_time.reserve(num_flying_pkts);</div>
<div class="line"><a id="l03688" name="l03688"></a><span class="lineno"> 3688</span>  <span class="comment">// Note I don&#39;t use `auto` only for clarity (to express it is a reverse iterator, hence why didn&#39;t use for(:)).</span></div>
<div class="line"><a id="l03689" name="l03689"></a><span class="lineno"> 3689</span>  <span class="keywordflow">for</span> (<a class="code hl_typedef" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Peer_socket::Sent_pkt_by_sent_when_map::Const_reverse_iterator</a> pkt_it = snd_flying_pkts_by_when.const_oldest();</div>
<div class="line"><a id="l03690" name="l03690"></a><span class="lineno"> 3690</span>       pkt_it != snd_flying_pkts_by_when.const_past_newest();</div>
<div class="line"><a id="l03691" name="l03691"></a><span class="lineno"> 3691</span>       ++pkt_it)</div>
<div class="line"><a id="l03692" name="l03692"></a><span class="lineno"> 3692</span>  {</div>
<div class="line"><a id="l03693" name="l03693"></a><span class="lineno"> 3693</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> start, end;</div>
<div class="line"><a id="l03694" name="l03694"></a><span class="lineno"> 3694</span>    <span class="comment">// The forward iterator F pointing to same list element as reverse iterator R is prior(R.base()) [sic].  Google it.</span></div>
<div class="line"><a id="l03695" name="l03695"></a><span class="lineno"> 3695</span>    get_seq_num_range(prior(pkt_it.base()), &amp;start, &amp;end);</div>
<div class="line"><a id="l03696" name="l03696"></a><span class="lineno"> 3696</span> </div>
<div class="line"><a id="l03697" name="l03697"></a><span class="lineno"> 3697</span>    <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> sent_pkt = pkt_it-&gt;second;</div>
<div class="line"><a id="l03698" name="l03698"></a><span class="lineno"> 3698</span> </div>
<div class="line"><a id="l03699" name="l03699"></a><span class="lineno"> 3699</span>    <span class="keywordtype">string</span> pkt_str;</div>
<div class="line"><a id="l03700" name="l03700"></a><span class="lineno"> 3700</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#a8afd30c50bcd670d45442df49d1da484">util::ostream_op_to_string</a>(&amp;pkt_str,</div>
<div class="line"><a id="l03701" name="l03701"></a><span class="lineno"> 3701</span>                               start, <span class="charliteral">&#39;[&#39;</span>, <span class="keywordtype">int</span>(sent_pkt-&gt;m_packet-&gt;m_rexmit_id), <span class="charliteral">&#39;/&#39;</span>,</div>
<div class="line"><a id="l03702" name="l03702"></a><span class="lineno"> 3702</span>                               sent_pkt-&gt;m_sent_when.back().m_order_num, <span class="stringliteral">&quot;], &quot;</span>, end, <span class="stringliteral">&quot;)&lt;&quot;</span>,</div>
<div class="line"><a id="l03703" name="l03703"></a><span class="lineno"> 3703</span>                               sent_pkt-&gt;m_acks_after_me, <span class="stringliteral">&quot;acks&quot;</span>);</div>
<div class="line"><a id="l03704" name="l03704"></a><span class="lineno"> 3704</span>    pkt_strs_time.push_back(pkt_str);</div>
<div class="line"><a id="l03705" name="l03705"></a><span class="lineno"> 3705</span>  }</div>
<div class="line"><a id="l03706" name="l03706"></a><span class="lineno"> 3706</span> </div>
<div class="line"><a id="l03707" name="l03707"></a><span class="lineno"> 3707</span>  <span class="comment">// Log it only if it is different (only possible if some retransmitted packets are actually involved).</span></div>
<div class="line"><a id="l03708" name="l03708"></a><span class="lineno"> 3708</span>  <span class="keywordflow">if</span> (pkt_strs_time != pkt_strs)</div>
<div class="line"><a id="l03709" name="l03709"></a><span class="lineno"> 3709</span>  {</div>
<div class="line"><a id="l03710" name="l03710"></a><span class="lineno"> 3710</span>    <a class="code hl_define" href="log_8hpp.html#a5daa2b6d16edea74bb8bddc75f7fb801">FLOW_LOG_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03711" name="l03711"></a><span class="lineno"> 3711</span>      (force_verbose_info_logging ? <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a> : <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">log::Sev::S_DATA</a>,</div>
<div class="line"><a id="l03712" name="l03712"></a><span class="lineno"> 3712</span>       <span class="stringliteral">&quot;Sorted by time sent: {&quot;</span> &lt;&lt; join(pkt_strs_time, <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;}.&quot;</span>);</div>
<div class="line"><a id="l03713" name="l03713"></a><span class="lineno"> 3713</span>  }</div>
<div class="line"><a id="l03714" name="l03714"></a><span class="lineno"> 3714</span>} <span class="comment">// Node::log_snd_window()</span></div>
<div class="line"><a id="l03715" name="l03715"></a><span class="lineno"> 3715</span> </div>
<div class="line"><a id="l03716" name="l03716"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8"> 3716</a></span><a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">Node::snd_past_last_flying_datum_seq_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="comment">// Static.</span></div>
<div class="line"><a id="l03717" name="l03717"></a><span class="lineno"> 3717</span>{</div>
<div class="line"><a id="l03718" name="l03718"></a><span class="lineno"> 3718</span>  <span class="keyword">using </span>boost::prior;</div>
<div class="line"><a id="l03719" name="l03719"></a><span class="lineno"> 3719</span> </div>
<div class="line"><a id="l03720" name="l03720"></a><span class="lineno"> 3720</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">Peer_socket::Sent_pkt_by_seq_num_map</a>&amp; flying_packets = sock-&gt;m_snd_flying_pkts_by_seq_num;</div>
<div class="line"><a id="l03721" name="l03721"></a><span class="lineno"> 3721</span>  <span class="keywordflow">if</span> (flying_packets.empty())</div>
<div class="line"><a id="l03722" name="l03722"></a><span class="lineno"> 3722</span>  {</div>
<div class="line"><a id="l03723" name="l03723"></a><span class="lineno"> 3723</span>    <span class="keywordflow">return</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>(); <span class="comment">// Default value.  Less than all others.</span></div>
<div class="line"><a id="l03724" name="l03724"></a><span class="lineno"> 3724</span>  }</div>
<div class="line"><a id="l03725" name="l03725"></a><span class="lineno"> 3725</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03726" name="l03726"></a><span class="lineno"> 3726</span> </div>
<div class="line"><a id="l03727" name="l03727"></a><span class="lineno"> 3727</span>  <span class="comment">// Get the sequence number of the first datum in the last unhandled packet.</span></div>
<div class="line"><a id="l03728" name="l03728"></a><span class="lineno"> 3728</span>  <span class="keyword">const</span> Peer_socket::Sent_pkt_by_seq_num_map::value_type&amp; highest_val = *(prior(flying_packets.end()));</div>
<div class="line"><a id="l03729" name="l03729"></a><span class="lineno"> 3729</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num = highest_val.first;</div>
<div class="line"><a id="l03730" name="l03730"></a><span class="lineno"> 3730</span> </div>
<div class="line"><a id="l03731" name="l03731"></a><span class="lineno"> 3731</span>  <span class="comment">// Advance just past the data in that packet to get what we want.</span></div>
<div class="line"><a id="l03732" name="l03732"></a><span class="lineno"> 3732</span>  advance_seq_num(&amp;seq_num, highest_val.second-&gt;second-&gt;m_size);</div>
<div class="line"><a id="l03733" name="l03733"></a><span class="lineno"> 3733</span> </div>
<div class="line"><a id="l03734" name="l03734"></a><span class="lineno"> 3734</span>  <span class="keywordflow">return</span> seq_num;</div>
<div class="line"><a id="l03735" name="l03735"></a><span class="lineno"> 3735</span>}</div>
<div class="line"><a id="l03736" name="l03736"></a><span class="lineno"> 3736</span> </div>
<div class="line"><a id="l03737" name="l03737"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922"> 3737</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">Node::snd_flying_pkts_erase_one</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> pkt_it)</div>
<div class="line"><a id="l03738" name="l03738"></a><span class="lineno"> 3738</span>{</div>
<div class="line"><a id="l03739" name="l03739"></a><span class="lineno"> 3739</span>  <span class="comment">// using boost::next; // Still ambiguous for some reason (in clang at least).</span></div>
<div class="line"><a id="l03740" name="l03740"></a><span class="lineno"> 3740</span> </div>
<div class="line"><a id="l03741" name="l03741"></a><span class="lineno"> 3741</span>  <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l03742" name="l03742"></a><span class="lineno"> 3742</span>  <span class="keywordflow">if</span> (logger_ptr &amp;&amp; logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>()))</div>
<div class="line"><a id="l03743" name="l03743"></a><span class="lineno"> 3743</span>  {</div>
<div class="line"><a id="l03744" name="l03744"></a><span class="lineno"> 3744</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Peer_socket::Sent_packet</a>&amp; sent_pkt = *pkt_it-&gt;second;</div>
<div class="line"><a id="l03745" name="l03745"></a><span class="lineno"> 3745</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> order_num = sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e">m_sent_when</a>.back().m_order_num;</div>
<div class="line"><a id="l03746" name="l03746"></a><span class="lineno"> 3746</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num, seq_num_end;</div>
<div class="line"><a id="l03747" name="l03747"></a><span class="lineno"> 3747</span>    get_seq_num_range(pkt_it, &amp;seq_num, &amp;seq_num_end);</div>
<div class="line"><a id="l03748" name="l03748"></a><span class="lineno"> 3748</span> </div>
<div class="line"><a id="l03749" name="l03749"></a><span class="lineno"> 3749</span>    <span class="keywordflow">if</span> (sock-&gt;rexmit_on())</div>
<div class="line"><a id="l03750" name="l03750"></a><span class="lineno"> 3750</span>    {</div>
<div class="line"><a id="l03751" name="l03751"></a><span class="lineno"> 3751</span>      <a class="code hl_define" href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03752" name="l03752"></a><span class="lineno"> 3752</span>        (<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] erasing packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03753" name="l03753"></a><span class="lineno"> 3753</span>         <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; order_num &lt;&lt; <span class="stringliteral">&quot;] rexmit_id [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(sent_pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a704afa0007b8354ad78acad64d029ecf">m_packet</a>-&gt;m_rexmit_id) &lt;&lt; <span class="stringliteral">&quot;] from &quot;</span></div>
<div class="line"><a id="l03754" name="l03754"></a><span class="lineno"> 3754</span>         <span class="stringliteral">&quot;snd_flying_pkts* and friends.&quot;</span>);</div>
<div class="line"><a id="l03755" name="l03755"></a><span class="lineno"> 3755</span>    }</div>
<div class="line"><a id="l03756" name="l03756"></a><span class="lineno"> 3756</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l03757" name="l03757"></a><span class="lineno"> 3757</span>    {</div>
<div class="line"><a id="l03758" name="l03758"></a><span class="lineno"> 3758</span>      <a class="code hl_define" href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03759" name="l03759"></a><span class="lineno"> 3759</span>        (<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] erasing packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03760" name="l03760"></a><span class="lineno"> 3760</span>         <span class="stringliteral">&quot;order_num [&quot;</span> &lt;&lt; order_num &lt;&lt; <span class="stringliteral">&quot;] from snd_flying_pkts* and friends.&quot;</span>);</div>
<div class="line"><a id="l03761" name="l03761"></a><span class="lineno"> 3761</span>    }</div>
<div class="line"><a id="l03762" name="l03762"></a><span class="lineno"> 3762</span>  }</div>
<div class="line"><a id="l03763" name="l03763"></a><span class="lineno"> 3763</span> </div>
<div class="line"><a id="l03764" name="l03764"></a><span class="lineno"> 3764</span>  <span class="comment">// Update byte count.</span></div>
<div class="line"><a id="l03765" name="l03765"></a><span class="lineno"> 3765</span>  snd_flying_pkts_updated(sock, pkt_it, boost::next(pkt_it), <span class="keyword">false</span>);</div>
<div class="line"><a id="l03766" name="l03766"></a><span class="lineno"> 3766</span> </div>
<div class="line"><a id="l03767" name="l03767"></a><span class="lineno"> 3767</span>  <span class="comment">// Finally erase from main structures.</span></div>
<div class="line"><a id="l03768" name="l03768"></a><span class="lineno"> 3768</span>  sock-&gt;m_snd_flying_pkts_by_seq_num.erase(pkt_it-&gt;first);</div>
<div class="line"><a id="l03769" name="l03769"></a><span class="lineno"> 3769</span>  sock-&gt;m_snd_flying_pkts_by_sent_when.erase(pkt_it);</div>
<div class="line"><a id="l03770" name="l03770"></a><span class="lineno"> 3770</span> </div>
<div class="line"><a id="l03771" name="l03771"></a><span class="lineno"> 3771</span>  <span class="comment">// Note: As advertsied, we do NOT inform sock-&gt;m_snd_drop_timer.  It is up to the caller to do the right thing there.</span></div>
<div class="line"><a id="l03772" name="l03772"></a><span class="lineno"> 3772</span>}</div>
<div class="line"><a id="l03773" name="l03773"></a><span class="lineno"> 3773</span> </div>
<div class="line"><a id="l03774" name="l03774"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062"> 3774</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">Node::snd_flying_pkts_push_one</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03775" name="l03775"></a><span class="lineno"> 3775</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num,</div>
<div class="line"><a id="l03776" name="l03776"></a><span class="lineno"> 3776</span>                                    <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> sent_pkt)</div>
<div class="line"><a id="l03777" name="l03777"></a><span class="lineno"> 3777</span>{</div>
<div class="line"><a id="l03778" name="l03778"></a><span class="lineno"> 3778</span>  <span class="keyword">using </span>std::pair;</div>
<div class="line"><a id="l03779" name="l03779"></a><span class="lineno"> 3779</span>  <span class="keyword">using </span>std::make_pair;</div>
<div class="line"><a id="l03780" name="l03780"></a><span class="lineno"> 3780</span>  <span class="comment">// using boost::next; // Still ambiguous for some reason (in clang at least).</span></div>
<div class="line"><a id="l03781" name="l03781"></a><span class="lineno"> 3781</span> </div>
<div class="line"><a id="l03782" name="l03782"></a><span class="lineno"> 3782</span>  <span class="comment">// For brevity and a bit of speed:</span></div>
<div class="line"><a id="l03783" name="l03783"></a><span class="lineno"> 3783</span>  <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l03784" name="l03784"></a><span class="lineno"> 3784</span> </div>
<div class="line"><a id="l03785" name="l03785"></a><span class="lineno"> 3785</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03786" name="l03786"></a><span class="lineno"> 3786</span>  <span class="keyword">const</span> <span class="keyword">auto</span> insert_result =</div>
<div class="line"><a id="l03787" name="l03787"></a><span class="lineno"> 3787</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03788" name="l03788"></a><span class="lineno"> 3788</span>    snd_flying_pkts_by_when.insert(make_pair(seq_num, sent_pkt));</div>
<div class="line"><a id="l03789" name="l03789"></a><span class="lineno"> 3789</span> </div>
<div class="line"><a id="l03790" name="l03790"></a><span class="lineno"> 3790</span>  <span class="comment">// In this map, last added (a/k/a last sent) packet = first in the ordering!</span></div>
<div class="line"><a id="l03791" name="l03791"></a><span class="lineno"> 3791</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; pkt_it = snd_flying_pkts_by_when.begin();</div>
<div class="line"><a id="l03792" name="l03792"></a><span class="lineno"> 3792</span>  assert(insert_result.second); <span class="comment">// Sequence numbers must not repeat ever.</span></div>
<div class="line"><a id="l03793" name="l03793"></a><span class="lineno"> 3793</span>  assert(insert_result.first == pkt_it); <span class="comment">// Check that just-inserted element is ordered at the start.</span></div>
<div class="line"><a id="l03794" name="l03794"></a><span class="lineno"> 3794</span> </div>
<div class="line"><a id="l03795" name="l03795"></a><span class="lineno"> 3795</span>  snd_flying_pkts_updated(sock, pkt_it, boost::next(pkt_it), <span class="keyword">true</span>); <span class="comment">// Update byte count.</span></div>
<div class="line"><a id="l03796" name="l03796"></a><span class="lineno"> 3796</span> </div>
<div class="line"><a id="l03797" name="l03797"></a><span class="lineno"> 3797</span>  <span class="comment">// Accordingly, insert packet (in the form of iterator into the above map) into sequence-number-ordered &quot;scoreboard.&quot;</span></div>
<div class="line"><a id="l03798" name="l03798"></a><span class="lineno"> 3798</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03799" name="l03799"></a><span class="lineno"> 3799</span>  <span class="keyword">const</span> <span class="keyword">auto</span> insert_result_by_seq =</div>
<div class="line"><a id="l03800" name="l03800"></a><span class="lineno"> 3800</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03801" name="l03801"></a><span class="lineno"> 3801</span>    sock-&gt;m_snd_flying_pkts_by_seq_num.insert(make_pair(seq_num, pkt_it));</div>
<div class="line"><a id="l03802" name="l03802"></a><span class="lineno"> 3802</span> </div>
<div class="line"><a id="l03803" name="l03803"></a><span class="lineno"> 3803</span>  <span class="comment">// Check invariant: Key X is in ..._by_sent_when &lt;=&gt; key X is in ..._by_seq_num.</span></div>
<div class="line"><a id="l03804" name="l03804"></a><span class="lineno"> 3804</span>  assert(insert_result_by_seq.second);</div>
<div class="line"><a id="l03805" name="l03805"></a><span class="lineno"> 3805</span> </div>
<div class="line"><a id="l03806" name="l03806"></a><span class="lineno"> 3806</span>  <span class="comment">/* Caution: As noted in the doc header for this method, note that while we&#39;ve already inserted sent_pkt into</span></div>
<div class="line"><a id="l03807" name="l03807"></a><span class="lineno"> 3807</span><span class="comment">   * snd_flying_pkts_by_when, the actual value of sent_pkt-&gt;m_sent_when.back() -- the absolute &quot;when&quot; -- isn&#39;t ready.</span></div>
<div class="line"><a id="l03808" name="l03808"></a><span class="lineno"> 3808</span><span class="comment">   * It will only be finalized once we actually send off the packet (after pacing, if any), in mark_data_packet_sent().</span></div>
<div class="line"><a id="l03809" name="l03809"></a><span class="lineno"> 3809</span><span class="comment">   * Nevertheless, we know the packet will be sent sometime fairly soon; and in fact AFTER all the packets</span></div>
<div class="line"><a id="l03810" name="l03810"></a><span class="lineno"> 3810</span><span class="comment">   * following it it in snd_flying_pkts_by_when&#39;s iterator ordering and in fact BEFORE any packets that</span></div>
<div class="line"><a id="l03811" name="l03811"></a><span class="lineno"> 3811</span><span class="comment">   * would be subsequently ahead of it in snd_flying_pkts_by_when&#39;s iterator ordering.  That is, we can</span></div>
<div class="line"><a id="l03812" name="l03812"></a><span class="lineno"> 3812</span><span class="comment">   * place it there now, despite not knowing the _absolute_ time when it be sent, because we are confident about</span></div>
<div class="line"><a id="l03813" name="l03813"></a><span class="lineno"> 3813</span><span class="comment">   * its _relative_ order of when it will be sent vs. all the other packets in that structure, past or future. */</span></div>
<div class="line"><a id="l03814" name="l03814"></a><span class="lineno"> 3814</span> </div>
<div class="line"><a id="l03815" name="l03815"></a><span class="lineno"> 3815</span>  <span class="comment">// Everything following this point is logging only.</span></div>
<div class="line"><a id="l03816" name="l03816"></a><span class="lineno"> 3816</span> </div>
<div class="line"><a id="l03817" name="l03817"></a><span class="lineno"> 3817</span>  <span class="keyword">auto</span> <span class="keyword">const</span> logger_ptr = <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>();</div>
<div class="line"><a id="l03818" name="l03818"></a><span class="lineno"> 3818</span>  <span class="keywordflow">if</span> ((!logger_ptr) || (!logger_ptr-&gt;should_log(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a>())))</div>
<div class="line"><a id="l03819" name="l03819"></a><span class="lineno"> 3819</span>  {</div>
<div class="line"><a id="l03820" name="l03820"></a><span class="lineno"> 3820</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03821" name="l03821"></a><span class="lineno"> 3821</span>  }</div>
<div class="line"><a id="l03822" name="l03822"></a><span class="lineno"> 3822</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03823" name="l03823"></a><span class="lineno"> 3823</span> </div>
<div class="line"><a id="l03824" name="l03824"></a><span class="lineno"> 3824</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num_end;</div>
<div class="line"><a id="l03825" name="l03825"></a><span class="lineno"> 3825</span>  get_seq_num_range(pkt_it, 0, &amp;seq_num_end);</div>
<div class="line"><a id="l03826" name="l03826"></a><span class="lineno"> 3826</span>  <span class="keywordflow">if</span> (sock-&gt;rexmit_on())</div>
<div class="line"><a id="l03827" name="l03827"></a><span class="lineno"> 3827</span>  {</div>
<div class="line"><a id="l03828" name="l03828"></a><span class="lineno"> 3828</span>    <a class="code hl_define" href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03829" name="l03829"></a><span class="lineno"> 3829</span>      (<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] pushing packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03830" name="l03830"></a><span class="lineno"> 3830</span>       <span class="stringliteral">&quot;rexmit_id [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(sent_pkt-&gt;m_packet-&gt;m_rexmit_id) &lt;&lt; <span class="stringliteral">&quot;] onto snd_flying_pkts and friends.&quot;</span>);</div>
<div class="line"><a id="l03831" name="l03831"></a><span class="lineno"> 3831</span>  }</div>
<div class="line"><a id="l03832" name="l03832"></a><span class="lineno"> 3832</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03833" name="l03833"></a><span class="lineno"> 3833</span>  {</div>
<div class="line"><a id="l03834" name="l03834"></a><span class="lineno"> 3834</span>    <a class="code hl_define" href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div>
<div class="line"><a id="l03835" name="l03835"></a><span class="lineno"> 3835</span>      (<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] pushing packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a id="l03836" name="l03836"></a><span class="lineno"> 3836</span>       <span class="stringliteral">&quot;onto snd_flying_pkts and friends.&quot;</span>);</div>
<div class="line"><a id="l03837" name="l03837"></a><span class="lineno"> 3837</span>  }</div>
<div class="line"><a id="l03838" name="l03838"></a><span class="lineno"> 3838</span>}</div>
<div class="line"><a id="l03839" name="l03839"></a><span class="lineno"> 3839</span> </div>
<div class="line"><a id="l03840" name="l03840"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe"> 3840</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">Node::snd_flying_pkts_updated</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03841" name="l03841"></a><span class="lineno"> 3841</span>                                   <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> pkt_begin,</div>
<div class="line"><a id="l03842" name="l03842"></a><span class="lineno"> 3842</span>                                   <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a>&amp; pkt_end,</div>
<div class="line"><a id="l03843" name="l03843"></a><span class="lineno"> 3843</span>                                   <span class="keywordtype">bool</span> added)</div>
<div class="line"><a id="l03844" name="l03844"></a><span class="lineno"> 3844</span>{</div>
<div class="line"><a id="l03845" name="l03845"></a><span class="lineno"> 3845</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l03846" name="l03846"></a><span class="lineno"> 3846</span> </div>
<div class="line"><a id="l03847" name="l03847"></a><span class="lineno"> 3847</span>  <span class="keywordflow">if</span> (pkt_begin == pkt_end)</div>
<div class="line"><a id="l03848" name="l03848"></a><span class="lineno"> 3848</span>  {</div>
<div class="line"><a id="l03849" name="l03849"></a><span class="lineno"> 3849</span>    <span class="keywordflow">return</span>; <span class="comment">// Wouldn&#39;t do anything anyway, but return here to avoid logging.</span></div>
<div class="line"><a id="l03850" name="l03850"></a><span class="lineno"> 3850</span>  }</div>
<div class="line"><a id="l03851" name="l03851"></a><span class="lineno"> 3851</span> </div>
<div class="line"><a id="l03852" name="l03852"></a><span class="lineno"> 3852</span>  <span class="comment">// For brevity and a bit of speed:</span></div>
<div class="line"><a id="l03853" name="l03853"></a><span class="lineno"> 3853</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; snd_flying_pkts_by_when = sock-&gt;m_snd_flying_pkts_by_sent_when;</div>
<div class="line"><a id="l03854" name="l03854"></a><span class="lineno"> 3854</span>  <span class="keywordtype">size_t</span>&amp; snd_flying_bytes = sock-&gt;m_snd_flying_bytes;</div>
<div class="line"><a id="l03855" name="l03855"></a><span class="lineno"> 3855</span> </div>
<div class="line"><a id="l03856" name="l03856"></a><span class="lineno"> 3856</span>  <span class="comment">// Optimization for when they effectively clear() snd_flying_pkts* (e.g., possibly on Drop Timeout):</span></div>
<div class="line"><a id="l03857" name="l03857"></a><span class="lineno"> 3857</span>  <span class="keywordflow">if</span> ((!added)</div>
<div class="line"><a id="l03858" name="l03858"></a><span class="lineno"> 3858</span>      &amp;&amp; (pkt_begin == snd_flying_pkts_by_when.const_newest())</div>
<div class="line"><a id="l03859" name="l03859"></a><span class="lineno"> 3859</span>      &amp;&amp; (pkt_end == snd_flying_pkts_by_when.const_past_oldest()))</div>
<div class="line"><a id="l03860" name="l03860"></a><span class="lineno"> 3860</span>  {</div>
<div class="line"><a id="l03861" name="l03861"></a><span class="lineno"> 3861</span>    snd_flying_bytes = 0;</div>
<div class="line"><a id="l03862" name="l03862"></a><span class="lineno"> 3862</span>  }</div>
<div class="line"><a id="l03863" name="l03863"></a><span class="lineno"> 3863</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03864" name="l03864"></a><span class="lineno"> 3864</span>  {</div>
<div class="line"><a id="l03865" name="l03865"></a><span class="lineno"> 3865</span>    <span class="keywordtype">size_t</span> delta_bytes = 0;</div>
<div class="line"><a id="l03866" name="l03866"></a><span class="lineno"> 3866</span>    <span class="keywordflow">for</span> ( ; pkt_begin != pkt_end; ++pkt_begin)</div>
<div class="line"><a id="l03867" name="l03867"></a><span class="lineno"> 3867</span>    {</div>
<div class="line"><a id="l03868" name="l03868"></a><span class="lineno"> 3868</span>      delta_bytes += pkt_begin-&gt;second-&gt;m_size;</div>
<div class="line"><a id="l03869" name="l03869"></a><span class="lineno"> 3869</span>    }</div>
<div class="line"><a id="l03870" name="l03870"></a><span class="lineno"> 3870</span>    added ? (snd_flying_bytes += delta_bytes) : (snd_flying_bytes -= delta_bytes);</div>
<div class="line"><a id="l03871" name="l03871"></a><span class="lineno"> 3871</span>  }</div>
<div class="line"><a id="l03872" name="l03872"></a><span class="lineno"> 3872</span> </div>
<div class="line"><a id="l03873" name="l03873"></a><span class="lineno"> 3873</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;cong_ctl [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] update: &quot;</span></div>
<div class="line"><a id="l03874" name="l03874"></a><span class="lineno"> 3874</span>                 <span class="stringliteral">&quot;In-flight [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(snd_flying_bytes) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03875" name="l03875"></a><span class="lineno"> 3875</span>}</div>
<div class="line"><a id="l03876" name="l03876"></a><span class="lineno"> 3876</span> </div>
<div class="line"><a id="l03877" name="l03877"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25"> 3877</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">Node::ok_to_rexmit_or_close</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03878" name="l03878"></a><span class="lineno"> 3878</span>                                 <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; pkt_it,</div>
<div class="line"><a id="l03879" name="l03879"></a><span class="lineno"> 3879</span>                                 <span class="keywordtype">bool</span> defer_delta_check)</div>
<div class="line"><a id="l03880" name="l03880"></a><span class="lineno"> 3880</span>{</div>
<div class="line"><a id="l03881" name="l03881"></a><span class="lineno"> 3881</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Peer_socket::Sent_packet</a>&amp; pkt = *pkt_it-&gt;second;</div>
<div class="line"><a id="l03882" name="l03882"></a><span class="lineno"> 3882</span> </div>
<div class="line"><a id="l03883" name="l03883"></a><span class="lineno"> 3883</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> seq_num, seq_num_end;</div>
<div class="line"><a id="l03884" name="l03884"></a><span class="lineno"> 3884</span>  get_seq_num_range(pkt_it, &amp;seq_num, &amp;seq_num_end);</div>
<div class="line"><a id="l03885" name="l03885"></a><span class="lineno"> 3885</span> </div>
<div class="line"><a id="l03886" name="l03886"></a><span class="lineno"> 3886</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rexmit_id = pkt.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a704afa0007b8354ad78acad64d029ecf">m_packet</a>-&gt;m_rexmit_id;</div>
<div class="line"><a id="l03887" name="l03887"></a><span class="lineno"> 3887</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;On [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] attempting to queue for retransmission &quot;</span></div>
<div class="line"><a id="l03888" name="l03888"></a><span class="lineno"> 3888</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; seq_num_end &lt;&lt; <span class="stringliteral">&quot;] which has been &quot;</span></div>
<div class="line"><a id="l03889" name="l03889"></a><span class="lineno"> 3889</span>                 <span class="stringliteral">&quot;retransmitted [&quot;</span> &lt;&lt; rexmit_id &lt;&lt; <span class="stringliteral">&quot;] times so far.&quot;</span>);</div>
<div class="line"><a id="l03890" name="l03890"></a><span class="lineno"> 3890</span>  <span class="keywordflow">if</span> (rexmit_id == sock-&gt;opt(sock-&gt;m_opts.m_st_max_rexmissions_per_packet))</div>
<div class="line"><a id="l03891" name="l03891"></a><span class="lineno"> 3891</span>  {</div>
<div class="line"><a id="l03892" name="l03892"></a><span class="lineno"> 3892</span>    rst_and_close_connection_immediately(socket_id(sock), sock,</div>
<div class="line"><a id="l03893" name="l03893"></a><span class="lineno"> 3893</span>                                         <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3c1dc923491f5e20763fc27d025665d4">error::Code::S_CONN_RESET_TOO_MANY_REXMITS</a>, defer_delta_check);</div>
<div class="line"><a id="l03894" name="l03894"></a><span class="lineno"> 3894</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03895" name="l03895"></a><span class="lineno"> 3895</span>  }</div>
<div class="line"><a id="l03896" name="l03896"></a><span class="lineno"> 3896</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03897" name="l03897"></a><span class="lineno"> 3897</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03898" name="l03898"></a><span class="lineno"> 3898</span>}</div>
<div class="line"><a id="l03899" name="l03899"></a><span class="lineno"> 3899</span> </div>
<div class="line"><a id="l03900" name="l03900"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd"> 3900</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">Node::connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code,</div>
<div class="line"><a id="l03901" name="l03901"></a><span class="lineno"> 3901</span>                               <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts)</div>
<div class="line"><a id="l03902" name="l03902"></a><span class="lineno"> 3902</span>{</div>
<div class="line"><a id="l03903" name="l03903"></a><span class="lineno"> 3903</span>  <span class="keywordflow">return</span> connect_with_metadata(to, boost::asio::buffer(&amp;S_DEFAULT_CONN_METADATA, <span class="keyword">sizeof</span>(S_DEFAULT_CONN_METADATA)),</div>
<div class="line"><a id="l03904" name="l03904"></a><span class="lineno"> 3904</span>                               err_code, opts);</div>
<div class="line"><a id="l03905" name="l03905"></a><span class="lineno"> 3905</span>}</div>
<div class="line"><a id="l03906" name="l03906"></a><span class="lineno"> 3906</span> </div>
<div class="line"><a id="l03907" name="l03907"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a"> 3907</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">Node::connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l03908" name="l03908"></a><span class="lineno"> 3908</span>                                             <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l03909" name="l03909"></a><span class="lineno"> 3909</span>                                             <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code,</div>
<div class="line"><a id="l03910" name="l03910"></a><span class="lineno"> 3910</span>                                             <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* sock_opts)</div>
<div class="line"><a id="l03911" name="l03911"></a><span class="lineno"> 3911</span>{</div>
<div class="line"><a id="l03912" name="l03912"></a><span class="lineno"> 3912</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>, connect_with_metadata, to, serialized_metadata, _1, sock_opts);</div>
<div class="line"><a id="l03913" name="l03913"></a><span class="lineno"> 3913</span>  <span class="comment">// ^-- Call ourselves and return if err_code is null.  If got to present line, err_code is not null.</span></div>
<div class="line"><a id="l03914" name="l03914"></a><span class="lineno"> 3914</span> </div>
<div class="line"><a id="l03915" name="l03915"></a><span class="lineno"> 3915</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">async::asio_exec_ctx_post</a>;</div>
<div class="line"><a id="l03916" name="l03916"></a><span class="lineno"> 3916</span>  <span class="keyword">using </span><a class="code hl_enumeration" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">async::Synchronicity</a>;</div>
<div class="line"><a id="l03917" name="l03917"></a><span class="lineno"> 3917</span> </div>
<div class="line"><a id="l03918" name="l03918"></a><span class="lineno"> 3918</span>  <span class="comment">// We are in thread U != W.</span></div>
<div class="line"><a id="l03919" name="l03919"></a><span class="lineno"> 3919</span> </div>
<div class="line"><a id="l03920" name="l03920"></a><span class="lineno"> 3920</span>  <span class="keywordflow">if</span> (!running())</div>
<div class="line"><a id="l03921" name="l03921"></a><span class="lineno"> 3921</span>  {</div>
<div class="line"><a id="l03922" name="l03922"></a><span class="lineno"> 3922</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l03923" name="l03923"></a><span class="lineno"> 3923</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>();</div>
<div class="line"><a id="l03924" name="l03924"></a><span class="lineno"> 3924</span>  }</div>
<div class="line"><a id="l03925" name="l03925"></a><span class="lineno"> 3925</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03926" name="l03926"></a><span class="lineno"> 3926</span> </div>
<div class="line"><a id="l03927" name="l03927"></a><span class="lineno"> 3927</span>  <span class="comment">// If it&#39;s good enough for DATA packets, it&#39;s good enough for metadata in SYN.</span></div>
<div class="line"><a id="l03928" name="l03928"></a><span class="lineno"> 3928</span>  <span class="keywordflow">if</span> (serialized_metadata.size() &gt; <a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a>())</div>
<div class="line"><a id="l03929" name="l03929"></a><span class="lineno"> 3929</span>  {</div>
<div class="line"><a id="l03930" name="l03930"></a><span class="lineno"> 3930</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd">error::Code::S_CONN_METADATA_TOO_LARGE</a>);</div>
<div class="line"><a id="l03931" name="l03931"></a><span class="lineno"> 3931</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>();</div>
<div class="line"><a id="l03932" name="l03932"></a><span class="lineno"> 3932</span>  }</div>
<div class="line"><a id="l03933" name="l03933"></a><span class="lineno"> 3933</span> </div>
<div class="line"><a id="l03934" name="l03934"></a><span class="lineno"> 3934</span>  <span class="comment">/* Put the rest of the work into thread W.  For justification, see big comment in listen().</span></div>
<div class="line"><a id="l03935" name="l03935"></a><span class="lineno"> 3935</span><span class="comment">   * Addendum regarding performance: connect() is probably called more frequently than listen(), but</span></div>
<div class="line"><a id="l03936" name="l03936"></a><span class="lineno"> 3936</span><span class="comment">   * I doubt the performance impact is serious even so.  send() and receive() might be a different</span></div>
<div class="line"><a id="l03937" name="l03937"></a><span class="lineno"> 3937</span><span class="comment">   * story. */</span></div>
<div class="line"><a id="l03938" name="l03938"></a><span class="lineno"> 3938</span> </div>
<div class="line"><a id="l03939" name="l03939"></a><span class="lineno"> 3939</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock;</div>
<div class="line"><a id="l03940" name="l03940"></a><span class="lineno"> 3940</span>  <span class="comment">/* Load this-&gt;connect_worker(...) onto thread W boost.asio work queue.</span></div>
<div class="line"><a id="l03941" name="l03941"></a><span class="lineno"> 3941</span><span class="comment">   * We don&#39;t return until it finishes; therefore it is fine to do total &amp; capture. */</span></div>
<div class="line"><a id="l03942" name="l03942"></a><span class="lineno"> 3942</span>  <a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">asio_exec_ctx_post</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), &amp;m_task_engine, Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION,</div>
<div class="line"><a id="l03943" name="l03943"></a><span class="lineno"> 3943</span>                     [&amp;]() { connect_worker(to, serialized_metadata, sock_opts, &amp;sock); });</div>
<div class="line"><a id="l03944" name="l03944"></a><span class="lineno"> 3944</span>  <span class="comment">// If got here, the task has completed in thread W and signaled us to that effect.</span></div>
<div class="line"><a id="l03945" name="l03945"></a><span class="lineno"> 3945</span> </div>
<div class="line"><a id="l03946" name="l03946"></a><span class="lineno"> 3946</span>  <span class="comment">// connect_worker() indicates success or failure through this data member.</span></div>
<div class="line"><a id="l03947" name="l03947"></a><span class="lineno"> 3947</span>  <span class="keywordflow">if</span> (sock-&gt;m_disconnect_cause)</div>
<div class="line"><a id="l03948" name="l03948"></a><span class="lineno"> 3948</span>  {</div>
<div class="line"><a id="l03949" name="l03949"></a><span class="lineno"> 3949</span>    *err_code = sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l03950" name="l03950"></a><span class="lineno"> 3950</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>(); <span class="comment">// sock will go out of scope and thus will be destroyed.</span></div>
<div class="line"><a id="l03951" name="l03951"></a><span class="lineno"> 3951</span>  }</div>
<div class="line"><a id="l03952" name="l03952"></a><span class="lineno"> 3952</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03953" name="l03953"></a><span class="lineno"> 3953</span>  err_code-&gt;clear();</div>
<div class="line"><a id="l03954" name="l03954"></a><span class="lineno"> 3954</span>  <span class="keywordflow">return</span> sock;</div>
<div class="line"><a id="l03955" name="l03955"></a><span class="lineno"> 3955</span>} <span class="comment">// Node::connect_with_metadata()</span></div>
<div class="line"><a id="l03956" name="l03956"></a><span class="lineno"> 3956</span> </div>
<div class="line"><a id="l03957" name="l03957"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff"> 3957</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">Node::connect_worker</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l03958" name="l03958"></a><span class="lineno"> 3958</span>                          <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* sock_opts,</div>
<div class="line"><a id="l03959" name="l03959"></a><span class="lineno"> 3959</span>                          <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>* sock_ptr)</div>
<div class="line"><a id="l03960" name="l03960"></a><span class="lineno"> 3960</span>{</div>
<div class="line"><a id="l03961" name="l03961"></a><span class="lineno"> 3961</span>  <span class="keyword">using </span>boost::asio::buffer;</div>
<div class="line"><a id="l03962" name="l03962"></a><span class="lineno"> 3962</span>  <span class="keyword">using </span>boost::asio::ip::address;</div>
<div class="line"><a id="l03963" name="l03963"></a><span class="lineno"> 3963</span> </div>
<div class="line"><a id="l03964" name="l03964"></a><span class="lineno"> 3964</span>  assert(sock_ptr);</div>
<div class="line"><a id="l03965" name="l03965"></a><span class="lineno"> 3965</span> </div>
<div class="line"><a id="l03966" name="l03966"></a><span class="lineno"> 3966</span>  <span class="comment">// We are in thread W.  connect() is waiting for us to set *sock_ptr and return.</span></div>
<div class="line"><a id="l03967" name="l03967"></a><span class="lineno"> 3967</span> </div>
<div class="line"><a id="l03968" name="l03968"></a><span class="lineno"> 3968</span>  <span class="comment">// Create new socket and set all members that may be immediately accessed by user in thread U after we&#39;re done.</span></div>
<div class="line"><a id="l03969" name="l03969"></a><span class="lineno"> 3969</span> </div>
<div class="line"><a id="l03970" name="l03970"></a><span class="lineno"> 3970</span>  <span class="keyword">auto</span>&amp; sock = *sock_ptr;</div>
<div class="line"><a id="l03971" name="l03971"></a><span class="lineno"> 3971</span>  <span class="keywordflow">if</span> (sock_opts)</div>
<div class="line"><a id="l03972" name="l03972"></a><span class="lineno"> 3972</span>  {</div>
<div class="line"><a id="l03973" name="l03973"></a><span class="lineno"> 3973</span>    <span class="comment">/* They provided custom per-socket options.  Before we give those to the new socket, let&#39;s</span></div>
<div class="line"><a id="l03974" name="l03974"></a><span class="lineno"> 3974</span><span class="comment">     * validate them (for proper values and internal consistency, etc.). */</span></div>
<div class="line"><a id="l03975" name="l03975"></a><span class="lineno"> 3975</span> </div>
<div class="line"><a id="l03976" name="l03976"></a><span class="lineno"> 3976</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> err_code;</div>
<div class="line"><a id="l03977" name="l03977"></a><span class="lineno"> 3977</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> opts_ok = sock_validate_options(*sock_opts, 0, &amp;err_code);</div>
<div class="line"><a id="l03978" name="l03978"></a><span class="lineno"> 3978</span> </div>
<div class="line"><a id="l03979" name="l03979"></a><span class="lineno"> 3979</span>    <span class="comment">// Due to the advertised interface of the current method, we must create a socket even on error.</span></div>
<div class="line"><a id="l03980" name="l03980"></a><span class="lineno"> 3980</span>    sock.reset(sock_create(*sock_opts));</div>
<div class="line"><a id="l03981" name="l03981"></a><span class="lineno"> 3981</span> </div>
<div class="line"><a id="l03982" name="l03982"></a><span class="lineno"> 3982</span>    <span class="comment">// Now report error if indeed options were invalid.  err_code is already set and logged in that case.</span></div>
<div class="line"><a id="l03983" name="l03983"></a><span class="lineno"> 3983</span>    <span class="keywordflow">if</span> (!opts_ok)</div>
<div class="line"><a id="l03984" name="l03984"></a><span class="lineno"> 3984</span>    {</div>
<div class="line"><a id="l03985" name="l03985"></a><span class="lineno"> 3985</span>      sock-&gt;m_disconnect_cause = err_code;</div>
<div class="line"><a id="l03986" name="l03986"></a><span class="lineno"> 3986</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03987" name="l03987"></a><span class="lineno"> 3987</span>    }</div>
<div class="line"><a id="l03988" name="l03988"></a><span class="lineno"> 3988</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03989" name="l03989"></a><span class="lineno"> 3989</span>  }</div>
<div class="line"><a id="l03990" name="l03990"></a><span class="lineno"> 3990</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03991" name="l03991"></a><span class="lineno"> 3991</span>  {</div>
<div class="line"><a id="l03992" name="l03992"></a><span class="lineno"> 3992</span>    <span class="comment">/* More typically, they did not provide per-socket options.  So we just pass our global</span></div>
<div class="line"><a id="l03993" name="l03993"></a><span class="lineno"> 3993</span><span class="comment">     * template for the per-socket options to the Peer_socket constructor.  The only caveat is</span></div>
<div class="line"><a id="l03994" name="l03994"></a><span class="lineno"> 3994</span><span class="comment">     * that template may be concurrently changed, so we must lock it.  Could do it with opt(), but</span></div>
<div class="line"><a id="l03995" name="l03995"></a><span class="lineno"> 3995</span><span class="comment">     * that introduces an extra copy of the entire struct, so just do it explicitly.</span></div>
<div class="line"><a id="l03996" name="l03996"></a><span class="lineno"> 3996</span><span class="comment">     *</span></div>
<div class="line"><a id="l03997" name="l03997"></a><span class="lineno"> 3997</span><span class="comment">     * Note: no need to validate; global options (including per-socket ones) are validated</span></div>
<div class="line"><a id="l03998" name="l03998"></a><span class="lineno"> 3998</span><span class="comment">     * elsewhere when set. */</span></div>
<div class="line"><a id="l03999" name="l03999"></a><span class="lineno"> 3999</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* sock_non_ptr;</div>
<div class="line"><a id="l04000" name="l04000"></a><span class="lineno"> 4000</span>    {</div>
<div class="line"><a id="l04001" name="l04001"></a><span class="lineno"> 4001</span>      <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">Options_lock</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a">m_opts_mutex</a>);</div>
<div class="line"><a id="l04002" name="l04002"></a><span class="lineno"> 4002</span>      sock_non_ptr = sock_create(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a>.m_dyn_sock_opts);</div>
<div class="line"><a id="l04003" name="l04003"></a><span class="lineno"> 4003</span>    }</div>
<div class="line"><a id="l04004" name="l04004"></a><span class="lineno"> 4004</span>    sock.reset(sock_non_ptr);</div>
<div class="line"><a id="l04005" name="l04005"></a><span class="lineno"> 4005</span>  }</div>
<div class="line"><a id="l04006" name="l04006"></a><span class="lineno"> 4006</span> </div>
<div class="line"><a id="l04007" name="l04007"></a><span class="lineno"> 4007</span>  <span class="comment">// Socket created; set members.</span></div>
<div class="line"><a id="l04008" name="l04008"></a><span class="lineno"> 4008</span> </div>
<div class="line"><a id="l04009" name="l04009"></a><span class="lineno"> 4009</span>  sock-&gt;m_active_connect = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04010" name="l04010"></a><span class="lineno"> 4010</span>  sock-&gt;m_node = <span class="keyword">this</span>;</div>
<div class="line"><a id="l04011" name="l04011"></a><span class="lineno"> 4011</span>  sock_set_state(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">Peer_socket::Open_sub_state::S_CONNECTING</a>);</div>
<div class="line"><a id="l04012" name="l04012"></a><span class="lineno"> 4012</span>  sock-&gt;m_remote_endpoint = to;</div>
<div class="line"><a id="l04013" name="l04013"></a><span class="lineno"> 4013</span>  <span class="comment">// Will be sent in SYN to be deserialized by user on the other side.  Save here if we must retransmit SYN.</span></div>
<div class="line"><a id="l04014" name="l04014"></a><span class="lineno"> 4014</span>  sock-&gt;m_serialized_metadata.assign_copy(serialized_metadata);</div>
<div class="line"><a id="l04015" name="l04015"></a><span class="lineno"> 4015</span> </div>
<div class="line"><a id="l04016" name="l04016"></a><span class="lineno"> 4016</span>  <span class="comment">/* Initialize the connection&#39;s send bandwidth estimator (object that estimates available</span></div>
<div class="line"><a id="l04017" name="l04017"></a><span class="lineno"> 4017</span><span class="comment">   * outgoing bandwidth based on incoming acknowledgments).  It may be used by m_snd_cong_ctl,</span></div>
<div class="line"><a id="l04018" name="l04018"></a><span class="lineno"> 4018</span><span class="comment">   * depending on the strategy chosen, but may be useful in its own right.  Hence it&#39;s a separate</span></div>
<div class="line"><a id="l04019" name="l04019"></a><span class="lineno"> 4019</span><span class="comment">   * object, not inside *m_snd_cong_ctl. */</span></div>
<div class="line"><a id="l04020" name="l04020"></a><span class="lineno"> 4020</span>  sock-&gt;m_snd_bandwidth_estimator.reset(<span class="keyword">new</span> <a class="code hl_friend" href="classflow_1_1net__flow_1_1Peer__socket.html#a7c0f36768414ae35afeb525636a41290">Send_bandwidth_estimator</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock));</div>
<div class="line"><a id="l04021" name="l04021"></a><span class="lineno"> 4021</span> </div>
<div class="line"><a id="l04022" name="l04022"></a><span class="lineno"> 4022</span>  <span class="comment">// Initialize the connection&#39;s congestion control strategy based on the configured strategy.</span></div>
<div class="line"><a id="l04023" name="l04023"></a><span class="lineno"> 4023</span>  sock-&gt;m_snd_cong_ctl.reset</div>
<div class="line"><a id="l04024" name="l04024"></a><span class="lineno"> 4024</span>    (<a class="code hl_function" href="classflow_1_1net__flow_1_1Congestion__control__selector.html#a52eee18d41c3f9cc7d6c48b766a7919f">Congestion_control_selector::create_strategy</a>(sock-&gt;m_opts.m_st_cong_ctl_strategy, <a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock));</div>
<div class="line"><a id="l04025" name="l04025"></a><span class="lineno"> 4025</span>  <span class="comment">// ^-- No need to use opt() yet: user doesn&#39;t have socket and cannot set_options() on it yet.</span></div>
<div class="line"><a id="l04026" name="l04026"></a><span class="lineno"> 4026</span> </div>
<div class="line"><a id="l04027" name="l04027"></a><span class="lineno"> 4027</span>  <span class="comment">/* Tweak: If they specify the &quot;any&quot; IP address as the destination (which means any interface on</span></div>
<div class="line"><a id="l04028" name="l04028"></a><span class="lineno"> 4028</span><span class="comment">   * this machine), response traffic will look as though it&#39;s coming from the loopback IP address,</span></div>
<div class="line"><a id="l04029" name="l04029"></a><span class="lineno"> 4029</span><span class="comment">   * or another specific IP address -- not &quot;any.&quot;  Thus it will not be able to be properly</span></div>
<div class="line"><a id="l04030" name="l04030"></a><span class="lineno"> 4030</span><span class="comment">   * demultiplexed to this socket, since that will be saved at the &quot;any&quot; address in our data</span></div>
<div class="line"><a id="l04031" name="l04031"></a><span class="lineno"> 4031</span><span class="comment">   * structures.  So that&#39;s an error. */</span></div>
<div class="line"><a id="l04032" name="l04032"></a><span class="lineno"> 4032</span>  <span class="keywordtype">bool</span> ip_addr_any_error = <span class="keyword">false</span>;</div>
<div class="line"><a id="l04033" name="l04033"></a><span class="lineno"> 4033</span>  <span class="keyword">const</span> address&amp; addr = to.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Remote__endpoint.html#a582f3a55d828cd4e36369682315c7629">m_udp_endpoint</a>.address(); <span class="comment">// Short-hand.</span></div>
<div class="line"><a id="l04034" name="l04034"></a><span class="lineno"> 4034</span>  <span class="keywordflow">if</span> (addr.is_v4())</div>
<div class="line"><a id="l04035" name="l04035"></a><span class="lineno"> 4035</span>  {</div>
<div class="line"><a id="l04036" name="l04036"></a><span class="lineno"> 4036</span>    <span class="keywordflow">if</span> (addr.to_v4() == util::Ip_address_v4::any())</div>
<div class="line"><a id="l04037" name="l04037"></a><span class="lineno"> 4037</span>    {</div>
<div class="line"><a id="l04038" name="l04038"></a><span class="lineno"> 4038</span>      ip_addr_any_error = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04039" name="l04039"></a><span class="lineno"> 4039</span>    }</div>
<div class="line"><a id="l04040" name="l04040"></a><span class="lineno"> 4040</span>  }</div>
<div class="line"><a id="l04041" name="l04041"></a><span class="lineno"> 4041</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (addr.is_v6())</div>
<div class="line"><a id="l04042" name="l04042"></a><span class="lineno"> 4042</span>  {</div>
<div class="line"><a id="l04043" name="l04043"></a><span class="lineno"> 4043</span>    <span class="keywordflow">if</span> (addr.to_v6() == util::Ip_address_v6::any())</div>
<div class="line"><a id="l04044" name="l04044"></a><span class="lineno"> 4044</span>    {</div>
<div class="line"><a id="l04045" name="l04045"></a><span class="lineno"> 4045</span>      ip_addr_any_error = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04046" name="l04046"></a><span class="lineno"> 4046</span>    }</div>
<div class="line"><a id="l04047" name="l04047"></a><span class="lineno"> 4047</span>  }</div>
<div class="line"><a id="l04048" name="l04048"></a><span class="lineno"> 4048</span>  <span class="comment">// else a new version of IP!  Yay!</span></div>
<div class="line"><a id="l04049" name="l04049"></a><span class="lineno"> 4049</span>  <span class="keywordflow">if</span> (ip_addr_any_error)</div>
<div class="line"><a id="l04050" name="l04050"></a><span class="lineno"> 4050</span>  {</div>
<div class="line"><a id="l04051" name="l04051"></a><span class="lineno"> 4051</span>    <span class="comment">// Mark/log error.</span></div>
<div class="line"><a id="l04052" name="l04052"></a><span class="lineno"> 4052</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = &amp;sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l04053" name="l04053"></a><span class="lineno"> 4053</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99">error::Code::S_CANNOT_CONNECT_TO_IP_ANY</a>);</div>
<div class="line"><a id="l04054" name="l04054"></a><span class="lineno"> 4054</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04055" name="l04055"></a><span class="lineno"> 4055</span>  }</div>
<div class="line"><a id="l04056" name="l04056"></a><span class="lineno"> 4056</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04057" name="l04057"></a><span class="lineno"> 4057</span> </div>
<div class="line"><a id="l04058" name="l04058"></a><span class="lineno"> 4058</span>  <span class="comment">// Allocate ephemeral local port.</span></div>
<div class="line"><a id="l04059" name="l04059"></a><span class="lineno"> 4059</span> </div>
<div class="line"><a id="l04060" name="l04060"></a><span class="lineno"> 4060</span>  sock-&gt;m_local_port = m_ports.reserve_ephemeral_port(&amp;sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l04061" name="l04061"></a><span class="lineno"> 4061</span>  <span class="keywordflow">if</span> (sock-&gt;m_local_port == <a class="code hl_variable" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">S_PORT_ANY</a>)</div>
<div class="line"><a id="l04062" name="l04062"></a><span class="lineno"> 4062</span>  {</div>
<div class="line"><a id="l04063" name="l04063"></a><span class="lineno"> 4063</span>    <span class="comment">// Error already logged and is in sock-&gt;m_disconnect_cause.</span></div>
<div class="line"><a id="l04064" name="l04064"></a><span class="lineno"> 4064</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04065" name="l04065"></a><span class="lineno"> 4065</span>  }</div>
<div class="line"><a id="l04066" name="l04066"></a><span class="lineno"> 4066</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04067" name="l04067"></a><span class="lineno"> 4067</span> </div>
<div class="line"><a id="l04068" name="l04068"></a><span class="lineno"> 4068</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> socket_id = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">Node::socket_id</a>(sock);</div>
<div class="line"><a id="l04069" name="l04069"></a><span class="lineno"> 4069</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;NetFlow worker thread starting active-connect of [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04070" name="l04070"></a><span class="lineno"> 4070</span> </div>
<div class="line"><a id="l04071" name="l04071"></a><span class="lineno"> 4071</span>  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">util::key_exists</a>(m_socks, socket_id))</div>
<div class="line"><a id="l04072" name="l04072"></a><span class="lineno"> 4072</span>  {</div>
<div class="line"><a id="l04073" name="l04073"></a><span class="lineno"> 4073</span>    <span class="comment">/* This is an active connect (we&#39;re intiating the connection).  Therefore in particular it</span></div>
<div class="line"><a id="l04074" name="l04074"></a><span class="lineno"> 4074</span><span class="comment">     * should be impossible that our local_port() equals an already existing connection&#39;s</span></div>
<div class="line"><a id="l04075" name="l04075"></a><span class="lineno"> 4075</span><span class="comment">     * local_port(); Port_space is supposed to prevent the same ephemeral port from being handed out</span></div>
<div class="line"><a id="l04076" name="l04076"></a><span class="lineno"> 4076</span><span class="comment">     * to more than one connection.  Therefore this must be a programming error. */</span></div>
<div class="line"><a id="l04077" name="l04077"></a><span class="lineno"> 4077</span> </div>
<div class="line"><a id="l04078" name="l04078"></a><span class="lineno"> 4078</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Cannot add [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;], because such a connection already exists.  &quot;</span></div>
<div class="line"><a id="l04079" name="l04079"></a><span class="lineno"> 4079</span>                     <span class="stringliteral">&quot;This is an ephemeral port collision and &quot;</span></div>
<div class="line"><a id="l04080" name="l04080"></a><span class="lineno"> 4080</span>                     <span class="stringliteral">&quot;constitutes either a bug or an extremely unlikely condition.&quot;</span>);</div>
<div class="line"><a id="l04081" name="l04081"></a><span class="lineno"> 4081</span> </div>
<div class="line"><a id="l04082" name="l04082"></a><span class="lineno"> 4082</span>    <span class="comment">// Mark/log error.</span></div>
<div class="line"><a id="l04083" name="l04083"></a><span class="lineno"> 4083</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = &amp;sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l04084" name="l04084"></a><span class="lineno"> 4084</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>);</div>
<div class="line"><a id="l04085" name="l04085"></a><span class="lineno"> 4085</span> </div>
<div class="line"><a id="l04086" name="l04086"></a><span class="lineno"> 4086</span>    <span class="comment">// Return port.</span></div>
<div class="line"><a id="l04087" name="l04087"></a><span class="lineno"> 4087</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> return_err_code;</div>
<div class="line"><a id="l04088" name="l04088"></a><span class="lineno"> 4088</span>    m_ports.return_port(sock-&gt;m_local_port, &amp;return_err_code);</div>
<div class="line"><a id="l04089" name="l04089"></a><span class="lineno"> 4089</span>    assert(!return_err_code);</div>
<div class="line"><a id="l04090" name="l04090"></a><span class="lineno"> 4090</span> </div>
<div class="line"><a id="l04091" name="l04091"></a><span class="lineno"> 4091</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04092" name="l04092"></a><span class="lineno"> 4092</span>  } <span class="comment">// if (that socket pair already exists)</span></div>
<div class="line"><a id="l04093" name="l04093"></a><span class="lineno"> 4093</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04094" name="l04094"></a><span class="lineno"> 4094</span> </div>
<div class="line"><a id="l04095" name="l04095"></a><span class="lineno"> 4095</span>  <span class="comment">/* Try the packet send just below again if SYN not acknowledged within a certain amount of time.</span></div>
<div class="line"><a id="l04096" name="l04096"></a><span class="lineno"> 4096</span><span class="comment">   * Give up if that happens too many times.  Why do this BEFORE sending packet?  Because</span></div>
<div class="line"><a id="l04097" name="l04097"></a><span class="lineno"> 4097</span><span class="comment">   * this can fail, in which case we don&#39;t want a weird situation where we&#39;ve sent</span></div>
<div class="line"><a id="l04098" name="l04098"></a><span class="lineno"> 4098</span><span class="comment">   * the packet but failed to start the retransmit/timeout timers.</span></div>
<div class="line"><a id="l04099" name="l04099"></a><span class="lineno"> 4099</span><span class="comment">   * Update: It can no longer fail, so that reasoning is N/A.  Not moving, though, because it&#39;s still fine here. */</span></div>
<div class="line"><a id="l04100" name="l04100"></a><span class="lineno"> 4100</span>  setup_connection_timers(socket_id, sock, <span class="keyword">true</span>);</div>
<div class="line"><a id="l04101" name="l04101"></a><span class="lineno"> 4101</span> </div>
<div class="line"><a id="l04102" name="l04102"></a><span class="lineno"> 4102</span>  <span class="comment">/* Initial Sequence Number (ISN) (save before create_syn() uses it).</span></div>
<div class="line"><a id="l04103" name="l04103"></a><span class="lineno"> 4103</span><span class="comment">   * Remember it in case we must retransmit the SYN.  (m_snd_next_seq_num may have been further increased by then.) */</span></div>
<div class="line"><a id="l04104" name="l04104"></a><span class="lineno"> 4104</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; init_seq_num = sock-&gt;m_snd_init_seq_num;</div>
<div class="line"><a id="l04105" name="l04105"></a><span class="lineno"> 4105</span>  init_seq_num = m_seq_num_generator.generate_init_seq_num();</div>
<div class="line"><a id="l04106" name="l04106"></a><span class="lineno"> 4106</span>  <span class="comment">/* Setting this now ensures ALL subsequent copies (essentially, every single Sequence_number on this socket&#39;s</span></div>
<div class="line"><a id="l04107" name="l04107"></a><span class="lineno"> 4107</span><span class="comment">   * local data number line!) will have the same nice metadata (hence nice logging) too.</span></div>
<div class="line"><a id="l04108" name="l04108"></a><span class="lineno"> 4108</span><span class="comment">   * The `+ 1` nuance is explained in class Sequence_number doc header, *Metadata* section. */</span></div>
<div class="line"><a id="l04109" name="l04109"></a><span class="lineno"> 4109</span>  init_seq_num.<a class="code hl_function" href="classflow_1_1net__flow_1_1Sequence__number.html#a77ce8cf348e93caa8bb03f22f7b7d120">set_metadata</a>(<span class="charliteral">&#39;L&#39;</span>, init_seq_num + 1, sock-&gt;max_block_size());</div>
<div class="line"><a id="l04110" name="l04110"></a><span class="lineno"> 4110</span>  <span class="comment">// Sequence number of first bit of actual data.</span></div>
<div class="line"><a id="l04111" name="l04111"></a><span class="lineno"> 4111</span>  sock-&gt;m_snd_next_seq_num = init_seq_num + 1;</div>
<div class="line"><a id="l04112" name="l04112"></a><span class="lineno"> 4112</span> </div>
<div class="line"><a id="l04113" name="l04113"></a><span class="lineno"> 4113</span>  <span class="comment">// Make a SYN packet to send.</span></div>
<div class="line"><a id="l04114" name="l04114"></a><span class="lineno"> 4114</span>  <span class="keyword">auto</span> syn = create_syn(sock);</div>
<div class="line"><a id="l04115" name="l04115"></a><span class="lineno"> 4115</span> </div>
<div class="line"><a id="l04116" name="l04116"></a><span class="lineno"> 4116</span>  <span class="comment">// Fill out common fields and asynchronously send packet.</span></div>
<div class="line"><a id="l04117" name="l04117"></a><span class="lineno"> 4117</span>  async_sock_low_lvl_packet_send_paced(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(syn));</div>
<div class="line"><a id="l04118" name="l04118"></a><span class="lineno"> 4118</span> </div>
<div class="line"><a id="l04119" name="l04119"></a><span class="lineno"> 4119</span>  <span class="comment">/* send will happen asynchronously, and the registered completion handler will execute in this</span></div>
<div class="line"><a id="l04120" name="l04120"></a><span class="lineno"> 4120</span><span class="comment">   * thread when done (NO SOONER than this method finishes executing). */</span></div>
<div class="line"><a id="l04121" name="l04121"></a><span class="lineno"> 4121</span> </div>
<div class="line"><a id="l04122" name="l04122"></a><span class="lineno"> 4122</span>  <span class="comment">// No more erros: Map socket pair to the socket data structure (kind of analogous to a TCP net-stack&#39;s TCB structure).</span></div>
<div class="line"><a id="l04123" name="l04123"></a><span class="lineno"> 4123</span>  m_socks[socket_id] = sock;</div>
<div class="line"><a id="l04124" name="l04124"></a><span class="lineno"> 4124</span> </div>
<div class="line"><a id="l04125" name="l04125"></a><span class="lineno"> 4125</span>  <span class="comment">// CLOSED -&gt; SYN_SENT.</span></div>
<div class="line"><a id="l04126" name="l04126"></a><span class="lineno"> 4126</span>  sock_set_int_state(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">Peer_socket::Int_state::S_SYN_SENT</a>);</div>
<div class="line"><a id="l04127" name="l04127"></a><span class="lineno"> 4127</span>} <span class="comment">// Node::connect_worker()</span></div>
<div class="line"><a id="l04128" name="l04128"></a><span class="lineno"> 4128</span> </div>
<div class="line"><a id="l04129" name="l04129"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35"> 4129</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">Node::sync_connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code,</div>
<div class="line"><a id="l04130" name="l04130"></a><span class="lineno"> 4130</span>                                    <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* sock_opts)</div>
<div class="line"><a id="l04131" name="l04131"></a><span class="lineno"> 4131</span>{</div>
<div class="line"><a id="l04132" name="l04132"></a><span class="lineno"> 4132</span>  <span class="keywordflow">return</span> sync_connect_with_metadata(to, Fine_duration::max(),</div>
<div class="line"><a id="l04133" name="l04133"></a><span class="lineno"> 4133</span>                                    boost::asio::buffer(&amp;S_DEFAULT_CONN_METADATA, <span class="keyword">sizeof</span>(S_DEFAULT_CONN_METADATA)),</div>
<div class="line"><a id="l04134" name="l04134"></a><span class="lineno"> 4134</span>                                    err_code, sock_opts);</div>
<div class="line"><a id="l04135" name="l04135"></a><span class="lineno"> 4135</span>}</div>
<div class="line"><a id="l04136" name="l04136"></a><span class="lineno"> 4136</span> </div>
<div class="line"><a id="l04137" name="l04137"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89"> 4137</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">Node::sync_connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l04138" name="l04138"></a><span class="lineno"> 4138</span>                                                  <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l04139" name="l04139"></a><span class="lineno"> 4139</span>                                                  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts)</div>
<div class="line"><a id="l04140" name="l04140"></a><span class="lineno"> 4140</span>{</div>
<div class="line"><a id="l04141" name="l04141"></a><span class="lineno"> 4141</span>  <span class="keywordflow">return</span> sync_connect_with_metadata(to, Fine_duration::max(), serialized_metadata, err_code, opts);</div>
<div class="line"><a id="l04142" name="l04142"></a><span class="lineno"> 4142</span>}</div>
<div class="line"><a id="l04143" name="l04143"></a><span class="lineno"> 4143</span> </div>
<div class="line"><a id="l04144" name="l04144"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a"> 4144</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">Node::sync_connect_impl</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; max_wait,</div>
<div class="line"><a id="l04145" name="l04145"></a><span class="lineno"> 4145</span>                                         <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l04146" name="l04146"></a><span class="lineno"> 4146</span>                                         <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* sock_opts)</div>
<div class="line"><a id="l04147" name="l04147"></a><span class="lineno"> 4147</span>{</div>
<div class="line"><a id="l04148" name="l04148"></a><span class="lineno"> 4148</span>  <a class="code hl_define" href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>, sync_connect_impl,</div>
<div class="line"><a id="l04149" name="l04149"></a><span class="lineno"> 4149</span>                                     to, max_wait, serialized_metadata, _1, sock_opts);</div>
<div class="line"><a id="l04150" name="l04150"></a><span class="lineno"> 4150</span>  <span class="comment">// ^-- Call ourselves and return if err_code is null.  If got to present line, err_code is not null.</span></div>
<div class="line"><a id="l04151" name="l04151"></a><span class="lineno"> 4151</span> </div>
<div class="line"><a id="l04152" name="l04152"></a><span class="lineno"> 4152</span>  <span class="comment">// We are in thread U != W.</span></div>
<div class="line"><a id="l04153" name="l04153"></a><span class="lineno"> 4153</span> </div>
<div class="line"><a id="l04154" name="l04154"></a><span class="lineno"> 4154</span>  <span class="comment">/* This is actually pretty simple.  All we want to do is connect(), which is non-blocking, and</span></div>
<div class="line"><a id="l04155" name="l04155"></a><span class="lineno"> 4155</span><span class="comment">   * then block until the connection is ready (at least according to our side).  Ready means that</span></div>
<div class="line"><a id="l04156" name="l04156"></a><span class="lineno"> 4156</span><span class="comment">   * the socket is Writable (since user has no access to the socket yet, nothing can be loading</span></div>
<div class="line"><a id="l04157" name="l04157"></a><span class="lineno"> 4157</span><span class="comment">   * data onto the Send buffer, and obviously the congestion window is clear, so it must be</span></div>
<div class="line"><a id="l04158" name="l04158"></a><span class="lineno"> 4158</span><span class="comment">   * Writable).  Note that, like BSD sockets, we specifically don&#39;t consider a socket Writable</span></div>
<div class="line"><a id="l04159" name="l04159"></a><span class="lineno"> 4159</span><span class="comment">   * until in ESTABLISHED internal state. */</span></div>
<div class="line"><a id="l04160" name="l04160"></a><span class="lineno"> 4160</span> </div>
<div class="line"><a id="l04161" name="l04161"></a><span class="lineno"> 4161</span>  <span class="comment">/* For the &quot;block until Writable&quot; part, create and load the Event_set.  Do this before connect(),</span></div>
<div class="line"><a id="l04162" name="l04162"></a><span class="lineno"> 4162</span><span class="comment">   * so that if it fails we don&#39;t have to then clean up the socket before returning error to user. */</span></div>
<div class="line"><a id="l04163" name="l04163"></a><span class="lineno"> 4163</span> </div>
<div class="line"><a id="l04164" name="l04164"></a><span class="lineno"> 4164</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set = event_set_create(err_code);</div>
<div class="line"><a id="l04165" name="l04165"></a><span class="lineno"> 4165</span>  <span class="keywordflow">if</span> (!event_set)</div>
<div class="line"><a id="l04166" name="l04166"></a><span class="lineno"> 4166</span>  {</div>
<div class="line"><a id="l04167" name="l04167"></a><span class="lineno"> 4167</span>    assert(*err_code == <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l04168" name="l04168"></a><span class="lineno"> 4168</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>(); <span class="comment">// *err_code is set.</span></div>
<div class="line"><a id="l04169" name="l04169"></a><span class="lineno"> 4169</span>  }</div>
<div class="line"><a id="l04170" name="l04170"></a><span class="lineno"> 4170</span>  <span class="comment">// Now we know Node is running(); and we have event_set.</span></div>
<div class="line"><a id="l04171" name="l04171"></a><span class="lineno"> 4171</span> </div>
<div class="line"><a id="l04172" name="l04172"></a><span class="lineno"> 4172</span>  <span class="comment">// We must clean up event_set at any return point below.</span></div>
<div class="line"><a id="l04173" name="l04173"></a><span class="lineno"> 4173</span>  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> dummy_prevents_throw;</div>
<div class="line"><a id="l04174" name="l04174"></a><span class="lineno"> 4174</span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#ab22fd89e165a9e6deaa174bc0dfdc8de">util::Auto_cleanup</a> event_set_cleanup = <a class="code hl_function" href="namespaceflow_1_1util.html#a09a032f8e1e77a3afc0b7df115a773e1">util::setup_auto_cleanup</a>([&amp;]()</div>
<div class="line"><a id="l04175" name="l04175"></a><span class="lineno"> 4175</span>  {</div>
<div class="line"><a id="l04176" name="l04176"></a><span class="lineno"> 4176</span>    <span class="comment">// Eat any error when closing Event_set, as it&#39;s unlikely and not interesting to user.</span></div>
<div class="line"><a id="l04177" name="l04177"></a><span class="lineno"> 4177</span>    event_set-&gt;close(&amp;dummy_prevents_throw);</div>
<div class="line"><a id="l04178" name="l04178"></a><span class="lineno"> 4178</span>  });</div>
<div class="line"><a id="l04179" name="l04179"></a><span class="lineno"> 4179</span> </div>
<div class="line"><a id="l04180" name="l04180"></a><span class="lineno"> 4180</span>  <span class="keyword">const</span> <span class="keyword">auto</span> sock = connect_with_metadata(to, serialized_metadata, err_code, sock_opts);</div>
<div class="line"><a id="l04181" name="l04181"></a><span class="lineno"> 4181</span>  <span class="keywordflow">if</span> (!sock)</div>
<div class="line"><a id="l04182" name="l04182"></a><span class="lineno"> 4182</span>  {</div>
<div class="line"><a id="l04183" name="l04183"></a><span class="lineno"> 4183</span>    <span class="keywordflow">return</span> sock; <span class="comment">// *err_code is set.  It&#39;s probably some user error like an invalid destination.</span></div>
<div class="line"><a id="l04184" name="l04184"></a><span class="lineno"> 4184</span>  }</div>
<div class="line"><a id="l04185" name="l04185"></a><span class="lineno"> 4185</span>  <span class="comment">// else we have a socket that has started connecting.</span></div>
<div class="line"><a id="l04186" name="l04186"></a><span class="lineno"> 4186</span> </div>
<div class="line"><a id="l04187" name="l04187"></a><span class="lineno"> 4187</span>  <span class="comment">/* We must clean up sock (call sock-&gt;close_abruptly(&amp;dummy_prevents_throw)) at any return point (including</span></div>
<div class="line"><a id="l04188" name="l04188"></a><span class="lineno"> 4188</span><span class="comment">   * exception throw) below, EXCEPT the success case.  Because of the latter, we can&#39;t use the</span></div>
<div class="line"><a id="l04189" name="l04189"></a><span class="lineno"> 4189</span><span class="comment">   * auto_cleanup trick we used on event_set.  So, we&#39;ll just have to handle sock cleanup</span></div>
<div class="line"><a id="l04190" name="l04190"></a><span class="lineno"> 4190</span><span class="comment">   * manually. */</span></div>
<div class="line"><a id="l04191" name="l04191"></a><span class="lineno"> 4191</span> </div>
<div class="line"><a id="l04192" name="l04192"></a><span class="lineno"> 4192</span>  <span class="comment">// Add the one event about which we care.</span></div>
<div class="line"><a id="l04193" name="l04193"></a><span class="lineno"> 4193</span>  <span class="keywordtype">bool</span> result = event_set-&gt;add_wanted_socket&lt;<a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>&gt;(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a>,</div>
<div class="line"><a id="l04194" name="l04194"></a><span class="lineno"> 4194</span>                                                          &amp;dummy_prevents_throw);</div>
<div class="line"><a id="l04195" name="l04195"></a><span class="lineno"> 4195</span>  assert(result); <span class="comment">// Node is running, so there&#39;s no way that should have failed.</span></div>
<div class="line"><a id="l04196" name="l04196"></a><span class="lineno"> 4196</span> </div>
<div class="line"><a id="l04197" name="l04197"></a><span class="lineno"> 4197</span>  <span class="comment">// Wait for Writable.</span></div>
<div class="line"><a id="l04198" name="l04198"></a><span class="lineno"> 4198</span>  result = event_set-&gt;sync_wait(max_wait, err_code);</div>
<div class="line"><a id="l04199" name="l04199"></a><span class="lineno"> 4199</span>  <span class="keywordflow">if</span> (!result)</div>
<div class="line"><a id="l04200" name="l04200"></a><span class="lineno"> 4200</span>  {</div>
<div class="line"><a id="l04201" name="l04201"></a><span class="lineno"> 4201</span>    <span class="keywordflow">if</span> (*err_code == <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">error::Code::S_EVENT_SET_CLOSED</a>)</div>
<div class="line"><a id="l04202" name="l04202"></a><span class="lineno"> 4202</span>    {</div>
<div class="line"><a id="l04203" name="l04203"></a><span class="lineno"> 4203</span>      <span class="comment">// It&#39;s unlikely, but I guess someone could have destroyed Node during the wait (we do allow that during sleep).</span></div>
<div class="line"><a id="l04204" name="l04204"></a><span class="lineno"> 4204</span>      *err_code = <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>;</div>
<div class="line"><a id="l04205" name="l04205"></a><span class="lineno"> 4205</span>    }</div>
<div class="line"><a id="l04206" name="l04206"></a><span class="lineno"> 4206</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l04207" name="l04207"></a><span class="lineno"> 4207</span>    {</div>
<div class="line"><a id="l04208" name="l04208"></a><span class="lineno"> 4208</span>      <span class="comment">// This is quite common and is analogous to POSIX&#39;s EINTR semantics (signal interrupted the blocking call).</span></div>
<div class="line"><a id="l04209" name="l04209"></a><span class="lineno"> 4209</span>      assert(*err_code == <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5">error::Code::S_WAIT_INTERRUPTED</a>);</div>
<div class="line"><a id="l04210" name="l04210"></a><span class="lineno"> 4210</span>    }</div>
<div class="line"><a id="l04211" name="l04211"></a><span class="lineno"> 4211</span> </div>
<div class="line"><a id="l04212" name="l04212"></a><span class="lineno"> 4212</span>    <span class="comment">// Clean up (as discussed above).</span></div>
<div class="line"><a id="l04213" name="l04213"></a><span class="lineno"> 4213</span>    sock-&gt;close_abruptly(&amp;dummy_prevents_throw); <span class="comment">// Eat any error; user doesn&#39;t care.</span></div>
<div class="line"><a id="l04214" name="l04214"></a><span class="lineno"> 4214</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>(); <span class="comment">// *err_code is set.</span></div>
<div class="line"><a id="l04215" name="l04215"></a><span class="lineno"> 4215</span>  } <span class="comment">// if (sync_wait() failed)</span></div>
<div class="line"><a id="l04216" name="l04216"></a><span class="lineno"> 4216</span>  <span class="comment">// else we know event_set is still open, and sync_wait() succeeded.</span></div>
<div class="line"><a id="l04217" name="l04217"></a><span class="lineno"> 4217</span> </div>
<div class="line"><a id="l04218" name="l04218"></a><span class="lineno"> 4218</span>  <span class="comment">// OK; either that returned 1 event, or 0 events (timeout).</span></div>
<div class="line"><a id="l04219" name="l04219"></a><span class="lineno"> 4219</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> ready = event_set-&gt;events_detected(err_code);</div>
<div class="line"><a id="l04220" name="l04220"></a><span class="lineno"> 4220</span>  <span class="comment">/* Node had not been destroyed by the time sync_wait() finished, and we don&#39;t allow simultaneous</span></div>
<div class="line"><a id="l04221" name="l04221"></a><span class="lineno"> 4221</span><span class="comment">   * ~Node() outside a blocking sleep (see notes in class Node doc header).  The only way this</span></div>
<div class="line"><a id="l04222" name="l04222"></a><span class="lineno"> 4222</span><span class="comment">   * failed is if Event_set was closed, and that could only happen if Node was destroyed. */</span></div>
<div class="line"><a id="l04223" name="l04223"></a><span class="lineno"> 4223</span>  assert(!*err_code);</div>
<div class="line"><a id="l04224" name="l04224"></a><span class="lineno"> 4224</span> </div>
<div class="line"><a id="l04225" name="l04225"></a><span class="lineno"> 4225</span>  <span class="keywordflow">if</span> (ready)</div>
<div class="line"><a id="l04226" name="l04226"></a><span class="lineno"> 4226</span>  {</div>
<div class="line"><a id="l04227" name="l04227"></a><span class="lineno"> 4227</span>    <span class="comment">/* Didn&#39;t time out; socket is Writable.  However, that does not mean it&#39;s Writable for &quot;good&quot;</span></div>
<div class="line"><a id="l04228" name="l04228"></a><span class="lineno"> 4228</span><span class="comment">     * reasons.  If an error was encountered since the original non-blocking connect (e.g., RST</span></div>
<div class="line"><a id="l04229" name="l04229"></a><span class="lineno"> 4229</span><span class="comment">     * received; or handshake timeout expired), then it is now Writable, but any operation like</span></div>
<div class="line"><a id="l04230" name="l04230"></a><span class="lineno"> 4230</span><span class="comment">     * send() or receive() will immediately yield an error.  If that is the case,</span></div>
<div class="line"><a id="l04231" name="l04231"></a><span class="lineno"> 4231</span><span class="comment">     * close_connection_immediately() has set user-visible state to S_CLOSED.  So let&#39;s check for</span></div>
<div class="line"><a id="l04232" name="l04232"></a><span class="lineno"> 4232</span><span class="comment">     * it and return an error in that case.</span></div>
<div class="line"><a id="l04233" name="l04233"></a><span class="lineno"> 4233</span><span class="comment">     *</span></div>
<div class="line"><a id="l04234" name="l04234"></a><span class="lineno"> 4234</span><span class="comment">     * We could also not; pretend socket is ready and let user discover error when trying to</span></div>
<div class="line"><a id="l04235" name="l04235"></a><span class="lineno"> 4235</span><span class="comment">     * transmit.  However it seems like a good property to help him out. */</span></div>
<div class="line"><a id="l04236" name="l04236"></a><span class="lineno"> 4236</span> </div>
<div class="line"><a id="l04237" name="l04237"></a><span class="lineno"> 4237</span>    <span class="keywordflow">if</span> (sock-&gt;state() == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>)</div>
<div class="line"><a id="l04238" name="l04238"></a><span class="lineno"> 4238</span>    {</div>
<div class="line"><a id="l04239" name="l04239"></a><span class="lineno"> 4239</span>      <span class="comment">// No need to cleanup socket; it is already closed.</span></div>
<div class="line"><a id="l04240" name="l04240"></a><span class="lineno"> 4240</span> </div>
<div class="line"><a id="l04241" name="l04241"></a><span class="lineno"> 4241</span>      <span class="comment">// Return error as above.</span></div>
<div class="line"><a id="l04242" name="l04242"></a><span class="lineno"> 4242</span>      *err_code = sock-&gt;m_disconnect_cause; <span class="comment">// No need to lock; m_disconnect_cause set and can&#39;t change later.</span></div>
<div class="line"><a id="l04243" name="l04243"></a><span class="lineno"> 4243</span>      <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>();</div>
<div class="line"><a id="l04244" name="l04244"></a><span class="lineno"> 4244</span>    }</div>
<div class="line"><a id="l04245" name="l04245"></a><span class="lineno"> 4245</span>    <span class="comment">// else it&#39;s probably really ready for action.</span></div>
<div class="line"><a id="l04246" name="l04246"></a><span class="lineno"> 4246</span> </div>
<div class="line"><a id="l04247" name="l04247"></a><span class="lineno"> 4247</span>    <span class="keywordflow">return</span> sock; <span class="comment">// *err_code is success.</span></div>
<div class="line"><a id="l04248" name="l04248"></a><span class="lineno"> 4248</span>  }</div>
<div class="line"><a id="l04249" name="l04249"></a><span class="lineno"> 4249</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04250" name="l04250"></a><span class="lineno"> 4250</span> </div>
<div class="line"><a id="l04251" name="l04251"></a><span class="lineno"> 4251</span>  <span class="comment">// Timed out!  Clean up socket, as above, and return null with a specific error (as advertised).</span></div>
<div class="line"><a id="l04252" name="l04252"></a><span class="lineno"> 4252</span>  sock-&gt;close_abruptly(&amp;dummy_prevents_throw);</div>
<div class="line"><a id="l04253" name="l04253"></a><span class="lineno"> 4253</span>  *err_code = <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c">error::Code::S_WAIT_USER_TIMEOUT</a>;</div>
<div class="line"><a id="l04254" name="l04254"></a><span class="lineno"> 4254</span>  <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>();</div>
<div class="line"><a id="l04255" name="l04255"></a><span class="lineno"> 4255</span>} <span class="comment">// Node::sync_connect_impl()</span></div>
<div class="line"><a id="l04256" name="l04256"></a><span class="lineno"> 4256</span> </div>
<div class="line"><a id="l04257" name="l04257"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12"> 4257</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">Node::setup_connection_timers</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> initial)</div>
<div class="line"><a id="l04258" name="l04258"></a><span class="lineno"> 4258</span>{</div>
<div class="line"><a id="l04259" name="l04259"></a><span class="lineno"> 4259</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667">util::schedule_task_from_now</a>;</div>
<div class="line"><a id="l04260" name="l04260"></a><span class="lineno"> 4260</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a79a0f182b38898771d669475d3e963a4">util::scheduled_task_fired</a>;</div>
<div class="line"><a id="l04261" name="l04261"></a><span class="lineno"> 4261</span>  <span class="keyword">using </span>boost::chrono::microseconds;</div>
<div class="line"><a id="l04262" name="l04262"></a><span class="lineno"> 4262</span>  <span class="keyword">using </span>boost::chrono::duration_cast;</div>
<div class="line"><a id="l04263" name="l04263"></a><span class="lineno"> 4263</span>  <span class="keyword">using </span>boost::weak_ptr;</div>
<div class="line"><a id="l04264" name="l04264"></a><span class="lineno"> 4264</span> </div>
<div class="line"><a id="l04265" name="l04265"></a><span class="lineno"> 4265</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04266" name="l04266"></a><span class="lineno"> 4266</span> </div>
<div class="line"><a id="l04267" name="l04267"></a><span class="lineno"> 4267</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> rexmit_from_now = sock-&gt;opt(sock-&gt;m_opts.m_st_connect_retransmit_period);</div>
<div class="line"><a id="l04268" name="l04268"></a><span class="lineno"> 4268</span> </div>
<div class="line"><a id="l04269" name="l04269"></a><span class="lineno"> 4269</span>  <span class="comment">// Finalize the retransmit scheduled task firing time; and update the # retries statistic.</span></div>
<div class="line"><a id="l04270" name="l04270"></a><span class="lineno"> 4270</span>  <span class="keywordflow">if</span> (!initial)</div>
<div class="line"><a id="l04271" name="l04271"></a><span class="lineno"> 4271</span>  {</div>
<div class="line"><a id="l04272" name="l04272"></a><span class="lineno"> 4272</span>    assert(<a class="code hl_function" href="namespaceflow_1_1util.html#a79a0f182b38898771d669475d3e963a4">scheduled_task_fired</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_init_rexmit_scheduled_task));</div>
<div class="line"><a id="l04273" name="l04273"></a><span class="lineno"> 4273</span> </div>
<div class="line"><a id="l04274" name="l04274"></a><span class="lineno"> 4274</span>    ++sock-&gt;m_init_rexmit_count;</div>
<div class="line"><a id="l04275" name="l04275"></a><span class="lineno"> 4275</span>    <span class="comment">/* This is a bit more precise than leaving rexmit_from_now alone, as it counts from when firing was</span></div>
<div class="line"><a id="l04276" name="l04276"></a><span class="lineno"> 4276</span><span class="comment">     * actually scheduled, vs. when the timer was actually triggered by boost.asio.  The 2nd addend should be a bit</span></div>
<div class="line"><a id="l04277" name="l04277"></a><span class="lineno"> 4277</span><span class="comment">     * negative and thus decrease rexmit_from_now a bit. */</span></div>
<div class="line"><a id="l04278" name="l04278"></a><span class="lineno"> 4278</span>    rexmit_from_now += <a class="code hl_function" href="namespaceflow_1_1util.html#a9a0812b36dc401a3b2ac5e60e2a070d0">scheduled_task_fires_from_now_or_canceled</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_init_rexmit_scheduled_task);</div>
<div class="line"><a id="l04279" name="l04279"></a><span class="lineno"> 4279</span>    <span class="comment">/* @todo RFC 6298 mandates that this must be doubled after each attempt instead of keeping</span></div>
<div class="line"><a id="l04280" name="l04280"></a><span class="lineno"> 4280</span><span class="comment">     * the same value.  Doesn&#39;t mean we should follow it. */</span></div>
<div class="line"><a id="l04281" name="l04281"></a><span class="lineno"> 4281</span>  }</div>
<div class="line"><a id="l04282" name="l04282"></a><span class="lineno"> 4282</span> </div>
<div class="line"><a id="l04283" name="l04283"></a><span class="lineno"> 4283</span>  <span class="comment">// Firing time is set; start timer.  Call that body when task fires, unless it is first canceled.</span></div>
<div class="line"><a id="l04284" name="l04284"></a><span class="lineno"> 4284</span>  sock-&gt;m_init_rexmit_scheduled_task</div>
<div class="line"><a id="l04285" name="l04285"></a><span class="lineno"> 4285</span>    = <a class="code hl_function" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667">schedule_task_from_now</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), rexmit_from_now, <span class="keyword">true</span>, &amp;m_task_engine,</div>
<div class="line"><a id="l04286" name="l04286"></a><span class="lineno"> 4286</span>                             [<span class="keyword">this</span>, socket_id,</div>
<div class="line"><a id="l04287" name="l04287"></a><span class="lineno"> 4287</span>                              sock_observer = weak_ptr&lt;Peer_socket&gt;(sock)]</div>
<div class="line"><a id="l04288" name="l04288"></a><span class="lineno"> 4288</span>                               (<span class="keywordtype">bool</span>)</div>
<div class="line"><a id="l04289" name="l04289"></a><span class="lineno"> 4289</span>  {</div>
<div class="line"><a id="l04290" name="l04290"></a><span class="lineno"> 4290</span>    <span class="keyword">auto</span> sock = sock_observer.lock();</div>
<div class="line"><a id="l04291" name="l04291"></a><span class="lineno"> 4291</span>    <span class="keywordflow">if</span> (sock)</div>
<div class="line"><a id="l04292" name="l04292"></a><span class="lineno"> 4292</span>    {</div>
<div class="line"><a id="l04293" name="l04293"></a><span class="lineno"> 4293</span>      handle_connection_rexmit_timer_event(socket_id, sock);</div>
<div class="line"><a id="l04294" name="l04294"></a><span class="lineno"> 4294</span>    }</div>
<div class="line"><a id="l04295" name="l04295"></a><span class="lineno"> 4295</span>    <span class="comment">// else { Possible or not, allow for this possibility for maintainability. }</span></div>
<div class="line"><a id="l04296" name="l04296"></a><span class="lineno"> 4296</span>  });</div>
<div class="line"><a id="l04297" name="l04297"></a><span class="lineno"> 4297</span> </div>
<div class="line"><a id="l04298" name="l04298"></a><span class="lineno"> 4298</span>  <span class="comment">// Also set up the timeout that will stop these retries from happening.</span></div>
<div class="line"><a id="l04299" name="l04299"></a><span class="lineno"> 4299</span>  <span class="keywordflow">if</span> (initial)</div>
<div class="line"><a id="l04300" name="l04300"></a><span class="lineno"> 4300</span>  {</div>
<div class="line"><a id="l04301" name="l04301"></a><span class="lineno"> 4301</span>    sock-&gt;m_connection_timeout_scheduled_task</div>
<div class="line"><a id="l04302" name="l04302"></a><span class="lineno"> 4302</span>      = <a class="code hl_function" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667">schedule_task_from_now</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(),</div>
<div class="line"><a id="l04303" name="l04303"></a><span class="lineno"> 4303</span>                               sock-&gt;opt(sock-&gt;m_opts.m_st_connect_retransmit_timeout),</div>
<div class="line"><a id="l04304" name="l04304"></a><span class="lineno"> 4304</span>                               <span class="keyword">true</span>, &amp;m_task_engine,</div>
<div class="line"><a id="l04305" name="l04305"></a><span class="lineno"> 4305</span>                               [<span class="keyword">this</span>, socket_id,</div>
<div class="line"><a id="l04306" name="l04306"></a><span class="lineno"> 4306</span>                                sock_observer = weak_ptr&lt;Peer_socket&gt;(sock)]</div>
<div class="line"><a id="l04307" name="l04307"></a><span class="lineno"> 4307</span>                                 (<span class="keywordtype">bool</span>)</div>
<div class="line"><a id="l04308" name="l04308"></a><span class="lineno"> 4308</span>   {</div>
<div class="line"><a id="l04309" name="l04309"></a><span class="lineno"> 4309</span>      <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04310" name="l04310"></a><span class="lineno"> 4310</span> </div>
<div class="line"><a id="l04311" name="l04311"></a><span class="lineno"> 4311</span>      auto sock = sock_observer.lock();</div>
<div class="line"><a id="l04312" name="l04312"></a><span class="lineno"> 4312</span>      if (!sock)</div>
<div class="line"><a id="l04313" name="l04313"></a><span class="lineno"> 4313</span>      {</div>
<div class="line"><a id="l04314" name="l04314"></a><span class="lineno"> 4314</span>        return; <span class="comment">// Possible or not, allow for this possibility for maintainability.</span></div>
<div class="line"><a id="l04315" name="l04315"></a><span class="lineno"> 4315</span>      }</div>
<div class="line"><a id="l04316" name="l04316"></a><span class="lineno"> 4316</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l04317" name="l04317"></a><span class="lineno"> 4317</span> </div>
<div class="line"><a id="l04318" name="l04318"></a><span class="lineno"> 4318</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Connection handshake timeout timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] has been triggered; was on &quot;</span></div>
<div class="line"><a id="l04319" name="l04319"></a><span class="lineno"> 4319</span>                    <span class="stringliteral">&quot;attempt [&quot;</span> &lt;&lt; (sock-&gt;m_init_rexmit_count + 1) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04320" name="l04320"></a><span class="lineno"> 4320</span> </div>
<div class="line"><a id="l04321" name="l04321"></a><span class="lineno"> 4321</span>      assert((sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">Peer_socket::Int_state::S_SYN_SENT</a>)</div>
<div class="line"><a id="l04322" name="l04322"></a><span class="lineno"> 4322</span>             || (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">Peer_socket::Int_state::S_SYN_RCVD</a>));</div>
<div class="line"><a id="l04323" name="l04323"></a><span class="lineno"> 4323</span> </div>
<div class="line"><a id="l04324" name="l04324"></a><span class="lineno"> 4324</span>      <span class="comment">// Timeout.  Give up.  Send RST, in case they do come to their senses -- but it&#39;s too late for us.</span></div>
<div class="line"><a id="l04325" name="l04325"></a><span class="lineno"> 4325</span> </div>
<div class="line"><a id="l04326" name="l04326"></a><span class="lineno"> 4326</span>      <span class="comment">/* Close connection in our structures and inform user.  Pre-conditions</span></div>
<div class="line"><a id="l04327" name="l04327"></a><span class="lineno"> 4327</span><span class="comment">       * assumed by call: sock in m_socks and sock-&gt;state() == S_OPEN (yes, since m_int_state ==</span></div>
<div class="line"><a id="l04328" name="l04328"></a><span class="lineno"> 4328</span><span class="comment">       * S_SYN_SENT/RCVD); err_code contains the reason for the close (yes). */</span></div>
<div class="line"><a id="l04329" name="l04329"></a><span class="lineno"> 4329</span>      rst_and_close_connection_immediately(socket_id, sock, <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090">error::Code::S_CONN_TIMEOUT</a>, <span class="keyword">false</span>);</div>
<div class="line"><a id="l04330" name="l04330"></a><span class="lineno"> 4330</span>      <span class="comment">/* ^-- defer_delta_check == false: for similar reason as when calling send_worker() from</span></div>
<div class="line"><a id="l04331" name="l04331"></a><span class="lineno"> 4331</span><span class="comment">       * send_worker_check_state(). */</span></div>
<div class="line"><a id="l04332" name="l04332"></a><span class="lineno"> 4332</span>    });</div>
<div class="line"><a id="l04333" name="l04333"></a><span class="lineno"> 4333</span>  } <span class="comment">// if (initial)</span></div>
<div class="line"><a id="l04334" name="l04334"></a><span class="lineno"> 4334</span>} <span class="comment">// Node::setup_connection_timers()</span></div>
<div class="line"><a id="l04335" name="l04335"></a><span class="lineno"> 4335</span> </div>
<div class="line"><a id="l04336" name="l04336"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0"> 4336</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">Node::handle_connection_rexmit_timer_event</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l04337" name="l04337"></a><span class="lineno"> 4337</span>{</div>
<div class="line"><a id="l04338" name="l04338"></a><span class="lineno"> 4338</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>;</div>
<div class="line"><a id="l04339" name="l04339"></a><span class="lineno"> 4339</span> </div>
<div class="line"><a id="l04340" name="l04340"></a><span class="lineno"> 4340</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04341" name="l04341"></a><span class="lineno"> 4341</span> </div>
<div class="line"><a id="l04342" name="l04342"></a><span class="lineno"> 4342</span>  assert((sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">Peer_socket::Int_state::S_SYN_SENT</a>)</div>
<div class="line"><a id="l04343" name="l04343"></a><span class="lineno"> 4343</span>         || (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">Peer_socket::Int_state::S_SYN_RCVD</a>));</div>
<div class="line"><a id="l04344" name="l04344"></a><span class="lineno"> 4344</span> </div>
<div class="line"><a id="l04345" name="l04345"></a><span class="lineno"> 4345</span>  <span class="comment">// Not an error (so not WARNING), but it&#39;s rare and interesting enough for INFO.</span></div>
<div class="line"><a id="l04346" name="l04346"></a><span class="lineno"> 4346</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Connection handshake retransmit timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered; was on &quot;</span></div>
<div class="line"><a id="l04347" name="l04347"></a><span class="lineno"> 4347</span>                <span class="stringliteral">&quot;attempt [&quot;</span> &lt;&lt; (sock-&gt;m_init_rexmit_count + 1) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04348" name="l04348"></a><span class="lineno"> 4348</span> </div>
<div class="line"><a id="l04349" name="l04349"></a><span class="lineno"> 4349</span>  <span class="comment">// Try again.  Reproduce the SYN or SYN_ACK... but first set up the next timer.</span></div>
<div class="line"><a id="l04350" name="l04350"></a><span class="lineno"> 4350</span> </div>
<div class="line"><a id="l04351" name="l04351"></a><span class="lineno"> 4351</span>  <span class="comment">// Setup the next timer before sending packet for the same reason as in the original SYN/SYN_ACK-sending code.</span></div>
<div class="line"><a id="l04352" name="l04352"></a><span class="lineno"> 4352</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">setup_connection_timers</a>(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock, <span class="keyword">false</span>);</div>
<div class="line"><a id="l04353" name="l04353"></a><span class="lineno"> 4353</span> </div>
<div class="line"><a id="l04354" name="l04354"></a><span class="lineno"> 4354</span>  <span class="comment">/* Send packet.</span></div>
<div class="line"><a id="l04355" name="l04355"></a><span class="lineno"> 4355</span><span class="comment">   * @todo More code reuse?  Or save the serialized version inside socket and resend here verbatim? */</span></div>
<div class="line"><a id="l04356" name="l04356"></a><span class="lineno"> 4356</span> </div>
<div class="line"><a id="l04357" name="l04357"></a><span class="lineno"> 4357</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> re_syn_base;</div>
<div class="line"><a id="l04358" name="l04358"></a><span class="lineno"> 4358</span>  <span class="keywordflow">if</span> (sock-&gt;m_active_connect)</div>
<div class="line"><a id="l04359" name="l04359"></a><span class="lineno"> 4359</span>  {</div>
<div class="line"><a id="l04360" name="l04360"></a><span class="lineno"> 4360</span>    <span class="keyword">auto</span> syn = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">create_syn</a>(sock);</div>
<div class="line"><a id="l04361" name="l04361"></a><span class="lineno"> 4361</span>    re_syn_base = <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(syn);</div>
<div class="line"><a id="l04362" name="l04362"></a><span class="lineno"> 4362</span>  }</div>
<div class="line"><a id="l04363" name="l04363"></a><span class="lineno"> 4363</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04364" name="l04364"></a><span class="lineno"> 4364</span>  {</div>
<div class="line"><a id="l04365" name="l04365"></a><span class="lineno"> 4365</span>    <span class="comment">// (Subtlety: As of this writing it wouldn&#39;t have changed since original SYN_ACK, but safe&gt;sorry.)</span></div>
<div class="line"><a id="l04366" name="l04366"></a><span class="lineno"> 4366</span>    sock-&gt;m_rcv_last_sent_rcv_wnd = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l04367" name="l04367"></a><span class="lineno"> 4367</span> </div>
<div class="line"><a id="l04368" name="l04368"></a><span class="lineno"> 4368</span>    <span class="keyword">auto</span> syn_ack = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">create_syn_ack</a>(sock);</div>
<div class="line"><a id="l04369" name="l04369"></a><span class="lineno"> 4369</span>    re_syn_base = <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(syn_ack);</div>
<div class="line"><a id="l04370" name="l04370"></a><span class="lineno"> 4370</span>  }</div>
<div class="line"><a id="l04371" name="l04371"></a><span class="lineno"> 4371</span> </div>
<div class="line"><a id="l04372" name="l04372"></a><span class="lineno"> 4372</span>  <span class="comment">// Fill out common fields and asynchronously send packet.</span></div>
<div class="line"><a id="l04373" name="l04373"></a><span class="lineno"> 4373</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, std::move(re_syn_base));</div>
<div class="line"><a id="l04374" name="l04374"></a><span class="lineno"> 4374</span>} <span class="comment">// Node::handle_connection_rexmit_timer_event()</span></div>
<div class="line"><a id="l04375" name="l04375"></a><span class="lineno"> 4375</span> </div>
<div class="line"><a id="l04376" name="l04376"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7"> 4376</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">Node::cancel_timers</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l04377" name="l04377"></a><span class="lineno"> 4377</span>{</div>
<div class="line"><a id="l04378" name="l04378"></a><span class="lineno"> 4378</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">util::scheduled_task_cancel</a>;</div>
<div class="line"><a id="l04379" name="l04379"></a><span class="lineno"> 4379</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a>;</div>
<div class="line"><a id="l04380" name="l04380"></a><span class="lineno"> 4380</span> </div>
<div class="line"><a id="l04381" name="l04381"></a><span class="lineno"> 4381</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04382" name="l04382"></a><span class="lineno"> 4382</span> </div>
<div class="line"><a id="l04383" name="l04383"></a><span class="lineno"> 4383</span>  <span class="comment">/* Cancel any timers.  Note that this will NOT prevent a given timer&#39;s handler from running.</span></div>
<div class="line"><a id="l04384" name="l04384"></a><span class="lineno"> 4384</span><span class="comment">   * It will try to make it run ASAP with operation_aborted error code.  However, it may not even</span></div>
<div class="line"><a id="l04385" name="l04385"></a><span class="lineno"> 4385</span><span class="comment">   * succeed in that.  In particular, if by the time the current handler started the timer handler</span></div>
<div class="line"><a id="l04386" name="l04386"></a><span class="lineno"> 4386</span><span class="comment">   * event was already queued inside m_task_engine, then canceling the timer now will not load</span></div>
<div class="line"><a id="l04387" name="l04387"></a><span class="lineno"> 4387</span><span class="comment">   * operation_aborted into the handler call; it will instead fire as if the timer really expired</span></div>
<div class="line"><a id="l04388" name="l04388"></a><span class="lineno"> 4388</span><span class="comment">   * (which it did).  Therefore the timer handler should be careful to check the state of the socket</span></div>
<div class="line"><a id="l04389" name="l04389"></a><span class="lineno"> 4389</span><span class="comment">   * and exit if the state is not suitable (in this case, S_CLOSED).</span></div>
<div class="line"><a id="l04390" name="l04390"></a><span class="lineno"> 4390</span><span class="comment">   *</span></div>
<div class="line"><a id="l04391" name="l04391"></a><span class="lineno"> 4391</span><span class="comment">   * Even so, try to cancel with operation_aborted just to cut down on entropy a bit (at least by</span></div>
<div class="line"><a id="l04392" name="l04392"></a><span class="lineno"> 4392</span><span class="comment">   * executing all handlers ASAP).</span></div>
<div class="line"><a id="l04393" name="l04393"></a><span class="lineno"> 4393</span><span class="comment">   *</span></div>
<div class="line"><a id="l04394" name="l04394"></a><span class="lineno"> 4394</span><span class="comment">   * Update: However, scheduled_task_cancel() will indeed cleanly cancel.  `Timer`s are still in direct use</span></div>
<div class="line"><a id="l04395" name="l04395"></a><span class="lineno"> 4395</span><span class="comment">   * as well however, so the above still applies to some of the below. */</span></div>
<div class="line"><a id="l04396" name="l04396"></a><span class="lineno"> 4396</span> </div>
<div class="line"><a id="l04397" name="l04397"></a><span class="lineno"> 4397</span>  sock-&gt;m_rcv_delayed_ack_timer.cancel();</div>
<div class="line"><a id="l04398" name="l04398"></a><span class="lineno"> 4398</span>  sock-&gt;m_snd_pacing_data.m_slice_timer.cancel();</div>
<div class="line"><a id="l04399" name="l04399"></a><span class="lineno"> 4399</span> </div>
<div class="line"><a id="l04400" name="l04400"></a><span class="lineno"> 4400</span>  <span class="keywordflow">if</span> (sock-&gt;m_init_rexmit_scheduled_task)</div>
<div class="line"><a id="l04401" name="l04401"></a><span class="lineno"> 4401</span>  {</div>
<div class="line"><a id="l04402" name="l04402"></a><span class="lineno"> 4402</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">scheduled_task_cancel</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_init_rexmit_scheduled_task);</div>
<div class="line"><a id="l04403" name="l04403"></a><span class="lineno"> 4403</span>    sock-&gt;m_init_rexmit_scheduled_task = <a class="code hl_typedef" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">Scheduled_task_handle</a>();</div>
<div class="line"><a id="l04404" name="l04404"></a><span class="lineno"> 4404</span>  }</div>
<div class="line"><a id="l04405" name="l04405"></a><span class="lineno"> 4405</span>  <span class="keywordflow">if</span> (sock-&gt;m_connection_timeout_scheduled_task)</div>
<div class="line"><a id="l04406" name="l04406"></a><span class="lineno"> 4406</span>  {</div>
<div class="line"><a id="l04407" name="l04407"></a><span class="lineno"> 4407</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">scheduled_task_cancel</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_connection_timeout_scheduled_task);</div>
<div class="line"><a id="l04408" name="l04408"></a><span class="lineno"> 4408</span>    sock-&gt;m_connection_timeout_scheduled_task = <a class="code hl_typedef" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">Scheduled_task_handle</a>();</div>
<div class="line"><a id="l04409" name="l04409"></a><span class="lineno"> 4409</span>  }</div>
<div class="line"><a id="l04410" name="l04410"></a><span class="lineno"> 4410</span>  <span class="keywordflow">if</span> (sock-&gt;m_rcv_in_rcv_wnd_recovery)</div>
<div class="line"><a id="l04411" name="l04411"></a><span class="lineno"> 4411</span>  {</div>
<div class="line"><a id="l04412" name="l04412"></a><span class="lineno"> 4412</span>    <a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">scheduled_task_cancel</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_rcv_wnd_recovery_scheduled_task);</div>
<div class="line"><a id="l04413" name="l04413"></a><span class="lineno"> 4413</span>    sock-&gt;m_rcv_in_rcv_wnd_recovery = <span class="keyword">false</span>;</div>
<div class="line"><a id="l04414" name="l04414"></a><span class="lineno"> 4414</span>  }</div>
<div class="line"><a id="l04415" name="l04415"></a><span class="lineno"> 4415</span> </div>
<div class="line"><a id="l04416" name="l04416"></a><span class="lineno"> 4416</span>  <span class="keywordflow">if</span> (sock-&gt;m_snd_drop_timer)</div>
<div class="line"><a id="l04417" name="l04417"></a><span class="lineno"> 4417</span>  {</div>
<div class="line"><a id="l04418" name="l04418"></a><span class="lineno"> 4418</span>    <span class="comment">// This Drop_timer guy actually will prevent any callbacks from firing.</span></div>
<div class="line"><a id="l04419" name="l04419"></a><span class="lineno"> 4419</span>    sock-&gt;m_snd_drop_timer-&gt;done();</div>
<div class="line"><a id="l04420" name="l04420"></a><span class="lineno"> 4420</span> </div>
<div class="line"><a id="l04421" name="l04421"></a><span class="lineno"> 4421</span>    <span class="comment">/* The two `shared_ptr`s (sock and m_snd_drop_timer) point to each other.  Nullify this to break the cycle</span></div>
<div class="line"><a id="l04422" name="l04422"></a><span class="lineno"> 4422</span><span class="comment">     * and thus avoid memory leak. */</span></div>
<div class="line"><a id="l04423" name="l04423"></a><span class="lineno"> 4423</span>    sock-&gt;m_snd_drop_timer.reset();</div>
<div class="line"><a id="l04424" name="l04424"></a><span class="lineno"> 4424</span>  }</div>
<div class="line"><a id="l04425" name="l04425"></a><span class="lineno"> 4425</span>}</div>
<div class="line"><a id="l04426" name="l04426"></a><span class="lineno"> 4426</span> </div>
<div class="line"><a id="l04427" name="l04427"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81"> 4427</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">Node::setup_drop_timer</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l04428" name="l04428"></a><span class="lineno"> 4428</span>{</div>
<div class="line"><a id="l04429" name="l04429"></a><span class="lineno"> 4429</span>  sock-&gt;m_snd_drop_timeout = sock-&gt;opt(sock-&gt;m_opts.m_st_init_drop_timeout);</div>
<div class="line"><a id="l04430" name="l04430"></a><span class="lineno"> 4430</span> </div>
<div class="line"><a id="l04431" name="l04431"></a><span class="lineno"> 4431</span>  <span class="keyword">const</span> <span class="keyword">auto</span> on_fail = [<span class="keyword">this</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock](<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code)</div>
<div class="line"><a id="l04432" name="l04432"></a><span class="lineno"> 4432</span>  {</div>
<div class="line"><a id="l04433" name="l04433"></a><span class="lineno"> 4433</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">rst_and_close_connection_immediately</a>(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock, err_code, <span class="keyword">false</span>);</div>
<div class="line"><a id="l04434" name="l04434"></a><span class="lineno"> 4434</span>    <span class="comment">// ^-- defer_delta_check == false: for similar reason as when calling send_worker() from send_worker_check_state().</span></div>
<div class="line"><a id="l04435" name="l04435"></a><span class="lineno"> 4435</span>  };</div>
<div class="line"><a id="l04436" name="l04436"></a><span class="lineno"> 4436</span>  <span class="keyword">const</span> <span class="keyword">auto</span> on_timer = [<span class="keyword">this</span>, <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock](<span class="keywordtype">bool</span> drop_all_packets)</div>
<div class="line"><a id="l04437" name="l04437"></a><span class="lineno"> 4437</span>  {</div>
<div class="line"><a id="l04438" name="l04438"></a><span class="lineno"> 4438</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">drop_timer_action</a>(sock, drop_all_packets);</div>
<div class="line"><a id="l04439" name="l04439"></a><span class="lineno"> 4439</span>  };</div>
<div class="line"><a id="l04440" name="l04440"></a><span class="lineno"> 4440</span> </div>
<div class="line"><a id="l04441" name="l04441"></a><span class="lineno"> 4441</span>  <span class="comment">/* Set up the Drop Timer.  Basically give it some key fields of sock (DTO value, the In-flight</span></div>
<div class="line"><a id="l04442" name="l04442"></a><span class="lineno"> 4442</span><span class="comment">   * queue) and the callbacks to call when events occur, such as the Drop Timer expiring.</span></div>
<div class="line"><a id="l04443" name="l04443"></a><span class="lineno"> 4443</span><span class="comment">   * Additionally, when events m_snd_drop_timer wants to know about happen, we will call</span></div>
<div class="line"><a id="l04444" name="l04444"></a><span class="lineno"> 4444</span><span class="comment">   * m_snd_drop_timer-&gt;on_...(). */</span></div>
<div class="line"><a id="l04445" name="l04445"></a><span class="lineno"> 4445</span>  sock-&gt;m_snd_drop_timer = <a class="code hl_function" href="classflow_1_1net__flow_1_1Drop__timer.html#a64def367e38954d8a392cdf92fcc8f24">Drop_timer::create_drop_timer</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), &amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, &amp;sock-&gt;m_snd_drop_timeout,</div>
<div class="line"><a id="l04446" name="l04446"></a><span class="lineno"> 4446</span>                                                         <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>(sock), on_fail, on_timer);</div>
<div class="line"><a id="l04447" name="l04447"></a><span class="lineno"> 4447</span>}</div>
<div class="line"><a id="l04448" name="l04448"></a><span class="lineno"> 4448</span> </div>
<div class="line"><a id="l04449" name="l04449"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc"> 4449</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">Node::send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l04450" name="l04450"></a><span class="lineno"> 4450</span>                  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> (<span class="keywordtype">size_t</span> max_data_size)&gt;&amp; snd_buf_feed_func,</div>
<div class="line"><a id="l04451" name="l04451"></a><span class="lineno"> 4451</span>                  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l04452" name="l04452"></a><span class="lineno"> 4452</span>{</div>
<div class="line"><a id="l04453" name="l04453"></a><span class="lineno"> 4453</span>  <span class="keyword">using </span>boost::asio::post;</div>
<div class="line"><a id="l04454" name="l04454"></a><span class="lineno"> 4454</span> </div>
<div class="line"><a id="l04455" name="l04455"></a><span class="lineno"> 4455</span>  <span class="comment">/* We are in user thread U != W.</span></div>
<div class="line"><a id="l04456" name="l04456"></a><span class="lineno"> 4456</span><span class="comment">   * It&#39;s important to keep that in mind in this method.  In particular, it is absolutely unsafe to</span></div>
<div class="line"><a id="l04457" name="l04457"></a><span class="lineno"> 4457</span><span class="comment">   * access m_int_state, which belongs solely to thread W and is never locked. */</span></div>
<div class="line"><a id="l04458" name="l04458"></a><span class="lineno"> 4458</span> </div>
<div class="line"><a id="l04459" name="l04459"></a><span class="lineno"> 4459</span>  <span class="comment">// IMPORTANT: The logic here must be consistent with sock_is_writable().</span></div>
<div class="line"><a id="l04460" name="l04460"></a><span class="lineno"> 4460</span> </div>
<div class="line"><a id="l04461" name="l04461"></a><span class="lineno"> 4461</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l04462" name="l04462"></a><span class="lineno"> 4462</span>  {</div>
<div class="line"><a id="l04463" name="l04463"></a><span class="lineno"> 4463</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l04464" name="l04464"></a><span class="lineno"> 4464</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l04465" name="l04465"></a><span class="lineno"> 4465</span>  }</div>
<div class="line"><a id="l04466" name="l04466"></a><span class="lineno"> 4466</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04467" name="l04467"></a><span class="lineno"> 4467</span> </div>
<div class="line"><a id="l04468" name="l04468"></a><span class="lineno"> 4468</span>  <span class="comment">// Pre-condition is that m_mutex is locked already.  So EVERYTHING that can be locked, is, including the buffers.</span></div>
<div class="line"><a id="l04469" name="l04469"></a><span class="lineno"> 4469</span> </div>
<div class="line"><a id="l04470" name="l04470"></a><span class="lineno"> 4470</span>  <span class="comment">// Pre-condition.</span></div>
<div class="line"><a id="l04471" name="l04471"></a><span class="lineno"> 4471</span>  assert(sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>); <span class="comment">// Locked.</span></div>
<div class="line"><a id="l04472" name="l04472"></a><span class="lineno"> 4472</span> </div>
<div class="line"><a id="l04473" name="l04473"></a><span class="lineno"> 4473</span>  <span class="keywordflow">if</span> (sock-&gt;m_disconnect_cause) <span class="comment">// Locked.</span></div>
<div class="line"><a id="l04474" name="l04474"></a><span class="lineno"> 4474</span>  {</div>
<div class="line"><a id="l04475" name="l04475"></a><span class="lineno"> 4475</span>    <span class="comment">// Error has been recorded, and we&#39;re not CLOSED =&gt; we are DISCONNECTING.</span></div>
<div class="line"><a id="l04476" name="l04476"></a><span class="lineno"> 4476</span>    assert(sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>);</div>
<div class="line"><a id="l04477" name="l04477"></a><span class="lineno"> 4477</span> </div>
<div class="line"><a id="l04478" name="l04478"></a><span class="lineno"> 4478</span>    <span class="comment">/* Disconnection is underway.  Adding more data to the Send buffer is pointless; we</span></div>
<div class="line"><a id="l04479" name="l04479"></a><span class="lineno"> 4479</span><span class="comment">     * don&#39;t allow more data to be queued to be sent after an error (though existing buffered data</span></div>
<div class="line"><a id="l04480" name="l04480"></a><span class="lineno"> 4480</span><span class="comment">     * may yet be sent... but that&#39;s not relevant here).  @todo No graceful close yet. */</span></div>
<div class="line"><a id="l04481" name="l04481"></a><span class="lineno"> 4481</span> </div>
<div class="line"><a id="l04482" name="l04482"></a><span class="lineno"> 4482</span>    <span class="comment">// Mark in *err_code and log.</span></div>
<div class="line"><a id="l04483" name="l04483"></a><span class="lineno"> 4483</span>    <a class="code hl_define" href="error_2error_8hpp.html#adc17094d4b9421abd04b90caab8b8e72">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a>(sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l04484" name="l04484"></a><span class="lineno"> 4484</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l04485" name="l04485"></a><span class="lineno"> 4485</span>  }</div>
<div class="line"><a id="l04486" name="l04486"></a><span class="lineno"> 4486</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04487" name="l04487"></a><span class="lineno"> 4487</span> </div>
<div class="line"><a id="l04488" name="l04488"></a><span class="lineno"> 4488</span>  <span class="comment">// No fatal error (socket not disconnecing or closed).  However it may still be connecting.</span></div>
<div class="line"><a id="l04489" name="l04489"></a><span class="lineno"> 4489</span> </div>
<div class="line"><a id="l04490" name="l04490"></a><span class="lineno"> 4490</span>  <span class="keywordflow">if</span> (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">Peer_socket::Open_sub_state::S_CONNECTING</a>)</div>
<div class="line"><a id="l04491" name="l04491"></a><span class="lineno"> 4491</span>  {</div>
<div class="line"><a id="l04492" name="l04492"></a><span class="lineno"> 4492</span>    <span class="comment">/* Here we draw a line in the sand and refuse to buffer any data.  We could easily allow</span></div>
<div class="line"><a id="l04493" name="l04493"></a><span class="lineno"> 4493</span><span class="comment">     * buffering data even when still S_CONNECTING.  However, I am copying BSD socket semantics</span></div>
<div class="line"><a id="l04494" name="l04494"></a><span class="lineno"> 4494</span><span class="comment">     * here, as they do seem to be useful.  As a user I don&#39;t want to think I&#39;ve &quot;sent&quot; gobs of data</span></div>
<div class="line"><a id="l04495" name="l04495"></a><span class="lineno"> 4495</span><span class="comment">     * while there&#39;s little to suggest that there&#39;s even anyone listening on the other side. */</span></div>
<div class="line"><a id="l04496" name="l04496"></a><span class="lineno"> 4496</span>    err_code-&gt;clear();</div>
<div class="line"><a id="l04497" name="l04497"></a><span class="lineno"> 4497</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l04498" name="l04498"></a><span class="lineno"> 4498</span>  }</div>
<div class="line"><a id="l04499" name="l04499"></a><span class="lineno"> 4499</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04500" name="l04500"></a><span class="lineno"> 4500</span>  assert(sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>);</div>
<div class="line"><a id="l04501" name="l04501"></a><span class="lineno"> 4501</span> </div>
<div class="line"><a id="l04502" name="l04502"></a><span class="lineno"> 4502</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> was_deqable = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a>(sock); <span class="comment">// See below.</span></div>
<div class="line"><a id="l04503" name="l04503"></a><span class="lineno"> 4503</span> </div>
<div class="line"><a id="l04504" name="l04504"></a><span class="lineno"> 4504</span>  <span class="comment">/* Write the user-provided data into m_snd_buf; provide the missing argument (max_data_size).</span></div>
<div class="line"><a id="l04505" name="l04505"></a><span class="lineno"> 4505</span><span class="comment">   * Round up to a multiple of max-block-size to ensure we never fragment a max-block-size-sized</span></div>
<div class="line"><a id="l04506" name="l04506"></a><span class="lineno"> 4506</span><span class="comment">   * chunk of data when they&#39;re using unreliable mode! */</span></div>
<div class="line"><a id="l04507" name="l04507"></a><span class="lineno"> 4507</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> sent = snd_buf_feed_func(sock-&gt;max_block_size_multiple(sock-&gt;m_opts.m_st_snd_buf_max_size));</div>
<div class="line"><a id="l04508" name="l04508"></a><span class="lineno"> 4508</span> </div>
<div class="line"><a id="l04509" name="l04509"></a><span class="lineno"> 4509</span>  <span class="comment">// Register that the Send buffer possibly grew.</span></div>
<div class="line"><a id="l04510" name="l04510"></a><span class="lineno"> 4510</span>  sock-&gt;m_snd_stats.buffer_fed(sock-&gt;m_snd_buf.data_size());</div>
<div class="line"><a id="l04511" name="l04511"></a><span class="lineno"> 4511</span> </div>
<div class="line"><a id="l04512" name="l04512"></a><span class="lineno"> 4512</span>  <span class="comment">/* We&#39;ve done the minimal thing send() does: added data to the send buffer.  Now we may need to</span></div>
<div class="line"><a id="l04513" name="l04513"></a><span class="lineno"> 4513</span><span class="comment">   * kick off the actual asynchronous sending of some of these data by thread W.  It&#39;s important to</span></div>
<div class="line"><a id="l04514" name="l04514"></a><span class="lineno"> 4514</span><span class="comment">   * discuss the overall strategy for how that works.</span></div>
<div class="line"><a id="l04515" name="l04515"></a><span class="lineno"> 4515</span><span class="comment">   *</span></div>
<div class="line"><a id="l04516" name="l04516"></a><span class="lineno"> 4516</span><span class="comment">   * Key question: how does W send low-level packets over UDP?  Answer: if there&#39;s anything on the</span></div>
<div class="line"><a id="l04517" name="l04517"></a><span class="lineno"> 4517</span><span class="comment">   * Send buffer or retransmission queue (if retransmission is enabled), and there is no other</span></div>
<div class="line"><a id="l04518" name="l04518"></a><span class="lineno"> 4518</span><span class="comment">   * (congestion control, probably) reason NOT to send packets, then dequeue a packet from</span></div>
<div class="line"><a id="l04519" name="l04519"></a><span class="lineno"> 4519</span><span class="comment">   * retransmission queue or Send buffer and send it off to the UDP layer; repeat in a tight loop</span></div>
<div class="line"><a id="l04520" name="l04520"></a><span class="lineno"> 4520</span><span class="comment">   * until both Send queues are empty, or there&#39;s some reason NOT to send packets (again, congestion</span></div>
<div class="line"><a id="l04521" name="l04521"></a><span class="lineno"> 4521</span><span class="comment">   * control). Let&#39;s write this in pseudo-code:</span></div>
<div class="line"><a id="l04522" name="l04522"></a><span class="lineno"> 4522</span><span class="comment">   *</span></div>
<div class="line"><a id="l04523" name="l04523"></a><span class="lineno"> 4523</span><span class="comment">   *   DEQ(sock): // Thread W only.</span></div>
<div class="line"><a id="l04524" name="l04524"></a><span class="lineno"> 4524</span><span class="comment">   *     if (!sendable(sock)):</span></div>
<div class="line"><a id="l04525" name="l04525"></a><span class="lineno"> 4525</span><span class="comment">   *       return // Slight optimization; perform this first check before locking.</span></div>
<div class="line"><a id="l04526" name="l04526"></a><span class="lineno"> 4526</span><span class="comment">   *     lock sock // Must lock because sock-&gt;m_snd_buf accessible from other threads.</span></div>
<div class="line"><a id="l04527" name="l04527"></a><span class="lineno"> 4527</span><span class="comment">   *     while (sendable(sock) &amp;&amp; deqable(sock)):</span></div>
<div class="line"><a id="l04528" name="l04528"></a><span class="lineno"> 4528</span><span class="comment">   *       dequeue sock-&gt;m_snd_buf -&gt; block</span></div>
<div class="line"><a id="l04529" name="l04529"></a><span class="lineno"> 4529</span><span class="comment">   *       serialize block into packet</span></div>
<div class="line"><a id="l04530" name="l04530"></a><span class="lineno"> 4530</span><span class="comment">   *       send packet via UDP</span></div>
<div class="line"><a id="l04531" name="l04531"></a><span class="lineno"> 4531</span><span class="comment">   *     unlock sock</span></div>
<div class="line"><a id="l04532" name="l04532"></a><span class="lineno"> 4532</span><span class="comment">   *</span></div>
<div class="line"><a id="l04533" name="l04533"></a><span class="lineno"> 4533</span><span class="comment">   *   sendable(sock):</span></div>
<div class="line"><a id="l04534" name="l04534"></a><span class="lineno"> 4534</span><span class="comment">   *     return &lt;...probably some congestion control condition involving CWND or something&gt;</span></div>
<div class="line"><a id="l04535" name="l04535"></a><span class="lineno"> 4535</span><span class="comment">   *</span></div>
<div class="line"><a id="l04536" name="l04536"></a><span class="lineno"> 4536</span><span class="comment">   *   deqable(sock):</span></div>
<div class="line"><a id="l04537" name="l04537"></a><span class="lineno"> 4537</span><span class="comment">   *     return !(sock-&gt;m_rexmit_q.empty() &amp;&amp; sock-&gt;m_snd_buf.empty())</span></div>
<div class="line"><a id="l04538" name="l04538"></a><span class="lineno"> 4538</span><span class="comment">   *</span></div>
<div class="line"><a id="l04539" name="l04539"></a><span class="lineno"> 4539</span><span class="comment">   * When should DEQ(sock) execute?  Answer: whenever sendable(sock) and deqable(sock) are true.  If</span></div>
<div class="line"><a id="l04540" name="l04540"></a><span class="lineno"> 4540</span><span class="comment">   * they&#39;re true, but DEQ(sock) doesn&#39;t run for time period P, then it&#39;s practically like adding</span></div>
<div class="line"><a id="l04541" name="l04541"></a><span class="lineno"> 4541</span><span class="comment">   * sleep(P) from the user&#39;s point of view.  So how do we get DEQ(sock) to execute as soon as those</span></div>
<div class="line"><a id="l04542" name="l04542"></a><span class="lineno"> 4542</span><span class="comment">   * conditions are true?  Well, running it repeatedly in a thread W tight loop would do it, but</span></div>
<div class="line"><a id="l04543" name="l04543"></a><span class="lineno"> 4543</span><span class="comment">   * obviously that&#39;s unacceptable.</span></div>
<div class="line"><a id="l04544" name="l04544"></a><span class="lineno"> 4544</span><span class="comment">   *</span></div>
<div class="line"><a id="l04545" name="l04545"></a><span class="lineno"> 4545</span><span class="comment">   * So consider the initial state after sock enters ESTABLISHED state.  sendable(sock) is true;</span></div>
<div class="line"><a id="l04546" name="l04546"></a><span class="lineno"> 4546</span><span class="comment">   * deqable(sock) is false.  The moment deqable(sock) becomes true, we should execute DEQ(sock); in</span></div>
<div class="line"><a id="l04547" name="l04547"></a><span class="lineno"> 4547</span><span class="comment">   * other words in the first sock-&gt;send(), as that will add to m_snd_buf.  After DEQ(sock) exits,</span></div>
<div class="line"><a id="l04548" name="l04548"></a><span class="lineno"> 4548</span><span class="comment">   * there&#39;s no need to call DEQ(sock) until again both conditions are true.  Therefore, the</span></div>
<div class="line"><a id="l04549" name="l04549"></a><span class="lineno"> 4549</span><span class="comment">   * algorithm is: whenever sendable(sock) goes from false to true, and/or deqable(sock) from false</span></div>
<div class="line"><a id="l04550" name="l04550"></a><span class="lineno"> 4550</span><span class="comment">   * to true, call DEQ(sock).  If inside DEQ(sock) one of the conditions is still false, it will</span></div>
<div class="line"><a id="l04551" name="l04551"></a><span class="lineno"> 4551</span><span class="comment">   * quickly return.  (Call the latter a NOOP.)</span></div>
<div class="line"><a id="l04552" name="l04552"></a><span class="lineno"> 4552</span><span class="comment">   *</span></div>
<div class="line"><a id="l04553" name="l04553"></a><span class="lineno"> 4553</span><span class="comment">   * Now we must come up with a scheme that will ensure DEQ(sock) will run very quickly after either</span></div>
<div class="line"><a id="l04554" name="l04554"></a><span class="lineno"> 4554</span><span class="comment">   * condition (sendable(sock), deqable(sock)) becomes true; and that will not peg the CPU.</span></div>
<div class="line"><a id="l04555" name="l04555"></a><span class="lineno"> 4555</span><span class="comment">   *</span></div>
<div class="line"><a id="l04556" name="l04556"></a><span class="lineno"> 4556</span><span class="comment">   * Consider sendable().  Only thread W (transport layer) can determine this value: it depends on</span></div>
<div class="line"><a id="l04557" name="l04557"></a><span class="lineno"> 4557</span><span class="comment">   * wholly internal details like packets in-flight and CWND.  Therefore sendable(sock) can go</span></div>
<div class="line"><a id="l04558" name="l04558"></a><span class="lineno"> 4558</span><span class="comment">   * false-&gt;true only in W.  Hence W, whenever changing any component that might affect</span></div>
<div class="line"><a id="l04559" name="l04559"></a><span class="lineno"> 4559</span><span class="comment">   * sendable(sock) would do:</span></div>
<div class="line"><a id="l04560" name="l04560"></a><span class="lineno"> 4560</span><span class="comment">   *</span></div>
<div class="line"><a id="l04561" name="l04561"></a><span class="lineno"> 4561</span><span class="comment">   *   // ... Something related to sendable(sock) has changed....</span></div>
<div class="line"><a id="l04562" name="l04562"></a><span class="lineno"> 4562</span><span class="comment">   *   DEQ(sock) // So check and send if possible.</span></div>
<div class="line"><a id="l04563" name="l04563"></a><span class="lineno"> 4563</span><span class="comment">   *</span></div>
<div class="line"><a id="l04564" name="l04564"></a><span class="lineno"> 4564</span><span class="comment">   * Clearly this calls DEQ(sock) as soon as humanly possible after sendable(sock) becomes true.</span></div>
<div class="line"><a id="l04565" name="l04565"></a><span class="lineno"> 4565</span><span class="comment">   * Clearly it wastes no CPU cycles either.  OK.</span></div>
<div class="line"><a id="l04566" name="l04566"></a><span class="lineno"> 4566</span><span class="comment">   *</span></div>
<div class="line"><a id="l04567" name="l04567"></a><span class="lineno"> 4567</span><span class="comment">   * Now consider deqable().  sock-&gt;m_snd_buf can only change from empty to non-empty in the</span></div>
<div class="line"><a id="l04568" name="l04568"></a><span class="lineno"> 4568</span><span class="comment">   * previous statement (snd_buf_feed_func()).  That is in thread U != W.  Suppose we write:</span></div>
<div class="line"><a id="l04569" name="l04569"></a><span class="lineno"> 4569</span><span class="comment">   *</span></div>
<div class="line"><a id="l04570" name="l04570"></a><span class="lineno"> 4570</span><span class="comment">   *   SEND(sock, blocks): // Non-W threads only.</span></div>
<div class="line"><a id="l04571" name="l04571"></a><span class="lineno"> 4571</span><span class="comment">   *     lock sock // Must lock because sock-&gt;m_snd_buf accessible from other threads.</span></div>
<div class="line"><a id="l04572" name="l04572"></a><span class="lineno"> 4572</span><span class="comment">   *     add blocks -&gt; sock-&gt;m_snd_buf</span></div>
<div class="line"><a id="l04573" name="l04573"></a><span class="lineno"> 4573</span><span class="comment">   *     if (sock-&gt;m_snd_buf was empty before previous statement)</span></div>
<div class="line"><a id="l04574" name="l04574"></a><span class="lineno"> 4574</span><span class="comment">   *       // Queue DEQ(sock) for asynchronous execution on thread W as soon as it&#39;s free:</span></div>
<div class="line"><a id="l04575" name="l04575"></a><span class="lineno"> 4575</span><span class="comment">   *       post(W, DEQ(sock))</span></div>
<div class="line"><a id="l04576" name="l04576"></a><span class="lineno"> 4576</span><span class="comment">   *     unlock sock</span></div>
<div class="line"><a id="l04577" name="l04577"></a><span class="lineno"> 4577</span><span class="comment">   *</span></div>
<div class="line"><a id="l04578" name="l04578"></a><span class="lineno"> 4578</span><span class="comment">   * Does this call DEQ(sock) as soon as deqable(sock) becomes true?  Well, DEQ(sock) can only run</span></div>
<div class="line"><a id="l04579" name="l04579"></a><span class="lineno"> 4579</span><span class="comment">   * on thread W, and the enqueuing of blocks can only happen on thread U, and post() will cause</span></div>
<div class="line"><a id="l04580" name="l04580"></a><span class="lineno"> 4580</span><span class="comment">   * DEQ(sock) to run as soon as possible.  Therefore that&#39;s as good as it can be.  Is it correct,</span></div>
<div class="line"><a id="l04581" name="l04581"></a><span class="lineno"> 4581</span><span class="comment">   * however?  The mainstream case is that once &quot;unlock sock&quot; finished in SEND(), thread W will get</span></div>
<div class="line"><a id="l04582" name="l04582"></a><span class="lineno"> 4582</span><span class="comment">   * some free time, execute the just-queued DEQ(), and thus everything works out.  OK so far.</span></div>
<div class="line"><a id="l04583" name="l04583"></a><span class="lineno"> 4583</span><span class="comment">   *</span></div>
<div class="line"><a id="l04584" name="l04584"></a><span class="lineno"> 4584</span><span class="comment">   * Since, however, post() is (obviously) asynchronous and done from thread non-W, there is</span></div>
<div class="line"><a id="l04585" name="l04585"></a><span class="lineno"> 4585</span><span class="comment">   * potential for other tomfoolery.  First consider competing SEND() calls from other threads.</span></div>
<div class="line"><a id="l04586" name="l04586"></a><span class="lineno"> 4586</span><span class="comment">   * Because of locking, they will be entirely sequential even from different threads and thus can</span></div>
<div class="line"><a id="l04587" name="l04587"></a><span class="lineno"> 4587</span><span class="comment">   * be considered as all in one thread U != W.  Now suppose SEND() placed DEQ() onto W, and another</span></div>
<div class="line"><a id="l04588" name="l04588"></a><span class="lineno"> 4588</span><span class="comment">   * SEND() executes before DEQ() executes on W.  No problem: since only DEQ() can dequeue the Send</span></div>
<div class="line"><a id="l04589" name="l04589"></a><span class="lineno"> 4589</span><span class="comment">   * buffer, and the 1st SEND() made the buffer non-empty, the 2nd SEND() will not affect the DEQ()</span></div>
<div class="line"><a id="l04590" name="l04590"></a><span class="lineno"> 4590</span><span class="comment">   * situation, since it cannot make m_snd_buf become non-empty after being empty (was already</span></div>
<div class="line"><a id="l04591" name="l04591"></a><span class="lineno"> 4591</span><span class="comment">   * non-empty).</span></div>
<div class="line"><a id="l04592" name="l04592"></a><span class="lineno"> 4592</span><span class="comment">   *</span></div>
<div class="line"><a id="l04593" name="l04593"></a><span class="lineno"> 4593</span><span class="comment">   * Second consider SEND(sock, blocks) executing while a W handler is executing.  Now suppose this</span></div>
<div class="line"><a id="l04594" name="l04594"></a><span class="lineno"> 4594</span><span class="comment">   * W handler discovers that sendable() may be affected and thus calls DEQ(sock) as shown above;</span></div>
<div class="line"><a id="l04595" name="l04595"></a><span class="lineno"> 4595</span><span class="comment">   * meanwhile SEND() posts DEQ(sock) onto W as well.  W will wait until SEND(sock, blocks) exits</span></div>
<div class="line"><a id="l04596" name="l04596"></a><span class="lineno"> 4596</span><span class="comment">   * (due to the lock) before executing most of DEQ(sock), but when it does it will be ITS DEQ(sock)</span></div>
<div class="line"><a id="l04597" name="l04597"></a><span class="lineno"> 4597</span><span class="comment">   * that executes first (regardless of whether the post from thread U happened first).  This</span></div>
<div class="line"><a id="l04598" name="l04598"></a><span class="lineno"> 4598</span><span class="comment">   * DEQ(sock) will not be a NOOP, which is great.  Now, thread W should exit that handler and</span></div>
<div class="line"><a id="l04599" name="l04599"></a><span class="lineno"> 4599</span><span class="comment">   * finally execute SEND()&#39;s posted DEQ() -- which will be a NOOP, because the synchronous</span></div>
<div class="line"><a id="l04600" name="l04600"></a><span class="lineno"> 4600</span><span class="comment">   * DEQ(sock) from thread W preempted it.</span></div>
<div class="line"><a id="l04601" name="l04601"></a><span class="lineno"> 4601</span><span class="comment">   *</span></div>
<div class="line"><a id="l04602" name="l04602"></a><span class="lineno"> 4602</span><span class="comment">   * Is this OK?  Most likely.  It&#39;ll spend some extra CPU cycles on the check in the NOOP, but</span></div>
<div class="line"><a id="l04603" name="l04603"></a><span class="lineno"> 4603</span><span class="comment">   * that&#39;s it.  Now, there is some conceivable way that, maybe, such NOOPs could happen a lot in a</span></div>
<div class="line"><a id="l04604" name="l04604"></a><span class="lineno"> 4604</span><span class="comment">   * very busy system and perhaps even &quot;bunch&quot; up to peg the CPU.  However, after doing many thought</span></div>
<div class="line"><a id="l04605" name="l04605"></a><span class="lineno"> 4605</span><span class="comment">   * experiments, I unable to come up with anything actually worrying.</span></div>
<div class="line"><a id="l04606" name="l04606"></a><span class="lineno"> 4606</span><span class="comment">   *</span></div>
<div class="line"><a id="l04607" name="l04607"></a><span class="lineno"> 4607</span><span class="comment">   * The other way deqable(sock) can become true is if m_rexmit_q was empty but becomes non-empty.</span></div>
<div class="line"><a id="l04608" name="l04608"></a><span class="lineno"> 4608</span><span class="comment">   * In other words, if we detect packet as Dropped, we will have added it (if retransmission is on)</span></div>
<div class="line"><a id="l04609" name="l04609"></a><span class="lineno"> 4609</span><span class="comment">   * to m_rexmit_q.  This can only happen on thread W and thus is handled similarly to</span></div>
<div class="line"><a id="l04610" name="l04610"></a><span class="lineno"> 4610</span><span class="comment">   * sendable(sock):</span></div>
<div class="line"><a id="l04611" name="l04611"></a><span class="lineno"> 4611</span><span class="comment">   *</span></div>
<div class="line"><a id="l04612" name="l04612"></a><span class="lineno"> 4612</span><span class="comment">   *   // ... Something related to deqable(sock) has changed....</span></div>
<div class="line"><a id="l04613" name="l04613"></a><span class="lineno"> 4613</span><span class="comment">   *   DEQ(sock) // So check and send if possible.</span></div>
<div class="line"><a id="l04614" name="l04614"></a><span class="lineno"> 4614</span><span class="comment">   *</span></div>
<div class="line"><a id="l04615" name="l04615"></a><span class="lineno"> 4615</span><span class="comment">   * So this system should be OK.  Now let&#39;s map the above pseudocode to actual code.</span></div>
<div class="line"><a id="l04616" name="l04616"></a><span class="lineno"> 4616</span><span class="comment">   *</span></div>
<div class="line"><a id="l04617" name="l04617"></a><span class="lineno"> 4617</span><span class="comment">   * SEND(sock, blocks) is the very method you&#39;re reading now (Peer_socket::send() and</span></div>
<div class="line"><a id="l04618" name="l04618"></a><span class="lineno"> 4618</span><span class="comment">   * Node::send(), runs in thread U != W).  DEQ(sock) is Node::send_worker(sock) (runs in thread</span></div>
<div class="line"><a id="l04619" name="l04619"></a><span class="lineno"> 4619</span><span class="comment">   * W).  sendable(sock) is Node::can_send(sock).  deqable(sock) is Node::snd_deqable(sock).</span></div>
<div class="line"><a id="l04620" name="l04620"></a><span class="lineno"> 4620</span><span class="comment">   * post(W, f) is post(Node::m_task_engine, f).</span></div>
<div class="line"><a id="l04621" name="l04621"></a><span class="lineno"> 4621</span><span class="comment">   *</span></div>
<div class="line"><a id="l04622" name="l04622"></a><span class="lineno"> 4622</span><span class="comment">   * OK, there is one more small caveat.  If DEQ(sock) is placed onto W by SEND(sock, blocks),</span></div>
<div class="line"><a id="l04623" name="l04623"></a><span class="lineno"> 4623</span><span class="comment">   * then before this DEQ() is executed, thread W may change the state of sock (for example, close</span></div>
<div class="line"><a id="l04624" name="l04624"></a><span class="lineno"> 4624</span><span class="comment">   * it).  Therefore, DEQ() must also ensure it&#39;s operating in a state where it can send data</span></div>
<div class="line"><a id="l04625" name="l04625"></a><span class="lineno"> 4625</span><span class="comment">   * (ESTABLISHED at least), and if not, NOOP.  Of course if DEQ() is executed synchronously by W,</span></div>
<div class="line"><a id="l04626" name="l04626"></a><span class="lineno"> 4626</span><span class="comment">   * then this is unnecessary (since W code wouldn&#39;t execute DEQ() directly unless already in a</span></div>
<div class="line"><a id="l04627" name="l04627"></a><span class="lineno"> 4627</span><span class="comment">   * proper state for this).  So, send_worker_check_state() is actually a little bit more than just</span></div>
<div class="line"><a id="l04628" name="l04628"></a><span class="lineno"> 4628</span><span class="comment">   * DEQ(), while send_worker() is just DEQ().  send() posts send_worker_check_state(), while</span></div>
<div class="line"><a id="l04629" name="l04629"></a><span class="lineno"> 4629</span><span class="comment">   * thread W executes send_worker() directly. */</span></div>
<div class="line"><a id="l04630" name="l04630"></a><span class="lineno"> 4630</span> </div>
<div class="line"><a id="l04631" name="l04631"></a><span class="lineno"> 4631</span>  <span class="keywordflow">if</span> ((!was_deqable) &amp;&amp; (sent != 0))</div>
<div class="line"><a id="l04632" name="l04632"></a><span class="lineno"> 4632</span>  {</div>
<div class="line"><a id="l04633" name="l04633"></a><span class="lineno"> 4633</span>    <span class="comment">// Possibly send_worker() can send packets now (send buffer went from empty to not).</span></div>
<div class="line"><a id="l04634" name="l04634"></a><span class="lineno"> 4634</span>    post(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, [<span class="keyword">this</span>, sock]() { <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">send_worker_check_state</a>(sock); });</div>
<div class="line"><a id="l04635" name="l04635"></a><span class="lineno"> 4635</span>  }</div>
<div class="line"><a id="l04636" name="l04636"></a><span class="lineno"> 4636</span> </div>
<div class="line"><a id="l04637" name="l04637"></a><span class="lineno"> 4637</span>  err_code-&gt;clear();</div>
<div class="line"><a id="l04638" name="l04638"></a><span class="lineno"> 4638</span>  <span class="keywordflow">return</span> sent;</div>
<div class="line"><a id="l04639" name="l04639"></a><span class="lineno"> 4639</span>  <span class="comment">// Note that sock-&gt;m_mutex is unlocked here (and send_worker() will lock it again when it [probably soon] executes).</span></div>
<div class="line"><a id="l04640" name="l04640"></a><span class="lineno"> 4640</span>} <span class="comment">// Node::send()</span></div>
<div class="line"><a id="l04641" name="l04641"></a><span class="lineno"> 4641</span> </div>
<div class="line"><a id="l04642" name="l04642"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06"> 4642</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">Node::sock_is_writable</a>(<span class="keyword">const</span> boost::any&amp; sock_as_any)<span class="keyword"> const</span></div>
<div class="line"><a id="l04643" name="l04643"></a><span class="lineno"> 4643</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04644" name="l04644"></a><span class="lineno"> 4644</span>  <span class="keyword">using </span>boost::any_cast;</div>
<div class="line"><a id="l04645" name="l04645"></a><span class="lineno"> 4645</span> </div>
<div class="line"><a id="l04646" name="l04646"></a><span class="lineno"> 4646</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock = any_cast&lt;Peer_socket::Ptr&gt;(sock_as_any);</div>
<div class="line"><a id="l04647" name="l04647"></a><span class="lineno"> 4647</span> </div>
<div class="line"><a id="l04648" name="l04648"></a><span class="lineno"> 4648</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex); <span class="comment">// Many threads can access/write below state.</span></div>
<div class="line"><a id="l04649" name="l04649"></a><span class="lineno"> 4649</span> </div>
<div class="line"><a id="l04650" name="l04650"></a><span class="lineno"> 4650</span>  <span class="comment">/* Our task here is to return true if and only if at this very moment calling sock-&gt;send() would</span></div>
<div class="line"><a id="l04651" name="l04651"></a><span class="lineno"> 4651</span><span class="comment">   * yield either a return value of &gt; 0 OR a non-success *err_code.  In other words, send() would</span></div>
<div class="line"><a id="l04652" name="l04652"></a><span class="lineno"> 4652</span><span class="comment">   * return &quot;something.&quot;  This is used for Event_set machinery.</span></div>
<div class="line"><a id="l04653" name="l04653"></a><span class="lineno"> 4653</span><span class="comment">   *</span></div>
<div class="line"><a id="l04654" name="l04654"></a><span class="lineno"> 4654</span><span class="comment">   * This should mirror send()&#39;s algorithm.  @todo Should send() call this, for code reuse?</span></div>
<div class="line"><a id="l04655" name="l04655"></a><span class="lineno"> 4655</span><span class="comment">   * Maybe/maybe not.  Consider performance when deciding.</span></div>
<div class="line"><a id="l04656" name="l04656"></a><span class="lineno"> 4656</span><span class="comment">   *</span></div>
<div class="line"><a id="l04657" name="l04657"></a><span class="lineno"> 4657</span><span class="comment">   * - If state is CLOSED, then some sort of error/terminating condition occurred, so send()</span></div>
<div class="line"><a id="l04658" name="l04658"></a><span class="lineno"> 4658</span><span class="comment">   *   would return 0 and non-success Error_code == sock-&gt;m_disconnect_cause.  (Writable.)</span></div>
<div class="line"><a id="l04659" name="l04659"></a><span class="lineno"> 4659</span><span class="comment">   * - Otherwise, if state is OPEN+DISCONNECTING, then graceful close (@todo implement it) is</span></div>
<div class="line"><a id="l04660" name="l04660"></a><span class="lineno"> 4660</span><span class="comment">   *   underway; we do not allow more data to be sent (except what&#39;s already in Sent buffer), so</span></div>
<div class="line"><a id="l04661" name="l04661"></a><span class="lineno"> 4661</span><span class="comment">   *   send() would return 0 and non-success Error_code == sock-&gt;m_disconnect_cause.</span></div>
<div class="line"><a id="l04662" name="l04662"></a><span class="lineno"> 4662</span><span class="comment">   *   (Writable.)</span></div>
<div class="line"><a id="l04663" name="l04663"></a><span class="lineno"> 4663</span><span class="comment">   * - Otherwise, if state is OPEN+CONNECTED, and there is Send buffer space, send() would return &gt;</span></div>
<div class="line"><a id="l04664" name="l04664"></a><span class="lineno"> 4664</span><span class="comment">   *   0 and no error.  (Writable.)</span></div>
<div class="line"><a id="l04665" name="l04665"></a><span class="lineno"> 4665</span><span class="comment">   * - The other remaining possibilities:</span></div>
<div class="line"><a id="l04666" name="l04666"></a><span class="lineno"> 4666</span><span class="comment">   *   - OPEN+CONNECTED but no Send buffer space (returns 0, no error).  (Not Writable.)</span></div>
<div class="line"><a id="l04667" name="l04667"></a><span class="lineno"> 4667</span><span class="comment">   *   - OPEN+CONNECTING -- we don&#39;t allow accumulating data in Send buffer (returns 0, no error).</span></div>
<div class="line"><a id="l04668" name="l04668"></a><span class="lineno"> 4668</span><span class="comment">   *     (Not Writable.) */</span></div>
<div class="line"><a id="l04669" name="l04669"></a><span class="lineno"> 4669</span> </div>
<div class="line"><a id="l04670" name="l04670"></a><span class="lineno"> 4670</span>  <span class="keywordflow">return</span> (sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>)</div>
<div class="line"><a id="l04671" name="l04671"></a><span class="lineno"> 4671</span>         || (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>)</div>
<div class="line"><a id="l04672" name="l04672"></a><span class="lineno"> 4672</span>         || ((sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>)</div>
<div class="line"><a id="l04673" name="l04673"></a><span class="lineno"> 4673</span>             &amp;&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">snd_buf_enqable</a>(sock));</div>
<div class="line"><a id="l04674" name="l04674"></a><span class="lineno"> 4674</span>} <span class="comment">// Node::sock_is_writable()</span></div>
<div class="line"><a id="l04675" name="l04675"></a><span class="lineno"> 4675</span> </div>
<div class="line"><a id="l04676" name="l04676"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d"> 4676</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">Node::send_worker_check_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l04677" name="l04677"></a><span class="lineno"> 4677</span>{</div>
<div class="line"><a id="l04678" name="l04678"></a><span class="lineno"> 4678</span>  <span class="comment">// See big comment block in Node::send() first.</span></div>
<div class="line"><a id="l04679" name="l04679"></a><span class="lineno"> 4679</span> </div>
<div class="line"><a id="l04680" name="l04680"></a><span class="lineno"> 4680</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04681" name="l04681"></a><span class="lineno"> 4681</span> </div>
<div class="line"><a id="l04682" name="l04682"></a><span class="lineno"> 4682</span>  <span class="comment">/* This method can be thought of as the chunk of the finite state machine that defines what</span></div>
<div class="line"><a id="l04683" name="l04683"></a><span class="lineno"> 4683</span><span class="comment">   * happens when the &quot;user called send, adding at least 1 block to the send buffer&quot; (@todo: or any data</span></div>
<div class="line"><a id="l04684" name="l04684"></a><span class="lineno"> 4684</span><span class="comment">   * at all, if in reliable mode?) event is defined.  Therefore, we will have a switch() that will handle every</span></div>
<div class="line"><a id="l04685" name="l04685"></a><span class="lineno"> 4685</span><span class="comment">   * state and decide what should happen when that event fires in that state.</span></div>
<div class="line"><a id="l04686" name="l04686"></a><span class="lineno"> 4686</span><span class="comment">   *</span></div>
<div class="line"><a id="l04687" name="l04687"></a><span class="lineno"> 4687</span><span class="comment">   * send() placed us onto thread W.  When send() did so, m_int_state (which it was not allowed to</span></div>
<div class="line"><a id="l04688" name="l04688"></a><span class="lineno"> 4688</span><span class="comment">   * check, as only thread W can access it) was at least ESTABLISHED (since state was</span></div>
<div class="line"><a id="l04689" name="l04689"></a><span class="lineno"> 4689</span><span class="comment">   * S_OPEN+S_CONNECTED, ensured via assert()).  Therefore, we can eliminate several states with</span></div>
<div class="line"><a id="l04690" name="l04690"></a><span class="lineno"> 4690</span><span class="comment">   * assert()s: SYN_SENT, SYN_RCVD. */</span></div>
<div class="line"><a id="l04691" name="l04691"></a><span class="lineno"> 4691</span> </div>
<div class="line"><a id="l04692" name="l04692"></a><span class="lineno"> 4692</span>  <span class="keywordflow">switch</span> (sock-&gt;m_int_state)</div>
<div class="line"><a id="l04693" name="l04693"></a><span class="lineno"> 4693</span>  {</div>
<div class="line"><a id="l04694" name="l04694"></a><span class="lineno"> 4694</span>  <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>:</div>
<div class="line"><a id="l04695" name="l04695"></a><span class="lineno"> 4695</span>    <span class="comment">// Mainstream case.</span></div>
<div class="line"><a id="l04696" name="l04696"></a><span class="lineno"> 4696</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">send_worker</a>(sock, <span class="keyword">false</span>);</div>
<div class="line"><a id="l04697" name="l04697"></a><span class="lineno"> 4697</span>    <span class="comment">/* ^-- defer_delta_check == false: because we were invoked from thread U != W, we are NOT</span></div>
<div class="line"><a id="l04698" name="l04698"></a><span class="lineno"> 4698</span><span class="comment">     * invoked from async_low_lvl_recv().  Therefore, we will NOT perform</span></div>
<div class="line"><a id="l04699" name="l04699"></a><span class="lineno"> 4699</span><span class="comment">     * event_set_all_check_delta(false) before the boost.asio handler exits.  Therefore boost.asio</span></div>
<div class="line"><a id="l04700" name="l04700"></a><span class="lineno"> 4700</span><span class="comment">     * may sleep (block) before event_set_all_check_delta(false).  Therefore that would delay</span></div>
<div class="line"><a id="l04701" name="l04701"></a><span class="lineno"> 4701</span><span class="comment">     * delivery of the Writable event to the user.  Therefore force the delta check immediately.</span></div>
<div class="line"><a id="l04702" name="l04702"></a><span class="lineno"> 4702</span><span class="comment">     * See Node::m_sock_events doc header for details. */</span></div>
<div class="line"><a id="l04703" name="l04703"></a><span class="lineno"> 4703</span>    <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l04704" name="l04704"></a><span class="lineno"> 4704</span>  <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::Int_state::S_CLOSED</a>:</div>
<div class="line"><a id="l04705" name="l04705"></a><span class="lineno"> 4705</span>    <span class="comment">// Unlikely but legitimate.</span></div>
<div class="line"><a id="l04706" name="l04706"></a><span class="lineno"> 4706</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04707" name="l04707"></a><span class="lineno"> 4707</span>                  <span class="stringliteral">&quot;in state [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04708" name="l04708"></a><span class="lineno"> 4708</span>                  <span class="stringliteral">&quot;closed before asynchronous send_worker() could proceed.&quot;</span>);</div>
<div class="line"><a id="l04709" name="l04709"></a><span class="lineno"> 4709</span>    <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l04710" name="l04710"></a><span class="lineno"> 4710</span>  <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">Peer_socket::Int_state::S_SYN_SENT</a>:</div>
<div class="line"><a id="l04711" name="l04711"></a><span class="lineno"> 4711</span>  <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">Peer_socket::Int_state::S_SYN_RCVD</a>:</div>
<div class="line"><a id="l04712" name="l04712"></a><span class="lineno"> 4712</span>    <span class="comment">// Crash.  See above reasoning.</span></div>
<div class="line"><a id="l04713" name="l04713"></a><span class="lineno"> 4713</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04714" name="l04714"></a><span class="lineno"> 4714</span>                     <span class="stringliteral">&quot;in state [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04715" name="l04715"></a><span class="lineno"> 4715</span>                     <span class="stringliteral">&quot;somehow had send() called on it.&quot;</span>);</div>
<div class="line"><a id="l04716" name="l04716"></a><span class="lineno"> 4716</span>    assert(<span class="keyword">false</span>);</div>
<div class="line"><a id="l04717" name="l04717"></a><span class="lineno"> 4717</span>    <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l04718" name="l04718"></a><span class="lineno"> 4718</span>  } <span class="comment">// switch (sock-&gt;m_int_state)</span></div>
<div class="line"><a id="l04719" name="l04719"></a><span class="lineno"> 4719</span>} <span class="comment">// Node::send_worker_check_state()</span></div>
<div class="line"><a id="l04720" name="l04720"></a><span class="lineno"> 4720</span> </div>
<div class="line"><a id="l04721" name="l04721"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1"> 4721</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">Node::send_worker</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> defer_delta_check)</div>
<div class="line"><a id="l04722" name="l04722"></a><span class="lineno"> 4722</span>{</div>
<div class="line"><a id="l04723" name="l04723"></a><span class="lineno"> 4723</span>  <span class="keyword">using </span>boost::asio::buffer;</div>
<div class="line"><a id="l04724" name="l04724"></a><span class="lineno"> 4724</span>  <span class="keyword">using </span>boost::next;</div>
<div class="line"><a id="l04725" name="l04725"></a><span class="lineno"> 4725</span>  <span class="keyword">using </span>boost::ratio;</div>
<div class="line"><a id="l04726" name="l04726"></a><span class="lineno"> 4726</span>  <span class="keyword">using </span>boost::ratio_string;</div>
<div class="line"><a id="l04727" name="l04727"></a><span class="lineno"> 4727</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l04728" name="l04728"></a><span class="lineno"> 4728</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l04729" name="l04729"></a><span class="lineno"> 4729</span>  <span class="keyword">using </span>boost::shared_ptr;</div>
<div class="line"><a id="l04730" name="l04730"></a><span class="lineno"> 4730</span>  <span class="keyword">using </span>std::list;</div>
<div class="line"><a id="l04731" name="l04731"></a><span class="lineno"> 4731</span> </div>
<div class="line"><a id="l04732" name="l04732"></a><span class="lineno"> 4732</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l04733" name="l04733"></a><span class="lineno"> 4733</span> </div>
<div class="line"><a id="l04734" name="l04734"></a><span class="lineno"> 4734</span>  <span class="comment">// See big comment block in Node::send() first.</span></div>
<div class="line"><a id="l04735" name="l04735"></a><span class="lineno"> 4735</span> </div>
<div class="line"><a id="l04736" name="l04736"></a><span class="lineno"> 4736</span>  <span class="comment">// Pre-condition.</span></div>
<div class="line"><a id="l04737" name="l04737"></a><span class="lineno"> 4737</span>  assert(sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>);</div>
<div class="line"><a id="l04738" name="l04738"></a><span class="lineno"> 4738</span> </div>
<div class="line"><a id="l04739" name="l04739"></a><span class="lineno"> 4739</span>  <span class="comment">/* We are about to potentially send a bunch of DATA packets.  Before sending a given packet, we</span></div>
<div class="line"><a id="l04740" name="l04740"></a><span class="lineno"> 4740</span><span class="comment">   * will call can_send() which will ask the congestion control module whether there is space in</span></div>
<div class="line"><a id="l04741" name="l04741"></a><span class="lineno"> 4741</span><span class="comment">   * what it thinks is the available pipe and return true if so (as well as check rcv_wnd, ensuring</span></div>
<div class="line"><a id="l04742" name="l04742"></a><span class="lineno"> 4742</span><span class="comment">   * the receiver&#39;s Receive buffer can handle the data once they arrive).  However, how it answers</span></div>
<div class="line"><a id="l04743" name="l04743"></a><span class="lineno"> 4743</span><span class="comment">   * that question depends on the size of the pipe (m_snd_cong_ctl-&gt;congestion_window_bytes(),</span></div>
<div class="line"><a id="l04744" name="l04744"></a><span class="lineno"> 4744</span><span class="comment">   * a/k/a CWND). Many (most?) congestion control modules will want to reduce CWND when a</span></div>
<div class="line"><a id="l04745" name="l04745"></a><span class="lineno"> 4745</span><span class="comment">   * connection has been idle -- not sending anything, due to no data to be sent in Send buffer --</span></div>
<div class="line"><a id="l04746" name="l04746"></a><span class="lineno"> 4746</span><span class="comment">   * for a while.  Thus we must call m_snd_cong_ctl-&gt;on_idle_timeout() if we&#39;ve hit Idle Timeout.</span></div>
<div class="line"><a id="l04747" name="l04747"></a><span class="lineno"> 4747</span><span class="comment">   *</span></div>
<div class="line"><a id="l04748" name="l04748"></a><span class="lineno"> 4748</span><span class="comment">   * The definition of Idle Timeout we use is from TCP RFC 5681-4.1 (and DCCP CCID 2 RFC 4341-5.1).</span></div>
<div class="line"><a id="l04749" name="l04749"></a><span class="lineno"> 4749</span><span class="comment">   * It&#39;s simple: Idle Timeout is DTO (Drop Timeout) time units since a DATA packet has been last</span></div>
<div class="line"><a id="l04750" name="l04750"></a><span class="lineno"> 4750</span><span class="comment">   * sent.  While I basically grasp the intuition behind it (if a DTO since even the last-sent</span></div>
<div class="line"><a id="l04751" name="l04751"></a><span class="lineno"> 4751</span><span class="comment">   * packet has expired, and no retransmission/further transmission has occurred, then there must</span></div>
<div class="line"><a id="l04752" name="l04752"></a><span class="lineno"> 4752</span><span class="comment">   * have been no more data for a while), I can&#39;t quite prove to myself that it&#39;s exactly right,</span></div>
<div class="line"><a id="l04753" name="l04753"></a><span class="lineno"> 4753</span><span class="comment">   * mostly due to the fact that DTO may change over time.  It&#39;s probably right though, as RFC 4341</span></div>
<div class="line"><a id="l04754" name="l04754"></a><span class="lineno"> 4754</span><span class="comment">   * recommends it, even though that protocol is closer to NetFlow than TCP (full selective ACKs).</span></div>
<div class="line"><a id="l04755" name="l04755"></a><span class="lineno"> 4755</span><span class="comment">   * Anyway, if we see too many false Idle timeouts, revisit this.</span></div>
<div class="line"><a id="l04756" name="l04756"></a><span class="lineno"> 4756</span><span class="comment">   *</span></div>
<div class="line"><a id="l04757" name="l04757"></a><span class="lineno"> 4757</span><span class="comment">   * Why check this now?  Why not start a proper timer, each time packet is sent, instead and just</span></div>
<div class="line"><a id="l04758" name="l04758"></a><span class="lineno"> 4758</span><span class="comment">   * inform m_snd_cong_ctl when it fires?  Answer: timer management is somewhat of a pain in the ass</span></div>
<div class="line"><a id="l04759" name="l04759"></a><span class="lineno"> 4759</span><span class="comment">   * (as you can see in our other various timers, such as m_snd_drop_timer).  Here we have an opportunity</span></div>
<div class="line"><a id="l04760" name="l04760"></a><span class="lineno"> 4760</span><span class="comment">   * to simply check the condition and affect CWND right before CWND would be used anyway</span></div>
<div class="line"><a id="l04761" name="l04761"></a><span class="lineno"> 4761</span><span class="comment">   * (can_send()).  It&#39;s simpler, and the performance impact is negligible (it&#39;s just a</span></div>
<div class="line"><a id="l04762" name="l04762"></a><span class="lineno"> 4762</span><span class="comment">   * Fine_clock::now() call and a comparison).  You ask, why not do the same for other timers</span></div>
<div class="line"><a id="l04763" name="l04763"></a><span class="lineno"> 4763</span><span class="comment">   * then, in particular the Drop Timer?  Answer: for Drop Timer, we really need to know exactly</span></div>
<div class="line"><a id="l04764" name="l04764"></a><span class="lineno"> 4764</span><span class="comment">   * when it fires, so that we can Drop In-flight packets right then and possibly send more</span></div>
<div class="line"><a id="l04765" name="l04765"></a><span class="lineno"> 4765</span><span class="comment">   * packets (among other things).  In this case there is no such requirement; we only care about</span></div>
<div class="line"><a id="l04766" name="l04766"></a><span class="lineno"> 4766</span><span class="comment">   * whether the Idle Timeout has tripped when we&#39;re about to send something. */</span></div>
<div class="line"><a id="l04767" name="l04767"></a><span class="lineno"> 4767</span> </div>
<div class="line"><a id="l04768" name="l04768"></a><span class="lineno"> 4768</span>  <span class="comment">/* To avoid a very close race between DTO and idle timeout, apply a slight factor of &gt; 1 to DTO.</span></div>
<div class="line"><a id="l04769" name="l04769"></a><span class="lineno"> 4769</span><span class="comment">   * Using boost::ratio&lt;&gt; instead of a double or something for same reason as in</span></div>
<div class="line"><a id="l04770" name="l04770"></a><span class="lineno"> 4770</span><span class="comment">   * new_round_trip_time_sample(). */</span></div>
<div class="line"><a id="l04771" name="l04771"></a><span class="lineno"> 4771</span>  <span class="keyword">using </span>Idle_timeout_dto_factor = ratio&lt;110, 100&gt;;</div>
<div class="line"><a id="l04772" name="l04772"></a><span class="lineno"> 4772</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> idle_timeout</div>
<div class="line"><a id="l04773" name="l04773"></a><span class="lineno"> 4773</span>    = sock-&gt;m_snd_drop_timeout * Idle_timeout_dto_factor::num / Idle_timeout_dto_factor::den;</div>
<div class="line"><a id="l04774" name="l04774"></a><span class="lineno"> 4774</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> since_last_send = Fine_clock::now() - sock-&gt;m_snd_last_data_sent_when;</div>
<div class="line"><a id="l04775" name="l04775"></a><span class="lineno"> 4775</span> </div>
<div class="line"><a id="l04776" name="l04776"></a><span class="lineno"> 4776</span>  <span class="keywordflow">if</span> ((sock-&gt;m_snd_last_data_sent_when != <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>()) &amp;&amp; (since_last_send &gt; idle_timeout))</div>
<div class="line"><a id="l04777" name="l04777"></a><span class="lineno"> 4777</span>  {</div>
<div class="line"><a id="l04778" name="l04778"></a><span class="lineno"> 4778</span>    <span class="comment">// Arguable if this should be INFO or TRACE.  We&#39;ll see.</span></div>
<div class="line"><a id="l04779" name="l04779"></a><span class="lineno"> 4779</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Idle timeout triggered for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l04780" name="l04780"></a><span class="lineno"> 4780</span>                  <span class="stringliteral">&quot;last activity [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(since_last_send) &lt;&lt; <span class="stringliteral">&quot;] ago &quot;</span></div>
<div class="line"><a id="l04781" name="l04781"></a><span class="lineno"> 4781</span>                  <span class="stringliteral">&quot;exceeds idle timeout [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(idle_timeout) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04782" name="l04782"></a><span class="lineno"> 4782</span>                  <span class="stringliteral">&quot;= &quot;</span> &lt;&lt; (ratio_string&lt;Idle_timeout_dto_factor, char&gt;::prefix()) &lt;&lt; <span class="stringliteral">&quot; x &quot;</span></div>
<div class="line"><a id="l04783" name="l04783"></a><span class="lineno"> 4783</span>                  <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(sock-&gt;m_snd_drop_timeout) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04784" name="l04784"></a><span class="lineno"> 4784</span>    sock-&gt;m_snd_cong_ctl-&gt;on_idle_timeout();</div>
<div class="line"><a id="l04785" name="l04785"></a><span class="lineno"> 4785</span>    sock-&gt;m_snd_stats.idle_timeout();</div>
<div class="line"><a id="l04786" name="l04786"></a><span class="lineno"> 4786</span>  }</div>
<div class="line"><a id="l04787" name="l04787"></a><span class="lineno"> 4787</span> </div>
<div class="line"><a id="l04788" name="l04788"></a><span class="lineno"> 4788</span>  <span class="comment">/* Check networking conditions (presumably congestion control) and flow control (rcv_wnd).</span></div>
<div class="line"><a id="l04789" name="l04789"></a><span class="lineno"> 4789</span><span class="comment">   * Ideally this would always be true, but then we&#39;d overwhelm the link when send() is invoked on</span></div>
<div class="line"><a id="l04790" name="l04790"></a><span class="lineno"> 4790</span><span class="comment">   * large amounts of data and/or repeatedly. */</span></div>
<div class="line"><a id="l04791" name="l04791"></a><span class="lineno"> 4791</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">can_send</a>(sock))</div>
<div class="line"><a id="l04792" name="l04792"></a><span class="lineno"> 4792</span>  {</div>
<div class="line"><a id="l04793" name="l04793"></a><span class="lineno"> 4793</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l04794" name="l04794"></a><span class="lineno"> 4794</span>                   <span class="stringliteral">&quot;Initial check: can_send() is false.&quot;</span>);</div>
<div class="line"><a id="l04795" name="l04795"></a><span class="lineno"> 4795</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04796" name="l04796"></a><span class="lineno"> 4796</span>  }</div>
<div class="line"><a id="l04797" name="l04797"></a><span class="lineno"> 4797</span>  <span class="comment">// else can send if there are data to send.</span></div>
<div class="line"><a id="l04798" name="l04798"></a><span class="lineno"> 4798</span> </div>
<div class="line"><a id="l04799" name="l04799"></a><span class="lineno"> 4799</span>  <span class="comment">/* Didn&#39;t lock sock above, as can_send() depends only on internal state, which is accessed from</span></div>
<div class="line"><a id="l04800" name="l04800"></a><span class="lineno"> 4800</span><span class="comment">   * thread W only.  This is an optimization to avoid thread contention (with non-W send()s) for the</span></div>
<div class="line"><a id="l04801" name="l04801"></a><span class="lineno"> 4801</span><span class="comment">   * lock in the case when congestion control is preventing sends.</span></div>
<div class="line"><a id="l04802" name="l04802"></a><span class="lineno"> 4802</span><span class="comment">   *</span></div>
<div class="line"><a id="l04803" name="l04803"></a><span class="lineno"> 4803</span><span class="comment">   * Have to lock now, for sock-&gt;m_snd_buf access (at least). */</span></div>
<div class="line"><a id="l04804" name="l04804"></a><span class="lineno"> 4804</span> </div>
<div class="line"><a id="l04805" name="l04805"></a><span class="lineno"> 4805</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> rexmit_on = sock-&gt;rexmit_on();</div>
<div class="line"><a id="l04806" name="l04806"></a><span class="lineno"> 4806</span>  <span class="keywordtype">bool</span> writable; <span class="comment">// See below.</span></div>
<div class="line"><a id="l04807" name="l04807"></a><span class="lineno"> 4807</span>  {</div>
<div class="line"><a id="l04808" name="l04808"></a><span class="lineno"> 4808</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l04809" name="l04809"></a><span class="lineno"> 4809</span> </div>
<div class="line"><a id="l04810" name="l04810"></a><span class="lineno"> 4810</span>    <span class="comment">// Check whether enough data in retransmission queue or snd_buf to send a packet.</span></div>
<div class="line"><a id="l04811" name="l04811"></a><span class="lineno"> 4811</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a>(sock))</div>
<div class="line"><a id="l04812" name="l04812"></a><span class="lineno"> 4812</span>    {</div>
<div class="line"><a id="l04813" name="l04813"></a><span class="lineno"> 4813</span>      <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l04814" name="l04814"></a><span class="lineno"> 4814</span>                     <span class="stringliteral">&quot;Initial check: can_send() is true, but no data to send.&quot;</span>);</div>
<div class="line"><a id="l04815" name="l04815"></a><span class="lineno"> 4815</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04816" name="l04816"></a><span class="lineno"> 4816</span>    }</div>
<div class="line"><a id="l04817" name="l04817"></a><span class="lineno"> 4817</span>    <span class="comment">// else can send &gt;= 1 packet.</span></div>
<div class="line"><a id="l04818" name="l04818"></a><span class="lineno"> 4818</span> </div>
<div class="line"><a id="l04819" name="l04819"></a><span class="lineno"> 4819</span>    <span class="comment">// For brevity and a bit of speed:</span></div>
<div class="line"><a id="l04820" name="l04820"></a><span class="lineno"> 4820</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a>&amp; snd_buf = sock-&gt;m_snd_buf;</div>
<div class="line"><a id="l04821" name="l04821"></a><span class="lineno"> 4821</span>    list&lt;Peer_socket::Sent_packet::Ptr&gt;&amp; rexmit_q = sock-&gt;m_snd_rexmit_q;</div>
<div class="line"><a id="l04822" name="l04822"></a><span class="lineno"> 4822</span>    <span class="keywordtype">size_t</span>&amp; rexmit_q_size = sock-&gt;m_snd_rexmit_q_size;</div>
<div class="line"><a id="l04823" name="l04823"></a><span class="lineno"> 4823</span>    <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; snd_next_seq_num = sock-&gt;m_snd_next_seq_num;</div>
<div class="line"><a id="l04824" name="l04824"></a><span class="lineno"> 4824</span> </div>
<div class="line"><a id="l04825" name="l04825"></a><span class="lineno"> 4825</span>    <span class="comment">// @todo Implement graceful close.</span></div>
<div class="line"><a id="l04826" name="l04826"></a><span class="lineno"> 4826</span>    assert(sock-&gt;m_open_sub_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>);</div>
<div class="line"><a id="l04827" name="l04827"></a><span class="lineno"> 4827</span> </div>
<div class="line"><a id="l04828" name="l04828"></a><span class="lineno"> 4828</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l04829" name="l04829"></a><span class="lineno"> 4829</span>                   <span class="stringliteral">&quot;Initial check: Will send from rexmit queue of size [&quot;</span> &lt;&lt; rexmit_q_size &lt;&lt; <span class="stringliteral">&quot;] and/or &quot;</span></div>
<div class="line"><a id="l04830" name="l04830"></a><span class="lineno"> 4830</span>                   <span class="stringliteral">&quot;Send buffer with total size [&quot;</span> &lt;&lt; snd_buf.<a class="code hl_function" href="classflow_1_1net__flow_1_1Socket__buffer.html#af21cd24bba62da1d16a8fc4f9b8e37fd">data_size</a>() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04831" name="l04831"></a><span class="lineno"> 4831</span>    <span class="comment">// Very verbose and CPU-intensive!</span></div>
<div class="line"><a id="l04832" name="l04832"></a><span class="lineno"> 4832</span>    <a class="code hl_define" href="log_8hpp.html#a07561c1c3f16b6c2c7335a09e25298c9">FLOW_LOG_DATA</a>(<span class="stringliteral">&quot;Send buffer data = [\n&quot;</span> &lt;&lt; snd_buf &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04833" name="l04833"></a><span class="lineno"> 4833</span> </div>
<div class="line"><a id="l04834" name="l04834"></a><span class="lineno"> 4834</span>    <span class="comment">// Send packets until one or both of can_send() and snd_deqable() become false.</span></div>
<div class="line"><a id="l04835" name="l04835"></a><span class="lineno"> 4835</span>    <span class="keywordflow">do</span></div>
<div class="line"><a id="l04836" name="l04836"></a><span class="lineno"> 4836</span>    {</div>
<div class="line"><a id="l04837" name="l04837"></a><span class="lineno"> 4837</span>      shared_ptr&lt;Data_packet&gt; data;</div>
<div class="line"><a id="l04838" name="l04838"></a><span class="lineno"> 4838</span>      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> sent_pkt;</div>
<div class="line"><a id="l04839" name="l04839"></a><span class="lineno"> 4839</span>      <span class="keywordtype">bool</span> rexmit = <span class="keyword">false</span>;</div>
<div class="line"><a id="l04840" name="l04840"></a><span class="lineno"> 4840</span> </div>
<div class="line"><a id="l04841" name="l04841"></a><span class="lineno"> 4841</span>      <span class="comment">/* Record send time.  It&#39;s only a temporary value for logging, until we</span></div>
<div class="line"><a id="l04842" name="l04842"></a><span class="lineno"> 4842</span><span class="comment">       * actually send packet.  However, do generate the permanent m_order_num, which is unique. */</span></div>
<div class="line"><a id="l04843" name="l04843"></a><span class="lineno"> 4843</span>      <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a> sent_when{ <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">sock_get_new_snd_order_num</a>(sock), Fine_clock::now(), 0 };</div>
<div class="line"><a id="l04844" name="l04844"></a><span class="lineno"> 4844</span> </div>
<div class="line"><a id="l04845" name="l04845"></a><span class="lineno"> 4845</span>      <span class="comment">/* To provide the best experience on the receiving side, retransmit before sending new data,</span></div>
<div class="line"><a id="l04846" name="l04846"></a><span class="lineno"> 4846</span><span class="comment">       * so that Receive buffer on other side receives data as soon as possible. */</span></div>
<div class="line"><a id="l04847" name="l04847"></a><span class="lineno"> 4847</span>      <span class="keywordflow">if</span> (rexmit_q.empty())</div>
<div class="line"><a id="l04848" name="l04848"></a><span class="lineno"> 4848</span>      {</div>
<div class="line"><a id="l04849" name="l04849"></a><span class="lineno"> 4849</span>        <span class="comment">// Nothing in retransmission queue, so something is in Send buffer.</span></div>
<div class="line"><a id="l04850" name="l04850"></a><span class="lineno"> 4850</span> </div>
<div class="line"><a id="l04851" name="l04851"></a><span class="lineno"> 4851</span>        <span class="comment">// Create low-level DATA packet.</span></div>
<div class="line"><a id="l04852" name="l04852"></a><span class="lineno"> 4852</span>        data = Low_lvl_packet::create_uninit_packet&lt;Data_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l04853" name="l04853"></a><span class="lineno"> 4853</span>        data-&gt;m_rexmit_id = 0; <span class="comment">// First (if retransmission is off, only) send attempt.</span></div>
<div class="line"><a id="l04854" name="l04854"></a><span class="lineno"> 4854</span> </div>
<div class="line"><a id="l04855" name="l04855"></a><span class="lineno"> 4855</span>        <span class="comment">// Dequeue one block into the packet&#39;s data field.</span></div>
<div class="line"><a id="l04856" name="l04856"></a><span class="lineno"> 4856</span> </div>
<div class="line"><a id="l04857" name="l04857"></a><span class="lineno"> 4857</span>        <span class="comment">/* Try to dequeue the head block directly into data.m_data.  Because we are operating snd_buf</span></div>
<div class="line"><a id="l04858" name="l04858"></a><span class="lineno"> 4858</span><span class="comment">         * with block_size_hint == sock-&gt;max_block_size(); and because we don&#39;t send unless CWND</span></div>
<div class="line"><a id="l04859" name="l04859"></a><span class="lineno"> 4859</span><span class="comment">         * allows for at least max_block_size() bytes to be sent, the following should be a</span></div>
<div class="line"><a id="l04860" name="l04860"></a><span class="lineno"> 4860</span><span class="comment">         * constant-time operation (a swap of internal buffers) as opposed to a copy. */</span></div>
<div class="line"><a id="l04861" name="l04861"></a><span class="lineno"> 4861</span>        snd_buf.<a class="code hl_function" href="classflow_1_1net__flow_1_1Socket__buffer.html#a8fe3fe5f6a33cfd8fb84eb2607fbc05b">consume_buf_move</a>(&amp;data-&gt;m_data, sock-&gt;max_block_size());</div>
<div class="line"><a id="l04862" name="l04862"></a><span class="lineno"> 4862</span> </div>
<div class="line"><a id="l04863" name="l04863"></a><span class="lineno"> 4863</span>        <span class="comment">// snd_deqable() returned true, so there must be at least one byte available.</span></div>
<div class="line"><a id="l04864" name="l04864"></a><span class="lineno"> 4864</span>        assert(!data-&gt;m_data.empty());</div>
<div class="line"><a id="l04865" name="l04865"></a><span class="lineno"> 4865</span> </div>
<div class="line"><a id="l04866" name="l04866"></a><span class="lineno"> 4866</span>        <span class="comment">// Set sequence number; then advance the next sequence number variable for the next time we do this.</span></div>
<div class="line"><a id="l04867" name="l04867"></a><span class="lineno"> 4867</span>        data-&gt;m_seq_num = snd_next_seq_num;</div>
<div class="line"><a id="l04868" name="l04868"></a><span class="lineno"> 4868</span>        <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a>(&amp;snd_next_seq_num, data);</div>
<div class="line"><a id="l04869" name="l04869"></a><span class="lineno"> 4869</span> </div>
<div class="line"><a id="l04870" name="l04870"></a><span class="lineno"> 4870</span>        <span class="comment">/* We are just about to send the packet.  Assume it has been sent.  It is not yet Acknowledged</span></div>
<div class="line"><a id="l04871" name="l04871"></a><span class="lineno"> 4871</span><span class="comment">         * and not yet Dropped.  Therefore it is now In-flight.  We should place its info at the back of</span></div>
<div class="line"><a id="l04872" name="l04872"></a><span class="lineno"> 4872</span><span class="comment">         * m_snd_flying_pkts_by_sent_when.  We must maintain the invariant w/r/t that structure (see comment</span></div>
<div class="line"><a id="l04873" name="l04873"></a><span class="lineno"> 4873</span><span class="comment">         * for m_snd_flying_pkts_by_sent_when).</span></div>
<div class="line"><a id="l04874" name="l04874"></a><span class="lineno"> 4874</span><span class="comment">         *</span></div>
<div class="line"><a id="l04875" name="l04875"></a><span class="lineno"> 4875</span><span class="comment">         * Purpose of keeping these data: at least for comparison against Congestion Window,</span></div>
<div class="line"><a id="l04876" name="l04876"></a><span class="lineno"> 4876</span><span class="comment">         * for congestion control. */</span></div>
<div class="line"><a id="l04877" name="l04877"></a><span class="lineno"> 4877</span> </div>
<div class="line"><a id="l04878" name="l04878"></a><span class="lineno"> 4878</span>        <span class="comment">// Guarantee that the new sequence number is &gt; all the currently In-flight ones.</span></div>
<div class="line"><a id="l04879" name="l04879"></a><span class="lineno"> 4879</span>        assert(data-&gt;m_seq_num &gt;= <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">snd_past_last_flying_datum_seq_num</a>(sock));</div>
<div class="line"><a id="l04880" name="l04880"></a><span class="lineno"> 4880</span>        <span class="comment">/* Therefore we will add the following to the end of the map&#39;s ordering.  Note we&#39;ve</span></div>
<div class="line"><a id="l04881" name="l04881"></a><span class="lineno"> 4881</span><span class="comment">         * incremented m_snd_next_seq_num already, maintaining that member&#39;s invariant relationship</span></div>
<div class="line"><a id="l04882" name="l04882"></a><span class="lineno"> 4882</span><span class="comment">         * with m_snd_flying_pkts_by_sent_when. */</span></div>
<div class="line"><a id="l04883" name="l04883"></a><span class="lineno"> 4883</span> </div>
<div class="line"><a id="l04884" name="l04884"></a><span class="lineno"> 4884</span>        <span class="comment">// New packet: create new metadata object.  Record send time.  (The latter will be rewritten later.)</span></div>
<div class="line"><a id="l04885" name="l04885"></a><span class="lineno"> 4885</span>        sent_pkt = <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a>(<span class="keyword">new</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Peer_socket::Sent_packet</a>(rexmit_on, data, sent_when));</div>
<div class="line"><a id="l04886" name="l04886"></a><span class="lineno"> 4886</span>      }</div>
<div class="line"><a id="l04887" name="l04887"></a><span class="lineno"> 4887</span>      <span class="keywordflow">else</span> <span class="comment">// if (!rexmit_q.empty())</span></div>
<div class="line"><a id="l04888" name="l04888"></a><span class="lineno"> 4888</span>      {</div>
<div class="line"><a id="l04889" name="l04889"></a><span class="lineno"> 4889</span>        <span class="comment">// Get packet and metadata from front of retransmission queue.</span></div>
<div class="line"><a id="l04890" name="l04890"></a><span class="lineno"> 4890</span>        rexmit = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04891" name="l04891"></a><span class="lineno"> 4891</span>        sent_pkt = rexmit_q.front();</div>
<div class="line"><a id="l04892" name="l04892"></a><span class="lineno"> 4892</span> </div>
<div class="line"><a id="l04893" name="l04893"></a><span class="lineno"> 4893</span>        --rexmit_q_size;</div>
<div class="line"><a id="l04894" name="l04894"></a><span class="lineno"> 4894</span>        rexmit_q.pop_front();</div>
<div class="line"><a id="l04895" name="l04895"></a><span class="lineno"> 4895</span> </div>
<div class="line"><a id="l04896" name="l04896"></a><span class="lineno"> 4896</span>        <span class="comment">// We&#39;d saved the packet we sent last time -- just need to update some things before resending.</span></div>
<div class="line"><a id="l04897" name="l04897"></a><span class="lineno"> 4897</span>        data = sent_pkt-&gt;m_packet;</div>
<div class="line"><a id="l04898" name="l04898"></a><span class="lineno"> 4898</span> </div>
<div class="line"><a id="l04899" name="l04899"></a><span class="lineno"> 4899</span>        <span class="comment">// Retransmitting -- update retransmit count ID (used to match acks to the acked transmit attempt).</span></div>
<div class="line"><a id="l04900" name="l04900"></a><span class="lineno"> 4900</span>        ++data-&gt;m_rexmit_id;</div>
<div class="line"><a id="l04901" name="l04901"></a><span class="lineno"> 4901</span> </div>
<div class="line"><a id="l04902" name="l04902"></a><span class="lineno"> 4902</span>        <span class="comment">// Record the send time of this newest attempt.  (If pacing enabled this will be rewritten later.)</span></div>
<div class="line"><a id="l04903" name="l04903"></a><span class="lineno"> 4903</span>        sent_pkt-&gt;m_sent_when.push_back(sent_when);</div>
<div class="line"><a id="l04904" name="l04904"></a><span class="lineno"> 4904</span> </div>
<div class="line"><a id="l04905" name="l04905"></a><span class="lineno"> 4905</span>        <span class="comment">// Chronologically, no packets sent after this one have been acked yet, as this packet is new.</span></div>
<div class="line"><a id="l04906" name="l04906"></a><span class="lineno"> 4906</span>        sent_pkt-&gt;m_acks_after_me = 0;</div>
<div class="line"><a id="l04907" name="l04907"></a><span class="lineno"> 4907</span>      }</div>
<div class="line"><a id="l04908" name="l04908"></a><span class="lineno"> 4908</span> </div>
<div class="line"><a id="l04909" name="l04909"></a><span class="lineno"> 4909</span>      <span class="comment">/* Note: We have saved Fine_clock::now() as the send time of the packet. However, especially</span></div>
<div class="line"><a id="l04910" name="l04910"></a><span class="lineno"> 4910</span><span class="comment">       * if pacing is enabled, we want to record it at the time it is actually sent (pacing may</span></div>
<div class="line"><a id="l04911" name="l04911"></a><span class="lineno"> 4911</span><span class="comment">       * delay it).  Even if pacing is disabled, CPU pegging may cause a delay in sending (although</span></div>
<div class="line"><a id="l04912" name="l04912"></a><span class="lineno"> 4912</span><span class="comment">       * whether that should &quot;count&quot; is a more philosophical question).  With pacing, though, since</span></div>
<div class="line"><a id="l04913" name="l04913"></a><span class="lineno"> 4913</span><span class="comment">       * pacing spreads out packets over SRTT, and SRTT is measured based on</span></div>
<div class="line"><a id="l04914" name="l04914"></a><span class="lineno"> 4914</span><span class="comment">       * Sent_packet::m_sent_when, RTTs artifically become longer and longer if we record the send</span></div>
<div class="line"><a id="l04915" name="l04915"></a><span class="lineno"> 4915</span><span class="comment">       * time now.  Anyway, this means m_sent_when.back() should be overwritten when the packet is</span></div>
<div class="line"><a id="l04916" name="l04916"></a><span class="lineno"> 4916</span><span class="comment">       * actually sent (which should be very soon, unless pacing is enabled).</span></div>
<div class="line"><a id="l04917" name="l04917"></a><span class="lineno"> 4917</span><span class="comment">       * See async_sock_low_lvl_packet_send_paced(). */</span></div>
<div class="line"><a id="l04918" name="l04918"></a><span class="lineno"> 4918</span> </div>
<div class="line"><a id="l04919" name="l04919"></a><span class="lineno"> 4919</span>      <span class="comment">// data and sent_pkt are ready.</span></div>
<div class="line"><a id="l04920" name="l04920"></a><span class="lineno"> 4920</span> </div>
<div class="line"><a id="l04921" name="l04921"></a><span class="lineno"> 4921</span>      <span class="comment">// Add to snd_flying_pkts* and friends; update byte counts.</span></div>
<div class="line"><a id="l04922" name="l04922"></a><span class="lineno"> 4922</span>      <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">snd_flying_pkts_push_one</a>(sock, data-&gt;m_seq_num, sent_pkt);</div>
<div class="line"><a id="l04923" name="l04923"></a><span class="lineno"> 4923</span> </div>
<div class="line"><a id="l04924" name="l04924"></a><span class="lineno"> 4924</span>      <span class="comment">/* By adding to m_snd_flying_pkts_by_sent_when (i.e., increasing In-flight byte count), we may have</span></div>
<div class="line"><a id="l04925" name="l04925"></a><span class="lineno"> 4925</span><span class="comment">       * affected the result of can_send().  We do check it at the end of the while () body, so OK. */</span></div>
<div class="line"><a id="l04926" name="l04926"></a><span class="lineno"> 4926</span> </div>
<div class="line"><a id="l04927" name="l04927"></a><span class="lineno"> 4927</span>      <span class="comment">// Fill out common fields and asynchronously send packet (packet pacing potentially performed inside).</span></div>
<div class="line"><a id="l04928" name="l04928"></a><span class="lineno"> 4928</span>      <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(data));</div>
<div class="line"><a id="l04929" name="l04929"></a><span class="lineno"> 4929</span> </div>
<div class="line"><a id="l04930" name="l04930"></a><span class="lineno"> 4930</span>      sock-&gt;m_snd_stats.data_sent(data-&gt;m_data.size(), rexmit);</div>
<div class="line"><a id="l04931" name="l04931"></a><span class="lineno"> 4931</span>    }</div>
<div class="line"><a id="l04932" name="l04932"></a><span class="lineno"> 4932</span>    <span class="keywordflow">while</span> (<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">can_send</a>(sock) &amp;&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a>(sock)); <span class="comment">// (there is CWND/rcv_wnd space; and either rexmittable or new data)</span></div>
<div class="line"><a id="l04933" name="l04933"></a><span class="lineno"> 4933</span> </div>
<div class="line"><a id="l04934" name="l04934"></a><span class="lineno"> 4934</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]; connection [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l04935" name="l04935"></a><span class="lineno"> 4935</span>                   <span class="stringliteral">&quot;Final check: &quot;</span></div>
<div class="line"><a id="l04936" name="l04936"></a><span class="lineno"> 4936</span>                   <span class="stringliteral">&quot;can_send() == [&quot;</span> &lt;&lt; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">can_send</a>(sock) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l04937" name="l04937"></a><span class="lineno"> 4937</span>                   <span class="stringliteral">&quot;snd_deqable() == [&quot;</span> &lt;&lt; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a>(sock) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04938" name="l04938"></a><span class="lineno"> 4938</span> </div>
<div class="line"><a id="l04939" name="l04939"></a><span class="lineno"> 4939</span>    writable = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">snd_buf_enqable</a>(sock); <span class="comment">// Must do before releasing lock.</span></div>
<div class="line"><a id="l04940" name="l04940"></a><span class="lineno"> 4940</span>  } <span class="comment">// lock</span></div>
<div class="line"><a id="l04941" name="l04941"></a><span class="lineno"> 4941</span> </div>
<div class="line"><a id="l04942" name="l04942"></a><span class="lineno"> 4942</span>  <span class="comment">/* Finally, check if the above has dequeued enough of m_snd_buf for it to accept more data from</span></div>
<div class="line"><a id="l04943" name="l04943"></a><span class="lineno"> 4943</span><span class="comment">   * user.  If so, sock is certainly now Writable.  Therefore we should soon inform anyone waiting</span></div>
<div class="line"><a id="l04944" name="l04944"></a><span class="lineno"> 4944</span><span class="comment">   * on any Event_sets for sock to become Writable.</span></div>
<div class="line"><a id="l04945" name="l04945"></a><span class="lineno"> 4945</span><span class="comment">   *</span></div>
<div class="line"><a id="l04946" name="l04946"></a><span class="lineno"> 4946</span><span class="comment">   * Caveat: Similar to that in Node::handle_syn_ack_ack_to_syn_rcvd() at similar point in the</span></div>
<div class="line"><a id="l04947" name="l04947"></a><span class="lineno"> 4947</span><span class="comment">   * code.</span></div>
<div class="line"><a id="l04948" name="l04948"></a><span class="lineno"> 4948</span><span class="comment">   *</span></div>
<div class="line"><a id="l04949" name="l04949"></a><span class="lineno"> 4949</span><span class="comment">   * Also: why do this outside the above locked block?  Same reason as similar code in</span></div>
<div class="line"><a id="l04950" name="l04950"></a><span class="lineno"> 4950</span><span class="comment">   * handle_data_to_established(). */</span></div>
<div class="line"><a id="l04951" name="l04951"></a><span class="lineno"> 4951</span>  <span class="keywordflow">if</span> (writable &amp;&amp;</div>
<div class="line"><a id="l04952" name="l04952"></a><span class="lineno"> 4952</span>      <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">m_sock_events</a>[<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a>].insert(sock).second)</div>
<div class="line"><a id="l04953" name="l04953"></a><span class="lineno"> 4953</span>  {</div>
<div class="line"><a id="l04954" name="l04954"></a><span class="lineno"> 4954</span>    <span class="comment">// Possibly inform the user for any applicable Event_sets right now.</span></div>
<div class="line"><a id="l04955" name="l04955"></a><span class="lineno"> 4955</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">event_set_all_check_delta</a>(defer_delta_check);</div>
<div class="line"><a id="l04956" name="l04956"></a><span class="lineno"> 4956</span>  }</div>
<div class="line"><a id="l04957" name="l04957"></a><span class="lineno"> 4957</span> </div>
<div class="line"><a id="l04958" name="l04958"></a><span class="lineno"> 4958</span>  <span class="comment">/* @todo After we implement graceful close, if we&#39;d emptied m_snd_buf above, then here we should</span></div>
<div class="line"><a id="l04959" name="l04959"></a><span class="lineno"> 4959</span><span class="comment">   * advance the graceful close towards the final situation (m_int_state and m_state both</span></div>
<div class="line"><a id="l04960" name="l04960"></a><span class="lineno"> 4960</span><span class="comment">   * S_CLOSED). */</span></div>
<div class="line"><a id="l04961" name="l04961"></a><span class="lineno"> 4961</span>} <span class="comment">// Node::send_worker()</span></div>
<div class="line"><a id="l04962" name="l04962"></a><span class="lineno"> 4962</span> </div>
<div class="line"><a id="l04963" name="l04963"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657"> 4963</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">Node::can_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l04964" name="l04964"></a><span class="lineno"> 4964</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04965" name="l04965"></a><span class="lineno"> 4965</span>  <span class="keyword">using </span>std::min;</div>
<div class="line"><a id="l04966" name="l04966"></a><span class="lineno"> 4966</span> </div>
<div class="line"><a id="l04967" name="l04967"></a><span class="lineno"> 4967</span>  <span class="comment">/* m_snd_cong_ctl is the congestion control module, and its CWND value determines how many bytes can</span></div>
<div class="line"><a id="l04968" name="l04968"></a><span class="lineno"> 4968</span><span class="comment">   * be In-flight at any given time.  If there are enough free bytes (CWND - In-flight) to send</span></div>
<div class="line"><a id="l04969" name="l04969"></a><span class="lineno"> 4969</span><span class="comment">   * data, then we can send.  Otherwise we cannot.  Easy, except what&#39;s &quot;data&quot;?  There are two</span></div>
<div class="line"><a id="l04970" name="l04970"></a><span class="lineno"> 4970</span><span class="comment">   * reasonable answers.  One: a byte or more.  Two: min(max-block-size, Send buffer size).  The former</span></div>
<div class="line"><a id="l04971" name="l04971"></a><span class="lineno"> 4971</span><span class="comment">   * answer is fine but somewhat annoying, because then we have to lock sock here***.  The 2nd answer</span></div>
<div class="line"><a id="l04972" name="l04972"></a><span class="lineno"> 4972</span><span class="comment">   * clearly works but is potentially a little greedier than necessary (i.e., if the 1st block to</span></div>
<div class="line"><a id="l04973" name="l04973"></a><span class="lineno"> 4973</span><span class="comment">   * send is small enough to fit into CWND, but CWND doesn&#39;t have max-block-size space).</span></div>
<div class="line"><a id="l04974" name="l04974"></a><span class="lineno"> 4974</span><span class="comment">   * However, actually, we pretty much have to choose the 2nd answer regardless, as we don&#39;t want to</span></div>
<div class="line"><a id="l04975" name="l04975"></a><span class="lineno"> 4975</span><span class="comment">   * fragment max-block-size-sized chunks, if we can help it (in the spirit of the reliability</span></div>
<div class="line"><a id="l04976" name="l04976"></a><span class="lineno"> 4976</span><span class="comment">   * guarantee [when running in unreliable mode] made in send() method doc header).</span></div>
<div class="line"><a id="l04977" name="l04977"></a><span class="lineno"> 4977</span><span class="comment">   *</span></div>
<div class="line"><a id="l04978" name="l04978"></a><span class="lineno"> 4978</span><span class="comment">   * I choose the 2nd answer, because (1) it&#39;s easier (no locking of sock); (2) it is used by real</span></div>
<div class="line"><a id="l04979" name="l04979"></a><span class="lineno"> 4979</span><span class="comment">   * TCP implementations which keep CWND in multiples of MSS (equivalent of max-block-size); (3)</span></div>
<div class="line"><a id="l04980" name="l04980"></a><span class="lineno"> 4980</span><span class="comment">   * it&#39;s still safe; and (4) see previous paragraph&#39;s end.  Regarding safety: it&#39;s safe, since</span></div>
<div class="line"><a id="l04981" name="l04981"></a><span class="lineno"> 4981</span><span class="comment">   * there can be no deadlock, because even if there&#39;s &lt; MBS bytes free, eventually In-flight</span></div>
<div class="line"><a id="l04982" name="l04982"></a><span class="lineno"> 4982</span><span class="comment">   * packets will become Acknowledged or Dropped and no longer be In-flight, freeing up CWND space;</span></div>
<div class="line"><a id="l04983" name="l04983"></a><span class="lineno"> 4983</span><span class="comment">   * and CWND is guaranteed to always be at least 1 * MBS. Thus eventually can_send() will return</span></div>
<div class="line"><a id="l04984" name="l04984"></a><span class="lineno"> 4984</span><span class="comment">   * true.</span></div>
<div class="line"><a id="l04985" name="l04985"></a><span class="lineno"> 4985</span><span class="comment">   *</span></div>
<div class="line"><a id="l04986" name="l04986"></a><span class="lineno"> 4986</span><span class="comment">   * *** - I am now not sure why I wrote this.  Why would we have to lock sock here in that case? */</span></div>
<div class="line"><a id="l04987" name="l04987"></a><span class="lineno"> 4987</span> </div>
<div class="line"><a id="l04988" name="l04988"></a><span class="lineno"> 4988</span>  <span class="comment">// We have rcv_wnd also; so pretend previous paragraph has: s/CWND/min(CWND, rcv_wnd)/.</span></div>
<div class="line"><a id="l04989" name="l04989"></a><span class="lineno"> 4989</span> </div>
<div class="line"><a id="l04990" name="l04990"></a><span class="lineno"> 4990</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> pipe_taken = sock-&gt;m_snd_flying_bytes;</div>
<div class="line"><a id="l04991" name="l04991"></a><span class="lineno"> 4991</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> cong_wnd = sock-&gt;m_snd_cong_ctl-&gt;congestion_window_bytes();</div>
<div class="line"><a id="l04992" name="l04992"></a><span class="lineno"> 4992</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; rcv_wnd = sock-&gt;m_snd_remote_rcv_wnd; <span class="comment">// @todo Any particular reason this has &amp; but not pipe_taken?</span></div>
<div class="line"><a id="l04993" name="l04993"></a><span class="lineno"> 4993</span>  <span class="comment">// Send no more than the network NOR the other side&#39;s Receive buffer can take.</span></div>
<div class="line"><a id="l04994" name="l04994"></a><span class="lineno"> 4994</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> pipe_total = min(cong_wnd, rcv_wnd);</div>
<div class="line"><a id="l04995" name="l04995"></a><span class="lineno"> 4995</span> </div>
<div class="line"><a id="l04996" name="l04996"></a><span class="lineno"> 4996</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> can</div>
<div class="line"><a id="l04997" name="l04997"></a><span class="lineno"> 4997</span>    = (pipe_taken &lt; pipe_total) &amp;&amp; ((pipe_total - pipe_taken) &gt;= sock-&gt;max_block_size());</div>
<div class="line"><a id="l04998" name="l04998"></a><span class="lineno"> 4998</span> </div>
<div class="line"><a id="l04999" name="l04999"></a><span class="lineno"> 4999</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;cong_ctl [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] info: can_send = [&quot;</span> &lt;&lt; can &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l05000" name="l05000"></a><span class="lineno"> 5000</span>                 <span class="stringliteral">&quot;pipe_taken = [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(pipe_taken) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l05001" name="l05001"></a><span class="lineno"> 5001</span>                 <span class="stringliteral">&quot;cong_wnd = [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(cong_wnd) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l05002" name="l05002"></a><span class="lineno"> 5002</span>                 <span class="stringliteral">&quot;rcv_wnd = [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(rcv_wnd) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l05003" name="l05003"></a><span class="lineno"> 5003</span> </div>
<div class="line"><a id="l05004" name="l05004"></a><span class="lineno"> 5004</span>  <span class="keywordflow">return</span> can;</div>
<div class="line"><a id="l05005" name="l05005"></a><span class="lineno"> 5005</span>} <span class="comment">// Node::can_send()</span></div>
<div class="line"><a id="l05006" name="l05006"></a><span class="lineno"> 5006</span> </div>
<div class="line"><a id="l05007" name="l05007"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c"> 5007</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">Node::receive</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l05008" name="l05008"></a><span class="lineno"> 5008</span>                     <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> ()&gt;&amp; rcv_buf_consume_func,</div>
<div class="line"><a id="l05009" name="l05009"></a><span class="lineno"> 5009</span>                     <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l05010" name="l05010"></a><span class="lineno"> 5010</span>{</div>
<div class="line"><a id="l05011" name="l05011"></a><span class="lineno"> 5011</span>  <span class="keyword">using </span>boost::asio::post;</div>
<div class="line"><a id="l05012" name="l05012"></a><span class="lineno"> 5012</span> </div>
<div class="line"><a id="l05013" name="l05013"></a><span class="lineno"> 5013</span>  <span class="comment">/* We are in user thread U != W.</span></div>
<div class="line"><a id="l05014" name="l05014"></a><span class="lineno"> 5014</span><span class="comment">   * It&#39;s important to keep that in mind in this method.  In particular, it is absolutely unsafe to</span></div>
<div class="line"><a id="l05015" name="l05015"></a><span class="lineno"> 5015</span><span class="comment">   * access m_int_state, which belongs solely to thread W and is never locked. */</span></div>
<div class="line"><a id="l05016" name="l05016"></a><span class="lineno"> 5016</span> </div>
<div class="line"><a id="l05017" name="l05017"></a><span class="lineno"> 5017</span>  <span class="comment">// IMPORTANT: The logic here must be consistent with sock_is_readable().</span></div>
<div class="line"><a id="l05018" name="l05018"></a><span class="lineno"> 5018</span> </div>
<div class="line"><a id="l05019" name="l05019"></a><span class="lineno"> 5019</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l05020" name="l05020"></a><span class="lineno"> 5020</span>  {</div>
<div class="line"><a id="l05021" name="l05021"></a><span class="lineno"> 5021</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l05022" name="l05022"></a><span class="lineno"> 5022</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l05023" name="l05023"></a><span class="lineno"> 5023</span>  }</div>
<div class="line"><a id="l05024" name="l05024"></a><span class="lineno"> 5024</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05025" name="l05025"></a><span class="lineno"> 5025</span> </div>
<div class="line"><a id="l05026" name="l05026"></a><span class="lineno"> 5026</span>  <span class="comment">// Pre-condition is that m_mutex is locked already.  So EVERYTHING that can be locked, is, including the buffers.</span></div>
<div class="line"><a id="l05027" name="l05027"></a><span class="lineno"> 5027</span> </div>
<div class="line"><a id="l05028" name="l05028"></a><span class="lineno"> 5028</span>  <span class="comment">// Pre-condition.</span></div>
<div class="line"><a id="l05029" name="l05029"></a><span class="lineno"> 5029</span>  assert(sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>); <span class="comment">// Locked.</span></div>
<div class="line"><a id="l05030" name="l05030"></a><span class="lineno"> 5030</span>  assert((sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>) ||</div>
<div class="line"><a id="l05031" name="l05031"></a><span class="lineno"> 5031</span>         (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">Peer_socket::Open_sub_state::S_CONNECTING</a>) ||</div>
<div class="line"><a id="l05032" name="l05032"></a><span class="lineno"> 5032</span>         (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>));</div>
<div class="line"><a id="l05033" name="l05033"></a><span class="lineno"> 5033</span> </div>
<div class="line"><a id="l05034" name="l05034"></a><span class="lineno"> 5034</span>  <span class="comment">/* In the rest of the method we must ensure we handle all the cases (-1a/b/c-, -2-) documented in</span></div>
<div class="line"><a id="l05035" name="l05035"></a><span class="lineno"> 5035</span><span class="comment">   * the Peer_socket::receive() documentation header.  -3- was already handled by</span></div>
<div class="line"><a id="l05036" name="l05036"></a><span class="lineno"> 5036</span><span class="comment">   * Peer_socket::receive() before calling us. */</span></div>
<div class="line"><a id="l05037" name="l05037"></a><span class="lineno"> 5037</span> </div>
<div class="line"><a id="l05038" name="l05038"></a><span class="lineno"> 5038</span>  <span class="comment">// Try to dequeue stuff into their buffer.</span></div>
<div class="line"><a id="l05039" name="l05039"></a><span class="lineno"> 5039</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> no_bytes_available = sock-&gt;m_rcv_buf.empty();</div>
<div class="line"><a id="l05040" name="l05040"></a><span class="lineno"> 5040</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> bytes_consumed = rcv_buf_consume_func();</div>
<div class="line"><a id="l05041" name="l05041"></a><span class="lineno"> 5041</span> </div>
<div class="line"><a id="l05042" name="l05042"></a><span class="lineno"> 5042</span>  <span class="keywordflow">if</span> (bytes_consumed != 0)</div>
<div class="line"><a id="l05043" name="l05043"></a><span class="lineno"> 5043</span>  {</div>
<div class="line"><a id="l05044" name="l05044"></a><span class="lineno"> 5044</span>    <span class="comment">/* Unequivocal: if there was stuff in the Receive buffer and was able to place it into their</span></div>
<div class="line"><a id="l05045" name="l05045"></a><span class="lineno"> 5045</span><span class="comment">     * buffer then there is no error.  (Even if m_disconnect_cause is not success, we are only</span></div>
<div class="line"><a id="l05046" name="l05046"></a><span class="lineno"> 5046</span><span class="comment">     * supposed to report that after the Receive buffer has been emptied.)</span></div>
<div class="line"><a id="l05047" name="l05047"></a><span class="lineno"> 5047</span><span class="comment">     *</span></div>
<div class="line"><a id="l05048" name="l05048"></a><span class="lineno"> 5048</span><span class="comment">     * This handles case -2-. */</span></div>
<div class="line"><a id="l05049" name="l05049"></a><span class="lineno"> 5049</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;User thread receive() for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05050" name="l05050"></a><span class="lineno"> 5050</span>                   <span class="stringliteral">&quot;has successfully returned [&quot;</span> &lt;&lt; bytes_consumed &lt;&lt; <span class="stringliteral">&quot;] bytes.&quot;</span>);</div>
<div class="line"><a id="l05051" name="l05051"></a><span class="lineno"> 5051</span>    err_code-&gt;clear();</div>
<div class="line"><a id="l05052" name="l05052"></a><span class="lineno"> 5052</span> </div>
<div class="line"><a id="l05053" name="l05053"></a><span class="lineno"> 5053</span>    <span class="comment">/* We have changed (increased) the amount of free space in m_rcv_buf.  This has rcv_wnd</span></div>
<div class="line"><a id="l05054" name="l05054"></a><span class="lineno"> 5054</span><span class="comment">     * implications.  We have to at least check whether we should send a window update to the</span></div>
<div class="line"><a id="l05055" name="l05055"></a><span class="lineno"> 5055</span><span class="comment">     * other side.  However all such book-keeping must be done in thread W due to the data</span></div>
<div class="line"><a id="l05056" name="l05056"></a><span class="lineno"> 5056</span><span class="comment">     * involved; call this-&gt;receive_wnd_updated(sock). */</span></div>
<div class="line"><a id="l05057" name="l05057"></a><span class="lineno"> 5057</span>    post(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, [<span class="keyword">this</span>, sock]() { <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">receive_wnd_updated</a>(sock); });</div>
<div class="line"><a id="l05058" name="l05058"></a><span class="lineno"> 5058</span> </div>
<div class="line"><a id="l05059" name="l05059"></a><span class="lineno"> 5059</span>    <span class="keywordflow">if</span> (sock-&gt;m_rcv_buf.empty()</div>
<div class="line"><a id="l05060" name="l05060"></a><span class="lineno"> 5060</span>        &amp;&amp; (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>))</div>
<div class="line"><a id="l05061" name="l05061"></a><span class="lineno"> 5061</span>    {</div>
<div class="line"><a id="l05062" name="l05062"></a><span class="lineno"> 5062</span>      <span class="comment">/* We&#39;ve emptied the Receive buffer; and we&#39;re in the middle of a graceful close.  (@todo</span></div>
<div class="line"><a id="l05063" name="l05063"></a><span class="lineno"> 5063</span><span class="comment">       * Graceful close not yet implemented.)  There are two possibilities.  One, m_int_state ==</span></div>
<div class="line"><a id="l05064" name="l05064"></a><span class="lineno"> 5064</span><span class="comment">       * S_CLOSED.  In this case the graceful close, at the transport layer, is over, and the only</span></div>
<div class="line"><a id="l05065" name="l05065"></a><span class="lineno"> 5065</span><span class="comment">       * thing stopping us from entering m_state == S_CLOSED (via close_connection_immediately())</span></div>
<div class="line"><a id="l05066" name="l05066"></a><span class="lineno"> 5066</span><span class="comment">       * was that the user hadn&#39;t read all of m_rcv_buf.  In this case thread W should</span></div>
<div class="line"><a id="l05067" name="l05067"></a><span class="lineno"> 5067</span><span class="comment">       * close_connection_immediately().  Two, m_int_state may be after ESTABLISHED but before</span></div>
<div class="line"><a id="l05068" name="l05068"></a><span class="lineno"> 5068</span><span class="comment">       * CLOSED, in which case thread W still has to finish up graceful closing anyway.</span></div>
<div class="line"><a id="l05069" name="l05069"></a><span class="lineno"> 5069</span><span class="comment">       *</span></div>
<div class="line"><a id="l05070" name="l05070"></a><span class="lineno"> 5070</span><span class="comment">       * We are in thread W and cannot work with m_int_state, so checking it here is not possible.</span></div>
<div class="line"><a id="l05071" name="l05071"></a><span class="lineno"> 5071</span><span class="comment">       * Therefore we put this task onto thread W. */</span></div>
<div class="line"><a id="l05072" name="l05072"></a><span class="lineno"> 5072</span>      post(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>,</div>
<div class="line"><a id="l05073" name="l05073"></a><span class="lineno"> 5073</span>           [<span class="keyword">this</span>, sock]() { <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">receive_emptied_rcv_buf_while_disconnecting</a>(sock); });</div>
<div class="line"><a id="l05074" name="l05074"></a><span class="lineno"> 5074</span>    }</div>
<div class="line"><a id="l05075" name="l05075"></a><span class="lineno"> 5075</span>    <span class="keywordflow">return</span> bytes_consumed;</div>
<div class="line"><a id="l05076" name="l05076"></a><span class="lineno"> 5076</span>  }</div>
<div class="line"><a id="l05077" name="l05077"></a><span class="lineno"> 5077</span>  <span class="comment">// else if (bytes_consumed == 0)</span></div>
<div class="line"><a id="l05078" name="l05078"></a><span class="lineno"> 5078</span> </div>
<div class="line"><a id="l05079" name="l05079"></a><span class="lineno"> 5079</span>  <span class="keywordflow">if</span> (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">Peer_socket::Open_sub_state::S_CONNECTING</a>)</div>
<div class="line"><a id="l05080" name="l05080"></a><span class="lineno"> 5080</span>  {</div>
<div class="line"><a id="l05081" name="l05081"></a><span class="lineno"> 5081</span>    <span class="comment">/* This is case -1b-.  Since we are CONNECTING, no data could have been received yet (simply</span></div>
<div class="line"><a id="l05082" name="l05082"></a><span class="lineno"> 5082</span><span class="comment">     * not at that stage of connection opening), so Receive buffer is empty. */</span></div>
<div class="line"><a id="l05083" name="l05083"></a><span class="lineno"> 5083</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;User thread receive() for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05084" name="l05084"></a><span class="lineno"> 5084</span>                   <span class="stringliteral">&quot;has successfully returned no bytes because still not fully connected.&quot;</span>);</div>
<div class="line"><a id="l05085" name="l05085"></a><span class="lineno"> 5085</span>    err_code-&gt;clear();</div>
<div class="line"><a id="l05086" name="l05086"></a><span class="lineno"> 5086</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l05087" name="l05087"></a><span class="lineno"> 5087</span>  }</div>
<div class="line"><a id="l05088" name="l05088"></a><span class="lineno"> 5088</span>  <span class="comment">// else if (state is CONNECTED or DISCONNECTING)</span></div>
<div class="line"><a id="l05089" name="l05089"></a><span class="lineno"> 5089</span> </div>
<div class="line"><a id="l05090" name="l05090"></a><span class="lineno"> 5090</span>  <span class="comment">/* We&#39;re CONNECTED or DISCONNECTING but could get no bytes.  Let&#39;s examine each state.</span></div>
<div class="line"><a id="l05091" name="l05091"></a><span class="lineno"> 5091</span><span class="comment">   *</span></div>
<div class="line"><a id="l05092" name="l05092"></a><span class="lineno"> 5092</span><span class="comment">   *   - CONNECTED: Either they provided a zero-sized target buffer (in which case</span></div>
<div class="line"><a id="l05093" name="l05093"></a><span class="lineno"> 5093</span><span class="comment">   *     !no_bytes_available), or the Receive buffer is simply empty.  Thus this is either -1a- or</span></div>
<div class="line"><a id="l05094" name="l05094"></a><span class="lineno"> 5094</span><span class="comment">   *     -1c- (no_bytes_available determines which).</span></div>
<div class="line"><a id="l05095" name="l05095"></a><span class="lineno"> 5095</span><span class="comment">   *</span></div>
<div class="line"><a id="l05096" name="l05096"></a><span class="lineno"> 5096</span><span class="comment">   *   - DISCONNECTING: Either:</span></div>
<div class="line"><a id="l05097" name="l05097"></a><span class="lineno"> 5097</span><span class="comment">   *     - the initial block was too large for the max_data_size they provided in their receive()</span></div>
<div class="line"><a id="l05098" name="l05098"></a><span class="lineno"> 5098</span><span class="comment">   *       call (in which case !no_bytes_available); or</span></div>
<div class="line"><a id="l05099" name="l05099"></a><span class="lineno"> 5099</span><span class="comment">   *     - they called close_final() (@todo not yet implemented) and thus the Receive buffer was</span></div>
<div class="line"><a id="l05100" name="l05100"></a><span class="lineno"> 5100</span><span class="comment">   *       cleared at that time, and all incoming data were ignored after that; thus the Receive</span></div>
<div class="line"><a id="l05101" name="l05101"></a><span class="lineno"> 5101</span><span class="comment">   *       buffer is empty, but a graceful close is still in progress; or</span></div>
<div class="line"><a id="l05102" name="l05102"></a><span class="lineno"> 5102</span><span class="comment">   *     - they did not call close_final(), but there is a graceful close in progress, and the</span></div>
<div class="line"><a id="l05103" name="l05103"></a><span class="lineno"> 5103</span><span class="comment">   *       Receive buffer is simply empty.</span></div>
<div class="line"><a id="l05104" name="l05104"></a><span class="lineno"> 5104</span><span class="comment">   *     Thus this is either -1a- or -1c-. */</span></div>
<div class="line"><a id="l05105" name="l05105"></a><span class="lineno"> 5105</span> </div>
<div class="line"><a id="l05106" name="l05106"></a><span class="lineno"> 5106</span>  <span class="keywordflow">if</span> (!no_bytes_available)</div>
<div class="line"><a id="l05107" name="l05107"></a><span class="lineno"> 5107</span>  {</div>
<div class="line"><a id="l05108" name="l05108"></a><span class="lineno"> 5108</span>    <span class="comment">// This is case -1c-.</span></div>
<div class="line"><a id="l05109" name="l05109"></a><span class="lineno"> 5109</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;User thread receive() for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05110" name="l05110"></a><span class="lineno"> 5110</span>                   <span class="stringliteral">&quot;has data to return, but the provided buffer size is too small.&quot;</span>);</div>
<div class="line"><a id="l05111" name="l05111"></a><span class="lineno"> 5111</span>    err_code-&gt;clear();</div>
<div class="line"><a id="l05112" name="l05112"></a><span class="lineno"> 5112</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l05113" name="l05113"></a><span class="lineno"> 5113</span>  }</div>
<div class="line"><a id="l05114" name="l05114"></a><span class="lineno"> 5114</span>  <span class="comment">// else if (no_bytes_available)</span></div>
<div class="line"><a id="l05115" name="l05115"></a><span class="lineno"> 5115</span> </div>
<div class="line"><a id="l05116" name="l05116"></a><span class="lineno"> 5116</span>  <span class="comment">// This is case -1a-.</span></div>
<div class="line"><a id="l05117" name="l05117"></a><span class="lineno"> 5117</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;User thread receive() for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05118" name="l05118"></a><span class="lineno"> 5118</span>                 <span class="stringliteral">&quot;returning no data because Receive buffer empty.&quot;</span>);</div>
<div class="line"><a id="l05119" name="l05119"></a><span class="lineno"> 5119</span> </div>
<div class="line"><a id="l05120" name="l05120"></a><span class="lineno"> 5120</span>  err_code-&gt;clear();</div>
<div class="line"><a id="l05121" name="l05121"></a><span class="lineno"> 5121</span> </div>
<div class="line"><a id="l05122" name="l05122"></a><span class="lineno"> 5122</span>  <span class="comment">/* @todo Sigh.  There&#39;s more.  Yes, in some situations we can return 0/success here.  In other</span></div>
<div class="line"><a id="l05123" name="l05123"></a><span class="lineno"> 5123</span><span class="comment">   * situations, though, we should return 0/&lt;Error_code for graceful close&gt; here.  The latter</span></div>
<div class="line"><a id="l05124" name="l05124"></a><span class="lineno"> 5124</span><span class="comment">   * case would be in the situations where we know no data is coming, or user has said he doesn&#39;t</span></div>
<div class="line"><a id="l05125" name="l05125"></a><span class="lineno"> 5125</span><span class="comment">   * care about any more data:</span></div>
<div class="line"><a id="l05126" name="l05126"></a><span class="lineno"> 5126</span><span class="comment">   *</span></div>
<div class="line"><a id="l05127" name="l05127"></a><span class="lineno"> 5127</span><span class="comment">   *   -1- A graceful close was initiated by the OTHER side.  (Therefore no data could be coming to</span></div>
<div class="line"><a id="l05128" name="l05128"></a><span class="lineno"> 5128</span><span class="comment">   *       save into Receive buffer.)</span></div>
<div class="line"><a id="l05129" name="l05129"></a><span class="lineno"> 5129</span><span class="comment">   *   -2- Only we initiated the graceful close, but it was via close_final(), i.e., user is not</span></div>
<div class="line"><a id="l05130" name="l05130"></a><span class="lineno"> 5130</span><span class="comment">   *       interested in any incoming data anymore.  (Therefore we&#39;ll always just ignore any</span></div>
<div class="line"><a id="l05131" name="l05131"></a><span class="lineno"> 5131</span><span class="comment">   *       incoming DATA and not put it into Receive buffer.)</span></div>
<div class="line"><a id="l05132" name="l05132"></a><span class="lineno"> 5132</span><span class="comment">   *   -3- Only we initiated the graceful close, and it was via close_start() (i.e., user cares</span></div>
<div class="line"><a id="l05133" name="l05133"></a><span class="lineno"> 5133</span><span class="comment">   *       about further incoming data); however, the final handshake has reached a state in which</span></div>
<div class="line"><a id="l05134" name="l05134"></a><span class="lineno"> 5134</span><span class="comment">   *       further data cannot be incoming.  (Therefore no data could be coming to save into Receive</span></div>
<div class="line"><a id="l05135" name="l05135"></a><span class="lineno"> 5135</span><span class="comment">   *       buffer.)</span></div>
<div class="line"><a id="l05136" name="l05136"></a><span class="lineno"> 5136</span><span class="comment">   *</span></div>
<div class="line"><a id="l05137" name="l05137"></a><span class="lineno"> 5137</span><span class="comment">   * I am not writing code for this logic at this time.  The implementations depends on how</span></div>
<div class="line"><a id="l05138" name="l05138"></a><span class="lineno"> 5138</span><span class="comment">   * exactly our graceful close works.  This entire method, right now, is dead code, since there is</span></div>
<div class="line"><a id="l05139" name="l05139"></a><span class="lineno"> 5139</span><span class="comment">   * no graceful close, but I wrote it anyway to provide a skeleton for the future, since I</span></div>
<div class="line"><a id="l05140" name="l05140"></a><span class="lineno"> 5140</span><span class="comment">   * already thought about it.  However it would be unreasonable to implement the above logic in the</span></div>
<div class="line"><a id="l05141" name="l05141"></a><span class="lineno"> 5141</span><span class="comment">   * absence of graceful close in the first place, skeleton or not.  Therefore, dead code or not, I</span></div>
<div class="line"><a id="l05142" name="l05142"></a><span class="lineno"> 5142</span><span class="comment">   * do the &quot;conservative&quot; thing: return 0/success even in the above situations.  Eventually the</span></div>
<div class="line"><a id="l05143" name="l05143"></a><span class="lineno"> 5143</span><span class="comment">   * graceful close will complete, at which point we&#39;ll return an error anyway, so the user won&#39;t be</span></div>
<div class="line"><a id="l05144" name="l05144"></a><span class="lineno"> 5144</span><span class="comment">   * left uninformed forever (worst case: the close will time out).</span></div>
<div class="line"><a id="l05145" name="l05145"></a><span class="lineno"> 5145</span><span class="comment">   *</span></div>
<div class="line"><a id="l05146" name="l05146"></a><span class="lineno"> 5146</span><span class="comment">   * For when we do implement the above logic, some thoughts: Detecting the situation in thread U</span></div>
<div class="line"><a id="l05147" name="l05147"></a><span class="lineno"> 5147</span><span class="comment">   * != W may be difficult and may introduce complex synchronization issues.  One way</span></div>
<div class="line"><a id="l05148" name="l05148"></a><span class="lineno"> 5148</span><span class="comment">   * to do it might be to introduce synchronized bool Peer_socket::m_no_more_rcv_data, which</span></div>
<div class="line"><a id="l05149" name="l05149"></a><span class="lineno"> 5149</span><span class="comment">   * starts at false and can become true (but not false again).  This member would be set to true,</span></div>
<div class="line"><a id="l05150" name="l05150"></a><span class="lineno"> 5150</span><span class="comment">   * by thread W, if and only if one of the above situations is detected by thread W.  Then here</span></div>
<div class="line"><a id="l05151" name="l05151"></a><span class="lineno"> 5151</span><span class="comment">   * we&#39;d check it, and if it&#39;s true, return error; otherwise return success.</span></div>
<div class="line"><a id="l05152" name="l05152"></a><span class="lineno"> 5152</span><span class="comment">   *</span></div>
<div class="line"><a id="l05153" name="l05153"></a><span class="lineno"> 5153</span><span class="comment">   * IMPORTANT: The logic here must be consistent with sock_is_readable(). */</span></div>
<div class="line"><a id="l05154" name="l05154"></a><span class="lineno"> 5154</span>  <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l05155" name="l05155"></a><span class="lineno"> 5155</span>} <span class="comment">// Node::receive()</span></div>
<div class="line"><a id="l05156" name="l05156"></a><span class="lineno"> 5156</span> </div>
<div class="line"><a id="l05157" name="l05157"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84"> 5157</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">Node::sock_is_readable</a>(<span class="keyword">const</span> boost::any&amp; sock_as_any)<span class="keyword"> const</span></div>
<div class="line"><a id="l05158" name="l05158"></a><span class="lineno"> 5158</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05159" name="l05159"></a><span class="lineno"> 5159</span>  <span class="keyword">using </span>boost::any_cast;</div>
<div class="line"><a id="l05160" name="l05160"></a><span class="lineno"> 5160</span> </div>
<div class="line"><a id="l05161" name="l05161"></a><span class="lineno"> 5161</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock = any_cast&lt;Peer_socket::Ptr&gt;(sock_as_any);</div>
<div class="line"><a id="l05162" name="l05162"></a><span class="lineno"> 5162</span> </div>
<div class="line"><a id="l05163" name="l05163"></a><span class="lineno"> 5163</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex); <span class="comment">// Many threads can access/write below state.</span></div>
<div class="line"><a id="l05164" name="l05164"></a><span class="lineno"> 5164</span> </div>
<div class="line"><a id="l05165" name="l05165"></a><span class="lineno"> 5165</span>  <span class="comment">/* Our task here is to return true if and only if at this very moment calling sock-&gt;receive(),</span></div>
<div class="line"><a id="l05166" name="l05166"></a><span class="lineno"> 5166</span><span class="comment">   * assuming sufficient user buffer space, would yield either a return value of &gt; 0 OR a</span></div>
<div class="line"><a id="l05167" name="l05167"></a><span class="lineno"> 5167</span><span class="comment">   * non-success *err_code.  In other words, receive() would return &quot;something.&quot;  This is used for</span></div>
<div class="line"><a id="l05168" name="l05168"></a><span class="lineno"> 5168</span><span class="comment">   * Event_set machinery.</span></div>
<div class="line"><a id="l05169" name="l05169"></a><span class="lineno"> 5169</span><span class="comment">   *</span></div>
<div class="line"><a id="l05170" name="l05170"></a><span class="lineno"> 5170</span><span class="comment">   * This should mirror receive()&#39;s algorithm.  @todo Should receive() call this, for code reuse?</span></div>
<div class="line"><a id="l05171" name="l05171"></a><span class="lineno"> 5171</span><span class="comment">   * Maybe/maybe not.  Consider performance when deciding.</span></div>
<div class="line"><a id="l05172" name="l05172"></a><span class="lineno"> 5172</span><span class="comment">   *</span></div>
<div class="line"><a id="l05173" name="l05173"></a><span class="lineno"> 5173</span><span class="comment">   * - If state is CLOSED, then some sort of error/terminating condition occurred, so receive()</span></div>
<div class="line"><a id="l05174" name="l05174"></a><span class="lineno"> 5174</span><span class="comment">   *   would return 0 and non-success Error_code == sock-&gt;m_disconnect_cause.  (Readable.)</span></div>
<div class="line"><a id="l05175" name="l05175"></a><span class="lineno"> 5175</span><span class="comment">   * - Otherwise, if Receive buffer can be dequeued, receive() would return &gt; 0.</span></div>
<div class="line"><a id="l05176" name="l05176"></a><span class="lineno"> 5176</span><span class="comment">   * - Otherwise, if Receive buffer cannot be dequeued, receive() would return 0 and no error. (Not</span></div>
<div class="line"><a id="l05177" name="l05177"></a><span class="lineno"> 5177</span><span class="comment">   *   Readable.)  Note that Receive buffer is guaranteed to be clear when entering non-Readable</span></div>
<div class="line"><a id="l05178" name="l05178"></a><span class="lineno"> 5178</span><span class="comment">   *   non-error states (OPEN+CONNECTING, OPEN+DISCONNECTING).  (Readable.)</span></div>
<div class="line"><a id="l05179" name="l05179"></a><span class="lineno"> 5179</span><span class="comment">   *</span></div>
<div class="line"><a id="l05180" name="l05180"></a><span class="lineno"> 5180</span><span class="comment">   * @todo Once we implement graceful close, there will be situations where Receive buffer is empty, state is</span></div>
<div class="line"><a id="l05181" name="l05181"></a><span class="lineno"> 5181</span><span class="comment">   * OPEN+DISCONNECTING, m_disconnect_cause = &lt;cause of disconnect&gt;, and we should return true (Readable)</span></div>
<div class="line"><a id="l05182" name="l05182"></a><span class="lineno"> 5182</span><span class="comment">   * here (only when we also know that no future Receive traffic possible).  See receive(). */</span></div>
<div class="line"><a id="l05183" name="l05183"></a><span class="lineno"> 5183</span> </div>
<div class="line"><a id="l05184" name="l05184"></a><span class="lineno"> 5184</span>  <span class="keywordflow">return</span> (sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>) || <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">rcv_buf_deqable</a>(sock);</div>
<div class="line"><a id="l05185" name="l05185"></a><span class="lineno"> 5185</span>} <span class="comment">// Node::sock_is_readable()</span></div>
<div class="line"><a id="l05186" name="l05186"></a><span class="lineno"> 5186</span> </div>
<div class="line"><a id="l05187" name="l05187"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357"> 5187</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">Node::receive_wnd_updated</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l05188" name="l05188"></a><span class="lineno"> 5188</span>{</div>
<div class="line"><a id="l05189" name="l05189"></a><span class="lineno"> 5189</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05190" name="l05190"></a><span class="lineno"> 5190</span> </div>
<div class="line"><a id="l05191" name="l05191"></a><span class="lineno"> 5191</span>  <span class="comment">/* rcv_wnd (free Receive buffer space) is sent to other side opportunistically in ACKs.  While</span></div>
<div class="line"><a id="l05192" name="l05192"></a><span class="lineno"> 5192</span><span class="comment">   * sender is sending data, they will have a good idea of our rcv_wnd as well.  Is that (in a</span></div>
<div class="line"><a id="l05193" name="l05193"></a><span class="lineno"> 5193</span><span class="comment">   * one-way-traffic situation) sufficient however?  If the sender is not sending data, because the</span></div>
<div class="line"><a id="l05194" name="l05194"></a><span class="lineno"> 5194</span><span class="comment">   * application on the sender doesn&#39;t provide more data to send, then the discussion is moot.</span></div>
<div class="line"><a id="l05195" name="l05195"></a><span class="lineno"> 5195</span><span class="comment">   * What if the sender is not sending data, because we have told it rcv_wnd is 0 (meaning our</span></div>
<div class="line"><a id="l05196" name="l05196"></a><span class="lineno"> 5196</span><span class="comment">   * Receive buffer is full)?  This can and will happen.  For example suppose our application layer</span></div>
<div class="line"><a id="l05197" name="l05197"></a><span class="lineno"> 5197</span><span class="comment">   * simply stops reading from Receive buffer for a while, resulting in rcv_wnd 0 sent in one of the</span></div>
<div class="line"><a id="l05198" name="l05198"></a><span class="lineno"> 5198</span><span class="comment">   * ACKs.  Now sender knows rcv_wnd is 0.  Now suppose our application reads off the entire Receive</span></div>
<div class="line"><a id="l05199" name="l05199"></a><span class="lineno"> 5199</span><span class="comment">   * buffer.  rcv_wnd is now 100%, but since sender is not sending (because it thinks rcv_wnd is</span></div>
<div class="line"><a id="l05200" name="l05200"></a><span class="lineno"> 5200</span><span class="comment">   * still 0), there will be no ACKs onto which to add rcv_wnd.  Thus the traffic completely stops.</span></div>
<div class="line"><a id="l05201" name="l05201"></a><span class="lineno"> 5201</span><span class="comment">   *</span></div>
<div class="line"><a id="l05202" name="l05202"></a><span class="lineno"> 5202</span><span class="comment">   * Original RFC 793 (as well as RFC 1122) suggests TCP sender should deal with this by &quot;probing&quot;</span></div>
<div class="line"><a id="l05203" name="l05203"></a><span class="lineno"> 5203</span><span class="comment">   * with 1-byte (I think) data segments sent regularly (every RTO; our DTO) in order to trigger</span></div>
<div class="line"><a id="l05204" name="l05204"></a><span class="lineno"> 5204</span><span class="comment">   * ACKs, which would eventually expose the non-zero rcv_wnd.  To me this seems to have the</span></div>
<div class="line"><a id="l05205" name="l05205"></a><span class="lineno"> 5205</span><span class="comment">   * disadvantage of complexity and implications on how we packetize data (especially since in</span></div>
<div class="line"><a id="l05206" name="l05206"></a><span class="lineno"> 5206</span><span class="comment">   * unreliable mode we&#39;re not supposed to break up contiguous blocks of max-block-size bytes).</span></div>
<div class="line"><a id="l05207" name="l05207"></a><span class="lineno"> 5207</span><span class="comment">   * Also it is not as responsive as it could be.  Consider that the most common scenario in</span></div>
<div class="line"><a id="l05208" name="l05208"></a><span class="lineno"> 5208</span><span class="comment">   * high-speed downloads is that the Receive buffer is exceeded only momentarily (due to thread</span></div>
<div class="line"><a id="l05209" name="l05209"></a><span class="lineno"> 5209</span><span class="comment">   * contention on receiver or something) but is then quickly emptied (once the thread contention is</span></div>
<div class="line"><a id="l05210" name="l05210"></a><span class="lineno"> 5210</span><span class="comment">   * resolved).  In case that happens in a fraction of a second, having the probe occur a DTO later</span></div>
<div class="line"><a id="l05211" name="l05211"></a><span class="lineno"> 5211</span><span class="comment">   * wastes a long time.  Instead the RECEIVER could take initiative and send an empty ACK with a</span></div>
<div class="line"><a id="l05212" name="l05212"></a><span class="lineno"> 5212</span><span class="comment">   * rcv_wnd update.  When should it do this?  A naive answer would be to do it simply EVERY time</span></div>
<div class="line"><a id="l05213" name="l05213"></a><span class="lineno"> 5213</span><span class="comment">   * free Receive buffer space increases.  However that&#39;d be terrible, as in a typical scenario</span></div>
<div class="line"><a id="l05214" name="l05214"></a><span class="lineno"> 5214</span><span class="comment">   * (where lots of bytes arrive, while user reads off lots of bytes due to them becoming available</span></div>
<div class="line"><a id="l05215" name="l05215"></a><span class="lineno"> 5215</span><span class="comment">   * to read) it would explode the number of ACKs.  Even in the &quot;sender has stopped due to</span></div>
<div class="line"><a id="l05216" name="l05216"></a><span class="lineno"> 5216</span><span class="comment">   * rcv_wnd=0&quot; situation, this would result in a ton of ACKs.  Plus it would cause sender to start</span></div>
<div class="line"><a id="l05217" name="l05217"></a><span class="lineno"> 5217</span><span class="comment">   * recovering with quite small windows which is inefficient.  So the less naive way is to send the</span></div>
<div class="line"><a id="l05218" name="l05218"></a><span class="lineno"> 5218</span><span class="comment">   * ACK of our volition if free buffer space has increased by some % of its max capacity (like</span></div>
<div class="line"><a id="l05219" name="l05219"></a><span class="lineno"> 5219</span><span class="comment">   * 50%).</span></div>
<div class="line"><a id="l05220" name="l05220"></a><span class="lineno"> 5220</span><span class="comment">   *</span></div>
<div class="line"><a id="l05221" name="l05221"></a><span class="lineno"> 5221</span><span class="comment">   * This would certainly solve aforementioned situation where Receive buffer fills up momentarily</span></div>
<div class="line"><a id="l05222" name="l05222"></a><span class="lineno"> 5222</span><span class="comment">   * but then is quickly cleared.  A fraction of a second later, the free space will have increased</span></div>
<div class="line"><a id="l05223" name="l05223"></a><span class="lineno"> 5223</span><span class="comment">   * by over 50%, an ACK would go to sender, and sender would work with a nice large rcv_wnd.</span></div>
<div class="line"><a id="l05224" name="l05224"></a><span class="lineno"> 5224</span><span class="comment">   * However, if the Receiver only reads off 49% of the data and then stops, traffic would remain</span></div>
<div class="line"><a id="l05225" name="l05225"></a><span class="lineno"> 5225</span><span class="comment">   * stuck (even though 49% of the buffer is available).  This is where the sender-side probing</span></div>
<div class="line"><a id="l05226" name="l05226"></a><span class="lineno"> 5226</span><span class="comment">   * would solve it (slowly); though sender-side unsolicited ACKing on a timer would also do.  I</span></div>
<div class="line"><a id="l05227" name="l05227"></a><span class="lineno"> 5227</span><span class="comment">   * leave that as a @todo; probably important in a widely-used net_flow; but without it it should be</span></div>
<div class="line"><a id="l05228" name="l05228"></a><span class="lineno"> 5228</span><span class="comment">   * sufficient for the initial intended purpose of net_flow.  In that use scenario, we count on the</span></div>
<div class="line"><a id="l05229" name="l05229"></a><span class="lineno"> 5229</span><span class="comment">   * receiver code to be well behaved and read from Receive buffer as soon as the computer lets it.</span></div>
<div class="line"><a id="l05230" name="l05230"></a><span class="lineno"> 5230</span><span class="comment">   *</span></div>
<div class="line"><a id="l05231" name="l05231"></a><span class="lineno"> 5231</span><span class="comment">   * With that settled, there is one more concern.  This is intuitively clear but is also mentioned</span></div>
<div class="line"><a id="l05232" name="l05232"></a><span class="lineno"> 5232</span><span class="comment">   * in RFC 1122-4.2.2.17.  Suppose the receiver-initiated ACK after 50% of buffer is cleared is</span></div>
<div class="line"><a id="l05233" name="l05233"></a><span class="lineno"> 5233</span><span class="comment">   * dropped by the network.  ACKs are not reliable (there are no ACKs of ACKs), so then we&#39;re back</span></div>
<div class="line"><a id="l05234" name="l05234"></a><span class="lineno"> 5234</span><span class="comment">   * in no-more-traffic-forever land.  To solve this, I implement this scheme: Having sent that ACK,</span></div>
<div class="line"><a id="l05235" name="l05235"></a><span class="lineno"> 5235</span><span class="comment">   * start a timer and then send it again periodically, until some long time period (something like</span></div>
<div class="line"><a id="l05236" name="l05236"></a><span class="lineno"> 5236</span><span class="comment">   * a minute) expires (just in case) OR we get a new DATA packet from the sender.  In the latter</span></div>
<div class="line"><a id="l05237" name="l05237"></a><span class="lineno"> 5237</span><span class="comment">   * case we&#39;re back in business, as it implies sender got our window update.  Note that this</span></div>
<div class="line"><a id="l05238" name="l05238"></a><span class="lineno"> 5238</span><span class="comment">   * mechanism is not necessary any longer, once we implement sender-side probing as explained</span></div>
<div class="line"><a id="l05239" name="l05239"></a><span class="lineno"> 5239</span><span class="comment">   * above. */</span></div>
<div class="line"><a id="l05240" name="l05240"></a><span class="lineno"> 5240</span> </div>
<div class="line"><a id="l05241" name="l05241"></a><span class="lineno"> 5241</span>  <span class="comment">// As always, no need to lock m_state, etc., unless we plan to alter them, since no other thread can alter them.</span></div>
<div class="line"><a id="l05242" name="l05242"></a><span class="lineno"> 5242</span> </div>
<div class="line"><a id="l05243" name="l05243"></a><span class="lineno"> 5243</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>)</div>
<div class="line"><a id="l05244" name="l05244"></a><span class="lineno"> 5244</span>  {</div>
<div class="line"><a id="l05245" name="l05245"></a><span class="lineno"> 5245</span>    <span class="comment">/* Yes, they emptied Receive buffer.  However, we haven&#39;t finished the graceful close.</span></div>
<div class="line"><a id="l05246" name="l05246"></a><span class="lineno"> 5246</span><span class="comment">     * Therefore -- even though one more barrier to reaching m_state == S_CLOSED has been removed --</span></div>
<div class="line"><a id="l05247" name="l05247"></a><span class="lineno"> 5247</span><span class="comment">     * there&#39;s nothing further to do at this time.  In fact, in certain situations we might even</span></div>
<div class="line"><a id="l05248" name="l05248"></a><span class="lineno"> 5248</span><span class="comment">     * get more data onto the Receive buffer!  @todo No graceful close yet. */</span></div>
<div class="line"><a id="l05249" name="l05249"></a><span class="lineno"> 5249</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] Receive buffer space freed, &quot;</span></div>
<div class="line"><a id="l05250" name="l05250"></a><span class="lineno"> 5250</span>                  <span class="stringliteral">&quot;but state is now [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;]; ignoring.&quot;</span>);</div>
<div class="line"><a id="l05251" name="l05251"></a><span class="lineno"> 5251</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05252" name="l05252"></a><span class="lineno"> 5252</span>  }</div>
<div class="line"><a id="l05253" name="l05253"></a><span class="lineno"> 5253</span>  <span class="comment">// else if (m_int_state == S_ESTABLISHED)</span></div>
<div class="line"><a id="l05254" name="l05254"></a><span class="lineno"> 5254</span> </div>
<div class="line"><a id="l05255" name="l05255"></a><span class="lineno"> 5255</span>  <span class="keywordflow">if</span> (sock-&gt;m_rcv_in_rcv_wnd_recovery)</div>
<div class="line"><a id="l05256" name="l05256"></a><span class="lineno"> 5256</span>  {</div>
<div class="line"><a id="l05257" name="l05257"></a><span class="lineno"> 5257</span>    <span class="comment">/* We have already sent the unsolicited ACK and are currently in the phase where we&#39;re</span></div>
<div class="line"><a id="l05258" name="l05258"></a><span class="lineno"> 5258</span><span class="comment">     * periodically sending more, until we get some DATA from sender or a long period of time</span></div>
<div class="line"><a id="l05259" name="l05259"></a><span class="lineno"> 5259</span><span class="comment">     * passes.  Even if we&#39;ve freed yet another large chunk of the buffer since the last ACK, do</span></div>
<div class="line"><a id="l05260" name="l05260"></a><span class="lineno"> 5260</span><span class="comment">     * not start again... just let it continue. */</span></div>
<div class="line"><a id="l05261" name="l05261"></a><span class="lineno"> 5261</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] Receive buffer space freed, but &quot;</span></div>
<div class="line"><a id="l05262" name="l05262"></a><span class="lineno"> 5262</span>                   <span class="stringliteral">&quot;we are already in rcv_wnd recovery mode.  Nothing to do.&quot;</span>);</div>
<div class="line"><a id="l05263" name="l05263"></a><span class="lineno"> 5263</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05264" name="l05264"></a><span class="lineno"> 5264</span>  }</div>
<div class="line"><a id="l05265" name="l05265"></a><span class="lineno"> 5265</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05266" name="l05266"></a><span class="lineno"> 5266</span> </div>
<div class="line"><a id="l05267" name="l05267"></a><span class="lineno"> 5267</span>  <span class="comment">// Grab available Receive buffer space.</span></div>
<div class="line"><a id="l05268" name="l05268"></a><span class="lineno"> 5268</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> rcv_wnd = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l05269" name="l05269"></a><span class="lineno"> 5269</span>  <span class="comment">// @todo That was a ~copy/paste of Node::async_low_lvl_ack_send().  Add code reuse.</span></div>
<div class="line"><a id="l05270" name="l05270"></a><span class="lineno"> 5270</span> </div>
<div class="line"><a id="l05271" name="l05271"></a><span class="lineno"> 5271</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; last_rcv_wnd = sock-&gt;m_rcv_last_sent_rcv_wnd;</div>
<div class="line"><a id="l05272" name="l05272"></a><span class="lineno"> 5272</span> </div>
<div class="line"><a id="l05273" name="l05273"></a><span class="lineno"> 5273</span>  <span class="keywordflow">if</span> (rcv_wnd &lt;= last_rcv_wnd)</div>
<div class="line"><a id="l05274" name="l05274"></a><span class="lineno"> 5274</span>  {</div>
<div class="line"><a id="l05275" name="l05275"></a><span class="lineno"> 5275</span>    <span class="comment">/* This seems odd, but one can imagine more data arriving between when we were placed onto W&#39;s</span></div>
<div class="line"><a id="l05276" name="l05276"></a><span class="lineno"> 5276</span><span class="comment">     * task queue and when we executed.  So it&#39;s not that odd and not worth INFO or WARNING. */</span></div>
<div class="line"><a id="l05277" name="l05277"></a><span class="lineno"> 5277</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] Receive buffer space freed, but &quot;</span></div>
<div class="line"><a id="l05278" name="l05278"></a><span class="lineno"> 5278</span>                   <span class="stringliteral">&quot;free space [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(rcv_wnd) &lt;&lt; <span class="stringliteral">&quot;] &lt;= prev &quot;</span></div>
<div class="line"><a id="l05279" name="l05279"></a><span class="lineno"> 5279</span>                   <span class="stringliteral">&quot;free space [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(last_rcv_wnd) &lt;&lt; <span class="stringliteral">&quot;].  Nothing to do.&quot;</span>);</div>
<div class="line"><a id="l05280" name="l05280"></a><span class="lineno"> 5280</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05281" name="l05281"></a><span class="lineno"> 5281</span>  }</div>
<div class="line"><a id="l05282" name="l05282"></a><span class="lineno"> 5282</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05283" name="l05283"></a><span class="lineno"> 5283</span> </div>
<div class="line"><a id="l05284" name="l05284"></a><span class="lineno"> 5284</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> diff = rcv_wnd - last_rcv_wnd;</div>
<div class="line"><a id="l05285" name="l05285"></a><span class="lineno"> 5285</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pct = sock-&gt;opt(sock-&gt;m_opts.m_st_rcv_buf_max_size_to_advertise_percent);</div>
<div class="line"><a id="l05286" name="l05286"></a><span class="lineno"> 5286</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_rcv_buf_size = sock-&gt;max_block_size_multiple(sock-&gt;m_opts.m_st_rcv_buf_max_size);</div>
<div class="line"><a id="l05287" name="l05287"></a><span class="lineno"> 5287</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> min_inc = max_rcv_buf_size * pct / 100;</div>
<div class="line"><a id="l05288" name="l05288"></a><span class="lineno"> 5288</span> </div>
<div class="line"><a id="l05289" name="l05289"></a><span class="lineno"> 5289</span>  <span class="keywordflow">if</span> (diff &lt; min_inc)</div>
<div class="line"><a id="l05290" name="l05290"></a><span class="lineno"> 5290</span>  {</div>
<div class="line"><a id="l05291" name="l05291"></a><span class="lineno"> 5291</span>    <span class="comment">// Not big enough increase; wait until more space is freed before informing other side.</span></div>
<div class="line"><a id="l05292" name="l05292"></a><span class="lineno"> 5292</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] Receive buffer space &quot;</span></div>
<div class="line"><a id="l05293" name="l05293"></a><span class="lineno"> 5293</span>                   <span class="stringliteral">&quot;freed is [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(diff) &lt;&lt; <span class="stringliteral">&quot;] since last advertisement; &quot;</span></div>
<div class="line"><a id="l05294" name="l05294"></a><span class="lineno"> 5294</span>                   <span class="stringliteral">&quot;&lt; threshold [&quot;</span> &lt;&lt; pct &lt;&lt; <span class="stringliteral">&quot;%] x &quot;</span></div>
<div class="line"><a id="l05295" name="l05295"></a><span class="lineno"> 5295</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(max_rcv_buf_size) &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span></div>
<div class="line"><a id="l05296" name="l05296"></a><span class="lineno"> 5296</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(min_inc) &lt;&lt; <span class="stringliteral">&quot;].  Not advertising rcv_wnd yet.&quot;</span>);</div>
<div class="line"><a id="l05297" name="l05297"></a><span class="lineno"> 5297</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05298" name="l05298"></a><span class="lineno"> 5298</span>  }</div>
<div class="line"><a id="l05299" name="l05299"></a><span class="lineno"> 5299</span>  <span class="comment">// else cool. Let&#39;s advertise it.</span></div>
<div class="line"><a id="l05300" name="l05300"></a><span class="lineno"> 5300</span> </div>
<div class="line"><a id="l05301" name="l05301"></a><span class="lineno"> 5301</span>  <span class="comment">// This is ~equally as rare as Receive buffer overflows, so this is worth an INFO message.</span></div>
<div class="line"><a id="l05302" name="l05302"></a><span class="lineno"> 5302</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] Receive buffer space &quot;</span></div>
<div class="line"><a id="l05303" name="l05303"></a><span class="lineno"> 5303</span>                <span class="stringliteral">&quot;freed is [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(diff) &lt;&lt; <span class="stringliteral">&quot;] since last advertisement; &quot;</span></div>
<div class="line"><a id="l05304" name="l05304"></a><span class="lineno"> 5304</span>                <span class="stringliteral">&quot;rcv_wnd = [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(rcv_wnd) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l05305" name="l05305"></a><span class="lineno"> 5305</span>                <span class="stringliteral">&quot;&gt;= threshold [&quot;</span> &lt;&lt; pct &lt;&lt; <span class="stringliteral">&quot;%] x &quot;</span></div>
<div class="line"><a id="l05306" name="l05306"></a><span class="lineno"> 5306</span>                <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(max_rcv_buf_size) &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span></div>
<div class="line"><a id="l05307" name="l05307"></a><span class="lineno"> 5307</span>                <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(min_inc) &lt;&lt; <span class="stringliteral">&quot;].  Sending unsolicited rcv_wnd-advertising ACK &quot;</span></div>
<div class="line"><a id="l05308" name="l05308"></a><span class="lineno"> 5308</span>                <span class="stringliteral">&quot;and entering rcv_wnd recovery.&quot;</span>);</div>
<div class="line"><a id="l05309" name="l05309"></a><span class="lineno"> 5309</span> </div>
<div class="line"><a id="l05310" name="l05310"></a><span class="lineno"> 5310</span>  <span class="comment">// Prevent any further shenanigans (see above), until we exit this mode.</span></div>
<div class="line"><a id="l05311" name="l05311"></a><span class="lineno"> 5311</span>  sock-&gt;m_rcv_in_rcv_wnd_recovery = <span class="keyword">true</span>;</div>
<div class="line"><a id="l05312" name="l05312"></a><span class="lineno"> 5312</span>  <span class="comment">// Mark this down, so that we exit this mode eventually.</span></div>
<div class="line"><a id="l05313" name="l05313"></a><span class="lineno"> 5313</span>  sock-&gt;m_rcv_wnd_recovery_start_time = Fine_clock::now();</div>
<div class="line"><a id="l05314" name="l05314"></a><span class="lineno"> 5314</span> </div>
<div class="line"><a id="l05315" name="l05315"></a><span class="lineno"> 5315</span>  <span class="comment">// Record we started the mode.</span></div>
<div class="line"><a id="l05316" name="l05316"></a><span class="lineno"> 5316</span>  sock-&gt;m_rcv_stats.rcv_wnd_recovery_event_start();</div>
<div class="line"><a id="l05317" name="l05317"></a><span class="lineno"> 5317</span> </div>
<div class="line"><a id="l05318" name="l05318"></a><span class="lineno"> 5318</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">async_rcv_wnd_recovery</a>(sock, rcv_wnd);</div>
<div class="line"><a id="l05319" name="l05319"></a><span class="lineno"> 5319</span>} <span class="comment">// Node::receive_wnd_updated()</span></div>
<div class="line"><a id="l05320" name="l05320"></a><span class="lineno"> 5320</span> </div>
<div class="line"><a id="l05321" name="l05321"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78"> 5321</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">Node::async_rcv_wnd_recovery</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">size_t</span> rcv_wnd)</div>
<div class="line"><a id="l05322" name="l05322"></a><span class="lineno"> 5322</span>{</div>
<div class="line"><a id="l05323" name="l05323"></a><span class="lineno"> 5323</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l05324" name="l05324"></a><span class="lineno"> 5324</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l05325" name="l05325"></a><span class="lineno"> 5325</span>  <span class="keyword">using </span>boost::weak_ptr;</div>
<div class="line"><a id="l05326" name="l05326"></a><span class="lineno"> 5326</span> </div>
<div class="line"><a id="l05327" name="l05327"></a><span class="lineno"> 5327</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05328" name="l05328"></a><span class="lineno"> 5328</span> </div>
<div class="line"><a id="l05329" name="l05329"></a><span class="lineno"> 5329</span>  <span class="comment">// As discussed in Node::receive_wnd_updated(), send the ACK and then periodically re-send it until canceled.</span></div>
<div class="line"><a id="l05330" name="l05330"></a><span class="lineno"> 5330</span> </div>
<div class="line"><a id="l05331" name="l05331"></a><span class="lineno"> 5331</span>  <span class="comment">// Create an ACK with no packets acknowledged (so just a window update) and send it off.</span></div>
<div class="line"><a id="l05332" name="l05332"></a><span class="lineno"> 5332</span>  <span class="keyword">auto</span> ack = Low_lvl_packet::create_uninit_packet&lt;Ack_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05333" name="l05333"></a><span class="lineno"> 5333</span>  ack-&gt;m_rcv_wnd = rcv_wnd;</div>
<div class="line"><a id="l05334" name="l05334"></a><span class="lineno"> 5334</span>  <span class="comment">// Record that it was advertised!</span></div>
<div class="line"><a id="l05335" name="l05335"></a><span class="lineno"> 5335</span>  sock-&gt;m_rcv_last_sent_rcv_wnd = rcv_wnd;</div>
<div class="line"><a id="l05336" name="l05336"></a><span class="lineno"> 5336</span> </div>
<div class="line"><a id="l05337" name="l05337"></a><span class="lineno"> 5337</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(ack));</div>
<div class="line"><a id="l05338" name="l05338"></a><span class="lineno"> 5338</span> </div>
<div class="line"><a id="l05339" name="l05339"></a><span class="lineno"> 5339</span>  <span class="comment">// Register one ACK packet we will send ASAP (and that it acknowledged no individual packets).</span></div>
<div class="line"><a id="l05340" name="l05340"></a><span class="lineno"> 5340</span>  sock-&gt;m_rcv_stats.sent_low_lvl_ack_packet(<span class="keyword">true</span>);</div>
<div class="line"><a id="l05341" name="l05341"></a><span class="lineno"> 5341</span> </div>
<div class="line"><a id="l05342" name="l05342"></a><span class="lineno"> 5342</span>  <span class="comment">// ACK queued to send soon.  Now, as discussed, protect against it being lost by scheduling a timer.</span></div>
<div class="line"><a id="l05343" name="l05343"></a><span class="lineno"> 5343</span> </div>
<div class="line"><a id="l05344" name="l05344"></a><span class="lineno"> 5344</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> fire_when_from_now = sock-&gt;opt(sock-&gt;m_opts.m_dyn_rcv_wnd_recovery_timer_period);</div>
<div class="line"><a id="l05345" name="l05345"></a><span class="lineno"> 5345</span> </div>
<div class="line"><a id="l05346" name="l05346"></a><span class="lineno"> 5346</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Setting timer to fire &quot;</span></div>
<div class="line"><a id="l05347" name="l05347"></a><span class="lineno"> 5347</span>                <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(fire_when_from_now) &lt;&lt; <span class="stringliteral">&quot;] from now.&quot;</span>);</div>
<div class="line"><a id="l05348" name="l05348"></a><span class="lineno"> 5348</span> </div>
<div class="line"><a id="l05349" name="l05349"></a><span class="lineno"> 5349</span>  <span class="comment">/* As usual, when scheduling a thing we can use the much simpler util::schedule_task_*() API; or the</span></div>
<div class="line"><a id="l05350" name="l05350"></a><span class="lineno"> 5350</span><span class="comment">   * full-featured boost.asio Timer.  We don&#39;t need the advanced features; so the only possible reason</span></div>
<div class="line"><a id="l05351" name="l05351"></a><span class="lineno"> 5351</span><span class="comment">   * to go with Timer would be the perf considerations (see schedule_task_from_now() doc header for discussion).</span></div>
<div class="line"><a id="l05352" name="l05352"></a><span class="lineno"> 5352</span><span class="comment">   * It is emphatically NOT the case that lots of these tasks are scheduled/fired/canceled per unit time;</span></div>
<div class="line"><a id="l05353" name="l05353"></a><span class="lineno"> 5353</span><span class="comment">   * e.g., we see it as rare enough to be OK with an INFO log message.  Hence no need to reuse a Timer repeatedly,</span></div>
<div class="line"><a id="l05354" name="l05354"></a><span class="lineno"> 5354</span><span class="comment">   * so use the simple API. */</span></div>
<div class="line"><a id="l05355" name="l05355"></a><span class="lineno"> 5355</span> </div>
<div class="line"><a id="l05356" name="l05356"></a><span class="lineno"> 5356</span>  sock-&gt;m_rcv_wnd_recovery_scheduled_task</div>
<div class="line"><a id="l05357" name="l05357"></a><span class="lineno"> 5357</span>    = <a class="code hl_function" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667">schedule_task_from_now</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), fire_when_from_now, <span class="keyword">true</span>, &amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>,</div>
<div class="line"><a id="l05358" name="l05358"></a><span class="lineno"> 5358</span>                             [<span class="keyword">this</span>, sock_observer = weak_ptr&lt;Peer_socket&gt;(sock)](<span class="keywordtype">bool</span>)</div>
<div class="line"><a id="l05359" name="l05359"></a><span class="lineno"> 5359</span>  {</div>
<div class="line"><a id="l05360" name="l05360"></a><span class="lineno"> 5360</span>     <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05361" name="l05361"></a><span class="lineno"> 5361</span> </div>
<div class="line"><a id="l05362" name="l05362"></a><span class="lineno"> 5362</span>    <span class="keyword">auto</span> sock = sock_observer.lock();</div>
<div class="line"><a id="l05363" name="l05363"></a><span class="lineno"> 5363</span>    <span class="keywordflow">if</span> (!sock)</div>
<div class="line"><a id="l05364" name="l05364"></a><span class="lineno"> 5364</span>    {</div>
<div class="line"><a id="l05365" name="l05365"></a><span class="lineno"> 5365</span>      <span class="keywordflow">return</span>; <span class="comment">// Possible or not, allow for this possibility for maintainability.</span></div>
<div class="line"><a id="l05366" name="l05366"></a><span class="lineno"> 5366</span>    }</div>
<div class="line"><a id="l05367" name="l05367"></a><span class="lineno"> 5367</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l05368" name="l05368"></a><span class="lineno"> 5368</span> </div>
<div class="line"><a id="l05369" name="l05369"></a><span class="lineno"> 5369</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> since_recovery_started = Fine_clock::now() - sock-&gt;m_rcv_wnd_recovery_start_time;</div>
<div class="line"><a id="l05370" name="l05370"></a><span class="lineno"> 5370</span>    <span class="keywordflow">if</span> (since_recovery_started &gt; sock-&gt;opt(sock-&gt;m_opts.m_dyn_rcv_wnd_recovery_max_period))</div>
<div class="line"><a id="l05371" name="l05371"></a><span class="lineno"> 5371</span>    {</div>
<div class="line"><a id="l05372" name="l05372"></a><span class="lineno"> 5372</span>      <span class="comment">// We&#39;ve kept ACKing for a long time, and still no data.  Give up: it&#39;s all up to the sender now.</span></div>
<div class="line"><a id="l05373" name="l05373"></a><span class="lineno"> 5373</span> </div>
<div class="line"><a id="l05374" name="l05374"></a><span class="lineno"> 5374</span>      <span class="comment">// This is ~equally as rare as Receive buffer overflows, so this is worth an INFO message.</span></div>
<div class="line"><a id="l05375" name="l05375"></a><span class="lineno"> 5375</span>      <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: still no new DATA arrived since last rcv_wnd advertisement; &quot;</span></div>
<div class="line"><a id="l05376" name="l05376"></a><span class="lineno"> 5376</span>                    <span class="stringliteral">&quot;Time since entering recovery [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(since_recovery_started) &lt;&lt; <span class="stringliteral">&quot;] expired.  &quot;</span></div>
<div class="line"><a id="l05377" name="l05377"></a><span class="lineno"> 5377</span>                    <span class="stringliteral">&quot;Ending rcv_wnd recovery.&quot;</span>);</div>
<div class="line"><a id="l05378" name="l05378"></a><span class="lineno"> 5378</span>      sock-&gt;m_rcv_in_rcv_wnd_recovery = <span class="keyword">false</span>;</div>
<div class="line"><a id="l05379" name="l05379"></a><span class="lineno"> 5379</span> </div>
<div class="line"><a id="l05380" name="l05380"></a><span class="lineno"> 5380</span>      <span class="comment">// Record we ended in timeout.</span></div>
<div class="line"><a id="l05381" name="l05381"></a><span class="lineno"> 5381</span>      sock-&gt;m_rcv_stats.rcv_wnd_recovery_event_finish(<span class="keyword">false</span>);</div>
<div class="line"><a id="l05382" name="l05382"></a><span class="lineno"> 5382</span> </div>
<div class="line"><a id="l05383" name="l05383"></a><span class="lineno"> 5383</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05384" name="l05384"></a><span class="lineno"> 5384</span>    }</div>
<div class="line"><a id="l05385" name="l05385"></a><span class="lineno"> 5385</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l05386" name="l05386"></a><span class="lineno"> 5386</span> </div>
<div class="line"><a id="l05387" name="l05387"></a><span class="lineno"> 5387</span>    <span class="comment">// Still in rcv_wnd recovery.  Send another unsolicited ACK (as in receive_wnd_updated()).</span></div>
<div class="line"><a id="l05388" name="l05388"></a><span class="lineno"> 5388</span> </div>
<div class="line"><a id="l05389" name="l05389"></a><span class="lineno"> 5389</span>    <span class="comment">// Re-grab available Receive buffer space.</span></div>
<div class="line"><a id="l05390" name="l05390"></a><span class="lineno"> 5390</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> rcv_wnd = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l05391" name="l05391"></a><span class="lineno"> 5391</span> </div>
<div class="line"><a id="l05392" name="l05392"></a><span class="lineno"> 5392</span>    <span class="comment">// This is ~equally as rare as Receive buffer overflows, so this is worth an INFO message.</span></div>
<div class="line"><a id="l05393" name="l05393"></a><span class="lineno"> 5393</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: still no new DATA arrived since last rcv_wnd advertisement; &quot;</span></div>
<div class="line"><a id="l05394" name="l05394"></a><span class="lineno"> 5394</span>                  <span class="stringliteral">&quot;rcv_wnd = [&quot;</span> &lt;&lt; sock-&gt;bytes_blocks_str(rcv_wnd) &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l05395" name="l05395"></a><span class="lineno"> 5395</span>                  <span class="stringliteral">&quot;time since entering recovery [&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(since_recovery_started) &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l05396" name="l05396"></a><span class="lineno"> 5396</span>                  <span class="stringliteral">&quot;Sending unsolicited rcv_wnd-advertising ACK and continuing rcv_wnd recovery.&quot;</span>);</div>
<div class="line"><a id="l05397" name="l05397"></a><span class="lineno"> 5397</span> </div>
<div class="line"><a id="l05398" name="l05398"></a><span class="lineno"> 5398</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">async_rcv_wnd_recovery</a>(sock, rcv_wnd);</div>
<div class="line"><a id="l05399" name="l05399"></a><span class="lineno"> 5399</span>  }); <span class="comment">// on-scheduled-task-fired</span></div>
<div class="line"><a id="l05400" name="l05400"></a><span class="lineno"> 5400</span>} <span class="comment">// Node::async_rcv_wnd_recovery()</span></div>
<div class="line"><a id="l05401" name="l05401"></a><span class="lineno"> 5401</span> </div>
<div class="line"><a id="l05402" name="l05402"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f"> 5402</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">Node::receive_wnd_recovery_data_received</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l05403" name="l05403"></a><span class="lineno"> 5403</span>{</div>
<div class="line"><a id="l05404" name="l05404"></a><span class="lineno"> 5404</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l05405" name="l05405"></a><span class="lineno"> 5405</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l05406" name="l05406"></a><span class="lineno"> 5406</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">util::scheduled_task_cancel</a>;</div>
<div class="line"><a id="l05407" name="l05407"></a><span class="lineno"> 5407</span> </div>
<div class="line"><a id="l05408" name="l05408"></a><span class="lineno"> 5408</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05409" name="l05409"></a><span class="lineno"> 5409</span> </div>
<div class="line"><a id="l05410" name="l05410"></a><span class="lineno"> 5410</span>  <span class="comment">// We got some good DATA.  If we were sending unsolicited window update ACKs, we can now stop.</span></div>
<div class="line"><a id="l05411" name="l05411"></a><span class="lineno"> 5411</span> </div>
<div class="line"><a id="l05412" name="l05412"></a><span class="lineno"> 5412</span>  <span class="keywordflow">if</span> (!sock-&gt;m_rcv_in_rcv_wnd_recovery)</div>
<div class="line"><a id="l05413" name="l05413"></a><span class="lineno"> 5413</span>  {</div>
<div class="line"><a id="l05414" name="l05414"></a><span class="lineno"> 5414</span>    <span class="comment">// We weren&#39;t.</span></div>
<div class="line"><a id="l05415" name="l05415"></a><span class="lineno"> 5415</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05416" name="l05416"></a><span class="lineno"> 5416</span>  }</div>
<div class="line"><a id="l05417" name="l05417"></a><span class="lineno"> 5417</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05418" name="l05418"></a><span class="lineno"> 5418</span> </div>
<div class="line"><a id="l05419" name="l05419"></a><span class="lineno"> 5419</span>  <span class="comment">// This is ~equally as rare as Receive buffer overflows, so this is worth an INFO message.</span></div>
<div class="line"><a id="l05420" name="l05420"></a><span class="lineno"> 5420</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]: Canceling rcv_wnd recovery; &quot;</span></div>
<div class="line"><a id="l05421" name="l05421"></a><span class="lineno"> 5421</span>                <span class="stringliteral">&quot;Time since entering recovery &quot;</span></div>
<div class="line"><a id="l05422" name="l05422"></a><span class="lineno"> 5422</span>                <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; round&lt;milliseconds&gt;(Fine_clock::now() - sock-&gt;m_rcv_wnd_recovery_start_time) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l05423" name="l05423"></a><span class="lineno"> 5423</span> </div>
<div class="line"><a id="l05424" name="l05424"></a><span class="lineno"> 5424</span>  sock-&gt;m_rcv_in_rcv_wnd_recovery = <span class="keyword">false</span>;</div>
<div class="line"><a id="l05425" name="l05425"></a><span class="lineno"> 5425</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l05426" name="l05426"></a><span class="lineno"> 5426</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> canceled =</div>
<div class="line"><a id="l05427" name="l05427"></a><span class="lineno"> 5427</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l05428" name="l05428"></a><span class="lineno"> 5428</span>  <a class="code hl_function" href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">scheduled_task_cancel</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), sock-&gt;m_rcv_wnd_recovery_scheduled_task);</div>
<div class="line"><a id="l05429" name="l05429"></a><span class="lineno"> 5429</span>  assert(canceled);</div>
<div class="line"><a id="l05430" name="l05430"></a><span class="lineno"> 5430</span> </div>
<div class="line"><a id="l05431" name="l05431"></a><span class="lineno"> 5431</span>  <span class="comment">// Record we ended in success.</span></div>
<div class="line"><a id="l05432" name="l05432"></a><span class="lineno"> 5432</span>  sock-&gt;m_rcv_stats.rcv_wnd_recovery_event_finish(<span class="keyword">true</span>);</div>
<div class="line"><a id="l05433" name="l05433"></a><span class="lineno"> 5433</span>}</div>
<div class="line"><a id="l05434" name="l05434"></a><span class="lineno"> 5434</span> </div>
<div class="line"><a id="l05435" name="l05435"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c"> 5435</a></span><span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">Node::sock_rcv_wnd</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l05436" name="l05436"></a><span class="lineno"> 5436</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05437" name="l05437"></a><span class="lineno"> 5437</span>  <span class="keyword">using </span>std::numeric_limits;</div>
<div class="line"><a id="l05438" name="l05438"></a><span class="lineno"> 5438</span> </div>
<div class="line"><a id="l05439" name="l05439"></a><span class="lineno"> 5439</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05440" name="l05440"></a><span class="lineno"> 5440</span> </div>
<div class="line"><a id="l05441" name="l05441"></a><span class="lineno"> 5441</span>  <span class="keywordflow">if</span> (!sock-&gt;opt(sock-&gt;m_opts.m_st_rcv_flow_control_on))</div>
<div class="line"><a id="l05442" name="l05442"></a><span class="lineno"> 5442</span>  {</div>
<div class="line"><a id="l05443" name="l05443"></a><span class="lineno"> 5443</span>    <span class="comment">/* Flow control disabled, so if we always advertise the same huge value, the other side will</span></div>
<div class="line"><a id="l05444" name="l05444"></a><span class="lineno"> 5444</span><span class="comment">     * never stop sending due to rcv_wnd.  On this side, we won&#39;t activate rcv_wnd recovery, because</span></div>
<div class="line"><a id="l05445" name="l05445"></a><span class="lineno"> 5445</span><span class="comment">     * the &quot;last advertised&quot; window will always equal the current window. */</span></div>
<div class="line"><a id="l05446" name="l05446"></a><span class="lineno"> 5446</span>    <span class="keywordflow">return</span> numeric_limits&lt;size_t&gt;::max();</div>
<div class="line"><a id="l05447" name="l05447"></a><span class="lineno"> 5447</span>  }</div>
<div class="line"><a id="l05448" name="l05448"></a><span class="lineno"> 5448</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05449" name="l05449"></a><span class="lineno"> 5449</span> </div>
<div class="line"><a id="l05450" name="l05450"></a><span class="lineno"> 5450</span>  <span class="comment">// Grab available Receive buffer space.  We have to momentarily lock sock due to access to sock-&gt;m_rcv_buf.</span></div>
<div class="line"><a id="l05451" name="l05451"></a><span class="lineno"> 5451</span>  <span class="keywordtype">size_t</span> rcv_buf_size;</div>
<div class="line"><a id="l05452" name="l05452"></a><span class="lineno"> 5452</span>  {</div>
<div class="line"><a id="l05453" name="l05453"></a><span class="lineno"> 5453</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock;</div>
<div class="line"><a id="l05454" name="l05454"></a><span class="lineno"> 5454</span>    rcv_buf_size = sock-&gt;m_rcv_buf.data_size();</div>
<div class="line"><a id="l05455" name="l05455"></a><span class="lineno"> 5455</span>  }</div>
<div class="line"><a id="l05456" name="l05456"></a><span class="lineno"> 5456</span> </div>
<div class="line"><a id="l05457" name="l05457"></a><span class="lineno"> 5457</span>  <span class="comment">// Add the reassembly queue cumulative stored data size.  Why? See sock_data_to_reassembly_q_unless_overflow().</span></div>
<div class="line"><a id="l05458" name="l05458"></a><span class="lineno"> 5458</span>  <span class="keywordflow">if</span> (sock-&gt;rexmit_on())</div>
<div class="line"><a id="l05459" name="l05459"></a><span class="lineno"> 5459</span>  {</div>
<div class="line"><a id="l05460" name="l05460"></a><span class="lineno"> 5460</span>    rcv_buf_size += sock-&gt;m_rcv_reassembly_q_data_size; <span class="comment">// (At least one reason we must be in thread W.)</span></div>
<div class="line"><a id="l05461" name="l05461"></a><span class="lineno"> 5461</span>  }</div>
<div class="line"><a id="l05462" name="l05462"></a><span class="lineno"> 5462</span> </div>
<div class="line"><a id="l05463" name="l05463"></a><span class="lineno"> 5463</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_rcv_buf_size = sock-&gt;max_block_size_multiple(sock-&gt;m_opts.m_st_rcv_buf_max_size);</div>
<div class="line"><a id="l05464" name="l05464"></a><span class="lineno"> 5464</span> </div>
<div class="line"><a id="l05465" name="l05465"></a><span class="lineno"> 5465</span>  <span class="keywordflow">return</span> (max_rcv_buf_size &gt; rcv_buf_size) ? (max_rcv_buf_size - rcv_buf_size) : 0;</div>
<div class="line"><a id="l05466" name="l05466"></a><span class="lineno"> 5466</span>}</div>
<div class="line"><a id="l05467" name="l05467"></a><span class="lineno"> 5467</span> </div>
<div class="line"><a id="l05468" name="l05468"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0"> 5468</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">Node::receive_emptied_rcv_buf_while_disconnecting</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l05469" name="l05469"></a><span class="lineno"> 5469</span>{</div>
<div class="line"><a id="l05470" name="l05470"></a><span class="lineno"> 5470</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05471" name="l05471"></a><span class="lineno"> 5471</span> </div>
<div class="line"><a id="l05472" name="l05472"></a><span class="lineno"> 5472</span>  <span class="comment">/* As always, no need to lock m_state, etc., unless we plan to alter them, since no other thread can alter them.</span></div>
<div class="line"><a id="l05473" name="l05473"></a><span class="lineno"> 5473</span><span class="comment">   * ...On the other hand, we are going to be checking m_rcv_buf for emptiness below, and if it&#39;s not empty,</span></div>
<div class="line"><a id="l05474" name="l05474"></a><span class="lineno"> 5474</span><span class="comment">   * a user thread U != W may be altering it right now by consuming it.  So, lock.</span></div>
<div class="line"><a id="l05475" name="l05475"></a><span class="lineno"> 5475</span><span class="comment">   *</span></div>
<div class="line"><a id="l05476" name="l05476"></a><span class="lineno"> 5476</span><span class="comment">   * Could think about locking later in this function, but this is called so rarely I&#39;d rather not have to</span></div>
<div class="line"><a id="l05477" name="l05477"></a><span class="lineno"> 5477</span><span class="comment">   * worry about whether it&#39;s OK to do that and just not. */</span></div>
<div class="line"><a id="l05478" name="l05478"></a><span class="lineno"> 5478</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l05479" name="l05479"></a><span class="lineno"> 5479</span> </div>
<div class="line"><a id="l05480" name="l05480"></a><span class="lineno"> 5480</span>  <span class="keywordflow">if</span> (sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>)</div>
<div class="line"><a id="l05481" name="l05481"></a><span class="lineno"> 5481</span>  {</div>
<div class="line"><a id="l05482" name="l05482"></a><span class="lineno"> 5482</span>    <span class="comment">/* When were placed onto thread W, state was S_OPEN+S_DISCONNECTING, but before boost.asio</span></div>
<div class="line"><a id="l05483" name="l05483"></a><span class="lineno"> 5483</span><span class="comment">     * could execute us, it executed another handler which already moved us to S_CLOSED for</span></div>
<div class="line"><a id="l05484" name="l05484"></a><span class="lineno"> 5484</span><span class="comment">     * whatever reason (there are many valid ones).  So just don&#39;t do anything, as we no longer</span></div>
<div class="line"><a id="l05485" name="l05485"></a><span class="lineno"> 5485</span><span class="comment">     * apply.  It&#39;s kind of interesting, so log INFO message. */</span></div>
<div class="line"><a id="l05486" name="l05486"></a><span class="lineno"> 5486</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05487" name="l05487"></a><span class="lineno"> 5487</span>                  <span class="stringliteral">&quot;was completely closed before asynchronous &quot;</span></div>
<div class="line"><a id="l05488" name="l05488"></a><span class="lineno"> 5488</span>                  <span class="stringliteral">&quot;receive_emptied_rcv_buf_while_disconnecting() could proceed.&quot;</span>);</div>
<div class="line"><a id="l05489" name="l05489"></a><span class="lineno"> 5489</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05490" name="l05490"></a><span class="lineno"> 5490</span>  }</div>
<div class="line"><a id="l05491" name="l05491"></a><span class="lineno"> 5491</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05492" name="l05492"></a><span class="lineno"> 5492</span> </div>
<div class="line"><a id="l05493" name="l05493"></a><span class="lineno"> 5493</span>  <span class="comment">// Sanity-check (we cannot be called until there&#39;s a graceful close underway).</span></div>
<div class="line"><a id="l05494" name="l05494"></a><span class="lineno"> 5494</span>  assert((sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>) &amp;&amp;</div>
<div class="line"><a id="l05495" name="l05495"></a><span class="lineno"> 5495</span>         (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>));</div>
<div class="line"><a id="l05496" name="l05496"></a><span class="lineno"> 5496</span> </div>
<div class="line"><a id="l05497" name="l05497"></a><span class="lineno"> 5497</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a> = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">Node::socket_id</a>(sock);</div>
<div class="line"><a id="l05498" name="l05498"></a><span class="lineno"> 5498</span> </div>
<div class="line"><a id="l05499" name="l05499"></a><span class="lineno"> 5499</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::Int_state::S_CLOSED</a>)</div>
<div class="line"><a id="l05500" name="l05500"></a><span class="lineno"> 5500</span>  {</div>
<div class="line"><a id="l05501" name="l05501"></a><span class="lineno"> 5501</span>    <span class="comment">/* Yes, they emptied Receive buffer.  However, we haven&#39;t finished the graceful close.</span></div>
<div class="line"><a id="l05502" name="l05502"></a><span class="lineno"> 5502</span><span class="comment">     * Therefore -- even though one more barrier to reaching m_state == S_CLOSED has been removed --</span></div>
<div class="line"><a id="l05503" name="l05503"></a><span class="lineno"> 5503</span><span class="comment">     * there&#39;s nothing further to do at this time.  In fact, in certain situations we might even</span></div>
<div class="line"><a id="l05504" name="l05504"></a><span class="lineno"> 5504</span><span class="comment">     * get more data onto the Receive buffer!  @todo No graceful close yet. */</span></div>
<div class="line"><a id="l05505" name="l05505"></a><span class="lineno"> 5505</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05506" name="l05506"></a><span class="lineno"> 5506</span>                   <span class="stringliteral">&quot;is gracefully closing, and Receive buffer is empty, but graceful close itself not yet finished.&quot;</span>);</div>
<div class="line"><a id="l05507" name="l05507"></a><span class="lineno"> 5507</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05508" name="l05508"></a><span class="lineno"> 5508</span>  }</div>
<div class="line"><a id="l05509" name="l05509"></a><span class="lineno"> 5509</span>  <span class="comment">// else if (m_int_state == S_CLOSED)</span></div>
<div class="line"><a id="l05510" name="l05510"></a><span class="lineno"> 5510</span> </div>
<div class="line"><a id="l05511" name="l05511"></a><span class="lineno"> 5511</span>  <span class="comment">// Ensure Receive buffer is indeed still empty.  (Can still get data while gracefully closing.)</span></div>
<div class="line"><a id="l05512" name="l05512"></a><span class="lineno"> 5512</span>  <span class="keywordflow">if</span> (!sock-&gt;m_rcv_buf.empty())</div>
<div class="line"><a id="l05513" name="l05513"></a><span class="lineno"> 5513</span>  {</div>
<div class="line"><a id="l05514" name="l05514"></a><span class="lineno"> 5514</span>    <span class="comment">/* Some data arrived between the time we were placed on thread W and boost.asio executing us.</span></div>
<div class="line"><a id="l05515" name="l05515"></a><span class="lineno"> 5515</span><span class="comment">     * So we can&#39;t do anything; user has to receive() the stuff first, which should call us again. */</span></div>
<div class="line"><a id="l05516" name="l05516"></a><span class="lineno"> 5516</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05517" name="l05517"></a><span class="lineno"> 5517</span>                   <span class="stringliteral">&quot;is gracefully closing, but Receive buffer has data again.&quot;</span>);</div>
<div class="line"><a id="l05518" name="l05518"></a><span class="lineno"> 5518</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05519" name="l05519"></a><span class="lineno"> 5519</span>  }</div>
<div class="line"><a id="l05520" name="l05520"></a><span class="lineno"> 5520</span>  <span class="comment">// else if (m_int_state == S_CLOSED, and m_rcv_buf is empty)</span></div>
<div class="line"><a id="l05521" name="l05521"></a><span class="lineno"> 5521</span> </div>
<div class="line"><a id="l05522" name="l05522"></a><span class="lineno"> 5522</span>  <span class="comment">// Yes, the transport layer final handshake is finished.  Since Receive buffer now empty, no more barriers remain.</span></div>
<div class="line"><a id="l05523" name="l05523"></a><span class="lineno"> 5523</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l05524" name="l05524"></a><span class="lineno"> 5524</span>                 <span class="stringliteral">&quot;is gracefully closing, and Receive buffer is now empty.  Ready to permanently close.&quot;</span>);</div>
<div class="line"><a id="l05525" name="l05525"></a><span class="lineno"> 5525</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">close_connection_immediately</a>(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock,</div>
<div class="line"><a id="l05526" name="l05526"></a><span class="lineno"> 5526</span>                               <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>(), <span class="comment">/* err_code == success indicates clean close here. */</span></div>
<div class="line"><a id="l05527" name="l05527"></a><span class="lineno"> 5527</span>                               <span class="keyword">false</span>);</div>
<div class="line"><a id="l05528" name="l05528"></a><span class="lineno"> 5528</span>  <span class="comment">/* ^-- defer_delta_check == false: for similar reason as when calling send_worker() from</span></div>
<div class="line"><a id="l05529" name="l05529"></a><span class="lineno"> 5529</span><span class="comment">   * send_worker_check_state(). */</span></div>
<div class="line"><a id="l05530" name="l05530"></a><span class="lineno"> 5530</span>} <span class="comment">// Node::receive_emptied_rcv_buf_while_disconnecting()</span></div>
<div class="line"><a id="l05531" name="l05531"></a><span class="lineno"> 5531</span> </div>
<div class="line"><a id="l05532" name="l05532"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632"> 5532</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">Node::close_abruptly</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l05533" name="l05533"></a><span class="lineno"> 5533</span>{</div>
<div class="line"><a id="l05534" name="l05534"></a><span class="lineno"> 5534</span>  <span class="keyword">using </span>boost::adopt_lock;</div>
<div class="line"><a id="l05535" name="l05535"></a><span class="lineno"> 5535</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">async::asio_exec_ctx_post</a>;</div>
<div class="line"><a id="l05536" name="l05536"></a><span class="lineno"> 5536</span>  <span class="keyword">using </span><a class="code hl_enumeration" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">async::Synchronicity</a>;</div>
<div class="line"><a id="l05537" name="l05537"></a><span class="lineno"> 5537</span> </div>
<div class="line"><a id="l05538" name="l05538"></a><span class="lineno"> 5538</span>  <span class="comment">/* We are in user thread U != W.</span></div>
<div class="line"><a id="l05539" name="l05539"></a><span class="lineno"> 5539</span><span class="comment">   * It&#39;s important to keep that in mind in this method.  In particular, it is absolutely unsafe to</span></div>
<div class="line"><a id="l05540" name="l05540"></a><span class="lineno"> 5540</span><span class="comment">   * access m_int_state, which belongs solely to thread W and is never locked. */</span></div>
<div class="line"><a id="l05541" name="l05541"></a><span class="lineno"> 5541</span> </div>
<div class="line"><a id="l05542" name="l05542"></a><span class="lineno"> 5542</span>  {</div>
<div class="line"><a id="l05543" name="l05543"></a><span class="lineno"> 5543</span>    <span class="comment">/* WARNING!!!  sock-&gt;m_mutex is locked, but WE must unlock it before returning!  Can&#39;t leave that</span></div>
<div class="line"><a id="l05544" name="l05544"></a><span class="lineno"> 5544</span><span class="comment">     * to the caller, because we must unlock at a specific point below, right before post()ing</span></div>
<div class="line"><a id="l05545" name="l05545"></a><span class="lineno"> 5545</span><span class="comment">     * close_abruptly_worker() onto thread W.  Use a Lock_guard that adopts an</span></div>
<div class="line"><a id="l05546" name="l05546"></a><span class="lineno"> 5546</span><span class="comment">     * already-locked mutex. */</span></div>
<div class="line"><a id="l05547" name="l05547"></a><span class="lineno"> 5547</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex, adopt_lock);</div>
<div class="line"><a id="l05548" name="l05548"></a><span class="lineno"> 5548</span> </div>
<div class="line"><a id="l05549" name="l05549"></a><span class="lineno"> 5549</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l05550" name="l05550"></a><span class="lineno"> 5550</span>    {</div>
<div class="line"><a id="l05551" name="l05551"></a><span class="lineno"> 5551</span>      <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l05552" name="l05552"></a><span class="lineno"> 5552</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05553" name="l05553"></a><span class="lineno"> 5553</span>    }</div>
<div class="line"><a id="l05554" name="l05554"></a><span class="lineno"> 5554</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l05555" name="l05555"></a><span class="lineno"> 5555</span> </div>
<div class="line"><a id="l05556" name="l05556"></a><span class="lineno"> 5556</span>    <span class="comment">// Pre-condition.</span></div>
<div class="line"><a id="l05557" name="l05557"></a><span class="lineno"> 5557</span>    assert(sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>);</div>
<div class="line"><a id="l05558" name="l05558"></a><span class="lineno"> 5558</span> </div>
<div class="line"><a id="l05559" name="l05559"></a><span class="lineno"> 5559</span>    <span class="comment">/* Put the rest of the work into thread W.  For justification, see big comment in listen().</span></div>
<div class="line"><a id="l05560" name="l05560"></a><span class="lineno"> 5560</span><span class="comment">     * Addendum regarding performance: close_abruptly() is probably called more frequently than</span></div>
<div class="line"><a id="l05561" name="l05561"></a><span class="lineno"> 5561</span><span class="comment">     * listen(), but I doubt the performance impact is serious even so.  send() and receive() might be</span></div>
<div class="line"><a id="l05562" name="l05562"></a><span class="lineno"> 5562</span><span class="comment">     * a different story. */</span></div>
<div class="line"><a id="l05563" name="l05563"></a><span class="lineno"> 5563</span> </div>
<div class="line"><a id="l05564" name="l05564"></a><span class="lineno"> 5564</span>    <span class="comment">// We&#39;re done -- must unlock so that thread W can do what it wants to with sock.</span></div>
<div class="line"><a id="l05565" name="l05565"></a><span class="lineno"> 5565</span>  } <span class="comment">// lock</span></div>
<div class="line"><a id="l05566" name="l05566"></a><span class="lineno"> 5566</span> </div>
<div class="line"><a id="l05567" name="l05567"></a><span class="lineno"> 5567</span>  <span class="comment">// Load this onto thread W boost.asio work queue.  We don&#39;t return until it runs, so [&amp;].</span></div>
<div class="line"><a id="l05568" name="l05568"></a><span class="lineno"> 5568</span>  <a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">asio_exec_ctx_post</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), &amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION, [&amp;]()</div>
<div class="line"><a id="l05569" name="l05569"></a><span class="lineno"> 5569</span>  {</div>
<div class="line"><a id="l05570" name="l05570"></a><span class="lineno"> 5570</span>    <span class="comment">// We are in thread W.  Thread U is waiting for us to do our stuff and return.</span></div>
<div class="line"><a id="l05571" name="l05571"></a><span class="lineno"> 5571</span> </div>
<div class="line"><a id="l05572" name="l05572"></a><span class="lineno"> 5572</span>    <span class="comment">/* Since we were placed onto thread W, another handler may have been executed before boost.asio</span></div>
<div class="line"><a id="l05573" name="l05573"></a><span class="lineno"> 5573</span><span class="comment">     * got to us.  Therefore we may already be S_CLOSED.  Detect this. */</span></div>
<div class="line"><a id="l05574" name="l05574"></a><span class="lineno"> 5574</span> </div>
<div class="line"><a id="l05575" name="l05575"></a><span class="lineno"> 5575</span>    <span class="keywordflow">if</span> (sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>) <span class="comment">// No need to lock: only W can write to this.</span></div>
<div class="line"><a id="l05576" name="l05576"></a><span class="lineno"> 5576</span>    {</div>
<div class="line"><a id="l05577" name="l05577"></a><span class="lineno"> 5577</span>      <span class="comment">// Yep, already closed.  sock-&gt;m_disconnect_cause is already set to closure reason.  Done.</span></div>
<div class="line"><a id="l05578" name="l05578"></a><span class="lineno"> 5578</span>      *err_code = sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l05579" name="l05579"></a><span class="lineno"> 5579</span>      return;</div>
<div class="line"><a id="l05580" name="l05580"></a><span class="lineno"> 5580</span>    }</div>
<div class="line"><a id="l05581" name="l05581"></a><span class="lineno"> 5581</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l05582" name="l05582"></a><span class="lineno"> 5582</span> </div>
<div class="line"><a id="l05583" name="l05583"></a><span class="lineno"> 5583</span>    <span class="comment">/* Cool, we&#39;re not quite closed yet.  We could be connecting... or connected... or even in the</span></div>
<div class="line"><a id="l05584" name="l05584"></a><span class="lineno"> 5584</span><span class="comment">     * middle of graceful close (@todo that&#39;s not yet implemented).  Any of those situations allow</span></div>
<div class="line"><a id="l05585" name="l05585"></a><span class="lineno"> 5585</span><span class="comment">     * close_abruptly(), just as (indeed because of the fact that) any of those situations allow</span></div>
<div class="line"><a id="l05586" name="l05586"></a><span class="lineno"> 5586</span><span class="comment">     * close_connection_immediately() (..., error::...).</span></div>
<div class="line"><a id="l05587" name="l05587"></a><span class="lineno"> 5587</span><span class="comment">     *</span></div>
<div class="line"><a id="l05588" name="l05588"></a><span class="lineno"> 5588</span><span class="comment">     * Therefore simply do the following.  Pre-conditions hold: sock is in m_socks and is S_OPEN</span></div>
<div class="line"><a id="l05589" name="l05589"></a><span class="lineno"> 5589</span><span class="comment">     * (because not S_CLOSED); 3rd arg contains failure reason. */</span></div>
<div class="line"><a id="l05590" name="l05590"></a><span class="lineno"> 5590</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">rst_and_close_connection_immediately</a>(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>(sock), sock, <a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8">error::Code::S_USER_CLOSED_ABRUPTLY</a>, <span class="keyword">false</span>);</div>
<div class="line"><a id="l05591" name="l05591"></a><span class="lineno"> 5591</span>    <span class="comment">/* ^-- defer_delta_check == false: for similar reason as when calling send_worker() from</span></div>
<div class="line"><a id="l05592" name="l05592"></a><span class="lineno"> 5592</span><span class="comment">     * send_worker_check_state(). */</span></div>
<div class="line"><a id="l05593" name="l05593"></a><span class="lineno"> 5593</span> </div>
<div class="line"><a id="l05594" name="l05594"></a><span class="lineno"> 5594</span>    <span class="comment">// That set sock-&gt;m_disconnect_cause.  Closure successful.  Done.</span></div>
<div class="line"><a id="l05595" name="l05595"></a><span class="lineno"> 5595</span>    err_code-&gt;clear(); <span class="comment">// Success.</span></div>
<div class="line"><a id="l05596" name="l05596"></a><span class="lineno"> 5596</span>  }); <span class="comment">// asio_exec_ctx_post()</span></div>
<div class="line"><a id="l05597" name="l05597"></a><span class="lineno"> 5597</span>  <span class="comment">// If got here, the task has completed in thread W and signaled us to that effect.</span></div>
<div class="line"><a id="l05598" name="l05598"></a><span class="lineno"> 5598</span>} <span class="comment">// Node::close_abruptly()</span></div>
<div class="line"><a id="l05599" name="l05599"></a><span class="lineno"> 5599</span> </div>
<div class="line"><a id="l05600" name="l05600"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177"> 5600</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">Node::close_connection_immediately</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l05601" name="l05601"></a><span class="lineno"> 5601</span>                                        <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <span class="keywordtype">bool</span> defer_delta_check)</div>
<div class="line"><a id="l05602" name="l05602"></a><span class="lineno"> 5602</span>{</div>
<div class="line"><a id="l05603" name="l05603"></a><span class="lineno"> 5603</span>  <span class="keyword">using </span>boost::lexical_cast;</div>
<div class="line"><a id="l05604" name="l05604"></a><span class="lineno"> 5604</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l05605" name="l05605"></a><span class="lineno"> 5605</span> </div>
<div class="line"><a id="l05606" name="l05606"></a><span class="lineno"> 5606</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05607" name="l05607"></a><span class="lineno"> 5607</span> </div>
<div class="line"><a id="l05608" name="l05608"></a><span class="lineno"> 5608</span>  <span class="comment">// @todo OK if a graceful close (S_OPEN+S_DISCONNECTING) is already in progress?  Below provides for it, but ensure.</span></div>
<div class="line"><a id="l05609" name="l05609"></a><span class="lineno"> 5609</span>  assert(sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>);</div>
<div class="line"><a id="l05610" name="l05610"></a><span class="lineno"> 5610</span> </div>
<div class="line"><a id="l05611" name="l05611"></a><span class="lineno"> 5611</span>  <span class="keywordflow">if</span> (err_code)</div>
<div class="line"><a id="l05612" name="l05612"></a><span class="lineno"> 5612</span>  {</div>
<div class="line"><a id="l05613" name="l05613"></a><span class="lineno"> 5613</span>    <a class="code hl_define" href="error_2error_8hpp.html#a5d44fa375b0080a95f45f664c0407c72">FLOW_ERROR_LOG_ERROR</a>(err_code);</div>
<div class="line"><a id="l05614" name="l05614"></a><span class="lineno"> 5614</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Closing and destroying [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] abruptly.&quot;</span>);</div>
<div class="line"><a id="l05615" name="l05615"></a><span class="lineno"> 5615</span>  }</div>
<div class="line"><a id="l05616" name="l05616"></a><span class="lineno"> 5616</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l05617" name="l05617"></a><span class="lineno"> 5617</span>  {</div>
<div class="line"><a id="l05618" name="l05618"></a><span class="lineno"> 5618</span>    <span class="comment">// m_disconnect_cause has already been set and logged.</span></div>
<div class="line"><a id="l05619" name="l05619"></a><span class="lineno"> 5619</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Closing and destroying [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] after graceful close.&quot;</span>);</div>
<div class="line"><a id="l05620" name="l05620"></a><span class="lineno"> 5620</span>  }</div>
<div class="line"><a id="l05621" name="l05621"></a><span class="lineno"> 5621</span>  <span class="comment">// Log final state report.</span></div>
<div class="line"><a id="l05622" name="l05622"></a><span class="lineno"> 5622</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">sock_log_detail</a>(sock);</div>
<div class="line"><a id="l05623" name="l05623"></a><span class="lineno"> 5623</span> </div>
<div class="line"><a id="l05624" name="l05624"></a><span class="lineno"> 5624</span>  <span class="comment">/* Thread safety: we&#39;re in thread W, so no need to lock things by default (as most resources can</span></div>
<div class="line"><a id="l05625" name="l05625"></a><span class="lineno"> 5625</span><span class="comment">   * also only be accessed from thread W).  Exceptions are certain data members in Peer_socket</span></div>
<div class="line"><a id="l05626" name="l05626"></a><span class="lineno"> 5626</span><span class="comment">   * sock and Server_socket serv that may have originated it (if it was a passive open).  I will</span></div>
<div class="line"><a id="l05627" name="l05627"></a><span class="lineno"> 5627</span><span class="comment">   * comment on the locking situation for those data members as they come up in the code. */</span></div>
<div class="line"><a id="l05628" name="l05628"></a><span class="lineno"> 5628</span> </div>
<div class="line"><a id="l05629" name="l05629"></a><span class="lineno"> 5629</span>  <span class="comment">// First, set various state in *sock (including emptying Send and Receive buffers and setting m_node = 0).</span></div>
<div class="line"><a id="l05630" name="l05630"></a><span class="lineno"> 5630</span> </div>
<div class="line"><a id="l05631" name="l05631"></a><span class="lineno"> 5631</span>  <span class="comment">/* Save the final set of stats for Peer_socket::info(), as the source data will probably get</span></div>
<div class="line"><a id="l05632" name="l05632"></a><span class="lineno"> 5632</span><span class="comment">   * purged just below in sock_disconnect_*(). */</span></div>
<div class="line"><a id="l05633" name="l05633"></a><span class="lineno"> 5633</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a>(sock, &amp;sock-&gt;m_info_on_close);</div>
<div class="line"><a id="l05634" name="l05634"></a><span class="lineno"> 5634</span>  <span class="comment">// We may have to massage it a little more, because some info is set below, by when it&#39;s too late.</span></div>
<div class="line"><a id="l05635" name="l05635"></a><span class="lineno"> 5635</span> </div>
<div class="line"><a id="l05636" name="l05636"></a><span class="lineno"> 5636</span>  <span class="keywordflow">if</span> (err_code)</div>
<div class="line"><a id="l05637" name="l05637"></a><span class="lineno"> 5637</span>  {</div>
<div class="line"><a id="l05638" name="l05638"></a><span class="lineno"> 5638</span>    <span class="comment">// sock-&gt;m_disconnect_cause has not yet been set; so sock_load_info_struct() did not copy it properly yet.  Do so.</span></div>
<div class="line"><a id="l05639" name="l05639"></a><span class="lineno"> 5639</span>    sock-&gt;m_info_on_close.m_disconnect_cause = err_code;</div>
<div class="line"><a id="l05640" name="l05640"></a><span class="lineno"> 5640</span>    <span class="comment">// Similarly:</span></div>
<div class="line"><a id="l05641" name="l05641"></a><span class="lineno"> 5641</span>    sock-&gt;m_info_on_close.m_int_state_str = lexical_cast&lt;string&gt;(<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::Int_state::S_CLOSED</a>);</div>
<div class="line"><a id="l05642" name="l05642"></a><span class="lineno"> 5642</span> </div>
<div class="line"><a id="l05643" name="l05643"></a><span class="lineno"> 5643</span>    <span class="comment">/* This is an abrupt close.  This can be called in any situation once sock is in m_socks.  It&#39;s</span></div>
<div class="line"><a id="l05644" name="l05644"></a><span class="lineno"> 5644</span><span class="comment">     * our responsibility to move directly to transport layer state S_CLOSED and user state</span></div>
<div class="line"><a id="l05645" name="l05645"></a><span class="lineno"> 5645</span><span class="comment">     * S_CLOSED. */</span></div>
<div class="line"><a id="l05646" name="l05646"></a><span class="lineno"> 5646</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">sock_set_int_state</a>(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::Int_state::S_CLOSED</a>); <span class="comment">// Thread W access only; no need to lock.</span></div>
<div class="line"><a id="l05647" name="l05647"></a><span class="lineno"> 5647</span>    <span class="comment">// Sets S_CLOSED public state (and related data, including m_disconnect_cause).  Locked inside.</span></div>
<div class="line"><a id="l05648" name="l05648"></a><span class="lineno"> 5648</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">sock_disconnect_detected</a>(sock, err_code, <span class="keyword">true</span>);</div>
<div class="line"><a id="l05649" name="l05649"></a><span class="lineno"> 5649</span>  }</div>
<div class="line"><a id="l05650" name="l05650"></a><span class="lineno"> 5650</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l05651" name="l05651"></a><span class="lineno"> 5651</span>  {</div>
<div class="line"><a id="l05652" name="l05652"></a><span class="lineno"> 5652</span>    <span class="comment">/* We are in a graceful close and have reached the final stage of it (connection entirely</span></div>
<div class="line"><a id="l05653" name="l05653"></a><span class="lineno"> 5653</span><span class="comment">     * closed without having to abruptly close; buffers emptied gracefully by user and/or Node).</span></div>
<div class="line"><a id="l05654" name="l05654"></a><span class="lineno"> 5654</span><span class="comment">     * Therefore m_int_state is already S_CLOSED (method pre-condition), so</span></div>
<div class="line"><a id="l05655" name="l05655"></a><span class="lineno"> 5655</span><span class="comment">     * we just complete the user-visible state change. */</span></div>
<div class="line"><a id="l05656" name="l05656"></a><span class="lineno"> 5656</span> </div>
<div class="line"><a id="l05657" name="l05657"></a><span class="lineno"> 5657</span>    assert(sock-&gt;m_int_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::Int_state::S_CLOSED</a>); <span class="comment">// Thread W access only; no need to lock.</span></div>
<div class="line"><a id="l05658" name="l05658"></a><span class="lineno"> 5658</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">sock_disconnect_completed</a>(sock); <span class="comment">// Sets S_CLOSED public state (and related data).  Locked inside.</span></div>
<div class="line"><a id="l05659" name="l05659"></a><span class="lineno"> 5659</span>  }</div>
<div class="line"><a id="l05660" name="l05660"></a><span class="lineno"> 5660</span> </div>
<div class="line"><a id="l05661" name="l05661"></a><span class="lineno"> 5661</span>  <span class="comment">// Next, remove sock from our main socket list.</span></div>
<div class="line"><a id="l05662" name="l05662"></a><span class="lineno"> 5662</span> </div>
<div class="line"><a id="l05663" name="l05663"></a><span class="lineno"> 5663</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l05664" name="l05664"></a><span class="lineno"> 5664</span>  <span class="keyword">const</span> <span class="keyword">auto</span> erased = 1 ==</div>
<div class="line"><a id="l05665" name="l05665"></a><span class="lineno"> 5665</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l05666" name="l05666"></a><span class="lineno"> 5666</span>    <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">m_socks</a>.erase(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>);</div>
<div class="line"><a id="l05667" name="l05667"></a><span class="lineno"> 5667</span>  assert(erased); <span class="comment">// S_OPEN =&gt; it&#39;s in m_socks.  Otherwise there&#39;s a serious bug somewhere.</span></div>
<div class="line"><a id="l05668" name="l05668"></a><span class="lineno"> 5668</span> </div>
<div class="line"><a id="l05669" name="l05669"></a><span class="lineno"> 5669</span>  <span class="comment">// Next, if this potentially is an unaccepted connection, delete it from the corresponding server socket.</span></div>
<div class="line"><a id="l05670" name="l05670"></a><span class="lineno"> 5670</span>  <span class="keywordflow">if</span> (!sock-&gt;m_active_connect)</div>
<div class="line"><a id="l05671" name="l05671"></a><span class="lineno"> 5671</span>  {</div>
<div class="line"><a id="l05672" name="l05672"></a><span class="lineno"> 5672</span>    <span class="comment">/* What is that Server_socket though?  Well, it&#39;s in sock-&gt;m_originating_serv... but that data</span></div>
<div class="line"><a id="l05673" name="l05673"></a><span class="lineno"> 5673</span><span class="comment">     * member can be accessed from a non-W thread, so we&#39;d have to lock it.  But the mutex that</span></div>
<div class="line"><a id="l05674" name="l05674"></a><span class="lineno"> 5674</span><span class="comment">     * protects it in in *m_originating_serv itself!  So it&#39;s a chicked/egg problem.  However, we</span></div>
<div class="line"><a id="l05675" name="l05675"></a><span class="lineno"> 5675</span><span class="comment">     * can find that Server_socket (if it applies to sock) another way: through the port.  Its port</span></div>
<div class="line"><a id="l05676" name="l05676"></a><span class="lineno"> 5676</span><span class="comment">     * must be the same as local_port.  If such a Server_socket exists, cool; and if sock is</span></div>
<div class="line"><a id="l05677" name="l05677"></a><span class="lineno"> 5677</span><span class="comment">     * tracked inside it, cool.  Otherwise we needn&#39;t do anything. */</span></div>
<div class="line"><a id="l05678" name="l05678"></a><span class="lineno"> 5678</span>    Port_to_server_map::const_iterator port_to_server_it = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">m_servs</a>.find(sock-&gt;m_local_port);</div>
<div class="line"><a id="l05679" name="l05679"></a><span class="lineno"> 5679</span>    <span class="keywordflow">if</span> (port_to_server_it != <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">m_servs</a>.end()) <span class="comment">// Server at same port number exists.  Not necessarily our guy though.</span></div>
<div class="line"><a id="l05680" name="l05680"></a><span class="lineno"> 5680</span>    {</div>
<div class="line"><a id="l05681" name="l05681"></a><span class="lineno"> 5681</span>      <span class="comment">// If it is our guy, delete us from him.</span></div>
<div class="line"><a id="l05682" name="l05682"></a><span class="lineno"> 5682</span>      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv = port_to_server_it-&gt;second;</div>
<div class="line"><a id="l05683" name="l05683"></a><span class="lineno"> 5683</span>      <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">serv_peer_socket_closed</a>(serv, sock); <span class="comment">// Thread-safe (in particular with respect to simultaneous serv-&gt;accept()).</span></div>
<div class="line"><a id="l05684" name="l05684"></a><span class="lineno"> 5684</span>    }</div>
<div class="line"><a id="l05685" name="l05685"></a><span class="lineno"> 5685</span>  }</div>
<div class="line"><a id="l05686" name="l05686"></a><span class="lineno"> 5686</span> </div>
<div class="line"><a id="l05687" name="l05687"></a><span class="lineno"> 5687</span>  <span class="comment">// sock now should not be (directly or indirectly) referenced in any Node data structures.</span></div>
<div class="line"><a id="l05688" name="l05688"></a><span class="lineno"> 5688</span> </div>
<div class="line"><a id="l05689" name="l05689"></a><span class="lineno"> 5689</span>  <span class="comment">// Cancel any timers.</span></div>
<div class="line"><a id="l05690" name="l05690"></a><span class="lineno"> 5690</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">cancel_timers</a>(sock);</div>
<div class="line"><a id="l05691" name="l05691"></a><span class="lineno"> 5691</span> </div>
<div class="line"><a id="l05692" name="l05692"></a><span class="lineno"> 5692</span>  <span class="comment">/* Return the port -- but only if it is an active open.  If it&#39;s a passive open the port is</span></div>
<div class="line"><a id="l05693" name="l05693"></a><span class="lineno"> 5693</span><span class="comment">   * still reserved for the server socket. */</span></div>
<div class="line"><a id="l05694" name="l05694"></a><span class="lineno"> 5694</span>  <span class="keywordflow">if</span> (sock-&gt;m_active_connect)</div>
<div class="line"><a id="l05695" name="l05695"></a><span class="lineno"> 5695</span>  {</div>
<div class="line"><a id="l05696" name="l05696"></a><span class="lineno"> 5696</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> return_err_code;</div>
<div class="line"><a id="l05697" name="l05697"></a><span class="lineno"> 5697</span>    <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">m_ports</a>.<a class="code hl_function" href="classflow_1_1net__flow_1_1Port__space.html#a9fe1be917ff7584ff587b5da5967127a">return_port</a>(sock-&gt;m_local_port, &amp;return_err_code);</div>
<div class="line"><a id="l05698" name="l05698"></a><span class="lineno"> 5698</span>    assert(!return_err_code);</div>
<div class="line"><a id="l05699" name="l05699"></a><span class="lineno"> 5699</span>  }</div>
<div class="line"><a id="l05700" name="l05700"></a><span class="lineno"> 5700</span> </div>
<div class="line"><a id="l05701" name="l05701"></a><span class="lineno"> 5701</span>  <span class="comment">/* sock has changed to CLOSED state.  Performing sock-&gt;receive() or sock-&gt;write() would therefore</span></div>
<div class="line"><a id="l05702" name="l05702"></a><span class="lineno"> 5702</span><span class="comment">   * certainly return an error.  Returning an error from those methods (as opposed to 0 but no</span></div>
<div class="line"><a id="l05703" name="l05703"></a><span class="lineno"> 5703</span><span class="comment">   * error) is considered Readable and Writable, respectively (as we want to alert the user to the</span></div>
<div class="line"><a id="l05704" name="l05704"></a><span class="lineno"> 5704</span><span class="comment">   * error, so her wait [if any] wakes up and notices the error).  Therefore we should soon inform</span></div>
<div class="line"><a id="l05705" name="l05705"></a><span class="lineno"> 5705</span><span class="comment">   * anyone waiting on any Event_sets for sock to become Readable or Writable.</span></div>
<div class="line"><a id="l05706" name="l05706"></a><span class="lineno"> 5706</span><span class="comment">   *</span></div>
<div class="line"><a id="l05707" name="l05707"></a><span class="lineno"> 5707</span><span class="comment">   * Caveat: Similar to that in Node::handle_syn_ack_ack_to_syn_rcvd() at similar point in the</span></div>
<div class="line"><a id="l05708" name="l05708"></a><span class="lineno"> 5708</span><span class="comment">   * code. */</span></div>
<div class="line"><a id="l05709" name="l05709"></a><span class="lineno"> 5709</span> </div>
<div class="line"><a id="l05710" name="l05710"></a><span class="lineno"> 5710</span>  <span class="comment">// Accumulate the event into the Node store (note: not any Event_set yet).</span></div>
<div class="line"><a id="l05711" name="l05711"></a><span class="lineno"> 5711</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> inserted_rd = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">m_sock_events</a>[<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">Event_set::Event_type::S_PEER_SOCKET_READABLE</a>].<a class="code hl_function" href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963">insert</a>(sock).second;</div>
<div class="line"><a id="l05712" name="l05712"></a><span class="lineno"> 5712</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> inserted_wr = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">m_sock_events</a>[<a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a>].<a class="code hl_function" href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963">insert</a>(sock).second;</div>
<div class="line"><a id="l05713" name="l05713"></a><span class="lineno"> 5713</span>  <span class="keywordflow">if</span> (inserted_rd || inserted_wr) <span class="comment">// Must always perform both insert()s, hence the use of the 2 variables.</span></div>
<div class="line"><a id="l05714" name="l05714"></a><span class="lineno"> 5714</span>  {</div>
<div class="line"><a id="l05715" name="l05715"></a><span class="lineno"> 5715</span>    <span class="comment">// Possibly inform the user for any applicable Event_sets right now.</span></div>
<div class="line"><a id="l05716" name="l05716"></a><span class="lineno"> 5716</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">event_set_all_check_delta</a>(defer_delta_check);</div>
<div class="line"><a id="l05717" name="l05717"></a><span class="lineno"> 5717</span>  }</div>
<div class="line"><a id="l05718" name="l05718"></a><span class="lineno"> 5718</span>} <span class="comment">// Node::close_connection_immediately()</span></div>
<div class="line"><a id="l05719" name="l05719"></a><span class="lineno"> 5719</span> </div>
<div class="line"><a id="l05720" name="l05720"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151"> 5720</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">Node::rst_and_close_connection_immediately</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; socket_id, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l05721" name="l05721"></a><span class="lineno"> 5721</span>                                                <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <span class="keywordtype">bool</span> defer_delta_check)</div>
<div class="line"><a id="l05722" name="l05722"></a><span class="lineno"> 5722</span>{</div>
<div class="line"><a id="l05723" name="l05723"></a><span class="lineno"> 5723</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05724" name="l05724"></a><span class="lineno"> 5724</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">async_sock_low_lvl_rst_send</a>(sock);</div>
<div class="line"><a id="l05725" name="l05725"></a><span class="lineno"> 5725</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">close_connection_immediately</a>(<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, sock, err_code, defer_delta_check);</div>
<div class="line"><a id="l05726" name="l05726"></a><span class="lineno"> 5726</span>}</div>
<div class="line"><a id="l05727" name="l05727"></a><span class="lineno"> 5727</span> </div>
<div class="line"><a id="l05728" name="l05728"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7"> 5728</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_packet::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">Node::create_syn</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</div>
<div class="line"><a id="l05729" name="l05729"></a><span class="lineno"> 5729</span>{</div>
<div class="line"><a id="l05730" name="l05730"></a><span class="lineno"> 5730</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>;</div>
<div class="line"><a id="l05731" name="l05731"></a><span class="lineno"> 5731</span> </div>
<div class="line"><a id="l05732" name="l05732"></a><span class="lineno"> 5732</span>  <span class="keyword">auto</span> syn = Low_lvl_packet::create_uninit_packet&lt;Syn_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05733" name="l05733"></a><span class="lineno"> 5733</span>  <span class="comment">// Initial Sequence Number.</span></div>
<div class="line"><a id="l05734" name="l05734"></a><span class="lineno"> 5734</span>  syn-&gt;m_init_seq_num = sock-&gt;m_snd_init_seq_num;</div>
<div class="line"><a id="l05735" name="l05735"></a><span class="lineno"> 5735</span>  <span class="comment">/* Send serialized version of arbitrary user data, which user can deserialize on the other side</span></div>
<div class="line"><a id="l05736" name="l05736"></a><span class="lineno"> 5736</span><span class="comment">   * after accepting connection.</span></div>
<div class="line"><a id="l05737" name="l05737"></a><span class="lineno"> 5737</span><span class="comment">   * Add const to express we require a copy, not move. */</span></div>
<div class="line"><a id="l05738" name="l05738"></a><span class="lineno"> 5738</span>  syn-&gt;m_serialized_metadata = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">Blob</a>&amp;<span class="keyword">&gt;</span>(sock-&gt;m_serialized_metadata);</div>
<div class="line"><a id="l05739" name="l05739"></a><span class="lineno"> 5739</span> </div>
<div class="line"><a id="l05740" name="l05740"></a><span class="lineno"> 5740</span>  <span class="keywordflow">return</span> syn;</div>
<div class="line"><a id="l05741" name="l05741"></a><span class="lineno"> 5741</span>}</div>
<div class="line"><a id="l05742" name="l05742"></a><span class="lineno"> 5742</span> </div>
<div class="line"><a id="l05743" name="l05743"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b"> 5743</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_ack_packet::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">Node::create_syn_ack</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</div>
<div class="line"><a id="l05744" name="l05744"></a><span class="lineno"> 5744</span>{</div>
<div class="line"><a id="l05745" name="l05745"></a><span class="lineno"> 5745</span>  <span class="keyword">auto</span> syn_ack = Low_lvl_packet::create_uninit_packet&lt;Syn_ack_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05746" name="l05746"></a><span class="lineno"> 5746</span>  <span class="comment">// Initial Sequence Number (the start of our own series).</span></div>
<div class="line"><a id="l05747" name="l05747"></a><span class="lineno"> 5747</span>  syn_ack-&gt;m_init_seq_num = sock-&gt;m_snd_init_seq_num;</div>
<div class="line"><a id="l05748" name="l05748"></a><span class="lineno"> 5748</span>  <span class="comment">// Random security token.</span></div>
<div class="line"><a id="l05749" name="l05749"></a><span class="lineno"> 5749</span>  syn_ack-&gt;m_packed.m_security_token = sock-&gt;m_security_token;</div>
<div class="line"><a id="l05750" name="l05750"></a><span class="lineno"> 5750</span>  <span class="comment">// Advertise initial rcv_wnd.</span></div>
<div class="line"><a id="l05751" name="l05751"></a><span class="lineno"> 5751</span>  syn_ack-&gt;m_packed.m_rcv_wnd = sock-&gt;m_rcv_last_sent_rcv_wnd;</div>
<div class="line"><a id="l05752" name="l05752"></a><span class="lineno"> 5752</span> </div>
<div class="line"><a id="l05753" name="l05753"></a><span class="lineno"> 5753</span>  <span class="keywordflow">return</span> syn_ack;</div>
<div class="line"><a id="l05754" name="l05754"></a><span class="lineno"> 5754</span>}</div>
<div class="line"><a id="l05755" name="l05755"></a><span class="lineno"> 5755</span> </div>
<div class="line"><a id="l05756" name="l05756"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ae330d0f98ad34cb442d2bb251bdae460"> 5756</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae330d0f98ad34cb442d2bb251bdae460">Node::async_low_lvl_syn_ack_ack_send</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&amp; sock,</div>
<div class="line"><a id="l05757" name="l05757"></a><span class="lineno"> 5757</span>                                          boost::shared_ptr&lt;const Syn_ack_packet&gt;&amp; syn_ack)</div>
<div class="line"><a id="l05758" name="l05758"></a><span class="lineno"> 5758</span>{</div>
<div class="line"><a id="l05759" name="l05759"></a><span class="lineno"> 5759</span>  <span class="comment">// Make a packet.</span></div>
<div class="line"><a id="l05760" name="l05760"></a><span class="lineno"> 5760</span>  <span class="keyword">auto</span> syn_ack_ack = Low_lvl_packet::create_uninit_packet&lt;Syn_ack_ack_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05761" name="l05761"></a><span class="lineno"> 5761</span>  <span class="comment">// No sequence number (not the initial SYN; not data).</span></div>
<div class="line"><a id="l05762" name="l05762"></a><span class="lineno"> 5762</span>  <span class="comment">// Security token: give it back to them (they will verify).</span></div>
<div class="line"><a id="l05763" name="l05763"></a><span class="lineno"> 5763</span>  syn_ack_ack-&gt;m_packed.m_security_token = syn_ack-&gt;m_packed.m_security_token;</div>
<div class="line"><a id="l05764" name="l05764"></a><span class="lineno"> 5764</span>  <span class="comment">// Initial receive window is probably the entire, ~empty Receive buffer.  Save the advertised rcv_wnd as promised.</span></div>
<div class="line"><a id="l05765" name="l05765"></a><span class="lineno"> 5765</span>  syn_ack_ack-&gt;m_packed.m_rcv_wnd = sock-&gt;m_rcv_last_sent_rcv_wnd = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l05766" name="l05766"></a><span class="lineno"> 5766</span> </div>
<div class="line"><a id="l05767" name="l05767"></a><span class="lineno"> 5767</span>  <span class="comment">// Fill out common fields and asynchronously send packet.</span></div>
<div class="line"><a id="l05768" name="l05768"></a><span class="lineno"> 5768</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(syn_ack_ack));</div>
<div class="line"><a id="l05769" name="l05769"></a><span class="lineno"> 5769</span>}</div>
<div class="line"><a id="l05770" name="l05770"></a><span class="lineno"> 5770</span> </div>
<div class="line"><a id="l05771" name="l05771"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6524cbac013de26f46784b9a2823e5af"> 5771</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6524cbac013de26f46784b9a2823e5af">Node::async_low_lvl_ack_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code)</div>
<div class="line"><a id="l05772" name="l05772"></a><span class="lineno"> 5772</span>{</div>
<div class="line"><a id="l05773" name="l05773"></a><span class="lineno"> 5773</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l05774" name="l05774"></a><span class="lineno"> 5774</span>  <span class="keyword">using </span>boost::chrono::duration_cast;</div>
<div class="line"><a id="l05775" name="l05775"></a><span class="lineno"> 5775</span>  <span class="keyword">using </span>std::make_pair;</div>
<div class="line"><a id="l05776" name="l05776"></a><span class="lineno"> 5776</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l05777" name="l05777"></a><span class="lineno"> 5777</span>  <span class="keyword">using </span>std::numeric_limits;</div>
<div class="line"><a id="l05778" name="l05778"></a><span class="lineno"> 5778</span> </div>
<div class="line"><a id="l05779" name="l05779"></a><span class="lineno"> 5779</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05780" name="l05780"></a><span class="lineno"> 5780</span> </div>
<div class="line"><a id="l05781" name="l05781"></a><span class="lineno"> 5781</span>  <span class="comment">// Handle the timer-related corner cases (if we were invoked by m_rcv_delayed_ack_timer triggering).</span></div>
<div class="line"><a id="l05782" name="l05782"></a><span class="lineno"> 5782</span> </div>
<div class="line"><a id="l05783" name="l05783"></a><span class="lineno"> 5783</span>  <span class="comment">// For brevity and speed:</span></div>
<div class="line"><a id="l05784" name="l05784"></a><span class="lineno"> 5784</span>  vector&lt;Peer_socket::Individual_ack::Ptr&gt;&amp; pending_acks = sock-&gt;m_rcv_pending_acks;</div>
<div class="line"><a id="l05785" name="l05785"></a><span class="lineno"> 5785</span> </div>
<div class="line"><a id="l05786" name="l05786"></a><span class="lineno"> 5786</span>  <span class="keywordflow">if</span> (sys_err_code == boost::asio::error::operation_aborted)</div>
<div class="line"><a id="l05787" name="l05787"></a><span class="lineno"> 5787</span>  {</div>
<div class="line"><a id="l05788" name="l05788"></a><span class="lineno"> 5788</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] canceled; &quot;</span></div>
<div class="line"><a id="l05789" name="l05789"></a><span class="lineno"> 5789</span>                   <span class="stringliteral">&quot;pending acknowledgment count [&quot;</span> &lt;&lt; pending_acks.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l05790" name="l05790"></a><span class="lineno"> 5790</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05791" name="l05791"></a><span class="lineno"> 5791</span>  }</div>
<div class="line"><a id="l05792" name="l05792"></a><span class="lineno"> 5792</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05793" name="l05793"></a><span class="lineno"> 5793</span> </div>
<div class="line"><a id="l05794" name="l05794"></a><span class="lineno"> 5794</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered, or ACK forced; &quot;</span></div>
<div class="line"><a id="l05795" name="l05795"></a><span class="lineno"> 5795</span>                 <span class="stringliteral">&quot;pending acknowledgment count [&quot;</span> &lt;&lt; pending_acks.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l05796" name="l05796"></a><span class="lineno"> 5796</span> </div>
<div class="line"><a id="l05797" name="l05797"></a><span class="lineno"> 5797</span>  <span class="keywordflow">if</span> (sys_err_code)</div>
<div class="line"><a id="l05798" name="l05798"></a><span class="lineno"> 5798</span>  {</div>
<div class="line"><a id="l05799" name="l05799"></a><span class="lineno"> 5799</span>    <a class="code hl_define" href="error_2error_8hpp.html#a019ee6e90802e444572dd78d312d6e23">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>(); <span class="comment">// Log non-portable error.</span></div>
<div class="line"><a id="l05800" name="l05800"></a><span class="lineno"> 5800</span>    <span class="comment">// Nothing else to do here.  We don&#39;t know what this means.  So just treat it as if timer was triggered.</span></div>
<div class="line"><a id="l05801" name="l05801"></a><span class="lineno"> 5801</span>  }</div>
<div class="line"><a id="l05802" name="l05802"></a><span class="lineno"> 5802</span> </div>
<div class="line"><a id="l05803" name="l05803"></a><span class="lineno"> 5803</span>  <span class="keywordflow">if</span> (sock-&gt;m_int_state != <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">Peer_socket::Int_state::S_ESTABLISHED</a>)</div>
<div class="line"><a id="l05804" name="l05804"></a><span class="lineno"> 5804</span>  {</div>
<div class="line"><a id="l05805" name="l05805"></a><span class="lineno"> 5805</span>    <span class="comment">/* This is unlikely but legitimate.  (Can happen if, by the time the handler that advanced state</span></div>
<div class="line"><a id="l05806" name="l05806"></a><span class="lineno"> 5806</span><span class="comment">     * from ESTABLISHED to another state started, this timer also was triggered and thus queued the</span></div>
<div class="line"><a id="l05807" name="l05807"></a><span class="lineno"> 5807</span><span class="comment">     * current handler inside m_task_engine.) */</span></div>
<div class="line"><a id="l05808" name="l05808"></a><span class="lineno"> 5808</span>    <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered, &quot;</span></div>
<div class="line"><a id="l05809" name="l05809"></a><span class="lineno"> 5809</span>                   <span class="stringliteral">&quot;but socket already in inapplicable state [&quot;</span> &lt;&lt; sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;].  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l05810" name="l05810"></a><span class="lineno"> 5810</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05811" name="l05811"></a><span class="lineno"> 5811</span>  }</div>
<div class="line"><a id="l05812" name="l05812"></a><span class="lineno"> 5812</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05813" name="l05813"></a><span class="lineno"> 5813</span> </div>
<div class="line"><a id="l05814" name="l05814"></a><span class="lineno"> 5814</span>  <span class="keywordflow">if</span> (pending_acks.empty())</div>
<div class="line"><a id="l05815" name="l05815"></a><span class="lineno"> 5815</span>  {</div>
<div class="line"><a id="l05816" name="l05816"></a><span class="lineno"> 5816</span>    <span class="comment">/* This is probably a bug if we&#39;re here.  However, assert() or connection closure seems a bit</span></div>
<div class="line"><a id="l05817" name="l05817"></a><span class="lineno"> 5817</span><span class="comment">     * drastic... carry on. */</span></div>
<div class="line"><a id="l05818" name="l05818"></a><span class="lineno"> 5818</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered, &quot;</span></div>
<div class="line"><a id="l05819" name="l05819"></a><span class="lineno"> 5819</span>                     <span class="stringliteral">&quot;but socket has no pending acknowledgments.  This is likely an internal bug.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l05820" name="l05820"></a><span class="lineno"> 5820</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l05821" name="l05821"></a><span class="lineno"> 5821</span>  }</div>
<div class="line"><a id="l05822" name="l05822"></a><span class="lineno"> 5822</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05823" name="l05823"></a><span class="lineno"> 5823</span> </div>
<div class="line"><a id="l05824" name="l05824"></a><span class="lineno"> 5824</span>  <span class="comment">/* OK, let&#39;s do it.  Basically just shove all the acknowledgments into an ACK packet.  Namely, for</span></div>
<div class="line"><a id="l05825" name="l05825"></a><span class="lineno"> 5825</span><span class="comment">   * each one, shove the starting sequence number and the amount of time since we first received it</span></div>
<div class="line"><a id="l05826" name="l05826"></a><span class="lineno"> 5826</span><span class="comment">   * (so the other side can subtract that to compute RTT, if it wants).</span></div>
<div class="line"><a id="l05827" name="l05827"></a><span class="lineno"> 5827</span><span class="comment">   *</span></div>
<div class="line"><a id="l05828" name="l05828"></a><span class="lineno"> 5828</span><span class="comment">   * However we may run out of space and need more ACKs.  To keep track of how much space we&#39;ve</span></div>
<div class="line"><a id="l05829" name="l05829"></a><span class="lineno"> 5829</span><span class="comment">   * used, compute an estimate for serializing those two pieces of data and keep adding that for</span></div>
<div class="line"><a id="l05830" name="l05830"></a><span class="lineno"> 5830</span><span class="comment">   * each acknowledgment handled.  The budget is given by max-block-size; a DATA packet is allowed</span></div>
<div class="line"><a id="l05831" name="l05831"></a><span class="lineno"> 5831</span><span class="comment">   * that much payload on top of the normal header stuff, so that should be good enough for us too.</span></div>
<div class="line"><a id="l05832" name="l05832"></a><span class="lineno"> 5832</span><span class="comment">   * There&#39;s probably some constant overhead on top of that, but it&#39;s close enough.</span></div>
<div class="line"><a id="l05833" name="l05833"></a><span class="lineno"> 5833</span><span class="comment">   *</span></div>
<div class="line"><a id="l05834" name="l05834"></a><span class="lineno"> 5834</span><span class="comment">   * ACK is also used as an opportunistic way to send rcv_wnd to the other side, which informs</span></div>
<div class="line"><a id="l05835" name="l05835"></a><span class="lineno"> 5835</span><span class="comment">   * them of how much more data we can take at this time.  Naively we should just have rcv_wnd =</span></div>
<div class="line"><a id="l05836" name="l05836"></a><span class="lineno"> 5836</span><span class="comment">   * the max buffer size minus the buffer space currently taken, and that is the most accurate</span></div>
<div class="line"><a id="l05837" name="l05837"></a><span class="lineno"> 5837</span><span class="comment">   * thing.  However RFC 793 (&quot;Window Management Suggestions&quot;) and probably other literature</span></div>
<div class="line"><a id="l05838" name="l05838"></a><span class="lineno"> 5838</span><span class="comment">   * suggest to (when the available space is increasing) advertise the window in larger steps (so</span></div>
<div class="line"><a id="l05839" name="l05839"></a><span class="lineno"> 5839</span><span class="comment">   * withhold the higher rcv_wnd value until it increases even further up to some threshold).  For</span></div>
<div class="line"><a id="l05840" name="l05840"></a><span class="lineno"> 5840</span><span class="comment">   * now I forego such fanciness.  See also the rcv_wnd-related comment in</span></div>
<div class="line"><a id="l05841" name="l05841"></a><span class="lineno"> 5841</span><span class="comment">   * Node::receive_wnd_increased() for further reasoning on rcv_wnd (namely surrounding the fact</span></div>
<div class="line"><a id="l05842" name="l05842"></a><span class="lineno"> 5842</span><span class="comment">   * that sometimes we must send ACKs with no packets acknowledged to ensure a connection does not</span></div>
<div class="line"><a id="l05843" name="l05843"></a><span class="lineno"> 5843</span><span class="comment">   * stall due to a zero rcv_wnd). */</span></div>
<div class="line"><a id="l05844" name="l05844"></a><span class="lineno"> 5844</span> </div>
<div class="line"><a id="l05845" name="l05845"></a><span class="lineno"> 5845</span>  <span class="comment">// Grab available Receive buffer space.  Save it for later comparison.</span></div>
<div class="line"><a id="l05846" name="l05846"></a><span class="lineno"> 5846</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; rcv_wnd = sock-&gt;m_rcv_last_sent_rcv_wnd = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l05847" name="l05847"></a><span class="lineno"> 5847</span> </div>
<div class="line"><a id="l05848" name="l05848"></a><span class="lineno"> 5848</span>  <span class="keyword">auto</span> ack = Low_lvl_packet::create_uninit_packet&lt;Ack_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05849" name="l05849"></a><span class="lineno"> 5849</span>  ack-&gt;m_rcv_wnd = rcv_wnd; <span class="comment">// Advertise receive window.  @todo Code reuse?</span></div>
<div class="line"><a id="l05850" name="l05850"></a><span class="lineno"> 5850</span> </div>
<div class="line"><a id="l05851" name="l05851"></a><span class="lineno"> 5851</span>  <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a> = sock-&gt;max_block_size();</div>
<div class="line"><a id="l05852" name="l05852"></a><span class="lineno"> 5852</span>  <span class="keywordtype">size_t</span> size_est_inc</div>
<div class="line"><a id="l05853" name="l05853"></a><span class="lineno"> 5853</span>    = <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#a374da5eef60c7d8a4085b41cf7b2adfe">Ack_packet::ack_delay_t</a>) + <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="classflow_1_1net__flow_1_1Sequence__number.html#ab307e12c0cf8cefbe7fb1ec8588af2a8">Sequence_number::seq_num_t</a>);</div>
<div class="line"><a id="l05854" name="l05854"></a><span class="lineno"> 5854</span>  <span class="keywordflow">if</span> (sock-&gt;rexmit_on())</div>
<div class="line"><a id="l05855" name="l05855"></a><span class="lineno"> 5855</span>  {</div>
<div class="line"><a id="l05856" name="l05856"></a><span class="lineno"> 5856</span>    size_est_inc += <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a11e7750d22415a381e23112062f7ca74">Low_lvl_packet::rexmit_id_t</a>);</div>
<div class="line"><a id="l05857" name="l05857"></a><span class="lineno"> 5857</span>  }</div>
<div class="line"><a id="l05858" name="l05858"></a><span class="lineno"> 5858</span>  assert(size_est_inc &lt;= <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a>); <span class="comment">// At least one has to fit.</span></div>
<div class="line"><a id="l05859" name="l05859"></a><span class="lineno"> 5859</span> </div>
<div class="line"><a id="l05860" name="l05860"></a><span class="lineno"> 5860</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> time_now = Fine_clock::now();</div>
<div class="line"><a id="l05861" name="l05861"></a><span class="lineno"> 5861</span>  <span class="keywordtype">size_t</span> size_est_so_far = <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">Low_lvl_packet::rcv_wnd_t</a>); <span class="comment">// How many raw bytes we have, approximately, used.</span></div>
<div class="line"><a id="l05862" name="l05862"></a><span class="lineno"> 5862</span>  <span class="keywordflow">for</span> (<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#a209d79e058d103c84fc10be84d492a8b">Peer_socket::Individual_ack::Const_ptr</a> ind_ack : pending_acks)</div>
<div class="line"><a id="l05863" name="l05863"></a><span class="lineno"> 5863</span>  {</div>
<div class="line"><a id="l05864" name="l05864"></a><span class="lineno"> 5864</span>    <span class="keywordflow">if</span> (size_est_so_far + size_est_inc &gt; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a>)</div>
<div class="line"><a id="l05865" name="l05865"></a><span class="lineno"> 5865</span>    {</div>
<div class="line"><a id="l05866" name="l05866"></a><span class="lineno"> 5866</span>      <span class="comment">// Too big.  Send off what we have.</span></div>
<div class="line"><a id="l05867" name="l05867"></a><span class="lineno"> 5867</span>      <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(ack));</div>
<div class="line"><a id="l05868" name="l05868"></a><span class="lineno"> 5868</span> </div>
<div class="line"><a id="l05869" name="l05869"></a><span class="lineno"> 5869</span>      <span class="comment">// Register one ACK packet we will send ASAP.</span></div>
<div class="line"><a id="l05870" name="l05870"></a><span class="lineno"> 5870</span>      sock-&gt;m_rcv_stats.sent_low_lvl_ack_packet(<span class="keyword">false</span>);</div>
<div class="line"><a id="l05871" name="l05871"></a><span class="lineno"> 5871</span> </div>
<div class="line"><a id="l05872" name="l05872"></a><span class="lineno"> 5872</span>      <span class="comment">// As async_sock_low_lvl_packet_send_paced() says, we cannot reuse ack&#39;s pointed-to-object.  Make new one.</span></div>
<div class="line"><a id="l05873" name="l05873"></a><span class="lineno"> 5873</span>      ack = Low_lvl_packet::create_uninit_packet&lt;Ack_packet&gt;(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><a id="l05874" name="l05874"></a><span class="lineno"> 5874</span>      ack-&gt;m_rcv_wnd = rcv_wnd; <span class="comment">// Advertise receive window.  @todo Code reuse?</span></div>
<div class="line"><a id="l05875" name="l05875"></a><span class="lineno"> 5875</span> </div>
<div class="line"><a id="l05876" name="l05876"></a><span class="lineno"> 5876</span>      size_est_so_far = <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">Low_lvl_packet::rcv_wnd_t</a>);</div>
<div class="line"><a id="l05877" name="l05877"></a><span class="lineno"> 5877</span>    }</div>
<div class="line"><a id="l05878" name="l05878"></a><span class="lineno"> 5878</span> </div>
<div class="line"><a id="l05879" name="l05879"></a><span class="lineno"> 5879</span>    <span class="comment">// Add the acknowledgment to the current ACK.</span></div>
<div class="line"><a id="l05880" name="l05880"></a><span class="lineno"> 5880</span> </div>
<div class="line"><a id="l05881" name="l05881"></a><span class="lineno"> 5881</span>    <span class="comment">// First sequence number in packet.</span></div>
<div class="line"><a id="l05882" name="l05882"></a><span class="lineno"> 5882</span>    <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num = ind_ack-&gt;m_seq_num;</div>
<div class="line"><a id="l05883" name="l05883"></a><span class="lineno"> 5883</span> </div>
<div class="line"><a id="l05884" name="l05884"></a><span class="lineno"> 5884</span>    <span class="comment">// ACK delay for this individual acknowledgment.  Compute it; then validate it.</span></div>
<div class="line"><a id="l05885" name="l05885"></a><span class="lineno"> 5885</span> </div>
<div class="line"><a id="l05886" name="l05886"></a><span class="lineno"> 5886</span>    <span class="comment">/* @todo In low_lvl_io, we perform packet pacing but currently choose to assign a value of</span></div>
<div class="line"><a id="l05887" name="l05887"></a><span class="lineno"> 5887</span><span class="comment">     * 0 bytes to an ACK.  That is, while we do preserve the order of DATA and ACK packets -- if</span></div>
<div class="line"><a id="l05888" name="l05888"></a><span class="lineno"> 5888</span><span class="comment">     * both happen to be in the outgoing stream -- we do not delay the sending of the ACK once it is</span></div>
<div class="line"><a id="l05889" name="l05889"></a><span class="lineno"> 5889</span><span class="comment">     * the next packet to be sent out.  However, even so, an ACK&#39;s sending may be delayed by the</span></div>
<div class="line"><a id="l05890" name="l05890"></a><span class="lineno"> 5890</span><span class="comment">     * pacing applied to DATA packets intermixed with it.  Therefore the ACK delay measurement we</span></div>
<div class="line"><a id="l05891" name="l05891"></a><span class="lineno"> 5891</span><span class="comment">     * take here may be incorrect (too low) in that case.  This can cause overestimated RTTs on the</span></div>
<div class="line"><a id="l05892" name="l05892"></a><span class="lineno"> 5892</span><span class="comment">     * sender&#39;s side.  The to-do is to correct the ACK delay value in a given ACK by adding the</span></div>
<div class="line"><a id="l05893" name="l05893"></a><span class="lineno"> 5893</span><span class="comment">     * pacing delay (if any) of the ACK to the individual ACK delays within it.  Conceptually this</span></div>
<div class="line"><a id="l05894" name="l05894"></a><span class="lineno"> 5894</span><span class="comment">     * is similar to the sent_when value being set when choosing to send a DATA packet and then</span></div>
<div class="line"><a id="l05895" name="l05895"></a><span class="lineno"> 5895</span><span class="comment">     * corrected in the pacing module later.</span></div>
<div class="line"><a id="l05896" name="l05896"></a><span class="lineno"> 5896</span><span class="comment">     *</span></div>
<div class="line"><a id="l05897" name="l05897"></a><span class="lineno"> 5897</span><span class="comment">     * This to-do is not important until we in practice start mixing sending and receiving at the</span></div>
<div class="line"><a id="l05898" name="l05898"></a><span class="lineno"> 5898</span><span class="comment">     * application layer... but still -- it&#39;s worth knowing that there is a design bug here. */</span></div>
<div class="line"><a id="l05899" name="l05899"></a><span class="lineno"> 5899</span> </div>
<div class="line"><a id="l05900" name="l05900"></a><span class="lineno"> 5900</span>    <span class="comment">// Shouldn&#39;t be negative.</span></div>
<div class="line"><a id="l05901" name="l05901"></a><span class="lineno"> 5901</span>    <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> delay = time_now - ind_ack-&gt;m_received_when;</div>
<div class="line"><a id="l05902" name="l05902"></a><span class="lineno"> 5902</span>    <span class="keywordflow">if</span> (delay.count() &lt; 0)</div>
<div class="line"><a id="l05903" name="l05903"></a><span class="lineno"> 5903</span>    {</div>
<div class="line"><a id="l05904" name="l05904"></a><span class="lineno"> 5904</span>      <span class="comment">/* This is pretty crazy and should not happen according to the documented properties of</span></div>
<div class="line"><a id="l05905" name="l05905"></a><span class="lineno"> 5905</span><span class="comment">       * Fine_clock.  No need to crash or disconnect though, so do our best.... */</span></div>
<div class="line"><a id="l05906" name="l05906"></a><span class="lineno"> 5906</span>      <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered; &quot;</span></div>
<div class="line"><a id="l05907" name="l05907"></a><span class="lineno"> 5907</span>                       <span class="stringliteral">&quot;delay for packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) is &quot;</span></div>
<div class="line"><a id="l05908" name="l05908"></a><span class="lineno"> 5908</span>                       <span class="stringliteral">&quot;negative: [&quot;</span> &lt;&lt; delay &lt;&lt; <span class="stringliteral">&quot;]; using zero.&quot;</span>);</div>
<div class="line"><a id="l05909" name="l05909"></a><span class="lineno"> 5909</span>      delay = Fine_duration::zero();</div>
<div class="line"><a id="l05910" name="l05910"></a><span class="lineno"> 5910</span>    }</div>
<div class="line"><a id="l05911" name="l05911"></a><span class="lineno"> 5911</span> </div>
<div class="line"><a id="l05912" name="l05912"></a><span class="lineno"> 5912</span>    <span class="comment">/* Convert whatever resolution Fine_clock uses to milliseconds because we want to keep that</span></div>
<div class="line"><a id="l05913" name="l05913"></a><span class="lineno"> 5913</span><span class="comment">     * field of the ACK sized according to how the low-level packet handling code prefers it for</span></div>
<div class="line"><a id="l05914" name="l05914"></a><span class="lineno"> 5914</span><span class="comment">     * efficiency.  Overflow is possible.  Use duration_cast (truncation) instead of rounding,</span></div>
<div class="line"><a id="l05915" name="l05915"></a><span class="lineno"> 5915</span><span class="comment">     * because in very low-latency situations the extra microseconds rounding up can cause a</span></div>
<div class="line"><a id="l05916" name="l05916"></a><span class="lineno"> 5916</span><span class="comment">     * negative RTT calculation on the other side (when this ACK is received).  The ACK handling</span></div>
<div class="line"><a id="l05917" name="l05917"></a><span class="lineno"> 5917</span><span class="comment">     * code will just clamp the value at zero on the other side, but let&#39;s try to avoid it anyway</span></div>
<div class="line"><a id="l05918" name="l05918"></a><span class="lineno"> 5918</span><span class="comment">     * on this side.</span></div>
<div class="line"><a id="l05919" name="l05919"></a><span class="lineno"> 5919</span><span class="comment">     *</span></div>
<div class="line"><a id="l05920" name="l05920"></a><span class="lineno"> 5920</span><span class="comment">     * @todo This comment appears to be outdated, as Ack_delay_time_unit is just Fine_duration.</span></div>
<div class="line"><a id="l05921" name="l05921"></a><span class="lineno"> 5921</span><span class="comment">     * Look into this. */</span></div>
<div class="line"><a id="l05922" name="l05922"></a><span class="lineno"> 5922</span>    <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#abd3bc7f9e9195bf1b4aca2cad881646c">Ack_packet::Ack_delay_time_unit</a> pkt_delay = duration_cast&lt;Ack_packet::Ack_delay_time_unit&gt;(delay);</div>
<div class="line"><a id="l05923" name="l05923"></a><span class="lineno"> 5923</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#a374da5eef60c7d8a4085b41cf7b2adfe">Ack_packet::ack_delay_t</a> MAX_DELAY_VALUE = numeric_limits&lt;Ack_packet::ack_delay_t&gt;::max();</div>
<div class="line"><a id="l05924" name="l05924"></a><span class="lineno"> 5924</span>    <span class="keywordflow">if</span> (uint64_t(pkt_delay.count()) &gt; uint64_t(MAX_DELAY_VALUE))</div>
<div class="line"><a id="l05925" name="l05925"></a><span class="lineno"> 5925</span>    {</div>
<div class="line"><a id="l05926" name="l05926"></a><span class="lineno"> 5926</span>      <span class="comment">/* This is pretty crazy though not 100% impossible if the CPU is really loaded, or some other</span></div>
<div class="line"><a id="l05927" name="l05927"></a><span class="lineno"> 5927</span><span class="comment">       * shenanigans.  So do our best.... */</span></div>
<div class="line"><a id="l05928" name="l05928"></a><span class="lineno"> 5928</span>      <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Delayed [ACK] timer [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] triggered; &quot;</span></div>
<div class="line"><a id="l05929" name="l05929"></a><span class="lineno"> 5929</span>                       <span class="stringliteral">&quot;delay for packet [&quot;</span> &lt;&lt; seq_num &lt;&lt; <span class="stringliteral">&quot;, ...) is [&quot;</span> &lt;&lt; pkt_delay &lt;&lt; <span class="stringliteral">&quot;]; overflow; &quot;</span></div>
<div class="line"><a id="l05930" name="l05930"></a><span class="lineno"> 5930</span>                       <span class="stringliteral">&quot;using max value [&quot;</span> &lt;&lt; MAX_DELAY_VALUE &lt;&lt; <span class="stringliteral">&quot;] units.&quot;</span>);</div>
<div class="line"><a id="l05931" name="l05931"></a><span class="lineno"> 5931</span>      <span class="comment">// @todo Maybe there&#39;s a more sane ceiling value than the absolute maximum?</span></div>
<div class="line"><a id="l05932" name="l05932"></a><span class="lineno"> 5932</span>      pkt_delay = <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#abd3bc7f9e9195bf1b4aca2cad881646c">Ack_packet::Ack_delay_time_unit</a>(MAX_DELAY_VALUE);</div>
<div class="line"><a id="l05933" name="l05933"></a><span class="lineno"> 5933</span>    }</div>
<div class="line"><a id="l05934" name="l05934"></a><span class="lineno"> 5934</span> </div>
<div class="line"><a id="l05935" name="l05935"></a><span class="lineno"> 5935</span>    <span class="comment">// Finally write the individual acknowledgment.</span></div>
<div class="line"><a id="l05936" name="l05936"></a><span class="lineno"> 5936</span>    <span class="keywordflow">if</span> (sock-&gt;rexmit_on())</div>
<div class="line"><a id="l05937" name="l05937"></a><span class="lineno"> 5937</span>    {</div>
<div class="line"><a id="l05938" name="l05938"></a><span class="lineno"> 5938</span>      ack-&gt;m_rcv_acked_packets_rexmit_on_out.push_back</div>
<div class="line"><a id="l05939" name="l05939"></a><span class="lineno"> 5939</span>        (<a class="code hl_struct" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__on.html">Ack_packet::Individual_ack_rexmit_on</a>(seq_num,</div>
<div class="line"><a id="l05940" name="l05940"></a><span class="lineno"> 5940</span>                                              ind_ack-&gt;m_rexmit_id,</div>
<div class="line"><a id="l05941" name="l05941"></a><span class="lineno"> 5941</span>                                              <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#a374da5eef60c7d8a4085b41cf7b2adfe">Ack_packet::ack_delay_t</a>(pkt_delay.count())));</div>
<div class="line"><a id="l05942" name="l05942"></a><span class="lineno"> 5942</span>    }</div>
<div class="line"><a id="l05943" name="l05943"></a><span class="lineno"> 5943</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l05944" name="l05944"></a><span class="lineno"> 5944</span>    {</div>
<div class="line"><a id="l05945" name="l05945"></a><span class="lineno"> 5945</span>      ack-&gt;m_rcv_acked_packets_rexmit_off_out.push_back</div>
<div class="line"><a id="l05946" name="l05946"></a><span class="lineno"> 5946</span>        (<a class="code hl_struct" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__off.html">Ack_packet::Individual_ack_rexmit_off</a>(seq_num,</div>
<div class="line"><a id="l05947" name="l05947"></a><span class="lineno"> 5947</span>                                               <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet.html#a374da5eef60c7d8a4085b41cf7b2adfe">Ack_packet::ack_delay_t</a>(pkt_delay.count())));</div>
<div class="line"><a id="l05948" name="l05948"></a><span class="lineno"> 5948</span>    }</div>
<div class="line"><a id="l05949" name="l05949"></a><span class="lineno"> 5949</span>    size_est_so_far += size_est_inc;</div>
<div class="line"><a id="l05950" name="l05950"></a><span class="lineno"> 5950</span> </div>
<div class="line"><a id="l05951" name="l05951"></a><span class="lineno"> 5951</span>    <span class="comment">// Register one packet of unknown size that we&#39;ve packaged into an ACK and will send ASAP.</span></div>
<div class="line"><a id="l05952" name="l05952"></a><span class="lineno"> 5952</span>    sock-&gt;m_rcv_stats.sent_individual_ack();</div>
<div class="line"><a id="l05953" name="l05953"></a><span class="lineno"> 5953</span>  } <span class="comment">// for (ind_ack : pending_acks)</span></div>
<div class="line"><a id="l05954" name="l05954"></a><span class="lineno"> 5954</span> </div>
<div class="line"><a id="l05955" name="l05955"></a><span class="lineno"> 5955</span>  <span class="comment">// Don&#39;t forget the last non-full ACK, if any.</span></div>
<div class="line"><a id="l05956" name="l05956"></a><span class="lineno"> 5956</span>  <span class="keywordflow">if</span> (size_est_so_far != 0)</div>
<div class="line"><a id="l05957" name="l05957"></a><span class="lineno"> 5957</span>  {</div>
<div class="line"><a id="l05958" name="l05958"></a><span class="lineno"> 5958</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">async_sock_low_lvl_packet_send_paced</a>(sock, <a class="code hl_function" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">Low_lvl_packet::ptr_cast</a>(ack));</div>
<div class="line"><a id="l05959" name="l05959"></a><span class="lineno"> 5959</span>  }</div>
<div class="line"><a id="l05960" name="l05960"></a><span class="lineno"> 5960</span> </div>
<div class="line"><a id="l05961" name="l05961"></a><span class="lineno"> 5961</span>  <span class="comment">// Register one ACK packet we will send ASAP.</span></div>
<div class="line"><a id="l05962" name="l05962"></a><span class="lineno"> 5962</span>  sock-&gt;m_rcv_stats.sent_low_lvl_ack_packet(<span class="keyword">false</span>);</div>
<div class="line"><a id="l05963" name="l05963"></a><span class="lineno"> 5963</span> </div>
<div class="line"><a id="l05964" name="l05964"></a><span class="lineno"> 5964</span>  <span class="comment">// All serialized to be sent; the timer can start again when a packet must be acknowledged.</span></div>
<div class="line"><a id="l05965" name="l05965"></a><span class="lineno"> 5965</span>  pending_acks.clear();</div>
<div class="line"><a id="l05966" name="l05966"></a><span class="lineno"> 5966</span> </div>
<div class="line"><a id="l05967" name="l05967"></a><span class="lineno"> 5967</span>  <span class="comment">// Register that now there are 0 pending individual acks.</span></div>
<div class="line"><a id="l05968" name="l05968"></a><span class="lineno"> 5968</span>  sock-&gt;m_rcv_stats.current_pending_to_ack_packets(0);</div>
<div class="line"><a id="l05969" name="l05969"></a><span class="lineno"> 5969</span> </div>
<div class="line"><a id="l05970" name="l05970"></a><span class="lineno"> 5970</span>  <span class="comment">// Note that all the ACKs are sent off outside this handler and only once UDP is ready.</span></div>
<div class="line"><a id="l05971" name="l05971"></a><span class="lineno"> 5971</span>} <span class="comment">// Node::async_low_lvl_ack_send()</span></div>
<div class="line"><a id="l05972" name="l05972"></a><span class="lineno"> 5972</span> </div>
<div class="line"><a id="l05973" name="l05973"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97"> 5973</a></span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">Node::socket_id</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="comment">// Static.</span></div>
<div class="line"><a id="l05974" name="l05974"></a><span class="lineno"> 5974</span>{</div>
<div class="line"><a id="l05975" name="l05975"></a><span class="lineno"> 5975</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l05976" name="l05976"></a><span class="lineno"> 5976</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>{ sock-&gt;remote_endpoint(), sock-&gt;local_port() };</div>
<div class="line"><a id="l05977" name="l05977"></a><span class="lineno"> 5977</span>}</div>
<div class="line"><a id="l05978" name="l05978"></a><span class="lineno"> 5978</span> </div>
<div class="line"><a id="l05979" name="l05979"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7"> 5979</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">Node::snd_deqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l05980" name="l05980"></a><span class="lineno"> 5980</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05981" name="l05981"></a><span class="lineno"> 5981</span>  <span class="comment">// There is stuff to send if there is anything to retransmit or at least new user data.</span></div>
<div class="line"><a id="l05982" name="l05982"></a><span class="lineno"> 5982</span>  <span class="keywordflow">return</span> !(sock-&gt;m_snd_rexmit_q.empty() &amp;&amp; sock-&gt;m_snd_buf.empty());</div>
<div class="line"><a id="l05983" name="l05983"></a><span class="lineno"> 5983</span>}</div>
<div class="line"><a id="l05984" name="l05984"></a><span class="lineno"> 5984</span> </div>
<div class="line"><a id="l05985" name="l05985"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137"> 5985</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">Node::snd_buf_enqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l05986" name="l05986"></a><span class="lineno"> 5986</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05987" name="l05987"></a><span class="lineno"> 5987</span>  <span class="comment">// See doc comment for rationale for keeping this in a function.</span></div>
<div class="line"><a id="l05988" name="l05988"></a><span class="lineno"> 5988</span> </div>
<div class="line"><a id="l05989" name="l05989"></a><span class="lineno"> 5989</span>  <span class="comment">/* Since 1 block can be at most max-block-size, if that much space is free, then definitely one</span></div>
<div class="line"><a id="l05990" name="l05990"></a><span class="lineno"> 5990</span><span class="comment">   * can enqueue onto m_snd_buf.  Note that if less than max-block-size space is free, it would</span></div>
<div class="line"><a id="l05991" name="l05991"></a><span class="lineno"> 5991</span><span class="comment">   * still be possible to enqueue a smaller block; yet we still return false.  We are intentionally</span></div>
<div class="line"><a id="l05992" name="l05992"></a><span class="lineno"> 5992</span><span class="comment">   * conservative, because we are guaranteeing ANY one enqueueing will work.  More importantly, this</span></div>
<div class="line"><a id="l05993" name="l05993"></a><span class="lineno"> 5993</span><span class="comment">   * guarantees our Socket_buffer scheme (see class doc header) to guarantee constant-time</span></div>
<div class="line"><a id="l05994" name="l05994"></a><span class="lineno"> 5994</span><span class="comment">   * dequeueing will work.</span></div>
<div class="line"><a id="l05995" name="l05995"></a><span class="lineno"> 5995</span><span class="comment">   *</span></div>
<div class="line"><a id="l05996" name="l05996"></a><span class="lineno"> 5996</span><span class="comment">   * We&#39;re not overly conservative, either; i.e., no one is likely to complain this policy is too</span></div>
<div class="line"><a id="l05997" name="l05997"></a><span class="lineno"> 5997</span><span class="comment">   * stingy. */</span></div>
<div class="line"><a id="l05998" name="l05998"></a><span class="lineno"> 5998</span>  <span class="keywordflow">return</span> sock-&gt;m_snd_buf.data_size() + sock-&gt;max_block_size()</div>
<div class="line"><a id="l05999" name="l05999"></a><span class="lineno"> 5999</span>           &lt;= sock-&gt;opt(sock-&gt;m_opts.m_st_snd_buf_max_size);</div>
<div class="line"><a id="l06000" name="l06000"></a><span class="lineno"> 6000</span>}</div>
<div class="line"><a id="l06001" name="l06001"></a><span class="lineno"> 6001</span> </div>
<div class="line"><a id="l06002" name="l06002"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b"> 6002</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">Node::rcv_buf_deqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l06003" name="l06003"></a><span class="lineno"> 6003</span><span class="keyword"></span>{</div>
<div class="line"><a id="l06004" name="l06004"></a><span class="lineno"> 6004</span>  <span class="comment">// See doc comment for rationale for keeping this in a function.</span></div>
<div class="line"><a id="l06005" name="l06005"></a><span class="lineno"> 6005</span>  <span class="keywordflow">return</span> !sock-&gt;m_rcv_buf.empty();</div>
<div class="line"><a id="l06006" name="l06006"></a><span class="lineno"> 6006</span>}</div>
<div class="line"><a id="l06007" name="l06007"></a><span class="lineno"> 6007</span> </div>
<div class="line"><a id="l06008" name="l06008"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe"> 6008</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">Node::sock_set_int_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a> new_state)</div>
<div class="line"><a id="l06009" name="l06009"></a><span class="lineno"> 6009</span>{</div>
<div class="line"><a id="l06010" name="l06010"></a><span class="lineno"> 6010</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l06011" name="l06011"></a><span class="lineno"> 6011</span> </div>
<div class="line"><a id="l06012" name="l06012"></a><span class="lineno"> 6012</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="charliteral">&#39;[&#39;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] changing state from [&quot;</span> &lt;&lt;</div>
<div class="line"><a id="l06013" name="l06013"></a><span class="lineno"> 6013</span>                 sock-&gt;m_int_state &lt;&lt; <span class="stringliteral">&quot;] to [&quot;</span> &lt;&lt; new_state &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l06014" name="l06014"></a><span class="lineno"> 6014</span>  sock-&gt;m_int_state = new_state;</div>
<div class="line"><a id="l06015" name="l06015"></a><span class="lineno"> 6015</span>}</div>
<div class="line"><a id="l06016" name="l06016"></a><span class="lineno"> 6016</span> </div>
<div class="line"><a id="l06017" name="l06017"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280"> 6017</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">Node::sock_set_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> state, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Peer_socket::Open_sub_state</a> open_sub_state)</div>
<div class="line"><a id="l06018" name="l06018"></a><span class="lineno"> 6018</span>{</div>
<div class="line"><a id="l06019" name="l06019"></a><span class="lineno"> 6019</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l06020" name="l06020"></a><span class="lineno"> 6020</span> </div>
<div class="line"><a id="l06021" name="l06021"></a><span class="lineno"> 6021</span>  <span class="comment">// @todo Add TRACE logging.</span></div>
<div class="line"><a id="l06022" name="l06022"></a><span class="lineno"> 6022</span> </div>
<div class="line"><a id="l06023" name="l06023"></a><span class="lineno"> 6023</span>  sock-&gt;m_state = state;</div>
<div class="line"><a id="l06024" name="l06024"></a><span class="lineno"> 6024</span>  <span class="keywordflow">if</span> (state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>)</div>
<div class="line"><a id="l06025" name="l06025"></a><span class="lineno"> 6025</span>  {</div>
<div class="line"><a id="l06026" name="l06026"></a><span class="lineno"> 6026</span>    sock-&gt;m_open_sub_state = open_sub_state;</div>
<div class="line"><a id="l06027" name="l06027"></a><span class="lineno"> 6027</span>  }</div>
<div class="line"><a id="l06028" name="l06028"></a><span class="lineno"> 6028</span>  <span class="keywordflow">else</span> <span class="comment">// (state == Peer_socket::State::S_CLOSED)</span></div>
<div class="line"><a id="l06029" name="l06029"></a><span class="lineno"> 6029</span>  {</div>
<div class="line"><a id="l06030" name="l06030"></a><span class="lineno"> 6030</span>    <span class="comment">/* Important convention: S_CLOSED means socket is permanently incapable of sending or</span></div>
<div class="line"><a id="l06031" name="l06031"></a><span class="lineno"> 6031</span><span class="comment">     * receiving more data.  At this point the originating Node removes the socket from its internal</span></div>
<div class="line"><a id="l06032" name="l06032"></a><span class="lineno"> 6032</span><span class="comment">     * structures.  Therefore, the Node itself may even go away -- while this Peer_socket still</span></div>
<div class="line"><a id="l06033" name="l06033"></a><span class="lineno"> 6033</span><span class="comment">     * exists.  Since we use shared_ptr when giving our socket objects, that&#39;s fine -- but we want to</span></div>
<div class="line"><a id="l06034" name="l06034"></a><span class="lineno"> 6034</span><span class="comment">     * avoid returning an invalid Node* in node().  So, when S_CLOSED, sock-&gt;m_node = 0. */</span></div>
<div class="line"><a id="l06035" name="l06035"></a><span class="lineno"> 6035</span>    sock-&gt;m_node = 0;</div>
<div class="line"><a id="l06036" name="l06036"></a><span class="lineno"> 6036</span>  }</div>
<div class="line"><a id="l06037" name="l06037"></a><span class="lineno"> 6037</span>}</div>
<div class="line"><a id="l06038" name="l06038"></a><span class="lineno"> 6038</span> </div>
<div class="line"><a id="l06039" name="l06039"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471"> 6039</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">Node::sock_disconnect_detected</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; disconnect_cause, <span class="keywordtype">bool</span> close)</div>
<div class="line"><a id="l06040" name="l06040"></a><span class="lineno"> 6040</span>{</div>
<div class="line"><a id="l06041" name="l06041"></a><span class="lineno"> 6041</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l06042" name="l06042"></a><span class="lineno"> 6042</span> </div>
<div class="line"><a id="l06043" name="l06043"></a><span class="lineno"> 6043</span>  sock-&gt;m_disconnect_cause = disconnect_cause;</div>
<div class="line"><a id="l06044" name="l06044"></a><span class="lineno"> 6044</span> </div>
<div class="line"><a id="l06045" name="l06045"></a><span class="lineno"> 6045</span>  <span class="keywordflow">if</span> (close)</div>
<div class="line"><a id="l06046" name="l06046"></a><span class="lineno"> 6046</span>  {</div>
<div class="line"><a id="l06047" name="l06047"></a><span class="lineno"> 6047</span>    <span class="comment">// DONE.</span></div>
<div class="line"><a id="l06048" name="l06048"></a><span class="lineno"> 6048</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">sock_set_state</a>(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>); <span class="comment">// Reentrant mutex =&gt; OK.</span></div>
<div class="line"><a id="l06049" name="l06049"></a><span class="lineno"> 6049</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">sock_free_memory</a>(sock);</div>
<div class="line"><a id="l06050" name="l06050"></a><span class="lineno"> 6050</span>  }</div>
<div class="line"><a id="l06051" name="l06051"></a><span class="lineno"> 6051</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l06052" name="l06052"></a><span class="lineno"> 6052</span>  {</div>
<div class="line"><a id="l06053" name="l06053"></a><span class="lineno"> 6053</span>    <span class="comment">// This socket is screwed, but let user get any remaining buffer data out.</span></div>
<div class="line"><a id="l06054" name="l06054"></a><span class="lineno"> 6054</span> </div>
<div class="line"><a id="l06055" name="l06055"></a><span class="lineno"> 6055</span>    <span class="comment">// Reentrant mutex =&gt; OK:</span></div>
<div class="line"><a id="l06056" name="l06056"></a><span class="lineno"> 6056</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">sock_set_state</a>(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>);</div>
<div class="line"><a id="l06057" name="l06057"></a><span class="lineno"> 6057</span>  }</div>
<div class="line"><a id="l06058" name="l06058"></a><span class="lineno"> 6058</span>}</div>
<div class="line"><a id="l06059" name="l06059"></a><span class="lineno"> 6059</span> </div>
<div class="line"><a id="l06060" name="l06060"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb"> 6060</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">Node::sock_disconnect_completed</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l06061" name="l06061"></a><span class="lineno"> 6061</span>{</div>
<div class="line"><a id="l06062" name="l06062"></a><span class="lineno"> 6062</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l06063" name="l06063"></a><span class="lineno"> 6063</span> </div>
<div class="line"><a id="l06064" name="l06064"></a><span class="lineno"> 6064</span>  <span class="comment">// Sanity-check pre-conditions.  (Basically ensure disconnect_detected(err_code, false) was previously called.)</span></div>
<div class="line"><a id="l06065" name="l06065"></a><span class="lineno"> 6065</span>  assert(sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l06066" name="l06066"></a><span class="lineno"> 6066</span>  assert((sock-&gt;m_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">Peer_socket::State::S_OPEN</a>)</div>
<div class="line"><a id="l06067" name="l06067"></a><span class="lineno"> 6067</span>         &amp;&amp; (sock-&gt;m_open_sub_state == <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">Peer_socket::Open_sub_state::S_DISCONNECTING</a>));</div>
<div class="line"><a id="l06068" name="l06068"></a><span class="lineno"> 6068</span> </div>
<div class="line"><a id="l06069" name="l06069"></a><span class="lineno"> 6069</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">sock_set_state</a>(sock, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">Peer_socket::State::S_CLOSED</a>); <span class="comment">// Reentrant mutex =&gt; OK.</span></div>
<div class="line"><a id="l06070" name="l06070"></a><span class="lineno"> 6070</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">sock_free_memory</a>(sock);</div>
<div class="line"><a id="l06071" name="l06071"></a><span class="lineno"> 6071</span>}</div>
<div class="line"><a id="l06072" name="l06072"></a><span class="lineno"> 6072</span> </div>
<div class="line"><a id="l06073" name="l06073"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515"> 6073</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">Node::sock_free_memory</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</div>
<div class="line"><a id="l06074" name="l06074"></a><span class="lineno"> 6074</span>{</div>
<div class="line"><a id="l06075" name="l06075"></a><span class="lineno"> 6075</span>  sock-&gt;m_rcv_buf.clear();</div>
<div class="line"><a id="l06076" name="l06076"></a><span class="lineno"> 6076</span>  sock-&gt;m_snd_buf.clear();</div>
<div class="line"><a id="l06077" name="l06077"></a><span class="lineno"> 6077</span>  sock-&gt;m_rcv_packets_with_gaps.clear();</div>
<div class="line"><a id="l06078" name="l06078"></a><span class="lineno"> 6078</span>  sock-&gt;m_rcv_reassembly_q_data_size = 0;</div>
<div class="line"><a id="l06079" name="l06079"></a><span class="lineno"> 6079</span>  sock-&gt;m_snd_flying_pkts_by_sent_when.clear();</div>
<div class="line"><a id="l06080" name="l06080"></a><span class="lineno"> 6080</span>  sock-&gt;m_snd_flying_pkts_by_seq_num.clear();</div>
<div class="line"><a id="l06081" name="l06081"></a><span class="lineno"> 6081</span>  sock-&gt;m_snd_rexmit_q.clear();</div>
<div class="line"><a id="l06082" name="l06082"></a><span class="lineno"> 6082</span>  sock-&gt;m_serialized_metadata.make_zero(); <span class="comment">// clear() does not deallocate, but this does.</span></div>
<div class="line"><a id="l06083" name="l06083"></a><span class="lineno"> 6083</span>  sock-&gt;m_rcv_syn_rcvd_data_q.clear();</div>
<div class="line"><a id="l06084" name="l06084"></a><span class="lineno"> 6084</span>  sock-&gt;m_rcv_pending_acks.clear();</div>
<div class="line"><a id="l06085" name="l06085"></a><span class="lineno"> 6085</span>  sock-&gt;m_rcv_acked_packets.clear();</div>
<div class="line"><a id="l06086" name="l06086"></a><span class="lineno"> 6086</span>  sock-&gt;m_snd_pacing_data.m_packet_q.clear();</div>
<div class="line"><a id="l06087" name="l06087"></a><span class="lineno"> 6087</span> </div>
<div class="line"><a id="l06088" name="l06088"></a><span class="lineno"> 6088</span>  <span class="comment">/* Destroy memory stored in m_snd_cong_ctl which may be non-O(1).  This is a little questionable;</span></div>
<div class="line"><a id="l06089" name="l06089"></a><span class="lineno"> 6089</span><span class="comment">   * maybe should leave it to destructor?  However since we store it as a pointer and are to free</span></div>
<div class="line"><a id="l06090" name="l06090"></a><span class="lineno"> 6090</span><span class="comment">   * any &quot;significant&quot; memory, and this may be significant, we may as well just delete it. */</span></div>
<div class="line"><a id="l06091" name="l06091"></a><span class="lineno"> 6091</span>  sock-&gt;m_snd_cong_ctl.reset();</div>
<div class="line"><a id="l06092" name="l06092"></a><span class="lineno"> 6092</span>  <span class="comment">// Same deal.</span></div>
<div class="line"><a id="l06093" name="l06093"></a><span class="lineno"> 6093</span>  sock-&gt;m_snd_bandwidth_estimator.reset();</div>
<div class="line"><a id="l06094" name="l06094"></a><span class="lineno"> 6094</span>}</div>
<div class="line"><a id="l06095" name="l06095"></a><span class="lineno"> 6095</span> </div>
<div class="line"><a id="l06096" name="l06096"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb"> 6096</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">Node::sock_set_options</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l06097" name="l06097"></a><span class="lineno"> 6097</span>{</div>
<div class="line"><a id="l06098" name="l06098"></a><span class="lineno"> 6098</span>  <span class="comment">// We are in thread U != W.</span></div>
<div class="line"><a id="l06099" name="l06099"></a><span class="lineno"> 6099</span> </div>
<div class="line"><a id="l06100" name="l06100"></a><span class="lineno"> 6100</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l06101" name="l06101"></a><span class="lineno"> 6101</span>  {</div>
<div class="line"><a id="l06102" name="l06102"></a><span class="lineno"> 6102</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l06103" name="l06103"></a><span class="lineno"> 6103</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l06104" name="l06104"></a><span class="lineno"> 6104</span>  }</div>
<div class="line"><a id="l06105" name="l06105"></a><span class="lineno"> 6105</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l06106" name="l06106"></a><span class="lineno"> 6106</span> </div>
<div class="line"><a id="l06107" name="l06107"></a><span class="lineno"> 6107</span>  <span class="comment">/* We just want to replace m_opts with a copy of opts.  First validate opts (including with</span></div>
<div class="line"><a id="l06108" name="l06108"></a><span class="lineno"> 6108</span><span class="comment">   * respect to m_opts, and also check for invalid values and such), then copy it over. */</span></div>
<div class="line"><a id="l06109" name="l06109"></a><span class="lineno"> 6109</span> </div>
<div class="line"><a id="l06110" name="l06110"></a><span class="lineno"> 6110</span>  <span class="comment">// Log new options values.  A bit computationally expensive so just use TRACE for now.  @todo Reconsider?</span></div>
<div class="line"><a id="l06111" name="l06111"></a><span class="lineno"> 6111</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;For [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]:\n\n&quot;</span> &lt;&lt; opts);</div>
<div class="line"><a id="l06112" name="l06112"></a><span class="lineno"> 6112</span> </div>
<div class="line"><a id="l06113" name="l06113"></a><span class="lineno"> 6113</span>  <span class="comment">// Will be writing sock-&gt;m_opts if all goes well, so must acquire exclusive ownership of m_opts.</span></div>
<div class="line"><a id="l06114" name="l06114"></a><span class="lineno"> 6114</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Peer_socket::Options_lock</a> lock(sock-&gt;m_opts_mutex);</div>
<div class="line"><a id="l06115" name="l06115"></a><span class="lineno"> 6115</span> </div>
<div class="line"><a id="l06116" name="l06116"></a><span class="lineno"> 6116</span>  <span class="comment">/* Validate the new option set (including ensuring they&#39;re not changing static options&#39; values).</span></div>
<div class="line"><a id="l06117" name="l06117"></a><span class="lineno"> 6117</span><span class="comment">   * Note that an explicit pre-condition of this method is that m_opts_mutex is locked if needed,</span></div>
<div class="line"><a id="l06118" name="l06118"></a><span class="lineno"> 6118</span><span class="comment">   * hence the above locking statement is not below this call. */</span></div>
<div class="line"><a id="l06119" name="l06119"></a><span class="lineno"> 6119</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">sock_validate_options</a>(opts, &amp;sock-&gt;m_opts, err_code))</div>
<div class="line"><a id="l06120" name="l06120"></a><span class="lineno"> 6120</span>  {</div>
<div class="line"><a id="l06121" name="l06121"></a><span class="lineno"> 6121</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l06122" name="l06122"></a><span class="lineno"> 6122</span>  }</div>
<div class="line"><a id="l06123" name="l06123"></a><span class="lineno"> 6123</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l06124" name="l06124"></a><span class="lineno"> 6124</span> </div>
<div class="line"><a id="l06125" name="l06125"></a><span class="lineno"> 6125</span>  <span class="comment">// Boo-ya.</span></div>
<div class="line"><a id="l06126" name="l06126"></a><span class="lineno"> 6126</span>  sock-&gt;m_opts = opts;</div>
<div class="line"><a id="l06127" name="l06127"></a><span class="lineno"> 6127</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l06128" name="l06128"></a><span class="lineno"> 6128</span>} <span class="comment">// Node::sock_set_options()</span></div>
<div class="line"><a id="l06129" name="l06129"></a><span class="lineno"> 6129</span><span class="comment"></span> </div>
<div class="line"><a id="l06130" name="l06130"></a><span class="lineno"> 6130</span><span class="comment">/// @cond</span></div>
<div class="line"><a id="l06131" name="l06131"></a><span class="lineno"> 6131</span><span class="comment"></span><span class="comment">/* -^- Doxygen, please ignore the following.  (Don&#39;t want docs generated for temp macro; this is more maintainable</span></div>
<div class="line"><a id="l06132" name="l06132"></a><span class="lineno"> 6132</span><span class="comment"> * than specifying the macro name to omit it, in Doxygen-config EXCLUDE_SYMBOLS.) */</span></div>
<div class="line"><a id="l06133" name="l06133"></a><span class="lineno"> 6133</span> </div>
<div class="line"><a id="l06134" name="l06134"></a><span class="lineno"> 6134</span><span class="comment">/* Normaly I try to avoid macro cleverness, but in this case to get a nice printout we need the</span></div>
<div class="line"><a id="l06135" name="l06135"></a><span class="lineno"> 6135</span><span class="comment"> * # technique, and also this eliminates quite a bit of repetition.  So let&#39;s.... */</span></div>
<div class="line"><a id="l06136" name="l06136"></a><span class="lineno"> 6136</span><span class="preprocessor">#define VALIDATE_STATIC_OPTION(ARG_opt) \</span></div>
<div class="line"><a id="l06137" name="l06137"></a><span class="lineno"> 6137</span><span class="preprocessor">  validate_static_option(opts.ARG_opt, prev_opts-&gt;ARG_opt, #ARG_opt, err_code)</span></div>
<div class="line"><a id="l06138" name="l06138"></a><span class="lineno"> 6138</span><span class="preprocessor">#define VALIDATE_CHECK(ARG_check) \</span></div>
<div class="line"><a id="l06139" name="l06139"></a><span class="lineno"> 6139</span><span class="preprocessor">  validate_option_check(ARG_check, #ARG_check, err_code)</span></div>
<div class="line"><a id="l06140" name="l06140"></a><span class="lineno"> 6140</span> </div>
<div class="line"><a id="l06141" name="l06141"></a><span class="lineno"> 6141</span><span class="comment">// -v- Doxygen, please stop ignoring.</span><span class="comment"></span></div>
<div class="line"><a id="l06142" name="l06142"></a><span class="lineno"> 6142</span><span class="comment">/// @endcond</span></div>
<div class="line"><a id="l06143" name="l06143"></a><span class="lineno"> 6143</span><span class="comment"></span> </div>
<div class="line"><a id="l06144" name="l06144"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276"> 6144</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">Node::sock_validate_options</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts,</div>
<div class="line"><a id="l06145" name="l06145"></a><span class="lineno"> 6145</span>                                 <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* prev_opts,</div>
<div class="line"><a id="l06146" name="l06146"></a><span class="lineno"> 6146</span>                                 <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)<span class="keyword"> const</span></div>
<div class="line"><a id="l06147" name="l06147"></a><span class="lineno"> 6147</span><span class="keyword"></span>{</div>
<div class="line"><a id="l06148" name="l06148"></a><span class="lineno"> 6148</span>  <span class="comment">/* We are to validate the given set of per-socket option values.  If prev_opts, then the context</span></div>
<div class="line"><a id="l06149" name="l06149"></a><span class="lineno"> 6149</span><span class="comment">   * is that an already-existing socket (with already-set options) is being called with</span></div>
<div class="line"><a id="l06150" name="l06150"></a><span class="lineno"> 6150</span><span class="comment">   * set_options(), i.e. user is modifying options for an existing socket.  In that case we must</span></div>
<div class="line"><a id="l06151" name="l06151"></a><span class="lineno"> 6151</span><span class="comment">   * ensure that no static (unchangeable) option&#39;s value would be changed by this.</span></div>
<div class="line"><a id="l06152" name="l06152"></a><span class="lineno"> 6152</span><span class="comment">   *</span></div>
<div class="line"><a id="l06153" name="l06153"></a><span class="lineno"> 6153</span><span class="comment">   * If not prev_opts, then the per-socket options within the global per-Node Node_options object</span></div>
<div class="line"><a id="l06154" name="l06154"></a><span class="lineno"> 6154</span><span class="comment">   * are being changed.  Per-socket options in that context are always dynamic, since if they were</span></div>
<div class="line"><a id="l06155" name="l06155"></a><span class="lineno"> 6155</span><span class="comment">   * static, there&#39;d be no point in making the per-socket in the first place.  So in that case that</span></div>
<div class="line"><a id="l06156" name="l06156"></a><span class="lineno"> 6156</span><span class="comment">   * static option check is to be skipped.</span></div>
<div class="line"><a id="l06157" name="l06157"></a><span class="lineno"> 6157</span><span class="comment">   *</span></div>
<div class="line"><a id="l06158" name="l06158"></a><span class="lineno"> 6158</span><span class="comment">   * Finally, we must check for individual integrity of the specified values (including consistency</span></div>
<div class="line"><a id="l06159" name="l06159"></a><span class="lineno"> 6159</span><span class="comment">   * with other option values). */</span></div>
<div class="line"><a id="l06160" name="l06160"></a><span class="lineno"> 6160</span> </div>
<div class="line"><a id="l06161" name="l06161"></a><span class="lineno"> 6161</span>  <span class="keyword">using </span>boost::chrono::seconds;</div>
<div class="line"><a id="l06162" name="l06162"></a><span class="lineno"> 6162</span>  <span class="keyword">using </span>std::numeric_limits;</div>
<div class="line"><a id="l06163" name="l06163"></a><span class="lineno"> 6163</span> </div>
<div class="line"><a id="l06164" name="l06164"></a><span class="lineno"> 6164</span>  <span class="comment">// We are in thread U != W or in thread W.</span></div>
<div class="line"><a id="l06165" name="l06165"></a><span class="lineno"> 6165</span> </div>
<div class="line"><a id="l06166" name="l06166"></a><span class="lineno"> 6166</span>  <span class="keywordflow">if</span> (prev_opts)</div>
<div class="line"><a id="l06167" name="l06167"></a><span class="lineno"> 6167</span>  {</div>
<div class="line"><a id="l06168" name="l06168"></a><span class="lineno"> 6168</span>    <span class="comment">/* As explained above, they&#39;re trying to change an existing socket&#39;s option values.  Ensure</span></div>
<div class="line"><a id="l06169" name="l06169"></a><span class="lineno"> 6169</span><span class="comment">     * all the static options&#39; values are the same in opts and prev_opts. */</span></div>
<div class="line"><a id="l06170" name="l06170"></a><span class="lineno"> 6170</span> </div>
<div class="line"><a id="l06171" name="l06171"></a><span class="lineno"> 6171</span>    <span class="comment">// Explicitly documented pre-condition is that *prev_opts is already locked if necessary.  So don&#39;t lock.</span></div>
<div class="line"><a id="l06172" name="l06172"></a><span class="lineno"> 6172</span> </div>
<div class="line"><a id="l06173" name="l06173"></a><span class="lineno"> 6173</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> static_ok</div>
<div class="line"><a id="l06174" name="l06174"></a><span class="lineno"> 6174</span>      = VALIDATE_STATIC_OPTION(m_st_max_block_size) &amp;&amp;</div>
<div class="line"><a id="l06175" name="l06175"></a><span class="lineno"> 6175</span>        VALIDATE_STATIC_OPTION(m_st_connect_retransmit_period) &amp;&amp;</div>
<div class="line"><a id="l06176" name="l06176"></a><span class="lineno"> 6176</span>        VALIDATE_STATIC_OPTION(m_st_connect_retransmit_timeout) &amp;&amp;</div>
<div class="line"><a id="l06177" name="l06177"></a><span class="lineno"> 6177</span>        VALIDATE_STATIC_OPTION(m_st_snd_buf_max_size) &amp;&amp;</div>
<div class="line"><a id="l06178" name="l06178"></a><span class="lineno"> 6178</span>        VALIDATE_STATIC_OPTION(m_st_rcv_buf_max_size) &amp;&amp;</div>
<div class="line"><a id="l06179" name="l06179"></a><span class="lineno"> 6179</span>        VALIDATE_STATIC_OPTION(m_st_rcv_flow_control_on) &amp;&amp;</div>
<div class="line"><a id="l06180" name="l06180"></a><span class="lineno"> 6180</span>        VALIDATE_STATIC_OPTION(m_st_rcv_buf_max_size_slack_percent) &amp;&amp;</div>
<div class="line"><a id="l06181" name="l06181"></a><span class="lineno"> 6181</span>        VALIDATE_STATIC_OPTION(m_st_rcv_buf_max_size_to_advertise_percent) &amp;&amp;</div>
<div class="line"><a id="l06182" name="l06182"></a><span class="lineno"> 6182</span>        VALIDATE_STATIC_OPTION(m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent) &amp;&amp;</div>
<div class="line"><a id="l06183" name="l06183"></a><span class="lineno"> 6183</span>        VALIDATE_STATIC_OPTION(m_st_delayed_ack_timer_period) &amp;&amp;</div>
<div class="line"><a id="l06184" name="l06184"></a><span class="lineno"> 6184</span>        VALIDATE_STATIC_OPTION(m_st_max_full_blocks_before_ack_send) &amp;&amp;</div>
<div class="line"><a id="l06185" name="l06185"></a><span class="lineno"> 6185</span>        VALIDATE_STATIC_OPTION(m_st_rexmit_on) &amp;&amp;</div>
<div class="line"><a id="l06186" name="l06186"></a><span class="lineno"> 6186</span>        VALIDATE_STATIC_OPTION(m_st_max_rexmissions_per_packet) &amp;&amp;</div>
<div class="line"><a id="l06187" name="l06187"></a><span class="lineno"> 6187</span>        VALIDATE_STATIC_OPTION(m_st_init_drop_timeout) &amp;&amp;</div>
<div class="line"><a id="l06188" name="l06188"></a><span class="lineno"> 6188</span>        VALIDATE_STATIC_OPTION(m_st_snd_pacing_enabled) &amp;&amp;</div>
<div class="line"><a id="l06189" name="l06189"></a><span class="lineno"> 6189</span>        VALIDATE_STATIC_OPTION(m_st_snd_bandwidth_est_sample_period_floor) &amp;&amp;</div>
<div class="line"><a id="l06190" name="l06190"></a><span class="lineno"> 6190</span>        VALIDATE_STATIC_OPTION(m_st_cong_ctl_strategy) &amp;&amp;</div>
<div class="line"><a id="l06191" name="l06191"></a><span class="lineno"> 6191</span>        VALIDATE_STATIC_OPTION(m_st_cong_ctl_init_cong_wnd_blocks) &amp;&amp;</div>
<div class="line"><a id="l06192" name="l06192"></a><span class="lineno"> 6192</span>        VALIDATE_STATIC_OPTION(m_st_cong_ctl_max_cong_wnd_blocks) &amp;&amp;</div>
<div class="line"><a id="l06193" name="l06193"></a><span class="lineno"> 6193</span>        VALIDATE_STATIC_OPTION(m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks) &amp;&amp;</div>
<div class="line"><a id="l06194" name="l06194"></a><span class="lineno"> 6194</span>        VALIDATE_STATIC_OPTION(m_st_cong_ctl_classic_wnd_decay_percent) &amp;&amp;</div>
<div class="line"><a id="l06195" name="l06195"></a><span class="lineno"> 6195</span>        VALIDATE_STATIC_OPTION(m_st_drop_packet_exactly_after_drop_timeout) &amp;&amp;</div>
<div class="line"><a id="l06196" name="l06196"></a><span class="lineno"> 6196</span>        VALIDATE_STATIC_OPTION(m_st_drop_all_on_drop_timeout) &amp;&amp;</div>
<div class="line"><a id="l06197" name="l06197"></a><span class="lineno"> 6197</span>        VALIDATE_STATIC_OPTION(m_st_out_of_order_ack_restarts_drop_timer);</div>
<div class="line"><a id="l06198" name="l06198"></a><span class="lineno"> 6198</span> </div>
<div class="line"><a id="l06199" name="l06199"></a><span class="lineno"> 6199</span>    <span class="keywordflow">if</span> (!static_ok)</div>
<div class="line"><a id="l06200" name="l06200"></a><span class="lineno"> 6200</span>    {</div>
<div class="line"><a id="l06201" name="l06201"></a><span class="lineno"> 6201</span>      <span class="comment">// validate_static_option() has set *err_code.</span></div>
<div class="line"><a id="l06202" name="l06202"></a><span class="lineno"> 6202</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l06203" name="l06203"></a><span class="lineno"> 6203</span>    }</div>
<div class="line"><a id="l06204" name="l06204"></a><span class="lineno"> 6204</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l06205" name="l06205"></a><span class="lineno"> 6205</span>  } <span class="comment">// if (prev_opts)</span></div>
<div class="line"><a id="l06206" name="l06206"></a><span class="lineno"> 6206</span> </div>
<div class="line"><a id="l06207" name="l06207"></a><span class="lineno"> 6207</span>  <span class="comment">// Now sanity-check the values themselves.  @todo Comment and reconsider these?</span></div>
<div class="line"><a id="l06208" name="l06208"></a><span class="lineno"> 6208</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> checks_ok</div>
<div class="line"><a id="l06209" name="l06209"></a><span class="lineno"> 6209</span>    = VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a> &gt;= 512) &amp;&amp;</div>
<div class="line"><a id="l06210" name="l06210"></a><span class="lineno"> 6210</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8f18c8222ade5f99b83a85e0203ff130">m_st_connect_retransmit_period</a>.count() &gt; 0) &amp;&amp;</div>
<div class="line"><a id="l06211" name="l06211"></a><span class="lineno"> 6211</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac75171c4f1086d0aa38248ae5ffba884">m_st_connect_retransmit_timeout</a>.count() &gt; 0) &amp;&amp;</div>
<div class="line"><a id="l06212" name="l06212"></a><span class="lineno"> 6212</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8ca6086022691700f5e5d2dc87ca92fd">m_st_snd_buf_max_size</a> &gt;= 4 * opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a>) &amp;&amp;</div>
<div class="line"><a id="l06213" name="l06213"></a><span class="lineno"> 6213</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a171480324f26432928738532cb3c8556">m_st_rcv_buf_max_size</a> &gt;= 4 * opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a>) &amp;&amp;</div>
<div class="line"><a id="l06214" name="l06214"></a><span class="lineno"> 6214</span>      VALIDATE_CHECK(<a class="code hl_function" href="namespaceflow_1_1util.html#a8ae762ea4f743a98a73953d7f9ec2164">util::in_open_closed_range</a>(0u, opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#af483d0292f363e7dbf14dc7a2dd49f3f">m_st_rcv_buf_max_size_to_advertise_percent</a>, 100u)) &amp;&amp;</div>
<div class="line"><a id="l06215" name="l06215"></a><span class="lineno"> 6215</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#af78ca6cf3c6da3bc24cea40d522f0bdb">m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</a> &gt;= 100) &amp;&amp;</div>
<div class="line"><a id="l06216" name="l06216"></a><span class="lineno"> 6216</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#add7ccb9e8cd0715ca78e0710d2a6db06">m_st_delayed_ack_timer_period</a> &lt;= seconds(1)) &amp;&amp;</div>
<div class="line"><a id="l06217" name="l06217"></a><span class="lineno"> 6217</span>      VALIDATE_CHECK(<a class="code hl_function" href="namespaceflow_1_1util.html#ab10bc9e8bef148f875aa743fe0852743">util::in_closed_range</a>(Fine_duration::zero(),</div>
<div class="line"><a id="l06218" name="l06218"></a><span class="lineno"> 6218</span>                                           opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#add7ccb9e8cd0715ca78e0710d2a6db06">m_st_delayed_ack_timer_period</a>,</div>
<div class="line"><a id="l06219" name="l06219"></a><span class="lineno"> 6219</span>                                           <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>(seconds(1)))) &amp;&amp;</div>
<div class="line"><a id="l06220" name="l06220"></a><span class="lineno"> 6220</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7a76f7ae03e258b30b04c7350481de6">m_st_max_full_blocks_before_ack_send</a> &gt;= 1) &amp;&amp;</div>
<div class="line"><a id="l06221" name="l06221"></a><span class="lineno"> 6221</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a0b37da87848d01220c7e58f90e6764ba">m_st_max_rexmissions_per_packet</a> &gt;= 1) &amp;&amp;</div>
<div class="line"><a id="l06222" name="l06222"></a><span class="lineno"> 6222</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a0b37da87848d01220c7e58f90e6764ba">m_st_max_rexmissions_per_packet</a> &lt;= numeric_limits&lt;Low_lvl_packet::rexmit_id_t&gt;::max());</div>
<div class="line"><a id="l06223" name="l06223"></a><span class="lineno"> 6223</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a02afb5ed4201d83c87a3a30fcbdda489">m_st_init_drop_timeout</a>.count() &gt; 0) &amp;&amp;</div>
<div class="line"><a id="l06224" name="l06224"></a><span class="lineno"> 6224</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a3d420992e19e5addb7193d607e82e4">m_st_snd_bandwidth_est_sample_period_floor</a>.count() &gt; 0) &amp;&amp;</div>
<div class="line"><a id="l06225" name="l06225"></a><span class="lineno"> 6225</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a637811d19d4a2b4d9b3ab79742aadff8">m_st_cong_ctl_init_cong_wnd_blocks</a> &lt;= opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a1bdc21e84373dd96494a76f11603335e">m_st_cong_ctl_max_cong_wnd_blocks</a>) &amp;&amp;</div>
<div class="line"><a id="l06226" name="l06226"></a><span class="lineno"> 6226</span>      VALIDATE_CHECK</div>
<div class="line"><a id="l06227" name="l06227"></a><span class="lineno"> 6227</span>        (4 * opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a1bdc21e84373dd96494a76f11603335e">m_st_cong_ctl_max_cong_wnd_blocks</a> * opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a> &lt;= opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a171480324f26432928738532cb3c8556">m_st_rcv_buf_max_size</a>) &amp;&amp;</div>
<div class="line"><a id="l06228" name="l06228"></a><span class="lineno"> 6228</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a7ab1e27acd52d8fa3aadc9eb13d116">m_st_cong_ctl_cong_avoidance_increment_blocks</a> &lt; 20) &amp;&amp;</div>
<div class="line"><a id="l06229" name="l06229"></a><span class="lineno"> 6229</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeccfe97128c9f5f62ff26d73047dec2e">m_st_cong_ctl_classic_wnd_decay_percent</a> &lt;= 100) &amp;&amp;</div>
<div class="line"><a id="l06230" name="l06230"></a><span class="lineno"> 6230</span>      VALIDATE_CHECK(util::in_closed_range&lt;size_t&gt;(1, opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2c8fcb08dfb0d1ebcc21e02940c149e8">m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</a>, 10)) &amp;&amp;</div>
<div class="line"><a id="l06231" name="l06231"></a><span class="lineno"> 6231</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#afd02a9d91ef5e5c13ea95ea35624da1a">m_dyn_drop_timeout_ceiling</a> &gt; 4 * opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a02afb5ed4201d83c87a3a30fcbdda489">m_st_init_drop_timeout</a>) &amp;&amp;</div>
<div class="line"><a id="l06232" name="l06232"></a><span class="lineno"> 6232</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae2551f2995f5830e0461bec6fdd9035e">m_dyn_drop_timeout_backoff_factor</a> &gt;= 1) &amp;&amp;</div>
<div class="line"><a id="l06233" name="l06233"></a><span class="lineno"> 6233</span>      VALIDATE_CHECK(opts.<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac38c0bbba5edbb4964a3914ccf56018f">m_dyn_rcv_wnd_recovery_timer_period</a>.count() &gt; 0);</div>
<div class="line"><a id="l06234" name="l06234"></a><span class="lineno"> 6234</span> </div>
<div class="line"><a id="l06235" name="l06235"></a><span class="lineno"> 6235</span>  <span class="comment">// On error, validate_option_check() has set *err_code.</span></div>
<div class="line"><a id="l06236" name="l06236"></a><span class="lineno"> 6236</span> </div>
<div class="line"><a id="l06237" name="l06237"></a><span class="lineno"> 6237</span>  <span class="keywordflow">return</span> checks_ok;</div>
<div class="line"><a id="l06238" name="l06238"></a><span class="lineno"> 6238</span> </div>
<div class="line"><a id="l06239" name="l06239"></a><span class="lineno"> 6239</span><span class="preprocessor">#undef VALIDATE_CHECK</span></div>
<div class="line"><a id="l06240" name="l06240"></a><span class="lineno"> 6240</span><span class="preprocessor">#undef VALIDATE_STATIC_OPTION</span></div>
<div class="line"><a id="l06241" name="l06241"></a><span class="lineno"> 6241</span>} <span class="comment">// Node::sock_validate_options()</span></div>
<div class="line"><a id="l06242" name="l06242"></a><span class="lineno"> 6242</span> </div>
<div class="line"><a id="l06243" name="l06243"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3"> 6243</a></span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">Node::sock_info</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</div>
<div class="line"><a id="l06244" name="l06244"></a><span class="lineno"> 6244</span>{</div>
<div class="line"><a id="l06245" name="l06245"></a><span class="lineno"> 6245</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">async::asio_exec_ctx_post</a>;</div>
<div class="line"><a id="l06246" name="l06246"></a><span class="lineno"> 6246</span>  <span class="keyword">using </span><a class="code hl_enumeration" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">async::Synchronicity</a>;</div>
<div class="line"><a id="l06247" name="l06247"></a><span class="lineno"> 6247</span>  <span class="keyword">using </span>boost::adopt_lock;</div>
<div class="line"><a id="l06248" name="l06248"></a><span class="lineno"> 6248</span> </div>
<div class="line"><a id="l06249" name="l06249"></a><span class="lineno"> 6249</span>  <span class="comment">// We are in thread U != W.</span></div>
<div class="line"><a id="l06250" name="l06250"></a><span class="lineno"> 6250</span> </div>
<div class="line"><a id="l06251" name="l06251"></a><span class="lineno"> 6251</span>  <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> stats;</div>
<div class="line"><a id="l06252" name="l06252"></a><span class="lineno"> 6252</span>  {</div>
<div class="line"><a id="l06253" name="l06253"></a><span class="lineno"> 6253</span>    <span class="comment">/* WARNING!!!  sock-&gt;m_mutex is locked, but WE must unlock it before returning!  Can&#39;t leave that</span></div>
<div class="line"><a id="l06254" name="l06254"></a><span class="lineno"> 6254</span><span class="comment">     * to the caller, because we must unlock at a specific point below, right before post()ing</span></div>
<div class="line"><a id="l06255" name="l06255"></a><span class="lineno"> 6255</span><span class="comment">     * sock_info_worker() onto thread W.  Use a Lock_guard that adopts an already-locked mutex. */</span></div>
<div class="line"><a id="l06256" name="l06256"></a><span class="lineno"> 6256</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex, adopt_lock);</div>
<div class="line"><a id="l06257" name="l06257"></a><span class="lineno"> 6257</span> </div>
<div class="line"><a id="l06258" name="l06258"></a><span class="lineno"> 6258</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l06259" name="l06259"></a><span class="lineno"> 6259</span>    {</div>
<div class="line"><a id="l06260" name="l06260"></a><span class="lineno"> 6260</span>      <span class="comment">/* This is kind of a weird case, in that sock&#39;s Node having stopped running is a problem, but</span></div>
<div class="line"><a id="l06261" name="l06261"></a><span class="lineno"> 6261</span><span class="comment">       * in this case they just want the socket stats.  The only reason we&#39;re in this method --</span></div>
<div class="line"><a id="l06262" name="l06262"></a><span class="lineno"> 6262</span><span class="comment">       * calling sock-&gt;info() did not simply return the stats itself -- is that there was a danger</span></div>
<div class="line"><a id="l06263" name="l06263"></a><span class="lineno"> 6263</span><span class="comment">       * thread W might change the stats, while we&#39;d be copying them.  Well, if !running() there is no</span></div>
<div class="line"><a id="l06264" name="l06264"></a><span class="lineno"> 6264</span><span class="comment">       * danger of that.  So we can just: */</span></div>
<div class="line"><a id="l06265" name="l06265"></a><span class="lineno"> 6265</span>      <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a>(sock, &amp;stats);</div>
<div class="line"><a id="l06266" name="l06266"></a><span class="lineno"> 6266</span>      <span class="keywordflow">return</span> stats;</div>
<div class="line"><a id="l06267" name="l06267"></a><span class="lineno"> 6267</span>    }</div>
<div class="line"><a id="l06268" name="l06268"></a><span class="lineno"> 6268</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l06269" name="l06269"></a><span class="lineno"> 6269</span> </div>
<div class="line"><a id="l06270" name="l06270"></a><span class="lineno"> 6270</span>    <span class="comment">/* Okay -- Node is running and may change stats&#39;s source info at any time.  Therefore, since we</span></div>
<div class="line"><a id="l06271" name="l06271"></a><span class="lineno"> 6271</span><span class="comment">     * do not have a mutex for all that source info, we place a task on W and set up a future as a</span></div>
<div class="line"><a id="l06272" name="l06272"></a><span class="lineno"> 6272</span><span class="comment">     * way for it to inform us it&#39;s done.  This has a certain performance penalty, but that&#39;s better</span></div>
<div class="line"><a id="l06273" name="l06273"></a><span class="lineno"> 6273</span><span class="comment">     * than having to lock each time we need to modify this source data throughout W&#39;s operations.</span></div>
<div class="line"><a id="l06274" name="l06274"></a><span class="lineno"> 6274</span><span class="comment">     * Moreover we warned about the performance penalty in the doc header for Peer_socket::info(). */</span></div>
<div class="line"><a id="l06275" name="l06275"></a><span class="lineno"> 6275</span> </div>
<div class="line"><a id="l06276" name="l06276"></a><span class="lineno"> 6276</span>    <span class="comment">// We&#39;re done -- must unlock so that thread W can do what it wants to with sock.</span></div>
<div class="line"><a id="l06277" name="l06277"></a><span class="lineno"> 6277</span>  } <span class="comment">// lock</span></div>
<div class="line"><a id="l06278" name="l06278"></a><span class="lineno"> 6278</span> </div>
<div class="line"><a id="l06279" name="l06279"></a><span class="lineno"> 6279</span>  <span class="comment">// Load this onto thread W boost.asio work queue.  We don&#39;t return until it&#39;s done, so [&amp;] is OK.</span></div>
<div class="line"><a id="l06280" name="l06280"></a><span class="lineno"> 6280</span>  <a class="code hl_function" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">asio_exec_ctx_post</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), &amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION,</div>
<div class="line"><a id="l06281" name="l06281"></a><span class="lineno"> 6281</span>                     [&amp;]() { <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a>(sock, &amp;stats); });</div>
<div class="line"><a id="l06282" name="l06282"></a><span class="lineno"> 6282</span>  <span class="comment">// If got here, the task has completed in thread W and signaled us to that effect.</span></div>
<div class="line"><a id="l06283" name="l06283"></a><span class="lineno"> 6283</span> </div>
<div class="line"><a id="l06284" name="l06284"></a><span class="lineno"> 6284</span>  <span class="keywordflow">return</span> stats;</div>
<div class="line"><a id="l06285" name="l06285"></a><span class="lineno"> 6285</span>} <span class="comment">// Node::sock_info()</span></div>
<div class="line"><a id="l06286" name="l06286"></a><span class="lineno"> 6286</span> </div>
<div class="line"><a id="l06287" name="l06287"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09"> 6287</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">Node::sock_load_info_struct</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>* stats)<span class="keyword"> const</span></div>
<div class="line"><a id="l06288" name="l06288"></a><span class="lineno"> 6288</span><span class="keyword"></span>{</div>
<div class="line"><a id="l06289" name="l06289"></a><span class="lineno"> 6289</span>  <span class="keyword">using </span>boost::lexical_cast;</div>
<div class="line"><a id="l06290" name="l06290"></a><span class="lineno"> 6290</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l06291" name="l06291"></a><span class="lineno"> 6291</span> </div>
<div class="line"><a id="l06292" name="l06292"></a><span class="lineno"> 6292</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l06293" name="l06293"></a><span class="lineno"> 6293</span> </div>
<div class="line"><a id="l06294" name="l06294"></a><span class="lineno"> 6294</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#af8234f1645d63b9eee57f6937dc222de">m_rcv</a> = sock-&gt;m_rcv_stats.stats();</div>
<div class="line"><a id="l06295" name="l06295"></a><span class="lineno"> 6295</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a02c61270ec35141affc5bb9f6edc5cd0">m_snd</a> = sock-&gt;m_snd_stats.stats();</div>
<div class="line"><a id="l06296" name="l06296"></a><span class="lineno"> 6296</span> </div>
<div class="line"><a id="l06297" name="l06297"></a><span class="lineno"> 6297</span>  <span class="comment">// @todo This is more suitable for the non-existent Node_info and Node::load_info_struct().  (It&#39;s not per-socket.)</span></div>
<div class="line"><a id="l06298" name="l06298"></a><span class="lineno"> 6298</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a0ddfcfe377cda3266dfc968797ce4c18">m_low_lvl_max_buf_size</a> = <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">m_low_lvl_max_buf_size</a>;</div>
<div class="line"><a id="l06299" name="l06299"></a><span class="lineno"> 6299</span> </div>
<div class="line"><a id="l06300" name="l06300"></a><span class="lineno"> 6300</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21">m_int_state_str</a> = lexical_cast&lt;string&gt;(sock-&gt;m_int_state);</div>
<div class="line"><a id="l06301" name="l06301"></a><span class="lineno"> 6301</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#acc0db949c58be9d7779c342cf5a67c9c">m_is_active_connect</a> = sock-&gt;m_active_connect;</div>
<div class="line"><a id="l06302" name="l06302"></a><span class="lineno"> 6302</span>  <span class="comment">// No need to lock: no thread but W can write to it.</span></div>
<div class="line"><a id="l06303" name="l06303"></a><span class="lineno"> 6303</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#aa24bf78d7bad33c38b96694733836224">m_disconnect_cause</a> = sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l06304" name="l06304"></a><span class="lineno"> 6304</span> </div>
<div class="line"><a id="l06305" name="l06305"></a><span class="lineno"> 6305</span>  {</div>
<div class="line"><a id="l06306" name="l06306"></a><span class="lineno"> 6306</span>    <span class="comment">// Gotta lock, as Receive and Send buffers can be modified at any time by thread U at least.</span></div>
<div class="line"><a id="l06307" name="l06307"></a><span class="lineno"> 6307</span>    <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Peer_socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l06308" name="l06308"></a><span class="lineno"> 6308</span>    stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a127a03a0b0e2f73d1059b7b42f251fa2">m_rcv_buf_size</a> = sock-&gt;m_rcv_buf.data_size();</div>
<div class="line"><a id="l06309" name="l06309"></a><span class="lineno"> 6309</span>    stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a45e2cdb7f0a7e0fd470adeab4009f44a">m_snd_buf_size</a> = sock-&gt;m_snd_buf.data_size();</div>
<div class="line"><a id="l06310" name="l06310"></a><span class="lineno"> 6310</span>  }</div>
<div class="line"><a id="l06311" name="l06311"></a><span class="lineno"> 6311</span> </div>
<div class="line"><a id="l06312" name="l06312"></a><span class="lineno"> 6312</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a84ae8091d89ae59304fd5ebd18539d8b">m_rcv_wnd</a> = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(sock);</div>
<div class="line"><a id="l06313" name="l06313"></a><span class="lineno"> 6313</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a2562eebd9be1837147fef6fa616cb920">m_rcv_wnd_last_advertised</a> = sock-&gt;m_rcv_last_sent_rcv_wnd;</div>
<div class="line"><a id="l06314" name="l06314"></a><span class="lineno"> 6314</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3a38b2a47235621222eb58e6212a4f05">m_rcv_reassembly_q_data_size</a> = sock-&gt;m_rcv_reassembly_q_data_size;</div>
<div class="line"><a id="l06315" name="l06315"></a><span class="lineno"> 6315</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a8c3326fea94763621c47c8b0e4d31eb2">m_rcv_packets_with_gaps</a> = sock-&gt;m_rcv_packets_with_gaps.size();</div>
<div class="line"><a id="l06316" name="l06316"></a><span class="lineno"> 6316</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a4f97c94357653fe6df91677ef070d3e8">m_rcv_syn_rcvd_data_cumulative_size</a></div>
<div class="line"><a id="l06317" name="l06317"></a><span class="lineno"> 6317</span>    = sock-&gt;m_rcv_syn_rcvd_data_q.empty() ? 0 : sock-&gt;m_rcv_syn_rcvd_data_cumulative_size;</div>
<div class="line"><a id="l06318" name="l06318"></a><span class="lineno"> 6318</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a6210e5a1ecd85ed1cb46be696f5faec4">m_rcv_syn_rcvd_data_q_size</a> = sock-&gt;m_rcv_syn_rcvd_data_q.size();</div>
<div class="line"><a id="l06319" name="l06319"></a><span class="lineno"> 6319</span> </div>
<div class="line"><a id="l06320" name="l06320"></a><span class="lineno"> 6320</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#abb8b267eb5fa888e21e415f0e0d26a87">m_snd_rcv_wnd</a> = sock-&gt;m_snd_remote_rcv_wnd;</div>
<div class="line"><a id="l06321" name="l06321"></a><span class="lineno"> 6321</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9">m_snd_cong_ctl_in_flight_bytes</a> = sock-&gt;m_snd_flying_bytes;</div>
<div class="line"><a id="l06322" name="l06322"></a><span class="lineno"> 6322</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a76f59a6c658d45c3283865b97dd01489">m_snd_cong_ctl_in_flight_count</a> = sock-&gt;m_snd_flying_pkts_by_sent_when.size();</div>
<div class="line"><a id="l06323" name="l06323"></a><span class="lineno"> 6323</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a959898645f07733966840b7b8309e6c2">m_snd_cong_ctl_wnd_bytes</a> = sock-&gt;m_snd_cong_ctl-&gt;congestion_window_bytes();</div>
<div class="line"><a id="l06324" name="l06324"></a><span class="lineno"> 6324</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#ab9da1d80bbed4b286c084dba3ed5b12e">m_snd_cong_ctl_wnd_count_approx</a> = stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a959898645f07733966840b7b8309e6c2">m_snd_cong_ctl_wnd_bytes</a> / sock-&gt;max_block_size();</div>
<div class="line"><a id="l06325" name="l06325"></a><span class="lineno"> 6325</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a9fafa98dd848eb3944591472c6ce0548">m_snd_smoothed_round_trip_time</a> = sock-&gt;m_snd_smoothed_round_trip_time;</div>
<div class="line"><a id="l06326" name="l06326"></a><span class="lineno"> 6326</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#aedadfb406ca6842ab1ecc0c4020e2a58">m_snd_round_trip_time_variance</a> = sock-&gt;m_round_trip_time_variance;</div>
<div class="line"><a id="l06327" name="l06327"></a><span class="lineno"> 6327</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#afe104d81f760a454df6d3b0273a2d101">m_snd_drop_timeout</a> = sock-&gt;m_snd_drop_timeout;</div>
<div class="line"><a id="l06328" name="l06328"></a><span class="lineno"> 6328</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#accd2ed68fd975dfa113f9f66c41d152a">m_snd_pacing_packet_q_size</a> = sock-&gt;m_snd_pacing_data.m_packet_q.size();</div>
<div class="line"><a id="l06329" name="l06329"></a><span class="lineno"> 6329</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3ac6229cdcd3e949523658b02fa7d0e0">m_snd_pacing_bytes_allowed_this_slice</a> = sock-&gt;m_snd_pacing_data.m_bytes_allowed_this_slice;</div>
<div class="line"><a id="l06330" name="l06330"></a><span class="lineno"> 6330</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a6b03bba60c815cb17c40802eee400ae2">m_snd_pacing_slice_start</a> = sock-&gt;m_snd_pacing_data.m_slice_start;</div>
<div class="line"><a id="l06331" name="l06331"></a><span class="lineno"> 6331</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a36ab155050d2cc96c5dc7dc9a2d1e2b1">m_snd_pacing_slice_period</a> = sock-&gt;m_snd_pacing_data.m_slice_period;</div>
<div class="line"><a id="l06332" name="l06332"></a><span class="lineno"> 6332</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a788325f467420b83a92adce8302f2e18">m_snd_est_bandwidth_mbit_per_sec</a></div>
<div class="line"><a id="l06333" name="l06333"></a><span class="lineno"> 6333</span>    = util::to_mbit_per_sec&lt;Send_bandwidth_estimator::Time_unit&gt;</div>
<div class="line"><a id="l06334" name="l06334"></a><span class="lineno"> 6334</span>        (sock-&gt;m_snd_bandwidth_estimator-&gt;bandwidth_bytes_per_time());</div>
<div class="line"><a id="l06335" name="l06335"></a><span class="lineno"> 6335</span> </div>
<div class="line"><a id="l06336" name="l06336"></a><span class="lineno"> 6336</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a437ab79b98100ec9f8ee4f2195b24430">m_sock_opts</a> = sock-&gt;opt(sock-&gt;m_opts); <span class="comment">// Lock and copy... probably not the fastest thing ever....</span></div>
<div class="line"><a id="l06337" name="l06337"></a><span class="lineno"> 6337</span>  stats-&gt;<a class="code hl_variable" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a05abba2bde50995af42cd6cf02d0b167">m_node_opts</a> = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">opt</a>(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">m_opts</a>); <span class="comment">// Ditto.</span></div>
<div class="line"><a id="l06338" name="l06338"></a><span class="lineno"> 6338</span>}</div>
<div class="line"><a id="l06339" name="l06339"></a><span class="lineno"> 6339</span> </div>
<div class="line"><a id="l06340" name="l06340"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337"> 6340</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">Node::sock_log_detail</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)<span class="keyword"> const</span></div>
<div class="line"><a id="l06341" name="l06341"></a><span class="lineno"> 6341</span><span class="keyword"></span>{</div>
<div class="line"><a id="l06342" name="l06342"></a><span class="lineno"> 6342</span>  <span class="comment">// We are in thread W.</span></div>
<div class="line"><a id="l06343" name="l06343"></a><span class="lineno"> 6343</span> </div>
<div class="line"><a id="l06344" name="l06344"></a><span class="lineno"> 6344</span>  <span class="comment">/* We are to log details about the given socket.  Since the idea is that this would be called on</span></div>
<div class="line"><a id="l06345" name="l06345"></a><span class="lineno"> 6345</span><span class="comment">   * the order of at most once or twice a second, we can be as verbose as we think is useful without</span></div>
<div class="line"><a id="l06346" name="l06346"></a><span class="lineno"> 6346</span><span class="comment">   * (too much) concern for performance. */</span></div>
<div class="line"><a id="l06347" name="l06347"></a><span class="lineno"> 6347</span> </div>
<div class="line"><a id="l06348" name="l06348"></a><span class="lineno"> 6348</span>  <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> stats;</div>
<div class="line"><a id="l06349" name="l06349"></a><span class="lineno"> 6349</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a>(sock, &amp;stats); <span class="comment">// This involves some copying, but, again, we are not too concerned with speed.</span></div>
<div class="line"><a id="l06350" name="l06350"></a><span class="lineno"> 6350</span> </div>
<div class="line"><a id="l06351" name="l06351"></a><span class="lineno"> 6351</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;[=== Socket state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]. ===\n&quot;</span> &lt;&lt; stats);</div>
<div class="line"><a id="l06352" name="l06352"></a><span class="lineno"> 6352</span> </div>
<div class="line"><a id="l06353" name="l06353"></a><span class="lineno"> 6353</span>  <span class="comment">// Log receive and send windows details.  Force the logging of the most verbose possible amount of info.</span></div>
<div class="line"><a id="l06354" name="l06354"></a><span class="lineno"> 6354</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">log_snd_window</a>(sock, <span class="keyword">true</span>);</div>
<div class="line"><a id="l06355" name="l06355"></a><span class="lineno"> 6355</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">log_rcv_window</a>(sock, <span class="keyword">true</span>);</div>
<div class="line"><a id="l06356" name="l06356"></a><span class="lineno"> 6356</span>  <span class="comment">// @todo Should this be inside Peer_socket_info also?</span></div>
<div class="line"><a id="l06357" name="l06357"></a><span class="lineno"> 6357</span> </div>
<div class="line"><a id="l06358" name="l06358"></a><span class="lineno"> 6358</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;=== Socket state for [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;]. ===]&quot;</span>);</div>
<div class="line"><a id="l06359" name="l06359"></a><span class="lineno"> 6359</span>} <span class="comment">// Node::sock_log_detail()</span></div>
<div class="line"><a id="l06360" name="l06360"></a><span class="lineno"> 6360</span> </div>
<div class="line"><a id="l06361" name="l06361"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868"> 6361</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">Node::advance_seq_num</a>(<a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num, boost::shared_ptr&lt;const Data_packet&gt; data) <span class="comment">// Static.</span></div>
<div class="line"><a id="l06362" name="l06362"></a><span class="lineno"> 6362</span>{</div>
<div class="line"><a id="l06363" name="l06363"></a><span class="lineno"> 6363</span>  <span class="comment">/* We just need to increment *seq_num, which points to the start of the data in `data`,</span></div>
<div class="line"><a id="l06364" name="l06364"></a><span class="lineno"> 6364</span><span class="comment">   * to a value that points to the data just past the end of the data in `data`.  Why is this in a</span></div>
<div class="line"><a id="l06365" name="l06365"></a><span class="lineno"> 6365</span><span class="comment">   * separate method?  Answer: We may want to change the mapping from sequence number to byte of data.  In</span></div>
<div class="line"><a id="l06366" name="l06366"></a><span class="lineno"> 6366</span><span class="comment">   * particular the mapping can be one-to-one, as in TCP.  Or it can be one sequence number to all bytes in a</span></div>
<div class="line"><a id="l06367" name="l06367"></a><span class="lineno"> 6367</span><span class="comment">   * particular packet, which I&#39;ve seen in certain lesser known custom protocols.  This allows us to</span></div>
<div class="line"><a id="l06368" name="l06368"></a><span class="lineno"> 6368</span><span class="comment">   * (hopefully) change the code in one place. */</span></div>
<div class="line"><a id="l06369" name="l06369"></a><span class="lineno"> 6369</span> </div>
<div class="line"><a id="l06370" name="l06370"></a><span class="lineno"> 6370</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a>(seq_num, data-&gt;m_data.size());</div>
<div class="line"><a id="l06371" name="l06371"></a><span class="lineno"> 6371</span>} <span class="comment">// Node::advance_seq_num()</span></div>
<div class="line"><a id="l06372" name="l06372"></a><span class="lineno"> 6372</span> </div>
<div class="line"><a id="l06373" name="l06373"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a95399fe09e4bd18ac2a43b2fbec8ab17"> 6373</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">Node::advance_seq_num</a>(<a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num, <span class="keywordtype">size_t</span> data_size)</div>
<div class="line"><a id="l06374" name="l06374"></a><span class="lineno"> 6374</span>{</div>
<div class="line"><a id="l06375" name="l06375"></a><span class="lineno"> 6375</span>  <span class="comment">/* For now go with TCP&#39;s convention (one byte to one sequence number, no gaps).  While we deal</span></div>
<div class="line"><a id="l06376" name="l06376"></a><span class="lineno"> 6376</span><span class="comment">   * with blocks, instead of streams, this may complicate the math a bit and use more sequence</span></div>
<div class="line"><a id="l06377" name="l06377"></a><span class="lineno"> 6377</span><span class="comment">   * number space (faster wrapping).  However, it would make it easier to adapt the algorithms</span></div>
<div class="line"><a id="l06378" name="l06378"></a><span class="lineno"> 6378</span><span class="comment">   * when we move to byte streams; and we currently use a sequence number so large that wrapping</span></div>
<div class="line"><a id="l06379" name="l06379"></a><span class="lineno"> 6379</span><span class="comment">   * is impossible.  Update: we have moved to streams. */</span></div>
<div class="line"><a id="l06380" name="l06380"></a><span class="lineno"> 6380</span>  *seq_num += data_size;</div>
<div class="line"><a id="l06381" name="l06381"></a><span class="lineno"> 6381</span>}</div>
<div class="line"><a id="l06382" name="l06382"></a><span class="lineno"> 6382</span> </div>
<div class="line"><a id="l06383" name="l06383"></a><span class="lineno"> 6383</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Packet_map_iter&gt;</div>
<div class="line"><a id="l06384" name="l06384"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43"> 6384</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">Node::get_seq_num_range</a>(<span class="keyword">const</span> Packet_map_iter&amp; packet_it,</div>
<div class="line"><a id="l06385" name="l06385"></a><span class="lineno"> 6385</span>                             <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_start, <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_end) <span class="comment">// Static.</span></div>
<div class="line"><a id="l06386" name="l06386"></a><span class="lineno"> 6386</span>{</div>
<div class="line"><a id="l06387" name="l06387"></a><span class="lineno"> 6387</span>  <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num_start_cref = packet_it-&gt;first;</div>
<div class="line"><a id="l06388" name="l06388"></a><span class="lineno"> 6388</span>  <span class="keywordflow">if</span> (seq_num_start)</div>
<div class="line"><a id="l06389" name="l06389"></a><span class="lineno"> 6389</span>  {</div>
<div class="line"><a id="l06390" name="l06390"></a><span class="lineno"> 6390</span>    *seq_num_start = seq_num_start_cref;</div>
<div class="line"><a id="l06391" name="l06391"></a><span class="lineno"> 6391</span>  }</div>
<div class="line"><a id="l06392" name="l06392"></a><span class="lineno"> 6392</span>  <span class="keywordflow">if</span> (seq_num_end)</div>
<div class="line"><a id="l06393" name="l06393"></a><span class="lineno"> 6393</span>  {</div>
<div class="line"><a id="l06394" name="l06394"></a><span class="lineno"> 6394</span>    *seq_num_end = seq_num_start_cref;</div>
<div class="line"><a id="l06395" name="l06395"></a><span class="lineno"> 6395</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a>(seq_num_end, packet_it-&gt;second-&gt;m_size);</div>
<div class="line"><a id="l06396" name="l06396"></a><span class="lineno"> 6396</span>  }</div>
<div class="line"><a id="l06397" name="l06397"></a><span class="lineno"> 6397</span>}</div>
<div class="line"><a id="l06398" name="l06398"></a><span class="lineno"> 6398</span> </div>
<div class="line"><a id="l06399" name="l06399"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d"> 6399</a></span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">Node::sock_get_new_snd_order_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock) <span class="comment">// Static.</span></div>
<div class="line"><a id="l06400" name="l06400"></a><span class="lineno"> 6400</span>{</div>
<div class="line"><a id="l06401" name="l06401"></a><span class="lineno"> 6401</span>  <span class="comment">// Since m_snd_last_order_num starts at 0, this ensures 0 is reserved, as advertised.</span></div>
<div class="line"><a id="l06402" name="l06402"></a><span class="lineno"> 6402</span>  <span class="keywordflow">return</span> ++sock-&gt;m_snd_last_order_num;</div>
<div class="line"><a id="l06403" name="l06403"></a><span class="lineno"> 6403</span>}</div>
<div class="line"><a id="l06404" name="l06404"></a><span class="lineno"> 6404</span> </div>
<div class="line"><a id="l06405" name="l06405"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01"> 6405</a></span><a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">Node::sock_create</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts) <span class="comment">// Virtual.</span></div>
<div class="line"><a id="l06406" name="l06406"></a><span class="lineno"> 6406</span>{</div>
<div class="line"><a id="l06407" name="l06407"></a><span class="lineno"> 6407</span>  <span class="comment">// Just make a regular net_flow::Peer_socket.</span></div>
<div class="line"><a id="l06408" name="l06408"></a><span class="lineno"> 6408</span>  <span class="keywordflow">return</span> sock_create_forward_plus_ctor_args&lt;Peer_socket&gt;(opts);</div>
<div class="line"><a id="l06409" name="l06409"></a><span class="lineno"> 6409</span>}</div>
<div class="line"><a id="l06410" name="l06410"></a><span class="lineno"> 6410</span> </div>
<div class="line"><a id="l06411" name="l06411"></a><span class="lineno"> 6411</span><span class="comment">// Free implementations.</span></div>
<div class="line"><a id="l06412" name="l06412"></a><span class="lineno"> 6412</span> </div>
<div class="line"><a id="l06413" name="l06413"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a8497776b61df32a79707c264f8f2422b"> 6413</a></span>std::ostream&amp; <a class="code hl_function" href="namespaceflow_1_1net__flow.html#ab9f537c84f77e9b8fa742fc5dc6d5693">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* sock)</div>
<div class="line"><a id="l06414" name="l06414"></a><span class="lineno"> 6414</span>{</div>
<div class="line"><a id="l06415" name="l06415"></a><span class="lineno"> 6415</span>  <span class="keywordflow">return</span></div>
<div class="line"><a id="l06416" name="l06416"></a><span class="lineno"> 6416</span>    sock</div>
<div class="line"><a id="l06417" name="l06417"></a><span class="lineno"> 6417</span>      ? (os</div>
<div class="line"><a id="l06418" name="l06418"></a><span class="lineno"> 6418</span>         &lt;&lt; <span class="stringliteral">&quot;NetFlow_socket &quot;</span></div>
<div class="line"><a id="l06419" name="l06419"></a><span class="lineno"> 6419</span>         &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sock-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">remote_endpoint</a>() &lt;&lt; <span class="stringliteral">&quot;]&lt;=&gt;[NetFlow [:&quot;</span> &lt;&lt; sock-&gt;<a class="code hl_function" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">local_port</a>() &lt;&lt; <span class="stringliteral">&quot;]] &quot;</span></div>
<div class="line"><a id="l06420" name="l06420"></a><span class="lineno"> 6420</span>         <span class="stringliteral">&quot;@&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(sock))</div>
<div class="line"><a id="l06421" name="l06421"></a><span class="lineno"> 6421</span>      : (os &lt;&lt; <span class="stringliteral">&quot;NetFlow_socket@null&quot;</span>);</div>
<div class="line"><a id="l06422" name="l06422"></a><span class="lineno"> 6422</span>}</div>
<div class="line"><a id="l06423" name="l06423"></a><span class="lineno"> 6423</span><span class="comment"></span> </div>
<div class="line"><a id="l06424" name="l06424"></a><span class="lineno"> 6424</span><span class="comment">/// @cond</span></div>
<div class="line"><a id="l06425" name="l06425"></a><span class="lineno"> 6425</span><span class="comment"></span><span class="comment">/* -^- Doxygen, please ignore the following.  (Don&#39;t want docs generated for temp macro; this is more maintainable</span></div>
<div class="line"><a id="l06426" name="l06426"></a><span class="lineno"> 6426</span><span class="comment"> * than specifying the macro name to omit it, in Doxygen-config EXCLUDE_SYMBOLS.) */</span></div>
<div class="line"><a id="l06427" name="l06427"></a><span class="lineno"> 6427</span> </div>
<div class="line"><a id="l06428" name="l06428"></a><span class="lineno"> 6428</span><span class="comment">// That&#39;s right, I did this.  Wanna fight about it?</span></div>
<div class="line"><a id="l06429" name="l06429"></a><span class="lineno"> 6429</span><span class="preprocessor">#define STATE_TO_CASE_STATEMENT(ARG_state) \</span></div>
<div class="line"><a id="l06430" name="l06430"></a><span class="lineno"> 6430</span><span class="preprocessor">  case Peer_socket::Int_state::S_##ARG_state: \</span></div>
<div class="line"><a id="l06431" name="l06431"></a><span class="lineno"> 6431</span><span class="preprocessor">    return os &lt;&lt; #ARG_state</span></div>
<div class="line"><a id="l06432" name="l06432"></a><span class="lineno"> 6432</span> </div>
<div class="line"><a id="l06433" name="l06433"></a><span class="lineno"> 6433</span><span class="comment">// -v- Doxygen, please stop ignoring.</span><span class="comment"></span></div>
<div class="line"><a id="l06434" name="l06434"></a><span class="lineno"> 6434</span><span class="comment">/// @endcond</span></div>
<div class="line"><a id="l06435" name="l06435"></a><span class="lineno"> 6435</span><span class="comment"></span> </div>
<div class="line"><a id="l06436" name="l06436"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Peer__socket.html#a03ea7069aa4779abaf274989bd4c2fb6"> 6436</a></span>std::ostream&amp; <a class="code hl_function" href="namespaceflow_1_1net__flow.html#ab9f537c84f77e9b8fa742fc5dc6d5693">operator&lt;&lt;</a>(std::ostream&amp; os, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a> state)</div>
<div class="line"><a id="l06437" name="l06437"></a><span class="lineno"> 6437</span>{</div>
<div class="line"><a id="l06438" name="l06438"></a><span class="lineno"> 6438</span>  <span class="keywordflow">switch</span> (state)</div>
<div class="line"><a id="l06439" name="l06439"></a><span class="lineno"> 6439</span>  {</div>
<div class="line"><a id="l06440" name="l06440"></a><span class="lineno"> 6440</span>    STATE_TO_CASE_STATEMENT(CLOSED);</div>
<div class="line"><a id="l06441" name="l06441"></a><span class="lineno"> 6441</span>    STATE_TO_CASE_STATEMENT(SYN_SENT);</div>
<div class="line"><a id="l06442" name="l06442"></a><span class="lineno"> 6442</span>    STATE_TO_CASE_STATEMENT(SYN_RCVD);</div>
<div class="line"><a id="l06443" name="l06443"></a><span class="lineno"> 6443</span>    STATE_TO_CASE_STATEMENT(ESTABLISHED);</div>
<div class="line"><a id="l06444" name="l06444"></a><span class="lineno"> 6444</span>  }</div>
<div class="line"><a id="l06445" name="l06445"></a><span class="lineno"> 6445</span>  <span class="keywordflow">return</span> os;</div>
<div class="line"><a id="l06446" name="l06446"></a><span class="lineno"> 6446</span><span class="preprocessor">#undef STATE_TO_CASE_STATEMENT</span></div>
<div class="line"><a id="l06447" name="l06447"></a><span class="lineno"> 6447</span>}</div>
<div class="line"><a id="l06448" name="l06448"></a><span class="lineno"> 6448</span> </div>
<div class="line"><a id="l06449" name="l06449"></a><span class="lineno"> 6449</span>} <span class="comment">// namespace flow::net_flow</span></div>
<div class="ttc" id="aasync_2util_8hpp_html"><div class="ttname"><a href="async_2util_8hpp.html">util.hpp</a></div></div>
<div class="ttc" id="abandwidth_8hpp_html"><div class="ttname"><a href="bandwidth_8hpp.html">bandwidth.hpp</a></div></div>
<div class="ttc" id="aclassflow_1_1Function_html"><div class="ttname"><a href="classflow_1_1Function.html">flow::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00512">common.hpp:512</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_a8a5fef42dc2cedf3c0d1a6e83beb2948"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">flow::log::Log_context::get_log_component</a></div><div class="ttdeci">const Component &amp; get_log_component() const</div><div class="ttdoc">Returns reference to the stored Component object, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> <a href="log_8cpp_source.html#l00222">log.cpp:222</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_af4db395042b065b00398cd59845dcb4d"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">flow::log::Log_context::get_logger</a></div><div class="ttdeci">Logger * get_logger() const</div><div class="ttdoc">Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> <a href="log_8cpp_source.html#l00217">log.cpp:217</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Logger_html"><div class="ttname"><a href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a></div><div class="ttdoc">Interface that the user should implement, passing the implementing Logger into logging classes (Flow'...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l01280">log.hpp:1284</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Congestion__control__selector_html_a52eee18d41c3f9cc7d6c48b766a7919f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Congestion__control__selector.html#a52eee18d41c3f9cc7d6c48b766a7919f">flow::net_flow::Congestion_control_selector::create_strategy</a></div><div class="ttdeci">static Congestion_control_strategy * create_strategy(Strategy_choice strategy_choice, log::Logger *logger_ptr, Peer_socket::Const_ptr sock)</div><div class="ttdoc">Factory method that, given an enum identifying the desired strategy, allocates the appropriate Conges...</div><div class="ttdef"><b>Definition:</b> <a href="cong__ctl_8cpp_source.html#l00100">cong_ctl.cpp:101</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Drop__timer_html_a64def367e38954d8a392cdf92fcc8f24"><div class="ttname"><a href="classflow_1_1net__flow_1_1Drop__timer.html#a64def367e38954d8a392cdf92fcc8f24">flow::net_flow::Drop_timer::create_drop_timer</a></div><div class="ttdeci">static Ptr create_drop_timer(log::Logger *logger_ptr, util::Task_engine *node_task_engine, Fine_duration *sock_drop_timeout, Peer_socket::Const_ptr &amp;&amp;sock, const Function&lt; void(const Error_code &amp;err_code)&gt; &amp;timer_failure, const Function&lt; void(bool drop_all_packets)&gt; &amp;timer_fired)</div><div class="ttdoc">Constructs Drop_timer and returns a ref-counted pointer wrapping it.</div><div class="ttdef"><b>Definition:</b> <a href="drop__timer_8cpp_source.html#l00027">drop_timer.cpp:28</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::Event_type::S_PEER_SOCKET_WRITABLE</a></div><div class="ttdeci">@ S_PEER_SOCKET_WRITABLE</div><div class="ttdoc">Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">flow::net_flow::Event_set::Event_type::S_PEER_SOCKET_READABLE</a></div><div class="ttdeci">@ S_PEER_SOCKET_READABLE</div><div class="ttdoc">Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></div><div class="ttdoc">An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00930">node.hpp:934</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a00124a034c8fdac6f300900bdfcc8cfe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">flow::net_flow::Node::snd_flying_pkts_updated</a></div><div class="ttdeci">void snd_flying_pkts_updated(Peer_socket::Ptr sock, Peer_socket::Sent_pkt_ordered_by_when_const_iter pkt_begin, const Peer_socket::Sent_pkt_ordered_by_when_const_iter &amp;pkt_end, bool added)</div><div class="ttdoc">Updates Peer_socket::m_snd_flying_bytes according to an operation (add packets, remove packets) calle...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03840">peer_socket.cpp:3840</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a055ee380cf87f83c06d7380821c4679e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">flow::net_flow::Node::categorize_individual_ack</a></div><div class="ttdeci">bool categorize_individual_ack(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, Ack_packet::Individual_ack::Const_ptr ack, bool *dupe_or_late, Peer_socket::Sent_pkt_ordered_by_when_iter *acked_pkt_it)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that categorizes the given accumulated individual ackno...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02501">peer_socket.cpp:2501</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a06e4cea2eefa1b06975864f09740c96b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">flow::net_flow::Node::handle_data_to_established</a></div><div class="ttdeci">void handle_data_to_established(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet, bool syn_rcvd_qd_packet)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00545">peer_socket.cpp:545</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0756fc7301d0cfa66f19e681a9c60c06"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">flow::net_flow::Node::sock_is_writable</a></div><div class="ttdeci">bool sock_is_writable(const boost::any &amp;sock_as_any) const</div><div class="ttdoc">Returns true if and only if calling sock-&gt;send() with at least some arguments would return either non...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04642">peer_socket.cpp:4642</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a07ad769737db60dd637365010b80f4f3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">flow::net_flow::Node::sock_info</a></div><div class="ttdeci">Peer_socket_info sock_info(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Implementation of sock-&gt;info() for socket sock in all cases except when sock-&gt;state() == Peer_socket:...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06243">peer_socket.cpp:6243</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a08cf95363b26c0c676979437e34db357"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">flow::net_flow::Node::receive_wnd_updated</a></div><div class="ttdeci">void receive_wnd_updated(Peer_socket::Ptr sock)</div><div class="ttdoc">Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05187">peer_socket.cpp:5187</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0ea53f6b451895e8efcdc68ba8770a43"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">flow::net_flow::Node::sock_track_new_data_after_gap_rexmit_off</a></div><div class="ttdeci">void sock_track_new_data_after_gap_rexmit_off(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Data_packet &gt; packet, size_t data_size, bool *slide, size_t *slide_size)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01229">peer_socket.cpp:1229</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0f9f88761fc18c4f9e0d5f4dd6b4bc95"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">flow::net_flow::Node::sock_data_to_reassembly_q_unless_overflow</a></div><div class="ttdeci">bool sock_data_to_reassembly_q_unless_overflow(Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01305">peer_socket.cpp:1305</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a109a118ca312e94686595ea08dac7ad0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">flow::net_flow::Node::ensure_sock_open</a></div><div class="ttdeci">static bool ensure_sock_open(Socket_ptr sock, Error_code *err_code)</div><div class="ttdoc">Helper method that checks whether the given Peer_socket or Server_socket is CLOSED; if so,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04099">node.hpp:4099</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a10a92f11a2c9f218cdd9a55f282e79b1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">flow::net_flow::Node::send_worker</a></div><div class="ttdeci">void send_worker(Peer_socket::Ptr sock, bool defer_delta_check)</div><div class="ttdoc">Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04721">peer_socket.cpp:4721</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a136d9ccd25634cee2955ea79ae829006"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">flow::net_flow::Node::handle_accumulated_acks</a></div><div class="ttdeci">void handle_accumulated_acks(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02017">peer_socket.cpp:2017</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a192d4b95b9f8a5c3d08b1e5486eb6f78"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">flow::net_flow::Node::async_rcv_wnd_recovery</a></div><div class="ttdeci">void async_rcv_wnd_recovery(Peer_socket::Ptr sock, size_t rcv_wnd)</div><div class="ttdoc">receive_wnd_updated() helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a r...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05321">peer_socket.cpp:5321</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1bfde94f7d529ea8e6c26b560abfa9c7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">flow::net_flow::Node::log_accumulated_acks</a></div><div class="ttdeci">void log_accumulated_acks(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Helper of handle_accumulated_acks() that logs the about-to-be-handled accumulated individual acknowle...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03222">peer_socket.cpp:3222</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1d5f13062bec6730db533cc1e89bf515"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">flow::net_flow::Node::sock_free_memory</a></div><div class="ttdeci">void sock_free_memory(Peer_socket::Ptr sock)</div><div class="ttdoc">Helper that clears all non-O(1)-space data structures stored inside sock.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06073">peer_socket.cpp:6073</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2336fae98b318ab73e7268e9a242bf09"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">flow::net_flow::Node::sock_load_info_struct</a></div><div class="ttdeci">void sock_load_info_struct(Peer_socket::Const_ptr sock, Peer_socket_info *stats) const</div><div class="ttdoc">Given a Peer_socket, copies all stats info (as available via Peer_socket::info()) from various struct...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06287">peer_socket.cpp:6287</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a24785d3e04e0a9cd5daca43bc867e5aa"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">flow::net_flow::Node::log_snd_window</a></div><div class="ttdeci">void log_snd_window(Peer_socket::Const_ptr sock, bool force_verbose_info_logging=false) const</div><div class="ttdoc">Logs TRACE or DATA messages thats show the detailed state of the sending sequence number space.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03591">peer_socket.cpp:3591</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2565b7c0bd82cad86eb168b62f8ffd9d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">flow::net_flow::Node::send_worker_check_state</a></div><div class="ttdeci">void send_worker_check_state(Peer_socket::Ptr sock)</div><div class="ttdoc">Helper placed by send() onto W to invoke send_worker() but ensures that the socket has not entered so...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04676">peer_socket.cpp:4676</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a266ec5d00a44bc48caf37444eb2b43a1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">flow::net_flow::Node::m_low_lvl_max_buf_size</a></div><div class="ttdeci">size_t m_low_lvl_max_buf_size</div><div class="ttdoc">OS-reported m_low_lvl_sock UDP receive buffer maximum size, obtained right after we OS-set that setti...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03729">node.hpp:3729</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2a4dc3d8e294bbc8423e111f52e414ae"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">flow::net_flow::Node::sync_op</a></div><div class="ttdeci">Non_blocking_func_ret_type sync_op(typename Socket::Ptr sock, const Function&lt; Non_blocking_func_ret_type()&gt; &amp;non_blocking_func, Non_blocking_func_ret_type would_block_ret_val, Event_set::Event_type ev_type, const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">Implementation of core blocking transfer methods, namely Peer_socket::sync_send(),...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03935">node.hpp:3935</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a31d9838b735786bfed40fc1c437808d7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">flow::net_flow::Node::sock_max_packets_after_unrecvd_packet</a></div><div class="ttdeci">size_t sock_max_packets_after_unrecvd_packet(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Computes and returns the max size for Peer_socket::m_rcv_packets_with_gaps for sock.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01541">peer_socket.cpp:1541</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3326b5bdc85b43232f55e2b2ec1dbe60"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">flow::net_flow::Node::categorize_pkts_as_dropped_on_acks</a></div><div class="ttdeci">Peer_socket::Sent_pkt_ordered_by_when_iter categorize_pkts_as_dropped_on_acks(Peer_socket::Ptr sock, const boost::unordered_set&lt; Peer_socket::order_num_t &gt; &amp;flying_now_acked_pkts)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02892">peer_socket.cpp:2892</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3574d50742fa0b1230c049f4b29fd3dc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">flow::net_flow::Node::rcv_get_first_gap_info</a></div><div class="ttdeci">void rcv_get_first_gap_info(Peer_socket::Const_ptr sock, bool *first_gap_exists, Sequence_number *seq_num_after_first_gap)</div><div class="ttdoc">Helper for handle_data_to_established() that gets simple info about Peer_socket::m_rcv_packets_with_g...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01554">peer_socket.cpp:1554</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a382b607fa2e482886f2fd75edc36b8b7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">flow::net_flow::Node::snd_deqable</a></div><div class="ttdeci">bool snd_deqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there are enough data either in Peer_socket::m_snd_rexmit_q of sock (if re...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05979">peer_socket.cpp:5979</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3f9cf4d7160b3e27b3b0131fc4507ce7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">flow::net_flow::Node::cancel_timers</a></div><div class="ttdeci">void cancel_timers(Peer_socket::Ptr sock)</div><div class="ttdoc">Cancel any timers and scheduled tasks active in the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04376">peer_socket.cpp:4376</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a40595ee69bfb87fd64005bc8443329dc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">flow::net_flow::Node::sock_rcv_buf_now_readable</a></div><div class="ttdeci">void sock_rcv_buf_now_readable(Peer_socket::Ptr sock, bool syn_rcvd_qd_packet)</div><div class="ttdoc">Helper for handle_data_to_established() that assumes the given's socket Receive buffer is currently r...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01195">peer_socket.cpp:1195</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a43af576c6156f5d69682e664d9ff3922"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">flow::net_flow::Node::snd_flying_pkts_erase_one</a></div><div class="ttdeci">void snd_flying_pkts_erase_one(Peer_socket::Ptr sock, Peer_socket::Sent_pkt_ordered_by_when_iter pkt_it)</div><div class="ttdoc">Erases (for example if considered Acknowledged or Dropped) a packet struct from the &quot;scoreboard&quot; (Pee...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03737">peer_socket.cpp:3737</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a43c42121d48a55a43a48e3a84bd10595"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">flow::net_flow::Node::opt</a></div><div class="ttdeci">Opt_type opt(const Opt_type &amp;opt_val_ref) const</div><div class="ttdoc">Obtain a copy of the value of a given option in a thread-safe manner.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04138">node.hpp:4138</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a446ee7115c70cbcd48e3897d32fc0276"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">flow::net_flow::Node::sock_validate_options</a></div><div class="ttdeci">bool sock_validate_options(const Peer_socket_options &amp;opts, const Peer_socket_options *prev_opts, Error_code *err_code) const</div><div class="ttdoc">Analogous to validate_options() but checks per-socket options instead of per-Node options.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06144">peer_socket.cpp:6144</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a45583714bc147300158f074ecacce0fd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">flow::net_flow::Node::handle_accumulated_pending_acks</a></div><div class="ttdeci">void handle_accumulated_pending_acks(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that handles any additional individual outgoing acknowl...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01629">peer_socket.cpp:1629</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a45b05340098b0eb66f88a6a7e5f3d36f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">flow::net_flow::Node::receive_wnd_recovery_data_received</a></div><div class="ttdeci">void receive_wnd_recovery_data_received(Peer_socket::Ptr sock)</div><div class="ttdoc">Pertaining to the async_rcv_wnd_recovery() mechanism, this handles the event that we have received an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05402">peer_socket.cpp:5402</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a479dfcb7944cb6571af51f1feed2656d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">flow::net_flow::Node::sock_get_new_snd_order_num</a></div><div class="ttdeci">static Peer_socket::order_num_t sock_get_new_snd_order_num(Peer_socket::Ptr sock)</div><div class="ttdoc">Returns the &quot;order number&quot; to use for Peer_socket::Sent_packet::Sent_when structure corresponding to ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06399">peer_socket.cpp:6399</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a49e2786f5d1eeb068a828902a631a39a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">flow::net_flow::Node::sync_connect_impl</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect_impl(const Remote_endpoint &amp;to, const Fine_duration &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code, const Peer_socket_options *opts)</div><div class="ttdoc">Implementation core of sync_connect*() that gets rid of templated or missing arguments thereof.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04144">peer_socket.cpp:4144</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4bd7b471dd6cd3e3570930b48d30e577"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">flow::net_flow::Node::max_block_size</a></div><div class="ttdeci">size_t max_block_size() const</div><div class="ttdoc">The maximum number of bytes of user data per received or sent block on connections generated from thi...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01111">node.cpp:1111</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a52a3e10ef08b93daf87ea5f0f1e87062"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">flow::net_flow::Node::snd_flying_pkts_push_one</a></div><div class="ttdeci">void snd_flying_pkts_push_one(Peer_socket::Ptr sock, const Sequence_number &amp;seq_num, Peer_socket::Sent_packet::Ptr sent_pkt)</div><div class="ttdoc">Adds a new packet struct (presumably representing packet to be sent shortly) to the &quot;scoreboard&quot; (Pee...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03774">peer_socket.cpp:3774</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a5bca5c11ac5a4763fed6ce146fe733e7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">flow::net_flow::Node::create_syn</a></div><div class="ttdeci">Syn_packet::Ptr create_syn(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05728">peer_socket.cpp:5728</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6461124e5bc3e59083e172e26029e632"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">flow::net_flow::Node::close_abruptly</a></div><div class="ttdeci">void close_abruptly(Peer_socket::Ptr sock, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05532">peer_socket.cpp:5532</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6524cbac013de26f46784b9a2823e5af"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6524cbac013de26f46784b9a2823e5af">flow::net_flow::Node::async_low_lvl_ack_send</a></div><div class="ttdeci">void async_low_lvl_ack_send(Peer_socket::Ptr sock, const Error_code &amp;sys_err_code=Error_code())</div><div class="ttdoc">Sends a low-level ACK packet, with all accumulated in Peer_socket::m_rcv_pending_acks of sock individ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05771">peer_socket.cpp:5771</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a663f1fd8b524ffe63dfa6b7ca76b1a43"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">flow::net_flow::Node::get_seq_num_range</a></div><div class="ttdeci">static void get_seq_num_range(const Packet_map_iter &amp;packet_it, Sequence_number *seq_num_start, Sequence_number *seq_num_end)</div><div class="ttdoc">Given an iterator into a Peer_socket::Sent_pkt_by_sent_when_map or Peer_socket::Recv_pkt_map,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06384">peer_socket.cpp:6384</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6725d69ea1a6457d88abb63cef6e6bb2"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">flow::net_flow::Node::sync_connect_with_metadata</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect_with_metadata(const Remote_endpoint &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03914">node.hpp:3914</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6bcd840049c57150cdaa5c59d22c488b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">flow::net_flow::Node::create_syn_ack</a></div><div class="ttdeci">Syn_ack_packet::Ptr create_syn_ack(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Like create_syn() but for SYN_ACK.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05743">peer_socket.cpp:5743</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6daaa6a5a7d0b7e5a2266dd9db400c01"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">flow::net_flow::Node::sock_create</a></div><div class="ttdeci">virtual Peer_socket * sock_create(const Peer_socket_options &amp;opts)</div><div class="ttdoc">Internal factory used for ALL Peer_socket objects created by this Node (including subclasses).</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06405">peer_socket.cpp:6405</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a70d124ba678e2ab72f8c6d28140ca137"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">flow::net_flow::Node::snd_buf_enqable</a></div><div class="ttdeci">bool snd_buf_enqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there is enough free space in Peer_socket::m_snd_buf of sock to enqueue an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05985">peer_socket.cpp:5985</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7395ac534047f06629962ad19b3fa657"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">flow::net_flow::Node::can_send</a></div><div class="ttdeci">bool can_send(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Answers the perennial question of congestion and flow control: assuming there is a DATA packet to sen...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04963">peer_socket.cpp:4963</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a74adc7d61419f4beb7941d418a31a648"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">flow::net_flow::Node::sock_slide_rcv_next_seq_num</a></div><div class="ttdeci">void sock_slide_rcv_next_seq_num(Peer_socket::Ptr sock, size_t slide_size, bool reassembly_in_progress)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register a set of received DATA packet data as i...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01456">peer_socket.cpp:1456</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a755c329b9e0f2b8edb2e5b900bd2a337"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">flow::net_flow::Node::sock_log_detail</a></div><div class="ttdeci">void sock_log_detail(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Logs a verbose state report for the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06340">peer_socket.cpp:6340</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a80d58cfa8fad00a116a38f76ccb2b868"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">flow::net_flow::Node::advance_seq_num</a></div><div class="ttdeci">static void advance_seq_num(Sequence_number *seq_num, boost::shared_ptr&lt; const Data_packet &gt; data)</div><div class="ttdoc">Assuming *seq_num points to the start of data.m_data, increments *seq_num to point to the datum just ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06361">peer_socket.cpp:6361</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a837d37e6eb06fb6df4666bac327d20f8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">flow::net_flow::Node::snd_past_last_flying_datum_seq_num</a></div><div class="ttdeci">static Sequence_number snd_past_last_flying_datum_seq_num(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Obtain the sequence number for the datum just past the last (latest) In-flight (i....</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03716">peer_socket.cpp:3716</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a893c8393930110e2aa0823583e37cabd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">flow::net_flow::Node::connect</a></div><div class="ttdeci">Peer_socket::Ptr connect(const Remote_endpoint &amp;to, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">Initiates an active connect to the specified remote Flow server.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03900">peer_socket.cpp:3900</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8a4ddf81ddbeab1f740940c4cc0d3625"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">flow::net_flow::Node::event_set_all_check_delta</a></div><div class="ttdeci">void event_set_all_check_delta(bool defer_delta_check)</div><div class="ttdoc">For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01127">event_set.cpp:1127</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8a6c02bf520a16df4028bd3c88732a8d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">flow::net_flow::Node::serv_peer_socket_closed</a></div><div class="ttdeci">void serv_peer_socket_closed(Server_socket::Ptr serv, Peer_socket::Ptr sock)</div><div class="ttdoc">Records that a Server_socket-contained (i.e., currently un-established, or established but not yet ac...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00771">server_socket.cpp:771</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8cae2884eaf67d77c9f8cf56b31e4c4b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">flow::net_flow::Node::rcv_buf_deqable</a></div><div class="ttdeci">bool rcv_buf_deqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there are enough data in Peer_socket::m_rcv_buf of sock to give the user s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06002">peer_socket.cpp:6002</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8ece1750c8f0bee297af113f8808b7a6"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">flow::net_flow::Node::async_acknowledge_packet</a></div><div class="ttdeci">void async_acknowledge_packet(Peer_socket::Ptr sock, const Sequence_number &amp;seq_num, unsigned int rexmit_id, size_t data_size)</div><div class="ttdoc">Causes an acknowledgment of the given received packet to be included in a future Ack_packet sent to t...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01566">peer_socket.cpp:1566</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a90244d69d550370158bbe843ab595a7a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">flow::net_flow::Node::m_socks</a></div><div class="ttdeci">Socket_id_to_socket_map m_socks</div><div class="ttdoc">The peer-to-peer connections this Node is currently tracking.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03750">node.hpp:3750</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a97c8679c70ac9c7dda394fdf335aaed7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">flow::net_flow::Node::Options_lock</a></div><div class="ttdeci">Peer_socket::Options_lock Options_lock</div><div class="ttdoc">Short-hand for lock that acquires exclusive access to an Options_mutex.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01436">node.hpp:1436</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a99836ffb51eaefa4d2cc21770461cd97"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">flow::net_flow::Node::socket_id</a></div><div class="ttdeci">static Socket_id socket_id(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Constructs the socket pair (connection ID) for the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05973">peer_socket.cpp:5973</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa0f9ebea458490c37a38760c8335506c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">flow::net_flow::Node::handle_syn_ack_to_syn_sent</a></div><div class="ttdeci">void handle_syn_ack_to_syn_sent(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; syn_ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed low-level SYN_ACK packet delivered to the given peer ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00464">peer_socket.cpp:464</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa19d1f49638ef8ce8883e7477a06d3fc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">flow::net_flow::Node::send</a></div><div class="ttdeci">size_t send(Peer_socket::Ptr sock, const Function&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04449">peer_socket.cpp:4449</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa1d9656e9e1480021c87530ec6dbebbe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">flow::net_flow::Node::sock_set_int_state</a></div><div class="ttdeci">void sock_set_int_state(Peer_socket::Ptr sock, Peer_socket::Int_state new_state)</div><div class="ttdoc">Sets internal state of given socket to the given state and logs a TRACE message about it.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06008">peer_socket.cpp:6008</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa44feae2c97b4bc1fe1f14f83e932d84"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">flow::net_flow::Node::sock_is_readable</a></div><div class="ttdeci">bool sock_is_readable(const boost::any &amp;sock_as_any) const</div><div class="ttdoc">Returns true if and only if calling sock-&gt;receive() with at least some arguments would return either ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05157">peer_socket.cpp:5157</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aab414ebd0e2d27f02ed51270dab90c45"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">flow::net_flow::Node::sock_data_to_rcv_buf_unless_overflow</a></div><div class="ttdeci">bool sock_data_to_rcv_buf_unless_overflow(Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to pass the payload of the given DATA packet to the...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01118">peer_socket.cpp:1118</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aadea4a9941c6138d9c025401b1f85ceb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">flow::net_flow::Node::sock_set_options</a></div><div class="ttdeci">bool sock_set_options(Peer_socket::Ptr sock, const Peer_socket_options &amp;opts, Error_code *err_code)</div><div class="ttdoc">Thread W implementation of sock-&gt;set_options().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06096">peer_socket.cpp:6096</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aae148cec361b59237996a4b30c6624b5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">flow::net_flow::Node::running</a></div><div class="ttdeci">bool running() const</div><div class="ttdoc">Returns true if and only if the Node is operating.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00420">node.cpp:420</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aae28990628a86a07327f49973f2390df"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">flow::net_flow::Node::m_servs</a></div><div class="ttdeci">Port_to_server_map m_servs</div><div class="ttdoc">The server sockets this Node is currently tracking.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03756">node.hpp:3756</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab0026feecdb74eda904d00d2c7016bab"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">flow::net_flow::Node::m_sock_events</a></div><div class="ttdeci">Event_set::Ev_type_to_socks_map m_sock_events</div><div class="ttdoc">All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03788">node.hpp:3788</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab13749ccdf4ab44445f21c77296ffa13"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">flow::net_flow::Node::S_DEFAULT_CONN_METADATA</a></div><div class="ttdeci">static const uint8_t S_DEFAULT_CONN_METADATA</div><div class="ttdoc">Type and value to supply as user-supplied metadata in SYN, if user chooses to use [[a]sync_]connect()...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01400">node.hpp:1400</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab427ebc124a6233ae48a7562662a6e81"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">flow::net_flow::Node::setup_drop_timer</a></div><div class="ttdeci">void setup_drop_timer(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Creates a new Drop Timer and saves it to sock-&gt;m_snd_drop_timer.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04427">peer_socket.cpp:4427</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab515b28350c43635728d6de0e37ccb94"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">flow::net_flow::Node::handle_ack_to_established</a></div><div class="ttdeci">void handle_ack_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Ack_packet &gt; ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer soc...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01946">peer_socket.cpp:1946</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aba2e6fc905dbeef3ea9e31bf844f8da5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">flow::net_flow::Node::sync_connect</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect(const Remote_endpoint &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">The blocking (synchronous) version of connect().</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03925">node.hpp:3925</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abb3d760b3c880b41e5a4ee7f2c13fd81"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">flow::net_flow::Node::handle_syn_ack_to_established</a></div><div class="ttdeci">void handle_syn_ack_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; syn_ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, duplicate (equal to already-received SYN_ACK) low-le...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00524">peer_socket.cpp:524</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac1485c07049d4bee70ad4ef2fc07bf12"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">flow::net_flow::Node::setup_connection_timers</a></div><div class="ttdeci">void setup_connection_timers(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, bool initial)</div><div class="ttdoc">Assuming we've just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some a...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04257">peer_socket.cpp:4257</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac2fdb686165aae42f474cc655fca80c0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">flow::net_flow::Node::log_rcv_window</a></div><div class="ttdeci">void log_rcv_window(Peer_socket::Const_ptr sock, bool force_verbose_info_logging=false) const</div><div class="ttdoc">Logs TRACE or DATA messages that show the detailed state of the receiving sequence number space.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01860">peer_socket.cpp:1860</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac397d3fd163f1456b7bb370a3cff951c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">flow::net_flow::Node::sock_rcv_wnd</a></div><div class="ttdeci">size_t sock_rcv_wnd(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Computes and returns the currently correct rcv_wnd value; that is the amount of space free in Receive...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05435">peer_socket.cpp:5435</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac619d1a96cc62d223f990ee6a3c909ff"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">flow::net_flow::Node::connect_worker</a></div><div class="ttdeci">void connect_worker(const Remote_endpoint &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, const Peer_socket_options *opts, Peer_socket::Ptr *sock)</div><div class="ttdoc">Thread W implementation of connect().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03957">peer_socket.cpp:3957</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac910f24e5a176c4aa01992b08b62146a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">flow::net_flow::Node::drop_pkts_on_acks</a></div><div class="ttdeci">bool drop_pkts_on_acks(Peer_socket::Ptr sock, const Peer_socket::Sent_pkt_ordered_by_when_iter &amp;last_dropped_pkt_it, size_t *cong_ctl_dropped_pkts, size_t *cong_ctl_dropped_bytes, size_t *dropped_pkts, size_t *dropped_bytes, std::vector&lt; Peer_socket::order_num_t &gt; *pkts_marked_to_drop)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that acts on the determination made by categorize_pkts_...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03058">peer_socket.cpp:3058</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac9f6edfb36abcd0402c4bd75b595f271"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">flow::net_flow::Node::S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</a></div><div class="ttdeci">static const Peer_socket::Sent_packet::ack_count_t S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</div><div class="ttdoc">For a given unacknowledged sent packet P, the maximum number of times any individual packet with high...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03644">node.hpp:3644</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_acfbd969c7a16b2ea8bb7f0db6fa454df"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">flow::net_flow::Node::sock_categorize_data_to_established</a></div><div class="ttdeci">Error_code sock_categorize_data_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Data_packet &gt; packet, bool *dupe, bool *slide, size_t *slide_size)</div><div class="ttdoc">Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00810">peer_socket.cpp:810</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad03aa88df3d1d3981454ee3356e868c1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">flow::net_flow::Node::async_sock_low_lvl_rst_send</a></div><div class="ttdeci">void async_sock_low_lvl_rst_send(Peer_socket::Ptr sock)</div><div class="ttdoc">Sends an RST to the other side of the given socket asynchronously when possible.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00988">low_lvl_io.cpp:988</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad502e0a992a79b71af42a9cdc20a4280"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">flow::net_flow::Node::sock_set_state</a></div><div class="ttdeci">void sock_set_state(Peer_socket::Ptr sock, Peer_socket::State state, Peer_socket::Open_sub_state open_sub_state=Peer_socket::Open_sub_state::S_CONNECTED)</div><div class="ttdoc">Sets Peer_socket::m_state and Peer_socket::m_open_sub_state.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06017">peer_socket.cpp:6017</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad608f9bbe76426f4fbf4bf5af908e4e0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">flow::net_flow::Node::receive_emptied_rcv_buf_while_disconnecting</a></div><div class="ttdeci">void receive_emptied_rcv_buf_while_disconnecting(Peer_socket::Ptr sock)</div><div class="ttdoc">Placed by receive() onto W during a graceful close, after the Receive buffer had been emptied by the ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05468">peer_socket.cpp:5468</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ada9357f6ce9d5fc249b1cc176afdc471"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">flow::net_flow::Node::sock_disconnect_detected</a></div><div class="ttdeci">void sock_disconnect_detected(Peer_socket::Ptr sock, const Error_code &amp;disconnect_cause, bool close)</div><div class="ttdoc">Records that thread W shows underlying connection is broken (graceful termination,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06039">peer_socket.cpp:6039</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_addbb96858fd7b3c9ddd7c6fe8078809c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">flow::net_flow::Node::receive</a></div><div class="ttdeci">size_t receive(Peer_socket::Ptr sock, const Function&lt; size_t()&gt; &amp;rcv_buf_consume_func, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05007">peer_socket.cpp:5007</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_addd654cb6b1ccff34ddccbe5226be8f0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">flow::net_flow::Node::handle_connection_rexmit_timer_event</a></div><div class="ttdeci">void handle_connection_rexmit_timer_event(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Handles the triggering of the retransmit timer wait set up by setup_connection_timers(); it will re-s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04336">peer_socket.cpp:4336</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade08f0457943f803c23b55649139c0d3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">flow::net_flow::Node::m_opts</a></div><div class="ttdeci">Node_options m_opts</div><div class="ttdoc">This Node's global set of options.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03662">node.hpp:3662</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade49e7bc7202a0adf33fec2d93d1b177"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">flow::net_flow::Node::close_connection_immediately</a></div><div class="ttdeci">void close_connection_immediately(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, const Error_code &amp;err_code, bool defer_delta_check)</div><div class="ttdoc">A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05600">peer_socket.cpp:5600</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade529b5452c9fe363ae468346e662ceb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">flow::net_flow::Node::sock_disconnect_completed</a></div><div class="ttdeci">void sock_disconnect_completed(Peer_socket::Ptr sock)</div><div class="ttdoc">While in S_OPEN+S_DISCONNECTING state (i.e., after beginning a graceful close with sock_disconnect_de...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06060">peer_socket.cpp:6060</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_adeccd8c86fcd54733e42593629fad96b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">flow::net_flow::Node::compute_rtt_on_ack</a></div><div class="ttdeci">Fine_duration compute_rtt_on_ack(Peer_socket::Sent_packet::Const_ptr flying_pkt, const Fine_time_pt &amp;time_now, Ack_packet::Individual_ack::Const_ptr ack, const Peer_socket::Sent_packet::Sent_when **sent_when) const</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that computes the RTT implied by a given individual ack...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02826">peer_socket.cpp:2826</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae330d0f98ad34cb442d2bb251bdae460"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae330d0f98ad34cb442d2bb251bdae460">flow::net_flow::Node::async_low_lvl_syn_ack_ack_send</a></div><div class="ttdeci">void async_low_lvl_syn_ack_ack_send(const Peer_socket::Ptr &amp;sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; &amp;syn_ack)</div><div class="ttdoc">Helper to create, fully fill out, and asynchronously send via async_sock_low_lvl_packet_send_paced() ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05756">peer_socket.cpp:5756</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae9a0e5492b9ea005cc12c20c8e7cec9a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">flow::net_flow::Node::connect_with_metadata</a></div><div class="ttdeci">Peer_socket::Ptr connect_with_metadata(const Remote_endpoint &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03907">peer_socket.cpp:3907</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae9b88eadca41228fe6a671f2f14ead0b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">flow::net_flow::Node::new_round_trip_time_sample</a></div><div class="ttdeci">void new_round_trip_time_sample(Peer_socket::Ptr sock, Fine_duration round_trip_time)</div><div class="ttdoc">Handles a just-computed new RTT (round trip time) measurement for an individual packet earlier sent: ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03453">peer_socket.cpp:3453</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_af1c4623729d0a061200a386f7a651926"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#af1c4623729d0a061200a386f7a651926">flow::net_flow::Node::async_sock_low_lvl_packet_send_paced</a></div><div class="ttdeci">void async_sock_low_lvl_packet_send_paced(const Peer_socket::Ptr &amp;sock, Low_lvl_packet::Ptr &amp;&amp;packet)</div><div class="ttdoc">Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00599">low_lvl_io.cpp:599</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_af39d69abde4efa88d5d40e1c529c1a25"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">flow::net_flow::Node::ok_to_rexmit_or_close</a></div><div class="ttdeci">bool ok_to_rexmit_or_close(Peer_socket::Ptr sock, const Peer_socket::Sent_pkt_ordered_by_when_iter &amp;pkt_it, bool defer_delta_check)</div><div class="ttdoc">Checks whether the given sent packet has been retransmitted the maximum number of allowed times; if s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03877">peer_socket.cpp:3877</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_af5597a417d03e2bed87cd772ef5cef29"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">flow::net_flow::Node::m_task_engine</a></div><div class="ttdeci">util::Task_engine m_task_engine</div><div class="ttdoc">The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03697">node.hpp:3697</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afd6388a362531ada956a864fefff6011"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">flow::net_flow::Node::m_ports</a></div><div class="ttdeci">Port_space m_ports</div><div class="ttdoc">Flow port space for both client and server sockets. All threads may access this.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03735">node.hpp:3735</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afe70a0c32695e417e7a09e0ba773f151"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">flow::net_flow::Node::rst_and_close_connection_immediately</a></div><div class="ttdeci">void rst_and_close_connection_immediately(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, const Error_code &amp;err_code, bool defer_delta_check)</div><div class="ttdoc">Asynchronously send RST to the other side of the given socket and close_connection_immediately().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05720">peer_socket.cpp:5720</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_affbc6abb1e344c6e98d3ac8068a54670"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">flow::net_flow::Node::drop_timer_action</a></div><div class="ttdeci">void drop_timer_action(Peer_socket::Ptr sock, bool drop_all_packets)</div><div class="ttdoc">Handles a Drop_timer (Peer_socket::m_snd_drop_timer) event in ESTABLISHED state by dropping the speci...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03273">peer_socket.cpp:3273</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">flow::net_flow::Peer_socket_receive_stats_accumulator</a></div><div class="ttdoc">A class that keeps a Peer_socket_receive_stats data store, includes methods to conveniently accumulat...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8hpp_source.html#l00049">socket_stats.hpp:52</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a20f2fe00c0874f075fade075bb82e234"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a20f2fe00c0874f075fade075bb82e234">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_accepted_packet</a></div><div class="ttdeci">void good_data_accepted_packet(size_t data)</div><div class="ttdoc">Indicates good_data_packet(), and these data are not dropped (so either delivered into Receive buffer...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00051">socket_stats.cpp:51</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a30706cd9e07511f17ec73f6af10926f2"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a30706cd9e07511f17ec73f6af10926f2">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_dropped_reassembly_q_overflow_packet</a></div><div class="ttdeci">void good_data_dropped_reassembly_q_overflow_packet(size_t data)</div><div class="ttdoc">Indicates good_data_packet(), but these data are dropped due to insufficient Receive reassembly queue...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00045">socket_stats.cpp:45</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a31080df078b6408b60fab6f3d8396369"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a31080df078b6408b60fab6f3d8396369">flow::net_flow::Peer_socket_receive_stats_accumulator::presumed_dropped_data</a></div><div class="ttdeci">void presumed_dropped_data(size_t data)</div><div class="ttdoc">Indicates that one or more unreceived data packets have been considered Dropped due to the number of ...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00081">socket_stats.cpp:81</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a5cc77830ee793725a5bbc1e7660fb230"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a5cc77830ee793725a5bbc1e7660fb230">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_delivered_packet</a></div><div class="ttdeci">void good_data_delivered_packet(size_t data)</div><div class="ttdoc">Indicates good_data_accepted_packet(), and these data are delivered into Receive buffer (either immed...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00057">socket_stats.cpp:57</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a67e90d9c299777769ad090b24ba060cf"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a67e90d9c299777769ad090b24ba060cf">flow::net_flow::Peer_socket_receive_stats_accumulator::late_or_dupe_to_send_ack_packet</a></div><div class="ttdeci">void late_or_dupe_to_send_ack_packet(size_t data)</div><div class="ttdoc">Indicates that late_or_dupe_data_packet() and therefore an individual acknowledgment for this packet ...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00098">socket_stats.cpp:98</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a6e40a6152711f5ee78275180612f71dd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a6e40a6152711f5ee78275180612f71dd">flow::net_flow::Peer_socket_receive_stats_accumulator::total_data_packet</a></div><div class="ttdeci">void total_data_packet(size_t data)</div><div class="ttdoc">Indicates one DATA packet has been received on socket.</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00027">socket_stats.cpp:27</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_a7f68edbb903370ec36fa2deac09288ee"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#a7f68edbb903370ec36fa2deac09288ee">flow::net_flow::Peer_socket_receive_stats_accumulator::good_to_send_ack_packet</a></div><div class="ttdeci">void good_to_send_ack_packet(size_t data)</div><div class="ttdoc">Indicates that good_data_delivered_packet() and therefore an individual acknowledgment for this packe...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00092">socket_stats.cpp:92</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_aa44f429fb274ae4fad21efbc88aa9b95"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#aa44f429fb274ae4fad21efbc88aa9b95">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_packet</a></div><div class="ttdeci">void good_data_packet(size_t data)</div><div class="ttdoc">Indicates total_data_packet(), and these data are new and acceptable into Receive buffer assuming the...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00033">socket_stats.cpp:33</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_ab45ad2bb462371067b09ae4f97935a78"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ab45ad2bb462371067b09ae4f97935a78">flow::net_flow::Peer_socket_receive_stats_accumulator::error_data_packet</a></div><div class="ttdeci">void error_data_packet(size_t data)</div><div class="ttdoc">Indicates total_data_packet(), but there is some error about the sequence numbers so that they are no...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00069">socket_stats.cpp:69</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_ac2753b3e8e3932593fed431771b1df80"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ac2753b3e8e3932593fed431771b1df80">flow::net_flow::Peer_socket_receive_stats_accumulator::buffer_fed</a></div><div class="ttdeci">void buffer_fed(size_t size)</div><div class="ttdoc">Indicates the Receive buffer was enqueued with data from network (so its data_size() increased).</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00148">socket_stats.cpp:148</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_ae2ed3438420d6f331549e2decb9f0556"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#ae2ed3438420d6f331549e2decb9f0556">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_first_qd_packet</a></div><div class="ttdeci">void good_data_first_qd_packet(size_t data)</div><div class="ttdoc">Indicates good_data_accepted_packet(), and these data are, upon receipt, queued for reassembly (not i...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00063">socket_stats.cpp:63</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_aede48ce8c717e5e8f69accc4d8608613"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#aede48ce8c717e5e8f69accc4d8608613">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_dropped_buf_overflow_packet</a></div><div class="ttdeci">void good_data_dropped_buf_overflow_packet(size_t data)</div><div class="ttdoc">Indicates good_data_packet(), but these data are dropped due to insufficient Receive buffer space.</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00039">socket_stats.cpp:39</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator_html_af841e2009909b4166ee1f821e7054eff"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html#af841e2009909b4166ee1f821e7054eff">flow::net_flow::Peer_socket_receive_stats_accumulator::late_or_dupe_data_packet</a></div><div class="ttdeci">void late_or_dupe_data_packet(size_t data)</div><div class="ttdoc">Indicates total_data_packet(), but the arrived data have either already been received before or (more...</div><div class="ttdef"><b>Definition:</b> <a href="socket__stats_8cpp_source.html#l00075">socket_stats.cpp:75</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html">flow::net_flow::Peer_socket</a></div><div class="ttdoc">A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00216">peer_socket.hpp:224</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a05a765055fd54412c63e57e43697f1bc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc">flow::net_flow::Peer_socket::m_state</a></div><div class="ttdeci">State m_state</div><div class="ttdoc">See state().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01189">peer_socket.hpp:1189</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a0c99637726b3c2b2ff1dbf14c6c92752"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">flow::net_flow::Peer_socket::get_connect_metadata</a></div><div class="ttdeci">size_t get_connect_metadata(const boost::asio::mutable_buffer &amp;buffer, Error_code *err_code=0) const</div><div class="ttdoc">Obtains the serialized connect metadata, as supplied by the user during the connection handshake.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00381">peer_socket.cpp:381</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a102b78eaac9c8add512238ec5f26fcfc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a102b78eaac9c8add512238ec5f26fcfc">flow::net_flow::Peer_socket::max_block_size_multiple</a></div><div class="ttdeci">size_t max_block_size_multiple(const size_t &amp;opt_val_ref, const unsigned int *inflate_pct_val_ptr=0) const</div><div class="ttdoc">Returns the smallest multiple of max_block_size() that is &gt;= the given option value,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00348">peer_socket.cpp:348</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a15ba1d4af6d4e3fcab9534a307c00595"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">flow::net_flow::Peer_socket::sync_send_reactor_pattern_impl</a></div><div class="ttdeci">bool sync_send_reactor_pattern_impl(const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">Helper similar to sync_send_impl() but for the nullptr_t versions of sync_send().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00112">peer_socket.cpp:112</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a1958264af0c40f3c9c5769ddff4c9ade"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">flow::net_flow::Peer_socket::Sent_pkt_by_seq_num_map</a></div><div class="ttdeci">std::map&lt; Sequence_number, Sent_pkt_ordered_by_when_iter &gt; Sent_pkt_by_seq_num_map</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_seq_num type; see that data member.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00946">peer_socket.hpp:946</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a1a2eccfa314a397c12259f414ef6798c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">flow::net_flow::Peer_socket::sync_receive_reactor_pattern_impl</a></div><div class="ttdeci">bool sync_receive_reactor_pattern_impl(const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">Helper similar to sync_receive_impl() but for the nullptr_t versions of sync_receive().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00193">peer_socket.cpp:193</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a218ec098984b754b43940001f59ab787"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a218ec098984b754b43940001f59ab787">flow::net_flow::Peer_socket::m_remote_endpoint</a></div><div class="ttdeci">Remote_endpoint m_remote_endpoint</div><div class="ttdoc">See remote_endpoint(). Should be set before user gets access to *this and not changed afterwards.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01341">peer_socket.hpp:1341</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a256b77e546fff9394ef8d509e2ae771b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">flow::net_flow::Peer_socket::sync_receive</a></div><div class="ttdeci">size_t sync_receive(const Mutable_buffer_sequence &amp;target, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, Error_code *err_code=0)</div><div class="ttdoc">Blocking (synchronous) version of receive().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02572">peer_socket.hpp:2572</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a322dddf34a06bb199dab02c993bad686"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686">flow::net_flow::Peer_socket::m_serialized_metadata</a></div><div class="ttdeci">util::Blob m_serialized_metadata</div><div class="ttdoc">If !m_active_connect, this contains the serialized metadata that the user supplied on the other side ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01325">peer_socket.hpp:1325</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a34e2c7dfb5596269a6f86a716015f1a6"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">flow::net_flow::Peer_socket::node_sync_send</a></div><div class="ttdeci">size_t node_sync_send(const Function&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func_or_empty, const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">This is to sync_send() as node_send() is to send().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00145">peer_socket.cpp:145</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a36ab27af6886c7699f9965a5eb296cd6"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">flow::net_flow::Peer_socket::m_node</a></div><div class="ttdeci">Node * m_node</div><div class="ttdoc">See node().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01214">peer_socket.hpp:1214</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a4fb8e8df98efa023e8bd4bd825475a18"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18">flow::net_flow::Peer_socket::m_disconnect_cause</a></div><div class="ttdeci">Error_code m_disconnect_cause</div><div class="ttdoc">The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01309">peer_socket.hpp:1309</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a5003c554807f5b5b58989ad58be48d42"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">flow::net_flow::Peer_socket::Peer_socket</a></div><div class="ttdeci">Peer_socket(log::Logger *logger_ptr, util::Task_engine *task_engine, const Peer_socket_options &amp;opts)</div><div class="ttdoc">Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meani...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00037">peer_socket.cpp:37</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a5dc05d1f5deb71e1259c5d5aad1fcf84"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a5dc05d1f5deb71e1259c5d5aad1fcf84">flow::net_flow::Peer_socket::m_rcv_init_seq_num</a></div><div class="ttdeci">Sequence_number m_rcv_init_seq_num</div><div class="ttdoc">The Initial Sequence Number (ISN) contained in the original Syn_packet or Syn_ack_packet we received.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01383">peer_socket.hpp:1383</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a5e423a9fd18a45cc7cc5fc34af29161e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">flow::net_flow::Peer_socket::remote_endpoint</a></div><div class="ttdeci">const Remote_endpoint &amp; remote_endpoint() const</div><div class="ttdoc">Intended other side of the connection (regardless of success, failure, or current State).</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00369">peer_socket.cpp:369</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6a9bb727c8982f24bcf978c10c2c7345"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">flow::net_flow::Peer_socket::State</a></div><div class="ttdeci">State</div><div class="ttdoc">State of a Peer_socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00229">peer_socket.hpp:230</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::State::S_OPEN</a></div><div class="ttdeci">@ S_OPEN</div><div class="ttdoc">Future reads or writes may be possible. A socket in this state may be Writable or Readable.</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::State::S_CLOSED</a></div><div class="ttdeci">@ S_CLOSED</div><div class="ttdoc">Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">flow::net_flow::Peer_socket::Open_sub_state</a></div><div class="ttdeci">Open_sub_state</div><div class="ttdoc">The sub-state of a Peer_socket when state is State::S_OPEN.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00238">peer_socket.hpp:239</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::Open_sub_state::S_CONNECTED</a></div><div class="ttdeci">@ S_CONNECTED</div><div class="ttdoc">This Peer_socket was created through a passive connect (Node::accept() and the like) or an active con...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">flow::net_flow::Peer_socket::Open_sub_state::S_CONNECTING</a></div><div class="ttdeci">@ S_CONNECTING</div><div class="ttdoc">This Peer_socket was created through an active connect (Node::connect() and the like),...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::Open_sub_state::S_DISCONNECTING</a></div><div class="ttdeci">@ S_DISCONNECTING</div><div class="ttdoc">This Peer_socket was created through a passive connect (Node::accept() and the like) or an active con...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a70629642551f18e474b87c128d2d77e2"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">flow::net_flow::Peer_socket::sync_send</a></div><div class="ttdeci">size_t sync_send(const Const_buffer_sequence &amp;data, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, Error_code *err_code=0)</div><div class="ttdoc">Blocking (synchronous) version of send().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02485">peer_socket.hpp:2485</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a729af2cb3465b67b811d8e9438b5af5d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a729af2cb3465b67b811d8e9438b5af5d">flow::net_flow::Peer_socket::~Peer_socket</a></div><div class="ttdeci">~Peer_socket() override</div><div class="ttdoc">Boring virtual destructor. Note that deletion is to be handled exclusively via shared_ptr,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00077">peer_socket.cpp:77</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a74f6fd527766fdeb05a96c5c03729a00"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">flow::net_flow::Peer_socket::disconnect_cause</a></div><div class="ttdeci">Error_code disconnect_cause() const</div><div class="ttdoc">The error code that perviously caused state() to become State::S_CLOSED, or success code if state is ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00101">peer_socket.cpp:101</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a797a524b73e2626fcfefe1be64f4d481"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">flow::net_flow::Peer_socket::order_num_t</a></div><div class="ttdeci">Sequence_number::seq_num_t order_num_t</div><div class="ttdoc">Short-hand for order number type. 0 is reserved. Caution: Keep in sync with Drop_timer::packet_id_t.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00902">peer_socket.hpp:902</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a7af387476aa0bdc6b3906c153d824acb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">flow::net_flow::Peer_socket::local_port</a></div><div class="ttdeci">flow_port_t local_port() const</div><div class="ttdoc">The local Flow-protocol port chosen by the Node (if active or passive open) or user (if passive open)...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00375">peer_socket.cpp:375</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a7b65c1b26e38a2ae614d9a12edfa57dd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd">flow::net_flow::Peer_socket::m_local_port</a></div><div class="ttdeci">flow_port_t m_local_port</div><div class="ttdoc">See local_port(). Should be set before user gets access to *this and not changed afterwards.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01344">peer_socket.hpp:1344</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a7c0f36768414ae35afeb525636a41290"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a7c0f36768414ae35afeb525636a41290">flow::net_flow::Peer_socket::Send_bandwidth_estimator</a></div><div class="ttdeci">friend class Send_bandwidth_estimator</div><div class="ttdoc">Stats modules have const access to all socket internals.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00833">peer_socket.hpp:833</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a7d31cf18a3c075873de1c46c0176e41f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">flow::net_flow::Peer_socket::set_options</a></div><div class="ttdeci">bool set_options(const Peer_socket_options &amp;opts, Error_code *err_code=0)</div><div class="ttdoc">Dynamically replaces the current options set (options()) with the given options set.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00289">peer_socket.cpp:289</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a83ba2b4c39555afad67932ea6ed39bbe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe">flow::net_flow::Peer_socket::node_send</a></div><div class="ttdeci">size_t node_send(const Function&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func, Error_code *err_code)</div><div class="ttdoc">Non-template helper for template send() that forwards the send() logic to Node::send().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00130">peer_socket.cpp:130</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a89d852e3722532d75006b024714a5cef"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">flow::net_flow::Peer_socket::rexmit_on</a></div><div class="ttdeci">bool rexmit_on() const</div><div class="ttdoc">Whether retransmission is enabled on this connection.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00364">peer_socket.cpp:364</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a8abde92d5189bf2a058fe8741789f814"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">flow::net_flow::Peer_socket::node_sync_receive</a></div><div class="ttdeci">size_t node_sync_receive(const Function&lt; size_t()&gt; &amp;rcv_buf_consume_func_or_empty, const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">This is to sync_receive() as node_receive() is to receive().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00226">peer_socket.cpp:226</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a90abde8badaf451ba6ca615e9936d5df"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">flow::net_flow::Peer_socket::Lock_guard</a></div><div class="ttdeci">util::Lock_guard&lt; Mutex &gt; Lock_guard</div><div class="ttdoc">Short-hand for RAII lock guard of Mutex.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00896">peer_socket.hpp:896</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">flow::net_flow::Peer_socket::Int_state</a></div><div class="ttdeci">Int_state</div><div class="ttdoc">The state of the socket (and the connection from this end's point of view) for the internal state mac...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00910">peer_socket.hpp:911</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::Int_state::S_ESTABLISHED</a></div><div class="ttdeci">@ S_ESTABLISHED</div><div class="ttdoc">Public state is OPEN+CONNECTED; in our opinion the connection is established.</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::Int_state::S_SYN_SENT</a></div><div class="ttdeci">@ S_SYN_SENT</div><div class="ttdoc">Public state is OPEN+CONNECTING; user requested active connect; we sent SYN and are awaiting response...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::Int_state::S_CLOSED</a></div><div class="ttdeci">@ S_CLOSED</div><div class="ttdoc">Closed (dead or new) socket.</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::Int_state::S_SYN_RCVD</a></div><div class="ttdeci">@ S_SYN_RCVD</div><div class="ttdoc">Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a98c6729b318f28b61e144f8a9b1f4dfc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">flow::net_flow::Peer_socket::Options_lock</a></div><div class="ttdeci">util::Lock_guard&lt; Options_mutex &gt; Options_lock</div><div class="ttdoc">Short-hand for lock that acquires exclusive access to an Options_mutex.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00885">peer_socket.hpp:885</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9ab710704237f912eb219f9b8d574afc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">flow::net_flow::Peer_socket::close_abruptly</a></div><div class="ttdeci">void close_abruptly(Error_code *err_code=0)</div><div class="ttdoc">Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00261">peer_socket.cpp:261</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_aa1f821dde38a7aa572651730744edbd8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">flow::net_flow::Peer_socket::max_block_size</a></div><div class="ttdeci">size_t max_block_size() const</div><div class="ttdoc">The maximum number of bytes of user data per received or sent packet on this connection.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00343">peer_socket.cpp:343</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_aa9e7e1be830c901bc7348742e79ba2e7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">flow::net_flow::Peer_socket::node</a></div><div class="ttdeci">Node * node() const</div><div class="ttdoc">Node that produced this Peer_socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00095">peer_socket.cpp:95</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_aad81cc16fc6f0d353fdc1379e1dd4712"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">flow::net_flow::Peer_socket::info</a></div><div class="ttdeci">Peer_socket_info info() const</div><div class="ttdoc">Returns a structure containing the most up-to-date stats about this connection.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00314">peer_socket.cpp:314</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_aaec992a7a14368623cc03c4382d71107"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">flow::net_flow::Peer_socket::Recvd_pkt_iter</a></div><div class="ttdeci">Recvd_pkt_map::iterator Recvd_pkt_iter</div><div class="ttdoc">Short-hand for m_rcv_packets_with_gaps iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00968">peer_socket.hpp:968</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ab41b19ed4e62cb14fcd7dac81e4a8f41"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">flow::net_flow::Peer_socket::m_mutex</a></div><div class="ttdeci">Mutex m_mutex</div><div class="ttdoc">This object's mutex.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01338">peer_socket.hpp:1338</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ab7dc3b752b67295c82919c2f87aed60b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_iter</a></div><div class="ttdeci">Sent_pkt_by_sent_when_map::iterator Sent_pkt_ordered_by_when_iter</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_sent_when iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00943">peer_socket.hpp:943</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_abd6f3174914c3ec559954b4125f2f9dd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_seq_const_iter</a></div><div class="ttdeci">Sent_pkt_by_seq_num_map::const_iterator Sent_pkt_ordered_by_seq_const_iter</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_seq_num const iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00949">peer_socket.hpp:949</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ac4c942e1bb6c4dc4b24251f294a2f92d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ac4c942e1bb6c4dc4b24251f294a2f92d">flow::net_flow::Peer_socket::m_info_on_close</a></div><div class="ttdeci">Peer_socket_info m_info_on_close</div><div class="ttdoc">This is the final set of stats collected at the time the socket was moved to S_CLOSED m_state.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02163">peer_socket.hpp:2163</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ac7cbefb99ae173bd5f355f5d082564ce"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">flow::net_flow::Peer_socket::ensure_open</a></div><div class="ttdeci">bool ensure_open(Error_code *err_code) const</div><div class="ttdoc">Helper that is equivalent to Node::ensure_sock_open(this, err_code).</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00409">peer_socket.cpp:409</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ac974bdce3d2035d2af69078837f59482"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_const_iter</a></div><div class="ttdeci">Sent_pkt_by_sent_when_map::const_iterator Sent_pkt_ordered_by_when_const_iter</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_sent_when const iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00940">peer_socket.hpp:940</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_accf6d724ed1f145716ae3d4567f582f3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">flow::net_flow::Peer_socket::opt</a></div><div class="ttdeci">Opt_type opt(const Opt_type &amp;opt_val_ref) const</div><div class="ttdoc">Analogous to Node::opt() but for per-socket options.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02621">peer_socket.hpp:2621</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_acd100a3c02fad5d9e00fcbc1f645f116"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#acd100a3c02fad5d9e00fcbc1f645f116">flow::net_flow::Peer_socket::bytes_blocks_str</a></div><div class="ttdeci">std::string bytes_blocks_str(size_t bytes) const</div><div class="ttdoc">Helper that, given a byte count, returns a string with that byte count and the number of max_block_si...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00414">peer_socket.cpp:414</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ad59c09f34003873a3c207cc590236773"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">flow::net_flow::Peer_socket::m_opts</a></div><div class="ttdeci">Peer_socket_options m_opts</div><div class="ttdoc">This socket's per-socket set of options.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01175">peer_socket.hpp:1175</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ad94e37c8cca01f801f13e9e0e0bc857d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">flow::net_flow::Peer_socket::options</a></div><div class="ttdeci">Peer_socket_options options() const</div><div class="ttdoc">Copies this socket's option set and returns that copy.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00309">peer_socket.cpp:309</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_addfbe1487c621d4a9c464aec61bc108a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a">flow::net_flow::Peer_socket::m_opts_mutex</a></div><div class="ttdeci">Options_mutex m_opts_mutex</div><div class="ttdoc">The mutex protecting m_opts.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01178">peer_socket.hpp:1178</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_addfc181f4d43ab816b2ede9216bf9331"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">flow::net_flow::Peer_socket::Recvd_pkt_map</a></div><div class="ttdeci">std::map&lt; Sequence_number, boost::shared_ptr&lt; Received_packet &gt; &gt; Recvd_pkt_map</div><div class="ttdoc">Short-hand for m_rcv_packets_with_gaps type; see that data member.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00962">peer_socket.hpp:962</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ade41e13eb5176d833c7b1ea144612353"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">flow::net_flow::Peer_socket::Recvd_pkt_const_iter</a></div><div class="ttdeci">Recvd_pkt_map::const_iterator Recvd_pkt_const_iter</div><div class="ttdoc">Short-hand for m_rcv_packets_with_gaps const iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00965">peer_socket.hpp:965</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ae5d47460784cc20c9e44237edffaac95"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95">flow::net_flow::Peer_socket::m_open_sub_state</a></div><div class="ttdeci">Open_sub_state m_open_sub_state</div><div class="ttdoc">See state().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l01198">peer_socket.hpp:1198</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_af3ac1b0b3c9b1c3a5ec246148595c657"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657">flow::net_flow::Peer_socket::node_receive</a></div><div class="ttdeci">size_t node_receive(const Function&lt; size_t()&gt; &amp;rcv_buf_consume_func, Error_code *err_code)</div><div class="ttdoc">Non-template helper for template receive() that forwards the receive() logic to Node::receive().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00211">peer_socket.cpp:211</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_af982953b5136c1df488066eacc293a78"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">flow::net_flow::Peer_socket::state</a></div><div class="ttdeci">State state(Open_sub_state *open_sub_state=0) const</div><div class="ttdoc">Current State of the socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00085">peer_socket.cpp:85</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Port__space_html_a9fe1be917ff7584ff587b5da5967127a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Port__space.html#a9fe1be917ff7584ff587b5da5967127a">flow::net_flow::Port_space::return_port</a></div><div class="ttdeci">void return_port(flow_port_t port, Error_code *err_code)</div><div class="ttdoc">Return a previously reserved port (of any type).</div><div class="ttdef"><b>Definition:</b> <a href="port__space_8cpp_source.html#l00175">port_space.cpp:175</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Sequence__number_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Sequence__number.html">flow::net_flow::Sequence_number</a></div><div class="ttdoc">An internal net_flow sequence number identifying a piece of data.</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8hpp_source.html#l00125">seq_num.hpp:126</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Sequence__number_html_a77ce8cf348e93caa8bb03f22f7b7d120"><div class="ttname"><a href="classflow_1_1net__flow_1_1Sequence__number.html#a77ce8cf348e93caa8bb03f22f7b7d120">flow::net_flow::Sequence_number::set_metadata</a></div><div class="ttdeci">void set_metadata(char num_line_id=0, const Sequence_number &amp;zero_point=Sequence_number(), seq_num_delta_t multiple_size=0)</div><div class="ttdoc">Updates the full set of metadata (used at least for convenient convention-based logging but not actua...</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8cpp_source.html#l00268">seq_num.cpp:268</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Sequence__number_html_ab307e12c0cf8cefbe7fb1ec8588af2a8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Sequence__number.html#ab307e12c0cf8cefbe7fb1ec8588af2a8">flow::net_flow::Sequence_number::seq_num_t</a></div><div class="ttdeci">uint64_t seq_num_t</div><div class="ttdoc">Raw sequence number type.</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8hpp_source.html#l00138">seq_num.hpp:138</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Socket__buffer_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Socket__buffer.html">flow::net_flow::Socket_buffer</a></div><div class="ttdoc">Internal net_flow class that implements a socket buffer, as used by Peer_socket for Send and Receive ...</div><div class="ttdef"><b>Definition:</b> <a href="socket__buffer_8hpp_source.html#l00095">socket_buffer.hpp:98</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Socket__buffer_html_a8fe3fe5f6a33cfd8fb84eb2607fbc05b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Socket__buffer.html#a8fe3fe5f6a33cfd8fb84eb2607fbc05b">flow::net_flow::Socket_buffer::consume_buf_move</a></div><div class="ttdeci">void consume_buf_move(util::Blob *target_buf, size_t max_data_size)</div><div class="ttdoc">Consumes (removes from the front of the internal byte buffer and returns them to the caller) a byte s...</div><div class="ttdef"><b>Definition:</b> <a href="socket__buffer_8cpp_source.html#l00103">socket_buffer.cpp:103</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Socket__buffer_html_af21cd24bba62da1d16a8fc4f9b8e37fd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Socket__buffer.html#af21cd24bba62da1d16a8fc4f9b8e37fd">flow::net_flow::Socket_buffer::data_size</a></div><div class="ttdeci">size_t data_size() const</div><div class="ttdoc">The total number of bytes of application-layer data stored in this object.</div><div class="ttdef"><b>Definition:</b> <a href="socket__buffer_8cpp_source.html#l00034">socket_buffer.cpp:34</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Container__traits_html"><div class="ttname"><a href="classflow_1_1util_1_1Container__traits.html">flow::util::Container_traits</a></div><div class="ttdoc">Properties of various container types.</div><div class="ttdef"><b>Definition:</b> <a href="traits_8hpp_source.html#l00042">traits.hpp:43</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Linked__hash__map_html_a10095310ddb7fe3d7cf35d957cc1c477"><div class="ttname"><a href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">flow::util::Linked_hash_map&lt; Sequence_number, boost::shared_ptr&lt; Sent_packet &gt; &gt;::Const_reverse_iterator</a></div><div class="ttdeci">typename Value_list::const_reverse_iterator Const_reverse_iterator</div><div class="ttdoc">Type for reverse iterator pointing into an immutable structure of this type.</div><div class="ttdef"><b>Definition:</b> <a href="linked__hash__map_8hpp_source.html#l00108">linked_hash_map.hpp:108</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Linked__hash__map_html_a18f09acd8df06d9479840862b228463d"><div class="ttname"><a href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">flow::util::Linked_hash_map&lt; Sequence_number, boost::shared_ptr&lt; Sent_packet &gt; &gt;::Reverse_iterator</a></div><div class="ttdeci">typename Value_list::reverse_iterator Reverse_iterator</div><div class="ttdoc">Type for reverse iterator pointing into a mutable structure of this type.</div><div class="ttdef"><b>Definition:</b> <a href="linked__hash__map_8hpp_source.html#l00105">linked_hash_map.hpp:105</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Linked__hash__map_html_aae7a4a3047c90f0ab26ae1a4ec7b9963"><div class="ttname"><a href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963">flow::util::Linked_hash_map::insert</a></div><div class="ttdeci">std::pair&lt; Iterator, bool &gt; insert(Value const &amp;key_and_mapped)</div><div class="ttdoc">Attempts to insert the given key/mapped-value pair into the map.</div><div class="ttdef"><b>Definition:</b> <a href="linked__hash__map_8hpp_source.html#l00761">linked_hash_map.hpp:761</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_a55a247bb8fb2ec94b7cbfdd56be65a81"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast</a></div><div class="ttdeci">static Ptr ptr_cast(const From_ptr &amp;ptr_to_cast)</div><div class="ttdoc">Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00135">shared_ptr_alias_holder.hpp:180</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_aa4f1af88393042e60159a3a67f0accbc"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;::Ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Peer_socket &gt; Ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00118">shared_ptr_alias_holder.hpp:118</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_aef7998db71c60eeb5d1e3d1a97c14886"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;::Const_ptr</a></div><div class="ttdeci">Const_target_ptr Const_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to immutable values of type Target_type::element_type (a-la T cons...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00120">shared_ptr_alias_holder.hpp:120</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1String__ostream_html"><div class="ttname"><a href="classflow_1_1util_1_1String__ostream.html">flow::util::String_ostream</a></div><div class="ttdoc">Similar to ostringstream but allows fast read-only access directly into the std::string being written...</div><div class="ttdef"><b>Definition:</b> <a href="string__ostream_8hpp_source.html#l00045">string_ostream.hpp:47</a></div></div>
<div class="ttc" id="acong__ctl_8hpp_html"><div class="ttname"><a href="cong__ctl_8hpp.html">cong_ctl.hpp</a></div></div>
<div class="ttc" id="adrop__timer_8hpp_html"><div class="ttname"><a href="drop__timer_8hpp.html">drop_timer.hpp</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_a019ee6e90802e444572dd78d312d6e23"><div class="ttname"><a href="error_2error_8hpp.html#a019ee6e90802e444572dd78d312d6e23">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a></div><div class="ttdeci">#define FLOW_ERROR_SYS_ERROR_LOG_WARNING()</div><div class="ttdoc">Logs a warning about the (often errno-based or from a library) error code in sys_err_code.</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00269">error.hpp:269</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_a5d44fa375b0080a95f45f664c0407c72"><div class="ttname"><a href="error_2error_8hpp.html#a5d44fa375b0080a95f45f664c0407c72">FLOW_ERROR_LOG_ERROR</a></div><div class="ttdeci">#define FLOW_ERROR_LOG_ERROR(ARG_val)</div><div class="ttdoc">Logs a warning about the given error code using FLOW_LOG_WARNING().</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00233">error.hpp:233</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_a636b2d30a8785df6e84646b568bce9b5"><div class="ttname"><a href="error_2error_8hpp.html#a636b2d30a8785df6e84646b568bce9b5">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a></div><div class="ttdeci">#define FLOW_ERROR_EXEC_AND_THROW_ON_ERROR(ARG_ret_type, ARG_function_name,...)</div><div class="ttdoc">Narrow-use macro that implements the error code/exception semantics expected of most public-facing Fl...</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00363">error.hpp:363</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_ab6b8ed79012c994cfc381e0b92c066fd"><div class="ttname"><a href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a></div><div class="ttdeci">#define FLOW_ERROR_EMIT_ERROR(ARG_val)</div><div class="ttdoc">Sets *err_code to ARG_val and logs a warning about the error using FLOW_LOG_WARNING().</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00202">error.hpp:202</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_adc17094d4b9421abd04b90caab8b8e72"><div class="ttname"><a href="error_2error_8hpp.html#adc17094d4b9421abd04b90caab8b8e72">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a></div><div class="ttdeci">#define FLOW_ERROR_EMIT_ERROR_LOG_INFO(ARG_val)</div><div class="ttdoc">Identical to FLOW_ERROR_EMIT_ERROR(), but the message logged has flow::log::Sev::S_INFO severity inst...</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00218">error.hpp:218</a></div></div>
<div class="ttc" id="alog_8hpp_html_a07561c1c3f16b6c2c7335a09e25298c9"><div class="ttname"><a href="log_8hpp.html#a07561c1c3f16b6c2c7335a09e25298c9">FLOW_LOG_DATA</a></div><div class="ttdeci">#define FLOW_LOG_DATA(ARG_stream_fragment)</div><div class="ttdoc">Logs a DATA message into flow::log::Logger *get_logger() with flow::log::Component get_log_component(...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00242">log.hpp:242</a></div></div>
<div class="ttc" id="alog_8hpp_html_a325fdd4b5cf0be49b37d3b7b7c29070d"><div class="ttname"><a href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a></div><div class="ttdeci">#define FLOW_LOG_INFO(ARG_stream_fragment)</div><div class="ttdoc">Logs an INFO message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00197">log.hpp:197</a></div></div>
<div class="ttc" id="alog_8hpp_html_a5daa2b6d16edea74bb8bddc75f7fb801"><div class="ttname"><a href="log_8hpp.html#a5daa2b6d16edea74bb8bddc75f7fb801">FLOW_LOG_WITHOUT_CHECKING</a></div><div class="ttdeci">#define FLOW_LOG_WITHOUT_CHECKING(ARG_sev, ARG_stream_fragment)</div><div class="ttdoc">Identical to FLOW_LOG_WITH_CHECKING() but foregoes the filter (Logger::should_log()) check.</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00532">log.hpp:532</a></div></div>
<div class="ttc" id="alog_8hpp_html_a626c7dc4d3b4dc0b32a8aac8624d66bc"><div class="ttname"><a href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a></div><div class="ttdeci">#define FLOW_LOG_WARNING(ARG_stream_fragment)</div><div class="ttdoc">Logs a WARNING message into flow::log::Logger *get_logger() with flow::log::Component get_log_compone...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00152">log.hpp:152</a></div></div>
<div class="ttc" id="alog_8hpp_html_a692bbadd8b5c3e9cef7a0bbea1915e66"><div class="ttname"><a href="log_8hpp.html#a692bbadd8b5c3e9cef7a0bbea1915e66">FLOW_LOG_WITH_CHECKING</a></div><div class="ttdeci">#define FLOW_LOG_WITH_CHECKING(ARG_sev, ARG_stream_fragment)</div><div class="ttdoc">Logs a message of the specified severity into flow::log::Logger *get_logger() with flow::log::Compone...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00489">log.hpp:489</a></div></div>
<div class="ttc" id="alog_8hpp_html_a6b3b2cd7ddabf90a7c6ccd104a042cc6"><div class="ttname"><a href="log_8hpp.html#a6b3b2cd7ddabf90a7c6ccd104a042cc6">FLOW_LOG_TRACE_WITHOUT_CHECKING</a></div><div class="ttdeci">#define FLOW_LOG_TRACE_WITHOUT_CHECKING(ARG_stream_fragment)</div><div class="ttdoc">Logs a TRACE message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00354">log.hpp:354</a></div></div>
<div class="ttc" id="alog_8hpp_html_a9aa1d91ba9eb26345d4b83588ac489cb"><div class="ttname"><a href="log_8hpp.html#a9aa1d91ba9eb26345d4b83588ac489cb">FLOW_LOG_DATA_WITHOUT_CHECKING</a></div><div class="ttdeci">#define FLOW_LOG_DATA_WITHOUT_CHECKING(ARG_stream_fragment)</div><div class="ttdoc">Logs a DATA message into flow::log::Logger *get_logger() with flow::log::Component get_log_component(...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00372">log.hpp:372</a></div></div>
<div class="ttc" id="alog_8hpp_html_affcf2e4c496ce3f42adf981669c623b8"><div class="ttname"><a href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div><div class="ttdeci">#define FLOW_LOG_TRACE(ARG_stream_fragment)</div><div class="ttdoc">Logs a TRACE message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00227">log.hpp:227</a></div></div>
<div class="ttc" id="anamespaceflow_1_1async_html_a0a06794b16b72f2829ce3353557c8485"><div class="ttname"><a href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">flow::async::Synchronicity</a></div><div class="ttdeci">Synchronicity</div><div class="ttdoc">Enumeration indicating the manner in which asio_exec_ctx_post(), and various boost....</div><div class="ttdef"><b>Definition:</b> <a href="async__fwd_8hpp_source.html#l00222">async_fwd.hpp:223</a></div></div>
<div class="ttc" id="anamespaceflow_1_1async_html_a24567271e97a67d3cae6bd8bf8dc63c4"><div class="ttname"><a href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">flow::async::asio_exec_ctx_post</a></div><div class="ttdeci">void asio_exec_ctx_post(log::Logger *logger_ptr, Execution_context *exec_ctx, Synchronicity synchronicity, Task &amp;&amp;task)</div><div class="ttdoc">An extension of boost.asio's post() and dispatch() free function templates, this free function templa...</div><div class="ttdef"><b>Definition:</b> <a href="async_2util_8hpp_source.html#l00031">util.hpp:31</a></div></div>
<div class="ttc" id="anamespaceflow_1_1error_html_a48afa7f8c2e100acd461365dfb00a114"><div class="ttname"><a href="namespaceflow_1_1error.html#a48afa7f8c2e100acd461365dfb00a114">flow::error::exec_void_and_throw_on_error</a></div><div class="ttdeci">bool exec_void_and_throw_on_error(const Func &amp;func, Error_code *err_code, util::String_view context)</div><div class="ttdoc">Equivalent of exec_and_throw_on_error() for operations with void return type.</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00168">error.hpp:168</a></div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::Sev::S_DATA</a></div><div class="ttdeci">@ S_DATA</div><div class="ttdoc">Message satisfies Sev::S_TRACE description AND contains variable-length structure (like packet,...</div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::Sev::S_TRACE</a></div><div class="ttdeci">@ S_TRACE</div><div class="ttdoc">Message indicates any condition that may occur with great frequency (thus verbose if logged).</div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">flow::log::Sev::S_INFO</a></div><div class="ttdeci">@ S_INFO</div><div class="ttdoc">Message indicates a not-&quot;bad&quot; condition that is not frequent enough to be of severity Sev::S_TRACE.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090">flow::net_flow::error::Code::S_CONN_TIMEOUT</a></div><div class="ttdeci">@ S_CONN_TIMEOUT</div><div class="ttdoc">Other side did not complete connection handshake within the allowed time; perhaps no one is listening...</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8">flow::net_flow::error::Code::S_USER_CLOSED_ABRUPTLY</a></div><div class="ttdeci">@ S_USER_CLOSED_ABRUPTLY</div><div class="ttdoc">User code on this side abruptly closed connection; other side may be informed of this.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a3c1dc923491f5e20763fc27d025665d4"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3c1dc923491f5e20763fc27d025665d4">flow::net_flow::error::Code::S_CONN_RESET_TOO_MANY_REXMITS</a></div><div class="ttdeci">@ S_CONN_RESET_TOO_MANY_REXMITS</div><div class="ttdoc">Connection reset because a packet has been retransmitted too many times.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765">flow::net_flow::error::Code::S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</a></div><div class="ttdeci">@ S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</div><div class="ttdoc">Other side has sent packet with sequence number that implies a port collision between two connections...</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">flow::net_flow::error::Code::S_SEQ_NUM_ARITHMETIC_FAILURE</a></div><div class="ttdeci">@ S_SEQ_NUM_ARITHMETIC_FAILURE</div><div class="ttdoc">Other side has sent packets with inconsistent sequence numbers.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd">flow::net_flow::error::Code::S_CONN_METADATA_TOO_LARGE</a></div><div class="ttdeci">@ S_CONN_METADATA_TOO_LARGE</div><div class="ttdoc">During connection user supplied metadata that is too large.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99">flow::net_flow::error::Code::S_CANNOT_CONNECT_TO_IP_ANY</a></div><div class="ttdeci">@ S_CANNOT_CONNECT_TO_IP_ANY</div><div class="ttdoc">Cannot ask to connect to &quot;any&quot; IP address. Use specific IP address.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c">flow::net_flow::error::Code::S_WAIT_USER_TIMEOUT</a></div><div class="ttdeci">@ S_WAIT_USER_TIMEOUT</div><div class="ttdoc">A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5">flow::net_flow::error::Code::S_WAIT_INTERRUPTED</a></div><div class="ttdeci">@ S_WAIT_INTERRUPTED</div><div class="ttdoc">A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::Code::S_EVENT_SET_CLOSED</a></div><div class="ttdeci">@ S_EVENT_SET_CLOSED</div><div class="ttdoc">Attempted operation on an event set, when that event set was closed.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2">flow::net_flow::error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a></div><div class="ttdeci">@ S_INTERNAL_ERROR_PORT_COLLISION</div><div class="ttdoc">Internal error: Ephemeral port double reservation allowed.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::Code::S_NODE_NOT_RUNNING</a></div><div class="ttdeci">@ S_NODE_NOT_RUNNING</div><div class="ttdoc">Node not running.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html"><div class="ttname"><a href="namespaceflow_1_1net__flow.html">flow::net_flow</a></div><div class="ttdoc">Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...</div><div class="ttdef"><b>Definition:</b> <a href="asio_2node_8cpp_source.html#l00024">node.cpp:25</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a079d8cd87a68d1c5f04c6bce71f0061d"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow::net_flow::flow_port_t</a></div><div class="ttdeci">uint16_t flow_port_t</div><div class="ttdoc">Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).</div><div class="ttdef"><b>Definition:</b> <a href="net__flow__fwd_8hpp_source.html#l00054">net_flow_fwd.hpp:54</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a9dd0c9d8de00fab78d8b0a3f50dad2a9"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">flow::net_flow::S_PORT_ANY</a></div><div class="ttdeci">const flow_port_t S_PORT_ANY</div><div class="ttdoc">Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...</div><div class="ttdef"><b>Definition:</b> <a href="port__space_8cpp_source.html#l00033">port_space.cpp:33</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_ab9f537c84f77e9b8fa742fc5dc6d5693"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#ab9f537c84f77e9b8fa742fc5dc6d5693">flow::net_flow::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Congestion_control_selector::Strategy_choice &amp;strategy_choice)</div><div class="ttdoc">Serializes a Peer_socket_options::Congestion_control_strategy_choice enum to a standard ostream – the...</div><div class="ttdef"><b>Definition:</b> <a href="cong__ctl_8cpp_source.html#l00146">cong_ctl.cpp:146</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a03984e29450abf9cf287c501d6c8f866"><div class="ttname"><a href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">flow::util::key_exists</a></div><div class="ttdeci">bool key_exists(const Container &amp;container, const typename Container::key_type &amp;key)</div><div class="ttdoc">Returns true if and only if the given key is present at least once in the given associative container...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00301">util.hpp:301</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a09a032f8e1e77a3afc0b7df115a773e1"><div class="ttname"><a href="namespaceflow_1_1util.html#a09a032f8e1e77a3afc0b7df115a773e1">flow::util::setup_auto_cleanup</a></div><div class="ttdeci">Auto_cleanup setup_auto_cleanup(const Cleanup_func &amp;func)</div><div class="ttdoc">Provides a way to execute arbitrary (cleanup) code at the exit of the current block.</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00307">util.hpp:307</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a16357344c21456b86b7de3085e2661a2"><div class="ttname"><a href="namespaceflow_1_1util.html#a16357344c21456b86b7de3085e2661a2">flow::util::buffers_dump_string</a></div><div class="ttdeci">std::string buffers_dump_string(const Const_buffer_sequence &amp;data, const std::string &amp;indentation, size_t bytes_per_line)</div><div class="ttdoc">Identical to buffers_to_ostream() but returns an std::string instead of writing to a given ostream.</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00506">util.hpp:506</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a34ed70fa4de81a4fdb9234bfb5a3a914"><div class="ttname"><a href="namespaceflow_1_1util.html#a34ed70fa4de81a4fdb9234bfb5a3a914">flow::util::subtract_with_floor</a></div><div class="ttdeci">bool subtract_with_floor(Minuend *minuend, const Subtrahend &amp;subtrahend, const Minuend &amp;floor)</div><div class="ttdoc">Performs *minuend -= subtrahend, subject to a floor of floor.</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00324">util.hpp:324</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a6b7316b3ed6d89f54c91e17c2aab101e"><div class="ttname"><a href="namespaceflow_1_1util.html#a6b7316b3ed6d89f54c91e17c2aab101e">flow::util::ceil_div</a></div><div class="ttdeci">Integer ceil_div(Integer dividend, Integer divisor)</div><div class="ttdoc">Returns the result of the given non-negative integer divided by a positive integer,...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00258">util.hpp:258</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a733448fee07c2a77e343a3f1590ff82e"><div class="ttname"><a href="namespaceflow_1_1util.html#a733448fee07c2a77e343a3f1590ff82e">flow::util::in_open_open_range</a></div><div class="ttdeci">bool in_open_open_range(T const &amp;min_val, T const &amp;val, T const &amp;max_val)</div><div class="ttdoc">Returns true if and only if the given value is within the given range, given as a (low,...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00295">util.hpp:295</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a74d4a66fb00055be4e1bd6ee98e04667"><div class="ttname"><a href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667">flow::util::schedule_task_from_now</a></div><div class="ttdeci">Scheduled_task_handle schedule_task_from_now(log::Logger *logger_ptr, const Fine_duration &amp;from_now, bool single_threaded, Task_engine *task_engine, Scheduled_task_handler &amp;&amp;task_body_moved)</div><div class="ttdoc">Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...</div><div class="ttdef"><b>Definition:</b> <a href="sched__task_8hpp_source.html#l00034">sched_task.hpp:34</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a79a0f182b38898771d669475d3e963a4"><div class="ttname"><a href="namespaceflow_1_1util.html#a79a0f182b38898771d669475d3e963a4">flow::util::scheduled_task_fired</a></div><div class="ttdeci">bool scheduled_task_fired(log::Logger *logger_ptr, Scheduled_task_const_handle task)</div><div class="ttdoc">Returns whether a previously scheduled (by schedule_task_from_now() or similar) task has already fire...</div><div class="ttdef"><b>Definition:</b> <a href="sched__task_8cpp_source.html#l00238">sched_task.cpp:238</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a8ae762ea4f743a98a73953d7f9ec2164"><div class="ttname"><a href="namespaceflow_1_1util.html#a8ae762ea4f743a98a73953d7f9ec2164">flow::util::in_open_closed_range</a></div><div class="ttdeci">bool in_open_closed_range(T const &amp;min_val, T const &amp;val, T const &amp;max_val)</div><div class="ttdoc">Returns true if and only if the given value is within the given range, given as a (low,...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00279">util.hpp:279</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a8afd30c50bcd670d45442df49d1da484"><div class="ttname"><a href="namespaceflow_1_1util.html#a8afd30c50bcd670d45442df49d1da484">flow::util::ostream_op_to_string</a></div><div class="ttdeci">void ostream_op_to_string(std::string *target_str, T const &amp;... ostream_args)</div><div class="ttdoc">Writes to the specified string, as if the given arguments were each passed, via &lt;&lt; in sequence,...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00367">util.hpp:367</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a9a0812b36dc401a3b2ac5e60e2a070d0"><div class="ttname"><a href="namespaceflow_1_1util.html#a9a0812b36dc401a3b2ac5e60e2a070d0">flow::util::scheduled_task_fires_from_now_or_canceled</a></div><div class="ttdeci">Fine_duration scheduled_task_fires_from_now_or_canceled(log::Logger *logger_ptr, Scheduled_task_const_handle task)</div><div class="ttdoc">Returns how long remains until a previously scheduled (by schedule_task_from_now() or similar) task f...</div><div class="ttdef"><b>Definition:</b> <a href="sched__task_8cpp_source.html#l00200">sched_task.cpp:200</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_aa0d10f5a906b3229f48979aa43e9ff7e"><div class="ttname"><a href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">flow::util::Scheduled_task_handle</a></div><div class="ttdeci">boost::shared_ptr&lt; Scheduled_task_handle_state &gt; Scheduled_task_handle</div><div class="ttdoc">Black-box type that represents a handle to a scheduled task as scheduled by schedule_task_at() or sch...</div><div class="ttdef"><b>Definition:</b> <a href="sched__task__fwd_8hpp_source.html#l00045">sched_task_fwd.hpp:45</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ab10bc9e8bef148f875aa743fe0852743"><div class="ttname"><a href="namespaceflow_1_1util.html#ab10bc9e8bef148f875aa743fe0852743">flow::util::in_closed_range</a></div><div class="ttdeci">bool in_closed_range(T const &amp;min_val, T const &amp;val, T const &amp;max_val)</div><div class="ttdoc">Returns true if and only if the given value is within the given range, inclusive.</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00271">util.hpp:271</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ab22fd89e165a9e6deaa174bc0dfdc8de"><div class="ttname"><a href="namespaceflow_1_1util.html#ab22fd89e165a9e6deaa174bc0dfdc8de">flow::util::Auto_cleanup</a></div><div class="ttdeci">boost::shared_ptr&lt; void &gt; Auto_cleanup</div><div class="ttdoc">Helper type for setup_auto_cleanup().</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00205">util_fwd.hpp:205</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ac3e89a8a271b0ddc76ac2a0ce488dea4"><div class="ttname"><a href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">flow::util::Task_engine</a></div><div class="ttdeci">boost::asio::io_context Task_engine</div><div class="ttdoc">Short-hand for boost.asio event service, the central class of boost.asio.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00135">util_fwd.hpp:135</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ad92e68a1b22556f2625292098c0036a2"><div class="ttname"><a href="namespaceflow_1_1util.html#ad92e68a1b22556f2625292098c0036a2">flow::util::scheduled_task_cancel</a></div><div class="ttdeci">bool scheduled_task_cancel(log::Logger *logger_ptr, Scheduled_task_handle task)</div><div class="ttdoc">Attempts to prevent the execution of a previously scheduled (by schedule_task_from_now() or similar) ...</div><div class="ttdef"><b>Definition:</b> <a href="sched__task_8cpp_source.html#l00026">sched_task.cpp:26</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_af09888b3a8feaff209b6625e493bc338"><div class="ttname"><a href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">flow::util::Blob</a></div><div class="ttdeci">Blob_with_log_context&lt;&gt; Blob</div><div class="ttdoc">A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...</div><div class="ttdef"><b>Definition:</b> <a href="blob__fwd_8hpp_source.html#l00060">blob_fwd.hpp:60</a></div></div>
<div class="ttc" id="anamespaceflow_html_a29eaaa9d0fac4ce87d8b969222dbed09"><div class="ttname"><a href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">flow::Error_code</a></div><div class="ttdeci">boost::system::error_code Error_code</div><div class="ttdoc">Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00508">common.hpp:508</a></div></div>
<div class="ttc" id="anamespaceflow_html_a3938730ab4b89daf13d027a5f620e7ce"><div class="ttname"><a href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">flow::Flow_log_component</a></div><div class="ttdeci">Flow_log_component</div><div class="ttdoc">The flow::log::Component payload enumeration comprising various log components used by Flow's own int...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00637">common.hpp:638</a></div></div>
<div class="ttc" id="anamespaceflow_html_a48799f1263cdeedec125be51a3db2b79"><div class="ttname"><a href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">flow::Fine_duration</a></div><div class="ttdeci">Fine_clock::duration Fine_duration</div><div class="ttdoc">A high-res time duration as computed from two Fine_time_pts.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00416">common.hpp:416</a></div></div>
<div class="ttc" id="anamespaceflow_html_a9d9cc2eeb10d398cff5591d446b763b8"><div class="ttname"><a href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">flow::Fine_time_pt</a></div><div class="ttdeci">Fine_clock::time_point Fine_time_pt</div><div class="ttdoc">A high-res time point as returned by Fine_clock::now() and suitable for precise time math in general.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00413">common.hpp:413</a></div></div>
<div class="ttc" id="anamespaceflow_html_ae02da22c4a101eaab447511c905e4f32"><div class="ttname"><a href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">flow::uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">Byte. Best way to represent a byte of binary data. This is 8 bits on all modern systems.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00391">common.hpp:391</a></div></div>
<div class="ttc" id="anode_8hpp_html"><div class="ttname"><a href="node_8hpp.html">node.hpp</a></div></div>
<div class="ttc" id="apeer__socket_8hpp_html"><div class="ttname"><a href="peer__socket_8hpp.html">peer_socket.hpp</a></div></div>
<div class="ttc" id="asched__task_8hpp_html"><div class="ttname"><a href="sched__task_8hpp.html">sched_task.hpp</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__off_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__off.html">flow::net_flow::Ack_packet::Individual_ack_rexmit_off</a></div><div class="ttdoc">Specifies the outgoing (pre-serialization) acknowledgment of a single received Data_packet,...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01250">low_lvl_packet.hpp:1251</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__on_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack__rexmit__on.html">flow::net_flow::Ack_packet::Individual_ack_rexmit_on</a></div><div class="ttdoc">Equivalent of Individual_ack_rexmit_off but for sockets with retransmission enabled.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01282">low_lvl_packet.hpp:1283</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html">flow::net_flow::Ack_packet::Individual_ack</a></div><div class="ttdoc">Specifies the incoming (post-deserialization) acknowledgment of a single received Data_packet.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01195">low_lvl_packet.hpp:1197</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack_html_a55bebcb04b4cc192e38023e58bfd761c"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">flow::net_flow::Ack_packet::Individual_ack::Const_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; const Individual_ack &gt; Const_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to immutable objects of this class.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01204">low_lvl_packet.hpp:1204</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_html_a374da5eef60c7d8a4085b41cf7b2adfe"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet.html#a374da5eef60c7d8a4085b41cf7b2adfe">flow::net_flow::Ack_packet::ack_delay_t</a></div><div class="ttdeci">uint64_t ack_delay_t</div><div class="ttdoc">Type used to store the ACK delay for a given individual acknowledged packet.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01040">low_lvl_packet.hpp:1040</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_html_abd3bc7f9e9195bf1b4aca2cad881646c"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet.html#abd3bc7f9e9195bf1b4aca2cad881646c">flow::net_flow::Ack_packet::Ack_delay_time_unit</a></div><div class="ttdeci">Fine_duration Ack_delay_time_unit</div><div class="ttdoc">Ack_delay_time_unit(1) is the duration corresponding to the ack_delay_t value 1; and proportionally f...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01043">low_lvl_packet.hpp:1043</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Low__lvl__packet_html_a01ff17bec742d9e363aea2ecd23f2f72"><div class="ttname"><a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">flow::net_flow::Low_lvl_packet::rcv_wnd_t</a></div><div class="ttdeci">uint32_t rcv_wnd_t</div><div class="ttdoc">Type used to store the size of m_rcv_wnd member in a couple of different packet types.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l00203">low_lvl_packet.hpp:203</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Low__lvl__packet_html_a11e7750d22415a381e23112062f7ca74"><div class="ttname"><a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a11e7750d22415a381e23112062f7ca74">flow::net_flow::Low_lvl_packet::rexmit_id_t</a></div><div class="ttdeci">uint8_t rexmit_id_t</div><div class="ttdoc">Type used to store the retransmission count in DATA and ACK packets.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l00200">low_lvl_packet.hpp:200</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node_1_1Socket__id_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">flow::net_flow::Node::Socket_id</a></div><div class="ttdoc">The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to a port in th...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03861">node.hpp:3862</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html">flow::net_flow::Peer_socket::Individual_ack</a></div><div class="ttdoc">Metadata describing the data sent in the acknowledgment of an individual received packet.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02379">peer_socket.hpp:2381</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack_html_a209d79e058d103c84fc10be84d492a8b"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#a209d79e058d103c84fc10be84d492a8b">flow::net_flow::Peer_socket::Individual_ack::Const_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; const Individual_ack &gt; Const_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to immutable objects of this class.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02388">peer_socket.hpp:2388</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack_html_ad32d17739f7965eeeedfbeae5bfbc1a3"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#ad32d17739f7965eeeedfbeae5bfbc1a3">flow::net_flow::Peer_socket::Individual_ack::Ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Individual_ack &gt; Ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to mutable objects of this class.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02385">peer_socket.hpp:2385</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Received__packet_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">flow::net_flow::Peer_socket::Received_packet</a></div><div class="ttdoc">Metadata (and data, if retransmission is on) for a packet that has been received (and,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02334">peer_socket.hpp:2338</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Received__packet_html_a7d0760b1dead081bdcf775fbca7f708b"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a7d0760b1dead081bdcf775fbca7f708b">flow::net_flow::Peer_socket::Received_packet::m_size</a></div><div class="ttdeci">const size_t m_size</div><div class="ttdoc">Number of bytes in the Data_packet::m_data field of that packet.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02342">peer_socket.hpp:2342</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Received__packet_html_a9f0809d5dd7272e31f4111ee2be97330"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a9f0809d5dd7272e31f4111ee2be97330">flow::net_flow::Peer_socket::Received_packet::Received_packet</a></div><div class="ttdeci">Received_packet(log::Logger *logger_ptr, size_t size, util::Blob *src_data)</div><div class="ttdoc">Constructs object by storing size of data and, if so instructed, the data themselves.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00441">peer_socket.cpp:441</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Received__packet_html_ac3e88e37e53d2572f89c599e520e3e2a"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#ac3e88e37e53d2572f89c599e520e3e2a">flow::net_flow::Peer_socket::Received_packet::m_data</a></div><div class="ttdeci">util::Blob m_data</div><div class="ttdoc">Byte sequence equal to that of Data_packet::m_data of the packet.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02350">peer_socket.hpp:2350</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">flow::net_flow::Peer_socket::Sent_packet::Sent_when</a></div><div class="ttdoc">Data store to keep timing related info when a packet is sent out.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02279">peer_socket.hpp:2280</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when_html_a5265c3824ad25d1de4f888fa811dd4e6"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_order_num</a></div><div class="ttdeci">const order_num_t m_order_num</div><div class="ttdoc">Order number of the packet.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02294">peer_socket.hpp:2294</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when_html_abc5bf2e627dad5d2dcfb0324853b37f7"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#abc5bf2e627dad5d2dcfb0324853b37f7">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_sent_cwnd_bytes</a></div><div class="ttdeci">size_t m_sent_cwnd_bytes</div><div class="ttdoc">The congestion window size (in bytes) that is used when the packet is sent out.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02324">peer_socket.hpp:2324</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when_html_ad513e58f4eb611c3a91d96df26f53f2c"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#ad513e58f4eb611c3a91d96df26f53f2c">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_sent_time</a></div><div class="ttdeci">Fine_time_pt m_sent_time</div><div class="ttdoc">The timestamp when the packet is sent out.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02306">peer_socket.hpp:2306</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">flow::net_flow::Peer_socket::Sent_packet</a></div><div class="ttdoc">Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02174">peer_socket.hpp:2178</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a28eb52fe9520497d02f6c0cd51a5fa9b"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a28eb52fe9520497d02f6c0cd51a5fa9b">flow::net_flow::Peer_socket::Sent_packet::Sent_packet</a></div><div class="ttdeci">Sent_packet(bool rexmit_on, boost::shared_ptr&lt; Data_packet &gt; packet, const Sent_when &amp;sent_when)</div><div class="ttdoc">Constructs object with the given values and m_acks_after_me at zero.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00430">peer_socket.cpp:430</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e">flow::net_flow::Peer_socket::Sent_packet::m_sent_when</a></div><div class="ttdeci">std::vector&lt; Sent_when &gt; m_sent_when</div><div class="ttdoc">Time stamps, order numbers, and other info at the times when the different attempts (including origin...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02217">peer_socket.hpp:2217</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a5b5762a1effba90f631c06ad76f9774b"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a5b5762a1effba90f631c06ad76f9774b">flow::net_flow::Peer_socket::Sent_packet::m_size</a></div><div class="ttdeci">const size_t m_size</div><div class="ttdoc">Number of bytes in the Data_packet::m_data field of the sent packet.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02195">peer_socket.hpp:2195</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a704afa0007b8354ad78acad64d029ecf"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a704afa0007b8354ad78acad64d029ecf">flow::net_flow::Peer_socket::Sent_packet::m_packet</a></div><div class="ttdeci">const boost::shared_ptr&lt; Data_packet &gt; m_packet</div><div class="ttdoc">If retransmission is on, this is the DATA packet itself that was sent; otherwise null.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02251">peer_socket.hpp:2251</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a7913f73b4e2f164ca51ebb505b63c1f2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">flow::net_flow::Peer_socket::Sent_packet::ack_count_t</a></div><div class="ttdeci">uint16_t ack_count_t</div><div class="ttdoc">Type used for m_acks_after_me.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02190">peer_socket.hpp:2190</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_affeb974bc03966744adfcda0366a50aa"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa">flow::net_flow::Peer_socket::Sent_packet::m_acks_after_me</a></div><div class="ttdeci">ack_count_t m_acks_after_me</div><div class="ttdoc">The number of times any packet with m_sent_when.back().m_order_num &gt; this-&gt;m_sent_when....</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02236">peer_socket.hpp:2236</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html">flow::net_flow::Peer_socket_info</a></div><div class="ttdoc">A data store that keeps stats about the a Peer_socket connection.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00455">info.hpp:456</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a02c61270ec35141affc5bb9f6edc5cd0"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a02c61270ec35141affc5bb9f6edc5cd0">flow::net_flow::Peer_socket_info::m_snd</a></div><div class="ttdeci">Peer_socket_send_stats m_snd</div><div class="ttdoc">Stats for outgoing direction of traffic. As opposed to the other m_snd_* members, this typically accu...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00511">info.hpp:511</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a05abba2bde50995af42cd6cf02d0b167"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a05abba2bde50995af42cd6cf02d0b167">flow::net_flow::Peer_socket_info::m_node_opts</a></div><div class="ttdeci">Node_options m_node_opts</div><div class="ttdoc">Per-node options currently set on the socket's Node.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00651">info.hpp:651</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a0ddfcfe377cda3266dfc968797ce4c18"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a0ddfcfe377cda3266dfc968797ce4c18">flow::net_flow::Peer_socket_info::m_low_lvl_max_buf_size</a></div><div class="ttdeci">size_t m_low_lvl_max_buf_size</div><div class="ttdoc">The UDP receive buffer maximum size, as reported by an appropriate call to the appropriate getsockopt...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00526">info.hpp:526</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a127a03a0b0e2f73d1059b7b42f251fa2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a127a03a0b0e2f73d1059b7b42f251fa2">flow::net_flow::Peer_socket_info::m_rcv_buf_size</a></div><div class="ttdeci">size_t m_rcv_buf_size</div><div class="ttdoc">The number of bytes in the internal Receive buffer.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00549">info.hpp:549</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a2562eebd9be1837147fef6fa616cb920"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a2562eebd9be1837147fef6fa616cb920">flow::net_flow::Peer_socket_info::m_rcv_wnd_last_advertised</a></div><div class="ttdeci">size_t m_rcv_wnd_last_advertised</div><div class="ttdoc">The last rcv_wnd (receive window) size sent to sender (not necessarily received; packets can be lost)...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00555">info.hpp:555</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a36ab155050d2cc96c5dc7dc9a2d1e2b1"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a36ab155050d2cc96c5dc7dc9a2d1e2b1">flow::net_flow::Peer_socket_info::m_snd_pacing_slice_period</a></div><div class="ttdeci">Fine_duration m_snd_pacing_slice_period</div><div class="ttdoc">In pacing, the duration of the current pacing time slice.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00629">info.hpp:629</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a3a38b2a47235621222eb58e6212a4f05"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3a38b2a47235621222eb58e6212a4f05">flow::net_flow::Peer_socket_info::m_rcv_reassembly_q_data_size</a></div><div class="ttdeci">size_t m_rcv_reassembly_q_data_size</div><div class="ttdoc">If rexmit_on is false then 0; otherwise the total DATA payload in the reassembly queue of the socket.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00558">info.hpp:558</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a3ac6229cdcd3e949523658b02fa7d0e0"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3ac6229cdcd3e949523658b02fa7d0e0">flow::net_flow::Peer_socket_info::m_snd_pacing_bytes_allowed_this_slice</a></div><div class="ttdeci">size_t m_snd_pacing_bytes_allowed_this_slice</div><div class="ttdoc">This many bytes worth of DATA packets may still be sent, at this time, within the time slice defined ...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00635">info.hpp:635</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a437ab79b98100ec9f8ee4f2195b24430"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a437ab79b98100ec9f8ee4f2195b24430">flow::net_flow::Peer_socket_info::m_sock_opts</a></div><div class="ttdeci">Peer_socket_options m_sock_opts</div><div class="ttdoc">Per-socket options currently set on the socket.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00644">info.hpp:644</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a45e2cdb7f0a7e0fd470adeab4009f44a"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a45e2cdb7f0a7e0fd470adeab4009f44a">flow::net_flow::Peer_socket_info::m_snd_buf_size</a></div><div class="ttdeci">size_t m_snd_buf_size</div><div class="ttdoc">The number of bytes in the internal Send buffer.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00590">info.hpp:590</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a4f97c94357653fe6df91677ef070d3e8"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a4f97c94357653fe6df91677ef070d3e8">flow::net_flow::Peer_socket_info::m_rcv_syn_rcvd_data_cumulative_size</a></div><div class="ttdeci">size_t m_rcv_syn_rcvd_data_cumulative_size</div><div class="ttdoc">Total size of DATA payload queued while waiting for SYN_ACK_ACK in SYN_RCVD state.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00573">info.hpp:573</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a6210e5a1ecd85ed1cb46be696f5faec4"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a6210e5a1ecd85ed1cb46be696f5faec4">flow::net_flow::Peer_socket_info::m_rcv_syn_rcvd_data_q_size</a></div><div class="ttdeci">size_t m_rcv_syn_rcvd_data_q_size</div><div class="ttdoc">Number of DATA packets queued while waiting for SYN_ACK_ACK in SYN_RCVD state.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00576">info.hpp:576</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a636e783090aee4ca8770a9f85f35dd21"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21">flow::net_flow::Peer_socket_info::m_int_state_str</a></div><div class="ttdeci">std::string m_int_state_str</div><div class="ttdoc">The internal state of the socket, rendered into string (e.g., &quot;SYN_RECEIVED&quot; or &quot;ESTABLISHED&quot;).</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00533">info.hpp:533</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a6b03bba60c815cb17c40802eee400ae2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a6b03bba60c815cb17c40802eee400ae2">flow::net_flow::Peer_socket_info::m_snd_pacing_slice_start</a></div><div class="ttdeci">Fine_time_pt m_snd_pacing_slice_start</div><div class="ttdoc">In pacing, the time point marking the beginning of the current pacing time slice.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00626">info.hpp:626</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a76f59a6c658d45c3283865b97dd01489"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a76f59a6c658d45c3283865b97dd01489">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_in_flight_count</a></div><div class="ttdeci">size_t m_snd_cong_ctl_in_flight_count</div><div class="ttdoc">In congestion control, the current sent data packets that have been neither acknowledged nor consider...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00611">info.hpp:611</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a784bd75264e26acbccd966e48c07dab9"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_in_flight_bytes</a></div><div class="ttdeci">size_t m_snd_cong_ctl_in_flight_bytes</div><div class="ttdoc">In congestion control, the current sent data bytes that have been neither acknowledged nor considered...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00608">info.hpp:608</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a788325f467420b83a92adce8302f2e18"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a788325f467420b83a92adce8302f2e18">flow::net_flow::Peer_socket_info::m_snd_est_bandwidth_mbit_per_sec</a></div><div class="ttdeci">double m_snd_est_bandwidth_mbit_per_sec</div><div class="ttdoc">Estimate of the currently available (to this connection) outgoing bandwidth, in megabits per second.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00641">info.hpp:641</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a84ae8091d89ae59304fd5ebd18539d8b"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a84ae8091d89ae59304fd5ebd18539d8b">flow::net_flow::Peer_socket_info::m_rcv_wnd</a></div><div class="ttdeci">size_t m_rcv_wnd</div><div class="ttdoc">Receive window size = max Receive buffer space minus space taken. Infinity if flow control disabled.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00552">info.hpp:552</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a8c3326fea94763621c47c8b0e4d31eb2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a8c3326fea94763621c47c8b0e4d31eb2">flow::net_flow::Peer_socket_info::m_rcv_packets_with_gaps</a></div><div class="ttdeci">size_t m_rcv_packets_with_gaps</div><div class="ttdoc">Number of DATA packets tracked in structure tracking all valid received packets such at least one pac...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00570">info.hpp:570</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a959898645f07733966840b7b8309e6c2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a959898645f07733966840b7b8309e6c2">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_wnd_bytes</a></div><div class="ttdeci">size_t m_snd_cong_ctl_wnd_bytes</div><div class="ttdoc">In congestion control, the current congestion window (number of outgoing data bytes allowed In-flight...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00599">info.hpp:599</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_a9fafa98dd848eb3944591472c6ce0548"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a9fafa98dd848eb3944591472c6ce0548">flow::net_flow::Peer_socket_info::m_snd_smoothed_round_trip_time</a></div><div class="ttdeci">Fine_duration m_snd_smoothed_round_trip_time</div><div class="ttdoc">Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00614">info.hpp:614</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_aa24bf78d7bad33c38b96694733836224"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#aa24bf78d7bad33c38b96694733836224">flow::net_flow::Peer_socket_info::m_disconnect_cause</a></div><div class="ttdeci">Error_code m_disconnect_cause</div><div class="ttdoc">If the socket is closing or closed, this is the reason for the closure; otherwise the default-constru...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00539">info.hpp:539</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_ab9da1d80bbed4b286c084dba3ed5b12e"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#ab9da1d80bbed4b286c084dba3ed5b12e">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_wnd_count_approx</a></div><div class="ttdeci">size_t m_snd_cong_ctl_wnd_count_approx</div><div class="ttdoc">In congestion control, the approximate equivalent of m_snd_cong_ctl_in_flight_bytes as a full packet ...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00602">info.hpp:602</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_abb8b267eb5fa888e21e415f0e0d26a87"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#abb8b267eb5fa888e21e415f0e0d26a87">flow::net_flow::Peer_socket_info::m_snd_rcv_wnd</a></div><div class="ttdeci">size_t m_snd_rcv_wnd</div><div class="ttdoc">The receive window (rcv_wnd a/k/a free Receive buffer space) value of the peer socket on the other si...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00596">info.hpp:596</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_acc0db949c58be9d7779c342cf5a67c9c"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#acc0db949c58be9d7779c342cf5a67c9c">flow::net_flow::Peer_socket_info::m_is_active_connect</a></div><div class="ttdeci">bool m_is_active_connect</div><div class="ttdoc">true if this is the &quot;client&quot; socket (connect()ed); false otherwise (accept()ed).</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00536">info.hpp:536</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_accd2ed68fd975dfa113f9f66c41d152a"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#accd2ed68fd975dfa113f9f66c41d152a">flow::net_flow::Peer_socket_info::m_snd_pacing_packet_q_size</a></div><div class="ttdeci">size_t m_snd_pacing_packet_q_size</div><div class="ttdoc">In pacing, number of packets currently queued to be sent out by the pacing module.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00623">info.hpp:623</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_aedadfb406ca6842ab1ecc0c4020e2a58"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#aedadfb406ca6842ab1ecc0c4020e2a58">flow::net_flow::Peer_socket_info::m_snd_round_trip_time_variance</a></div><div class="ttdeci">Fine_duration m_snd_round_trip_time_variance</div><div class="ttdoc">RTTVAR used for m_snd_smoothed_round_trip_time calculation; it is the current RTT variance.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00617">info.hpp:617</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_af8234f1645d63b9eee57f6937dc222de"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#af8234f1645d63b9eee57f6937dc222de">flow::net_flow::Peer_socket_info::m_rcv</a></div><div class="ttdeci">Peer_socket_receive_stats m_rcv</div><div class="ttdoc">Stats for incoming direction of traffic. As opposed to the other m_rcv_* members, this typically accu...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00508">info.hpp:508</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html_afe104d81f760a454df6d3b0273a2d101"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html#afe104d81f760a454df6d3b0273a2d101">flow::net_flow::Peer_socket_info::m_snd_drop_timeout</a></div><div class="ttdeci">Fine_duration m_snd_drop_timeout</div><div class="ttdoc">Drop Timeout: how long a given packet must remain unacknowledged to be considered dropped due to Drop...</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00620">info.hpp:620</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html">flow::net_flow::Peer_socket_options</a></div><div class="ttdoc">A set of low-level options affecting a single Peer_socket.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00035">options.hpp:36</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a02afb5ed4201d83c87a3a30fcbdda489"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a02afb5ed4201d83c87a3a30fcbdda489">flow::net_flow::Peer_socket_options::m_st_init_drop_timeout</a></div><div class="ttdeci">Fine_duration m_st_init_drop_timeout</div><div class="ttdoc">Once socket enters ESTABLISHED state, this is the value for Peer_socket::m_snd_drop_timeout until the...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00226">options.hpp:226</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a0b37da87848d01220c7e58f90e6764ba"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a0b37da87848d01220c7e58f90e6764ba">flow::net_flow::Peer_socket_options::m_st_max_rexmissions_per_packet</a></div><div class="ttdeci">unsigned int m_st_max_rexmissions_per_packet</div><div class="ttdoc">If retransmission is enabled and a given packet is retransmitted this many times and has to be retran...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00220">options.hpp:220</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a171480324f26432928738532cb3c8556"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a171480324f26432928738532cb3c8556">flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size</a></div><div class="ttdeci">size_t m_st_rcv_buf_max_size</div><div class="ttdoc">Maximum number of bytes that the Receive buffer can hold.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00141">options.hpp:141</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a1bdc21e84373dd96494a76f11603335e"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a1bdc21e84373dd96494a76f11603335e">flow::net_flow::Peer_socket_options::m_st_cong_ctl_max_cong_wnd_blocks</a></div><div class="ttdeci">size_t m_st_cong_ctl_max_cong_wnd_blocks</div><div class="ttdoc">The constant that determines the CWND limit in Congestion_control_classic_data::congestion_window_at_...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00296">options.hpp:296</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a2a3d420992e19e5addb7193d607e82e4"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a3d420992e19e5addb7193d607e82e4">flow::net_flow::Peer_socket_options::m_st_snd_bandwidth_est_sample_period_floor</a></div><div class="ttdeci">Fine_duration m_st_snd_bandwidth_est_sample_period_floor</div><div class="ttdoc">When estimating the available send bandwidth, each sample must be compiled over at least this long of...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00267">options.hpp:267</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a2a7ab1e27acd52d8fa3aadc9eb13d116"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a7ab1e27acd52d8fa3aadc9eb13d116">flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_avoidance_increment_blocks</a></div><div class="ttdeci">unsigned int m_st_cong_ctl_cong_avoidance_increment_blocks</div><div class="ttdoc">The multiple of max-block-size by which to increment CWND in congestion avoidance mode after receivin...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00306">options.hpp:306</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a2c8fcb08dfb0d1ebcc21e02940c149e8"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2c8fcb08dfb0d1ebcc21e02940c149e8">flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</a></div><div class="ttdeci">size_t m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</div><div class="ttdoc">On Drop Timeout, set congestion window to this value times max-block-size.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00299">options.hpp:299</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a637811d19d4a2b4d9b3ab79742aadff8"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a637811d19d4a2b4d9b3ab79742aadff8">flow::net_flow::Peer_socket_options::m_st_cong_ctl_init_cong_wnd_blocks</a></div><div class="ttdeci">size_t m_st_cong_ctl_init_cong_wnd_blocks</div><div class="ttdoc">The initial size of the congestion window, given in units of max-block-size-sized blocks.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00277">options.hpp:277</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a6c35e6014182ccfcbee6bed4571a8360"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360">flow::net_flow::Peer_socket_options::m_st_rexmit_on</a></div><div class="ttdeci">bool m_st_rexmit_on</div><div class="ttdoc">Whether to enable reliability via retransmission.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00214">options.hpp:214</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a8ca6086022691700f5e5d2dc87ca92fd"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8ca6086022691700f5e5d2dc87ca92fd">flow::net_flow::Peer_socket_options::m_st_snd_buf_max_size</a></div><div class="ttdeci">size_t m_st_snd_buf_max_size</div><div class="ttdoc">Maximum number of bytes that the Send buffer can hold.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00134">options.hpp:134</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_a8f18c8222ade5f99b83a85e0203ff130"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8f18c8222ade5f99b83a85e0203ff130">flow::net_flow::Peer_socket_options::m_st_connect_retransmit_period</a></div><div class="ttdeci">Fine_duration m_st_connect_retransmit_period</div><div class="ttdoc">How often to resend SYN or SYN_ACK while SYN_ACK or SYN_ACK_ACK, respectively, has not been received.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00121">options.hpp:121</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_ac38c0bbba5edbb4964a3914ccf56018f"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac38c0bbba5edbb4964a3914ccf56018f">flow::net_flow::Peer_socket_options::m_dyn_rcv_wnd_recovery_timer_period</a></div><div class="ttdeci">Fine_duration m_dyn_rcv_wnd_recovery_timer_period</div><div class="ttdoc">When the mode triggered by rcv-buf-max-size-to-advertise-percent being exceeded is in effect,...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00333">options.hpp:333</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_ac75171c4f1086d0aa38248ae5ffba884"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac75171c4f1086d0aa38248ae5ffba884">flow::net_flow::Peer_socket_options::m_st_connect_retransmit_timeout</a></div><div class="ttdeci">Fine_duration m_st_connect_retransmit_timeout</div><div class="ttdoc">How long from the first SYN or SYN_ACK to allow for connection handshake before aborting connection.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00124">options.hpp:124</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_ad7a76f7ae03e258b30b04c7350481de6"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7a76f7ae03e258b30b04c7350481de6">flow::net_flow::Peer_socket_options::m_st_max_full_blocks_before_ack_send</a></div><div class="ttdeci">size_t m_st_max_full_blocks_before_ack_send</div><div class="ttdoc">If there are at least this many TIMES max-block-size bytes' worth of individual acknowledgments to be...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00198">options.hpp:198</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_add7ccb9e8cd0715ca78e0710d2a6db06"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#add7ccb9e8cd0715ca78e0710d2a6db06">flow::net_flow::Peer_socket_options::m_st_delayed_ack_timer_period</a></div><div class="ttdeci">Fine_duration m_st_delayed_ack_timer_period</div><div class="ttdoc">The maximum amount of time to delay sending ACK with individual packet's acknowledgment since receivi...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00191">options.hpp:191</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_ae2551f2995f5830e0461bec6fdd9035e"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae2551f2995f5830e0461bec6fdd9035e">flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_backoff_factor</a></div><div class="ttdeci">unsigned int m_dyn_drop_timeout_backoff_factor</div><div class="ttdoc">Whenever the Drop Timer fires, upon the requisite Dropping of packet(s), the DTO (Drop Timeout) is se...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00325">options.hpp:325</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_aeaaf832a38a5e334789e81e214686ea7"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">flow::net_flow::Peer_socket_options::m_st_max_block_size</a></div><div class="ttdeci">size_t m_st_max_block_size</div><div class="ttdoc">The size of block that we will strive to (and will, assuming at least that many bytes are available i...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00114">options.hpp:114</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_aeccfe97128c9f5f62ff26d73047dec2e"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeccfe97128c9f5f62ff26d73047dec2e">flow::net_flow::Peer_socket_options::m_st_cong_ctl_classic_wnd_decay_percent</a></div><div class="ttdeci">unsigned int m_st_cong_ctl_classic_wnd_decay_percent</div><div class="ttdoc">In classic congestion control, RFC 5681 specifies the window should be halved on loss; this option al...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00314">options.hpp:314</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_af483d0292f363e7dbf14dc7a2dd49f3f"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#af483d0292f363e7dbf14dc7a2dd49f3f">flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size_to_advertise_percent</a></div><div class="ttdeci">unsigned int m_st_rcv_buf_max_size_to_advertise_percent</div><div class="ttdoc">% of rcv-buf-max-size that has to be freed, since the last receive window advertisement,...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00171">options.hpp:171</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_af78ca6cf3c6da3bc24cea40d522f0bdb"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#af78ca6cf3c6da3bc24cea40d522f0bdb">flow::net_flow::Peer_socket_options::m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</a></div><div class="ttdeci">unsigned int m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</div><div class="ttdoc">The limit on the size of Peer_socket::m_rcv_packets_with_gaps, expressed as what percentage the maxim...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00183">options.hpp:183</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html_afd02a9d91ef5e5c13ea95ea35624da1a"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html#afd02a9d91ef5e5c13ea95ea35624da1a">flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_ceiling</a></div><div class="ttdeci">Fine_duration m_dyn_drop_timeout_ceiling</div><div class="ttdoc">Ceiling to impose on the Drop Timeout.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00317">options.hpp:317</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Remote__endpoint_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Remote__endpoint.html">flow::net_flow::Remote_endpoint</a></div><div class="ttdoc">Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...</div><div class="ttdef"><b>Definition:</b> <a href="endpoint_8hpp_source.html#l00092">endpoint.hpp:93</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Remote__endpoint_html_a582f3a55d828cd4e36369682315c7629"><div class="ttname"><a href="structflow_1_1net__flow_1_1Remote__endpoint.html#a582f3a55d828cd4e36369682315c7629">flow::net_flow::Remote_endpoint::m_udp_endpoint</a></div><div class="ttdeci">util::Udp_endpoint m_udp_endpoint</div><div class="ttdoc">UDP address (IP address/UDP port) where the Node identified by this endpoint bound its low-level UDP ...</div><div class="ttdef"><b>Definition:</b> <a href="endpoint_8hpp_source.html#l00097">endpoint.hpp:97</a></div></div>
<div class="ttc" id="autil__fwd_8hpp_html_a0cc4c82ac54e53b7a8a2431b66ff30df"><div class="ttname"><a href="util__fwd_8hpp.html#a0cc4c82ac54e53b7a8a2431b66ff30df">FLOW_UTIL_WHERE_AM_I_STR</a></div><div class="ttdeci">#define FLOW_UTIL_WHERE_AM_I_STR()</div><div class="ttdoc">Same as FLOW_UTIL_WHERE_AM_I() but evaluates to an std::string.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00971">util_fwd.hpp:971</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 7 2025 05:46:47 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
