<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Linked__hash__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a set that combines the lookup speed of an <code>unordered_set&lt;&gt;</code> and ordering and iterator stability capabilities of an <code>std::list&lt;&gt;</code>.  
 <a href="classflow_1_1util_1_1Linked__hash__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set__coll__graph.svg" width="311" height="239"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a591977b7bbcb0112db06722a9c9180a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> = Key</td></tr>
<tr class="memdesc:a591977b7bbcb0112db06722a9c9180a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for values, which in this case are simply the keys.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">More...</a><br /></td></tr>
<tr class="separator:a591977b7bbcb0112db06722a9c9180a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a280071f879fc40d0f62566d50fd76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a63a280071f879fc40d0f62566d50fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for index into array of items, where items are all applicable objects including <code>Value</code>s and <code>Key</code>s.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">More...</a><br /></td></tr>
<tr class="separator:a63a280071f879fc40d0f62566d50fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab12547b79b9d16d8441add22d4b194"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1ab12547b79b9d16d8441add22d4b194">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a1ab12547b79b9d16d8441add22d4b194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1ab12547b79b9d16d8441add22d4b194">More...</a><br /></td></tr>
<tr class="separator:a1ab12547b79b9d16d8441add22d4b194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f3367e577133372e20341f4c4f6413"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> = typename Value_list::const_iterator</td></tr>
<tr class="memdesc:a57f3367e577133372e20341f4c4f6413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">More...</a><br /></td></tr>
<tr class="separator:a57f3367e577133372e20341f4c4f6413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38053f68629a24e2ead1be3e052e99b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td></tr>
<tr class="memdesc:a38053f68629a24e2ead1be3e052e99b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">More...</a><br /></td></tr>
<tr class="separator:a38053f68629a24e2ead1be3e052e99b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9037058b814aba5dc586e47638cbb7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a> = typename Value_list::const_reverse_iterator</td></tr>
<tr class="memdesc:aa9037058b814aba5dc586e47638cbb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">More...</a><br /></td></tr>
<tr class="separator:aa9037058b814aba5dc586e47638cbb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df080186975dae439759eb42e1eea83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">Reverse_iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a></td></tr>
<tr class="memdesc:a7df080186975dae439759eb42e1eea83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d" title="Type for reverse iterator pointing into an immutable structure of this type.">Const_reverse_iterator</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">More...</a><br /></td></tr>
<tr class="separator:a7df080186975dae439759eb42e1eea83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee6a932c31cb6f96c2213e74c4c4238"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a0ee6a932c31cb6f96c2213e74c4c4238">key_type</a> = Key</td></tr>
<tr class="memdesc:a0ee6a932c31cb6f96c2213e74c4c4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a0ee6a932c31cb6f96c2213e74c4c4238">More...</a><br /></td></tr>
<tr class="separator:a0ee6a932c31cb6f96c2213e74c4c4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a8e84dda748d4f91cc3d3d2dabe6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a495a8e84dda748d4f91cc3d3d2dabe6a">value_type</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a></td></tr>
<tr class="memdesc:a495a8e84dda748d4f91cc3d3d2dabe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Value</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a495a8e84dda748d4f91cc3d3d2dabe6a">More...</a><br /></td></tr>
<tr class="separator:a495a8e84dda748d4f91cc3d3d2dabe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561ad11451af543e1799a6b95794f717"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a561ad11451af543e1799a6b95794f717">hasher</a> = Hash</td></tr>
<tr class="memdesc:a561ad11451af543e1799a6b95794f717"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Hash</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a561ad11451af543e1799a6b95794f717">More...</a><br /></td></tr>
<tr class="separator:a561ad11451af543e1799a6b95794f717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41de46363a846853b59a38d591ae2b32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a41de46363a846853b59a38d591ae2b32">key_equal</a> = Pred</td></tr>
<tr class="memdesc:a41de46363a846853b59a38d591ae2b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Pred</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a41de46363a846853b59a38d591ae2b32">More...</a><br /></td></tr>
<tr class="separator:a41de46363a846853b59a38d591ae2b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f839adf121c2b3f8f74ba98f59aaf73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6f839adf121c2b3f8f74ba98f59aaf73">pointer</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> *</td></tr>
<tr class="memdesc:a6f839adf121c2b3f8f74ba98f59aaf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a6f839adf121c2b3f8f74ba98f59aaf73">More...</a><br /></td></tr>
<tr class="separator:a6f839adf121c2b3f8f74ba98f59aaf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c16ed9c8ac77595d66f3d1593ed0a4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a9c16ed9c8ac77595d66f3d1593ed0a4d">const_pointer</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const *</td></tr>
<tr class="memdesc:a9c16ed9c8ac77595d66f3d1593ed0a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a9c16ed9c8ac77595d66f3d1593ed0a4d">More...</a><br /></td></tr>
<tr class="separator:a9c16ed9c8ac77595d66f3d1593ed0a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc32dd7af2de12556632664e23c0306"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6cc32dd7af2de12556632664e23c0306">reference</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> &amp;</td></tr>
<tr class="memdesc:a6cc32dd7af2de12556632664e23c0306"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a6cc32dd7af2de12556632664e23c0306">More...</a><br /></td></tr>
<tr class="separator:a6cc32dd7af2de12556632664e23c0306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f45d5e6ea44d01a3921116c76e3043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39f45d5e6ea44d01a3921116c76e3043">const_reference</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;</td></tr>
<tr class="memdesc:a39f45d5e6ea44d01a3921116c76e3043"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a39f45d5e6ea44d01a3921116c76e3043">More...</a><br /></td></tr>
<tr class="separator:a39f45d5e6ea44d01a3921116c76e3043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb17462264df56b98e2ad8d208c34081"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#adb17462264df56b98e2ad8d208c34081">iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a></td></tr>
<tr class="memdesc:adb17462264df56b98e2ad8d208c34081"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Iterator</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#adb17462264df56b98e2ad8d208c34081">More...</a><br /></td></tr>
<tr class="separator:adb17462264df56b98e2ad8d208c34081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6834d99cc4ad91bf0e386c4ade4a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a09f6834d99cc4ad91bf0e386c4ade4a7">const_iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td></tr>
<tr class="memdesc:a09f6834d99cc4ad91bf0e386c4ade4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Const_iterator</code> type.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a09f6834d99cc4ad91bf0e386c4ade4a7">More...</a><br /></td></tr>
<tr class="separator:a09f6834d99cc4ad91bf0e386c4ade4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8fd4b8108679dd6bb7551ebdbda0eb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#af8fd4b8108679dd6bb7551ebdbda0eb0">Linked_hash_set</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>(-1), Hash const &amp;hasher_instance=Hash(), Pred const &amp;key_equal_instance=Pred())</td></tr>
<tr class="memdesc:af8fd4b8108679dd6bb7551ebdbda0eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty structure with some basic parameters.  <a href="classflow_1_1util_1_1Linked__hash__set.html#af8fd4b8108679dd6bb7551ebdbda0eb0">More...</a><br /></td></tr>
<tr class="separator:af8fd4b8108679dd6bb7551ebdbda0eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7696dc83d8806530a9d2c916a9e30267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7696dc83d8806530a9d2c916a9e30267">Linked_hash_set</a> (std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> &gt; values, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>(-1), Hash const &amp;hasher_instance=Hash(), Pred const &amp;key_equal_instance=Pred())</td></tr>
<tr class="memdesc:a7696dc83d8806530a9d2c916a9e30267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs structure with some basic parameters, and values initialized from initializer list.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7696dc83d8806530a9d2c916a9e30267">More...</a><br /></td></tr>
<tr class="separator:a7696dc83d8806530a9d2c916a9e30267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2d3f7dc9e172260d7623f83a6bc5fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1c2d3f7dc9e172260d7623f83a6bc5fc">Linked_hash_set</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> const &amp;src)</td></tr>
<tr class="memdesc:a1c2d3f7dc9e172260d7623f83a6bc5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object that is a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1c2d3f7dc9e172260d7623f83a6bc5fc">More...</a><br /></td></tr>
<tr class="separator:a1c2d3f7dc9e172260d7623f83a6bc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6caa0e9ac4ef9eadccf6045f56c2700"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae6caa0e9ac4ef9eadccf6045f56c2700">Linked_hash_set</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ae6caa0e9ac4ef9eadccf6045f56c2700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ae6caa0e9ac4ef9eadccf6045f56c2700">More...</a><br /></td></tr>
<tr class="separator:ae6caa0e9ac4ef9eadccf6045f56c2700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc7b499be6563aff0f8bded23c05fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8fc7b499be6563aff0f8bded23c05fb0">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> const &amp;src)</td></tr>
<tr class="memdesc:a8fc7b499be6563aff0f8bded23c05fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object with a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a8fc7b499be6563aff0f8bded23c05fb0">More...</a><br /></td></tr>
<tr class="separator:a8fc7b499be6563aff0f8bded23c05fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add06f0744ac3838635500262c96282cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#add06f0744ac3838635500262c96282cd">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:add06f0744ac3838635500262c96282cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__set.html#add06f0744ac3838635500262c96282cd">More...</a><br /></td></tr>
<tr class="separator:add06f0744ac3838635500262c96282cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b9b0ac9d6ab2c56e27ba380f87180"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a517b9b0ac9d6ab2c56e27ba380f87180">insert</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;key)</td></tr>
<tr class="memdesc:a517b9b0ac9d6ab2c56e27ba380f87180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the given key into the set.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a517b9b0ac9d6ab2c56e27ba380f87180">More...</a><br /></td></tr>
<tr class="separator:a517b9b0ac9d6ab2c56e27ba380f87180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94baeef5c7506029339f81a77e7b8d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a94baeef5c7506029339f81a77e7b8d37">find</a> (Key const &amp;key) const</td></tr>
<tr class="memdesc:a94baeef5c7506029339f81a77e7b8d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find the given key in the set.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a94baeef5c7506029339f81a77e7b8d37">More...</a><br /></td></tr>
<tr class="separator:a94baeef5c7506029339f81a77e7b8d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba615340ed6d9b5d9c6ddd5284db4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a9ba615340ed6d9b5d9c6ddd5284db4a5">count</a> (Key const &amp;key) const</td></tr>
<tr class="memdesc:a9ba615340ed6d9b5d9c6ddd5284db4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a key is equivalent to the given one is present in the hash: either 1 or 0.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a9ba615340ed6d9b5d9c6ddd5284db4a5">More...</a><br /></td></tr>
<tr class="separator:a9ba615340ed6d9b5d9c6ddd5284db4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926db7e9160df1ff73634a7039e7c30c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a926db7e9160df1ff73634a7039e7c30c">const_front</a> () const</td></tr>
<tr class="memdesc:a926db7e9160df1ff73634a7039e7c30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a926db7e9160df1ff73634a7039e7c30c">More...</a><br /></td></tr>
<tr class="separator:a926db7e9160df1ff73634a7039e7c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72041477813e1e9cc8b4e793fb9830d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a72041477813e1e9cc8b4e793fb9830d0">const_back</a> () const</td></tr>
<tr class="memdesc:a72041477813e1e9cc8b4e793fb9830d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a72041477813e1e9cc8b4e793fb9830d0">More...</a><br /></td></tr>
<tr class="separator:a72041477813e1e9cc8b4e793fb9830d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3c86dc0fa2ae968fad1764241352fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6c3c86dc0fa2ae968fad1764241352fe">touch</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;it)</td></tr>
<tr class="memdesc:a6c3c86dc0fa2ae968fad1764241352fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a valid iterator into the structure, makes the pointed to element "newest" by moving it from wherever it is to be first in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a6c3c86dc0fa2ae968fad1764241352fe">More...</a><br /></td></tr>
<tr class="separator:a6c3c86dc0fa2ae968fad1764241352fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add178239cda109799d349bdcf8bb15a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#add178239cda109799d349bdcf8bb15a3">touch</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:add178239cda109799d349bdcf8bb15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key.  <a href="classflow_1_1util_1_1Linked__hash__set.html#add178239cda109799d349bdcf8bb15a3">More...</a><br /></td></tr>
<tr class="separator:add178239cda109799d349bdcf8bb15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63c73e7c2d6092331cb7bd3267b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b63c73e7c2d6092331cb7bd3267b830">erase</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;it)</td></tr>
<tr class="memdesc:a4b63c73e7c2d6092331cb7bd3267b830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element pointed to by the given valid iterator.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4b63c73e7c2d6092331cb7bd3267b830">More...</a><br /></td></tr>
<tr class="separator:a4b63c73e7c2d6092331cb7bd3267b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eeea34058e69e5dddb90bb92677cb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a2eeea34058e69e5dddb90bb92677cb92">erase</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;it_newest, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;it_past_oldest)</td></tr>
<tr class="memdesc:a2eeea34058e69e5dddb90bb92677cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a2eeea34058e69e5dddb90bb92677cb92">More...</a><br /></td></tr>
<tr class="separator:a2eeea34058e69e5dddb90bb92677cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeafee2318c0a3d173d005130ff58c88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aaeafee2318c0a3d173d005130ff58c88">erase</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:aaeafee2318c0a3d173d005130ff58c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element with the given key, if it exists.  <a href="classflow_1_1util_1_1Linked__hash__set.html#aaeafee2318c0a3d173d005130ff58c88">More...</a><br /></td></tr>
<tr class="separator:aaeafee2318c0a3d173d005130ff58c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1b763a78cae4f2636489b542685774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8c1b763a78cae4f2636489b542685774">pop_front</a> ()</td></tr>
<tr class="memdesc:a8c1b763a78cae4f2636489b542685774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue-style pop (erase) of the front &ndash; a/k/a newest &ndash; element. Behavior undefined if <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a8c1b763a78cae4f2636489b542685774">More...</a><br /></td></tr>
<tr class="separator:a8c1b763a78cae4f2636489b542685774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2caa69df6af34e5cc98e4be24203639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab2caa69df6af34e5cc98e4be24203639">pop_back</a> ()</td></tr>
<tr class="memdesc:ab2caa69df6af34e5cc98e4be24203639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue-style pop (erase) of the back &ndash; a/k/a oldest &ndash; element. Behavior undefined if <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ab2caa69df6af34e5cc98e4be24203639">More...</a><br /></td></tr>
<tr class="separator:ab2caa69df6af34e5cc98e4be24203639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8844c7594a079eb2d52d78436ed832c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8844c7594a079eb2d52d78436ed832c6">clear</a> ()</td></tr>
<tr class="memdesc:a8844c7594a079eb2d52d78436ed832c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad2ce3ff8f57696dcb230f419775ab865" title="Returns number of elements stored.">size()</a> == 0</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a8844c7594a079eb2d52d78436ed832c6">More...</a><br /></td></tr>
<tr class="separator:a8844c7594a079eb2d52d78436ed832c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e27b1b9b75e5dc890af26f85956190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a46e27b1b9b75e5dc890af26f85956190">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:a46e27b1b9b75e5dc890af26f85956190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a46e27b1b9b75e5dc890af26f85956190">More...</a><br /></td></tr>
<tr class="separator:a46e27b1b9b75e5dc890af26f85956190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1357ad93c44d71da9c02277c40b86d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1357ad93c44d71da9c02277c40b86d51">begin</a> () const</td></tr>
<tr class="memdesc:a1357ad93c44d71da9c02277c40b86d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac2d182fa6a6b6814527477991bc6ca68" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1357ad93c44d71da9c02277c40b86d51">More...</a><br /></td></tr>
<tr class="separator:a1357ad93c44d71da9c02277c40b86d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d182fa6a6b6814527477991bc6ca68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac2d182fa6a6b6814527477991bc6ca68">newest</a> () const</td></tr>
<tr class="memdesc:ac2d182fa6a6b6814527477991bc6ca68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#ac2d182fa6a6b6814527477991bc6ca68">More...</a><br /></td></tr>
<tr class="separator:ac2d182fa6a6b6814527477991bc6ca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a6bcbb95db8aa81dfb5112f3526304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a70a6bcbb95db8aa81dfb5112f3526304">end</a> () const</td></tr>
<tr class="memdesc:a70a6bcbb95db8aa81dfb5112f3526304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab40f5659f15a52138f6dcd9f8ac92a59" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a70a6bcbb95db8aa81dfb5112f3526304">More...</a><br /></td></tr>
<tr class="separator:a70a6bcbb95db8aa81dfb5112f3526304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40f5659f15a52138f6dcd9f8ac92a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab40f5659f15a52138f6dcd9f8ac92a59">past_oldest</a> () const</td></tr>
<tr class="memdesc:ab40f5659f15a52138f6dcd9f8ac92a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#ab40f5659f15a52138f6dcd9f8ac92a59">More...</a><br /></td></tr>
<tr class="separator:ab40f5659f15a52138f6dcd9f8ac92a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ed34864543d891f92c1ecf0a87dbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aab1ed34864543d891f92c1ecf0a87dbc">cbegin</a> () const</td></tr>
<tr class="memdesc:aab1ed34864543d891f92c1ecf0a87dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#aab1ed34864543d891f92c1ecf0a87dbc">More...</a><br /></td></tr>
<tr class="separator:aab1ed34864543d891f92c1ecf0a87dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91021f4ea7018811502cab360284c6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa">const_newest</a> () const</td></tr>
<tr class="memdesc:a91021f4ea7018811502cab360284c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa">More...</a><br /></td></tr>
<tr class="separator:a91021f4ea7018811502cab360284c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b5df45440be15dfac6c84fd436d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1c0b5df45440be15dfac6c84fd436d00">cend</a> () const</td></tr>
<tr class="memdesc:a1c0b5df45440be15dfac6c84fd436d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1c0b5df45440be15dfac6c84fd436d00">More...</a><br /></td></tr>
<tr class="separator:a1c0b5df45440be15dfac6c84fd436d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089ee6d083911c14d0fd44075b90b452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452">const_past_oldest</a> () const</td></tr>
<tr class="memdesc:a089ee6d083911c14d0fd44075b90b452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452">More...</a><br /></td></tr>
<tr class="separator:a089ee6d083911c14d0fd44075b90b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1696ca2455aeb36ba99387091373150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab1696ca2455aeb36ba99387091373150">rbegin</a> () const</td></tr>
<tr class="memdesc:ab1696ca2455aeb36ba99387091373150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a698156501a7a0c1c1f623b90527b1254" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ab1696ca2455aeb36ba99387091373150">More...</a><br /></td></tr>
<tr class="separator:ab1696ca2455aeb36ba99387091373150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698156501a7a0c1c1f623b90527b1254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a698156501a7a0c1c1f623b90527b1254">oldest</a> () const</td></tr>
<tr class="memdesc:a698156501a7a0c1c1f623b90527b1254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a698156501a7a0c1c1f623b90527b1254">More...</a><br /></td></tr>
<tr class="separator:a698156501a7a0c1c1f623b90527b1254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92064c4a806fdddef54062bfe9b89250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a92064c4a806fdddef54062bfe9b89250">rend</a> () const</td></tr>
<tr class="memdesc:a92064c4a806fdddef54062bfe9b89250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a736cffd41262e99cbff13c081edc15a3" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a92064c4a806fdddef54062bfe9b89250">More...</a><br /></td></tr>
<tr class="separator:a92064c4a806fdddef54062bfe9b89250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736cffd41262e99cbff13c081edc15a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a736cffd41262e99cbff13c081edc15a3">past_newest</a> () const</td></tr>
<tr class="memdesc:a736cffd41262e99cbff13c081edc15a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a736cffd41262e99cbff13c081edc15a3">More...</a><br /></td></tr>
<tr class="separator:a736cffd41262e99cbff13c081edc15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7c81fa11afdcfc9dd98665d1cd9af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a9e7c81fa11afdcfc9dd98665d1cd9af6">crbegin</a> () const</td></tr>
<tr class="memdesc:a9e7c81fa11afdcfc9dd98665d1cd9af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae0cb0394a239b8855a711d417aabe8e7" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a9e7c81fa11afdcfc9dd98665d1cd9af6">More...</a><br /></td></tr>
<tr class="separator:a9e7c81fa11afdcfc9dd98665d1cd9af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb0394a239b8855a711d417aabe8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae0cb0394a239b8855a711d417aabe8e7">const_oldest</a> () const</td></tr>
<tr class="memdesc:ae0cb0394a239b8855a711d417aabe8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#ae0cb0394a239b8855a711d417aabe8e7">More...</a><br /></td></tr>
<tr class="separator:ae0cb0394a239b8855a711d417aabe8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6490d9e317333934687919afa5be69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#adb6490d9e317333934687919afa5be69">crend</a> () const</td></tr>
<tr class="memdesc:adb6490d9e317333934687919afa5be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a16f0324ec7c8fb399ab002ea52ff4252" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#adb6490d9e317333934687919afa5be69">More...</a><br /></td></tr>
<tr class="separator:adb6490d9e317333934687919afa5be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f0324ec7c8fb399ab002ea52ff4252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a16f0324ec7c8fb399ab002ea52ff4252">const_past_newest</a> () const</td></tr>
<tr class="memdesc:a16f0324ec7c8fb399ab002ea52ff4252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a16f0324ec7c8fb399ab002ea52ff4252">More...</a><br /></td></tr>
<tr class="separator:a16f0324ec7c8fb399ab002ea52ff4252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a8d78c4ae3bc45c8bcede6b0e2dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6">empty</a> () const</td></tr>
<tr class="memdesc:a048a8d78c4ae3bc45c8bcede6b0e2dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if container is empty.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6">More...</a><br /></td></tr>
<tr class="separator:a048a8d78c4ae3bc45c8bcede6b0e2dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce3ff8f57696dcb230f419775ab865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad2ce3ff8f57696dcb230f419775ab865">size</a> () const</td></tr>
<tr class="memdesc:ad2ce3ff8f57696dcb230f419775ab865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ad2ce3ff8f57696dcb230f419775ab865">More...</a><br /></td></tr>
<tr class="separator:ad2ce3ff8f57696dcb230f419775ab865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bfed582b7ee057afe92be2bbabb422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac1bfed582b7ee057afe92be2bbabb422">max_size</a> () const</td></tr>
<tr class="memdesc:ac1bfed582b7ee057afe92be2bbabb422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max number of elements that can be stored.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ac1bfed582b7ee057afe92be2bbabb422">More...</a><br /></td></tr>
<tr class="separator:ac1bfed582b7ee057afe92be2bbabb422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad60bc54644375aff266f08a735e07610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad60bc54644375aff266f08a735e07610">Value_list</a> = std::list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> &gt;</td></tr>
<tr class="memdesc:ad60bc54644375aff266f08a735e07610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for doubly linked list of <code>Key</code>s.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ad60bc54644375aff266f08a735e07610">More...</a><br /></td></tr>
<tr class="separator:ad60bc54644375aff266f08a735e07610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383dac9998972cccbf12271d50ab081d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a383dac9998972cccbf12271d50ab081d">Value_list_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a></td></tr>
<tr class="memdesc:a383dac9998972cccbf12271d50ab081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for iterator into doubly linked list of <code>Key</code> elements.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a383dac9998972cccbf12271d50ab081d">More...</a><br /></td></tr>
<tr class="separator:a383dac9998972cccbf12271d50ab081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2690e27808a52713648282471c2848"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3a2690e27808a52713648282471c2848">Value_list_const_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td></tr>
<tr class="memdesc:a3a2690e27808a52713648282471c2848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for const iterator into doubly linked list of <code>Key</code> elements.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a3a2690e27808a52713648282471c2848">More...</a><br /></td></tr>
<tr class="separator:a3a2690e27808a52713648282471c2848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18a010dba2965436645418572ce6531"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab18a010dba2965436645418572ce6531">Key_to_value_iter_map</a> = boost::unordered_map&lt; Key, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a383dac9998972cccbf12271d50ab081d">Value_list_iter</a>, Hash, Pred &gt;</td></tr>
<tr class="memdesc:ab18a010dba2965436645418572ce6531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a hash map that maps <code>Key</code> to iterator into doubly linked list of <code>Key</code> elements.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ab18a010dba2965436645418572ce6531">More...</a><br /></td></tr>
<tr class="separator:ab18a010dba2965436645418572ce6531"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0a37ac9af14d0061e5b44436f939bc5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a0a37ac9af14d0061e5b44436f939bc5c">insert_impl</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;key)</td></tr>
<tr class="memdesc:a0a37ac9af14d0061e5b44436f939bc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4bae43bd9a1b68903af4b6f9452ccf9e" title="See Linked_hash_map::m_value_list. Essentially all of that applies here.">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aaac0d1e29ab268c967db182b30b766cc" title="See Linked_hash_map::m_keys_into_list_map. Essentially all of that applies here.">m_keys_into_list_map</a> so that <code>key</code>'s copy is inserted into the structure.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a0a37ac9af14d0061e5b44436f939bc5c">More...</a><br /></td></tr>
<tr class="separator:a0a37ac9af14d0061e5b44436f939bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4bae43bd9a1b68903af4b6f9452ccf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad60bc54644375aff266f08a735e07610">Value_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4bae43bd9a1b68903af4b6f9452ccf9e">m_value_list</a></td></tr>
<tr class="memdesc:a4bae43bd9a1b68903af4b6f9452ccf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">Linked_hash_map::m_value_list</a>. Essentially all of that applies here.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4bae43bd9a1b68903af4b6f9452ccf9e">More...</a><br /></td></tr>
<tr class="separator:a4bae43bd9a1b68903af4b6f9452ccf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac0d1e29ab268c967db182b30b766cc"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab18a010dba2965436645418572ce6531">Key_to_value_iter_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aaac0d1e29ab268c967db182b30b766cc">m_keys_into_list_map</a></td></tr>
<tr class="memdesc:aaac0d1e29ab268c967db182b30b766cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">Linked_hash_map::m_keys_into_list_map</a>. Essentially all of that applies here.  <a href="classflow_1_1util_1_1Linked__hash__set.html#aaac0d1e29ab268c967db182b30b766cc">More...</a><br /></td></tr>
<tr class="separator:aaac0d1e29ab268c967db182b30b766cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac7fd808e839d422a3f74fbea57fe367e"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Hash , typename Pred &gt; </td></tr>
<tr class="memitem:ac7fd808e839d422a3f74fbea57fe367e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac7fd808e839d422a3f74fbea57fe367e">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;val1, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;val2)</td></tr>
<tr class="memdesc:ac7fd808e839d422a3f74fbea57fe367e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>val1.swap(val2)</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ac7fd808e839d422a3f74fbea57fe367e">More...</a><br /></td></tr>
<tr class="separator:ac7fd808e839d422a3f74fbea57fe367e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Hash, typename Pred&gt;<br />
class flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;</div><p >An object of this class is a set that combines the lookup speed of an <code>unordered_set&lt;&gt;</code> and ordering and iterator stability capabilities of an <code>std::list&lt;&gt;</code>. </p>
<p >This is just like <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a>, except it only stores keys &ndash; no mapped values. All comments, except for self-explanatory differences, from <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a> apply here. Thus I will only speak of differences below to avoid duplication of this header.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a>. </td></tr>
    <tr><td class="paramname">Hash</td><td>Hasher type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a>. </td></tr>
    <tr><td class="paramname">Pred</td><td>Equality functor type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of a boost::unordered_map&lt;&gt; and order...">Linked_hash_map</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00047">47</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a57f3367e577133372e20341f4c4f6413" name="a57f3367e577133372e20341f4c4f6413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f3367e577133372e20341f4c4f6413">&#9670;&nbsp;</a></span>Const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Const_iterator =  typename Value_list::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00071">71</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a09f6834d99cc4ad91bf0e386c4ade4a7" name="a09f6834d99cc4ad91bf0e386c4ade4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6834d99cc4ad91bf0e386c4ade4a7">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Const_iterator</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00107">107</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a9c16ed9c8ac77595d66f3d1593ed0a4d" name="a9c16ed9c8ac77595d66f3d1593ed0a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c16ed9c8ac77595d66f3d1593ed0a4d">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_pointer =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>const Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00099">99</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a39f45d5e6ea44d01a3921116c76e3043" name="a39f45d5e6ea44d01a3921116c76e3043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f45d5e6ea44d01a3921116c76e3043">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_reference =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>const Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00103">103</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="aa9037058b814aba5dc586e47638cbb7d" name="aa9037058b814aba5dc586e47638cbb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9037058b814aba5dc586e47638cbb7d">&#9670;&nbsp;</a></span>Const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Const_reverse_iterator =  typename Value_list::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00080">80</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a1ab12547b79b9d16d8441add22d4b194" name="a1ab12547b79b9d16d8441add22d4b194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab12547b79b9d16d8441add22d4b194">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for difference of <code>size_type</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00068">68</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a561ad11451af543e1799a6b95794f717" name="a561ad11451af543e1799a6b95794f717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561ad11451af543e1799a6b95794f717">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::hasher =  Hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Hash</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00093">93</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a38053f68629a24e2ead1be3e052e99b1" name="a38053f68629a24e2ead1be3e052e99b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38053f68629a24e2ead1be3e052e99b1">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a>. </p>
<p >Note these are standard semantics (see <code>std::set</code>, etc.). </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00077">77</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="adb17462264df56b98e2ad8d208c34081" name="adb17462264df56b98e2ad8d208c34081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb17462264df56b98e2ad8d208c34081">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Iterator</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00105">105</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a41de46363a846853b59a38d591ae2b32" name="a41de46363a846853b59a38d591ae2b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41de46363a846853b59a38d591ae2b32">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::key_equal =  Pred</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Pred</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00095">95</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ab18a010dba2965436645418572ce6531" name="ab18a010dba2965436645418572ce6531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18a010dba2965436645418572ce6531">&#9670;&nbsp;</a></span>Key_to_value_iter_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Key_to_value_iter_map =  boost::unordered_map&lt;Key, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a383dac9998972cccbf12271d50ab081d">Value_list_iter</a>, Hash, Pred&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for a hash map that maps <code>Key</code> to iterator into doubly linked list of <code>Key</code> elements. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00470">470</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a0ee6a932c31cb6f96c2213e74c4c4238" name="a0ee6a932c31cb6f96c2213e74c4c4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee6a932c31cb6f96c2213e74c4c4238">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::key_type =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00089">89</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a6f839adf121c2b3f8f74ba98f59aaf73" name="a6f839adf121c2b3f8f74ba98f59aaf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f839adf121c2b3f8f74ba98f59aaf73">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::pointer =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00097">97</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a6cc32dd7af2de12556632664e23c0306" name="a6cc32dd7af2de12556632664e23c0306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc32dd7af2de12556632664e23c0306">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::reference =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00101">101</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a7df080186975dae439759eb42e1eea83" name="a7df080186975dae439759eb42e1eea83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df080186975dae439759eb42e1eea83">&#9670;&nbsp;</a></span>Reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Reverse_iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">Const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d" title="Type for reverse iterator pointing into an immutable structure of this type.">Const_reverse_iterator</a>. </p>
<p >Note these are standard semantics (see <code>std::set</code>, etc.). </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00086">86</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a63a280071f879fc40d0f62566d50fd76" name="a63a280071f879fc40d0f62566d50fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a280071f879fc40d0f62566d50fd76">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for index into array of items, where items are all applicable objects including <code>Value</code>s and <code>Key</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00066">66</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a591977b7bbcb0112db06722a9c9180a3" name="a591977b7bbcb0112db06722a9c9180a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591977b7bbcb0112db06722a9c9180a3">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Value =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for values, which in this case are simply the keys. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00053">53</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ad60bc54644375aff266f08a735e07610" name="ad60bc54644375aff266f08a735e07610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60bc54644375aff266f08a735e07610">&#9670;&nbsp;</a></span>Value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Value_list =  std::list&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for doubly linked list of <code>Key</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00059">59</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a3a2690e27808a52713648282471c2848" name="a3a2690e27808a52713648282471c2848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2690e27808a52713648282471c2848">&#9670;&nbsp;</a></span>Value_list_const_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Value_list_const_iter =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for const iterator into doubly linked list of <code>Key</code> elements. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00467">467</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a383dac9998972cccbf12271d50ab081d" name="a383dac9998972cccbf12271d50ab081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383dac9998972cccbf12271d50ab081d">&#9670;&nbsp;</a></span>Value_list_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Value_list_iter =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for iterator into doubly linked list of <code>Key</code> elements. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00464">464</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a495a8e84dda748d4f91cc3d3d2dabe6a" name="a495a8e84dda748d4f91cc3d3d2dabe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495a8e84dda748d4f91cc3d3d2dabe6a">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::value_type =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Value</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00091">91</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8fd4b8108679dd6bb7551ebdbda0eb0" name="af8fd4b8108679dd6bb7551ebdbda0eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fd4b8108679dd6bb7551ebdbda0eb0">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash const &amp;&#160;</td>
          <td class="paramname"><em>hasher_instance</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>key_equal_instance</em> = <code>Pred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty structure with some basic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_buckets</td><td>Number of buckets for the unordered (hash) table. Special value -1 (default) will cause us to use whatever <code>unordered_set&lt;&gt;</code> would use by default. </td></tr>
    <tr><td class="paramname">hasher_instance</td><td>Instance of the hash function type (<code>hasher_instance(Key k)</code> should be <code>size_type</code>d hash of key <code>k</code>). </td></tr>
    <tr><td class="paramname">key_equal_instance</td><td>Instance of the equality function type (<code>key_equal_instance(Key k1, Key k2)</code> should return <code>true</code> if and only if <code>k1</code> equals <code>k2</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00486">486</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a7696dc83d8806530a9d2c916a9e30267" name="a7696dc83d8806530a9d2c916a9e30267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7696dc83d8806530a9d2c916a9e30267">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash const &amp;&#160;</td>
          <td class="paramname"><em>hasher_instance</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>key_equal_instance</em> = <code>Pred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs structure with some basic parameters, and values initialized from initializer list. </p>
<p >The values are inserted as if <code>insert(v)</code> was called for each pair <code>v</code> in <code>values</code> <em>in reverse order</em>. Since the canonical ordering places the <em>newest</em> (last inserted/touch()ed) element at the <em>front</em> of the ordering, that means that forward iteration through the set (right after this constructor runs) will yield values in the <em>same</em> order as in initializer list <code>values</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Values with which to fill the structure after initializing it. Typically you'd provide a series of keys like this: <code>{ key1, key2, ... }</code>. They will appear in iterated sequence in the same order as they appear in this list. </td></tr>
    <tr><td class="paramname">n_buckets</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">hasher_instance</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">key_equal_instance</td><td>See other constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00495">495</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00478">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_keys_into_list_map</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00475">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_value_list</a>.</p>

</div>
</div>
<a id="a1c2d3f7dc9e172260d7623f83a6bc5fc" name="a1c2d3f7dc9e172260d7623f83a6bc5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2d3f7dc9e172260d7623f83a6bc5fc">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object that is a copy of the given source. </p>
<p >Equivalent to <code>operator=(src)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00525">525</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00540">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a1c2d3f7dc9e172260d7623f83a6bc5fc_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae6caa0e9ac4ef9eadccf6045f56c2700" name="ae6caa0e9ac4ef9eadccf6045f56c2700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6caa0e9ac4ef9eadccf6045f56c2700">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object by making it equal to the given source, while the given source becomes as-if default-cted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00532">532</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00540">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_ae6caa0e9ac4ef9eadccf6045f56c2700_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1357ad93c44d71da9c02277c40b86d51" name="a1357ad93c44d71da9c02277c40b86d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1357ad93c44d71da9c02277c40b86d51">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac2d182fa6a6b6814527477991bc6ca68" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ac2d182fa6a6b6814527477991bc6ca68" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00754">754</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="aab1ed34864543d891f92c1ecf0a87dbc" name="aab1ed34864543d891f92c1ecf0a87dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1ed34864543d891f92c1ecf0a87dbc">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00761">761</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a1c0b5df45440be15dfac6c84fd436d00" name="a1c0b5df45440be15dfac6c84fd436d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b5df45440be15dfac6c84fd436d00">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00789">789</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a8844c7594a079eb2d52d78436ed832c6" name="a8844c7594a079eb2d52d78436ed832c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8844c7594a079eb2d52d78436ed832c6">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad2ce3ff8f57696dcb230f419775ab865" title="Returns number of elements stored.">size()</a> == 0</code>. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00722">722</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00649">flow::net_flow::Event_set::clear_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">flow::net_flow::Event_set::clear_wanted_sockets()</a>, and <a class="el" href="event__set_8cpp_source.html#l00613">flow::net_flow::Event_set::emit_result_sockets()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a8844c7594a079eb2d52d78436ed832c6_icgraph.svg" width="344" height="239"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a72041477813e1e9cc8b4e793fb9830d0" name="a72041477813e1e9cc8b4e793fb9830d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72041477813e1e9cc8b4e793fb9830d0">&#9670;&nbsp;</a></span>const_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">::Value</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>)</code>. </p>
<p >All other comments for <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a926db7e9160df1ff73634a7039e7c30c" title="Returns reference to immutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(th...">const_front()</a> apply analogously.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to immutable <code>Key</code> (a/k/a <code>Value</code>) directly inside data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00643">643</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a926db7e9160df1ff73634a7039e7c30c" name="a926db7e9160df1ff73634a7039e7c30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926db7e9160df1ff73634a7039e7c30c">&#9670;&nbsp;</a></span>const_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">::Value</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a91021f4ea7018811502cab360284c6aa" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>)</code>. </p>
<p >OK to call when <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>; but behavior undefined if you attempt to access the result in any way if either <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a> when this was called; or if <code>!empty()</code> at that time, but the underlying element is erased at time of access. If not <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a></code> when this was called, then resulting reference continues to be valid as long as the underlying element is not erased; however, in the future the reference (while referring to the same element) might not refer to front ("newest") element any longer. (Informally, most uses would only call <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a926db7e9160df1ff73634a7039e7c30c" title="Returns reference to immutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(th...">const_front()</a> when <code>!empty()</code>, and would access it immediately and but once. However, I'm listing the corner cases above.)</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to immutable <code>Key</code> (a/k/a <code>Value</code>) directly inside data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00635">635</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a91021f4ea7018811502cab360284c6aa" name="a91021f4ea7018811502cab360284c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91021f4ea7018811502cab360284c6aa">&#9670;&nbsp;</a></span>const_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00747">747</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ae0cb0394a239b8855a711d417aabe8e7" name="ae0cb0394a239b8855a711d417aabe8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb0394a239b8855a711d417aabe8e7">&#9670;&nbsp;</a></span>const_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00803">803</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a16f0324ec7c8fb399ab002ea52ff4252" name="a16f0324ec7c8fb399ab002ea52ff4252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f0324ec7c8fb399ab002ea52ff4252">&#9670;&nbsp;</a></span>const_past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00831">831</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a089ee6d083911c14d0fd44075b90b452" name="a089ee6d083911c14d0fd44075b90b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089ee6d083911c14d0fd44075b90b452">&#9670;&nbsp;</a></span>const_past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::const_past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00775">775</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a9ba615340ed6d9b5d9c6ddd5284db4a5" name="a9ba615340ed6d9b5d9c6ddd5284db4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba615340ed6d9b5d9c6ddd5284db4a5">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::count </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times a key is equivalent to the given one is present in the hash: either 1 or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or 1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00628">628</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a9e7c81fa11afdcfc9dd98665d1cd9af6" name="a9e7c81fa11afdcfc9dd98665d1cd9af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7c81fa11afdcfc9dd98665d1cd9af6">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae0cb0394a239b8855a711d417aabe8e7" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae0cb0394a239b8855a711d417aabe8e7" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00817">817</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="adb6490d9e317333934687919afa5be69" name="adb6490d9e317333934687919afa5be69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6490d9e317333934687919afa5be69">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa9037058b814aba5dc586e47638cbb7d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a16f0324ec7c8fb399ab002ea52ff4252" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a16f0324ec7c8fb399ab002ea52ff4252" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00845">845</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a048a8d78c4ae3bc45c8bcede6b0e2dc6" name="a048a8d78c4ae3bc45c8bcede6b0e2dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a8d78c4ae3bc45c8bcede6b0e2dc6">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if container is empty. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00858">858</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, and <a class="el" href="event__set_8cpp_source.html#l01017">flow::net_flow::Node::event_set_check_baseline()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a048a8d78c4ae3bc45c8bcede6b0e2dc6_icgraph.svg" width="2055" height="830"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a70a6bcbb95db8aa81dfb5112f3526304" name="a70a6bcbb95db8aa81dfb5112f3526304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a6bcbb95db8aa81dfb5112f3526304">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab40f5659f15a52138f6dcd9f8ac92a59" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab40f5659f15a52138f6dcd9f8ac92a59" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00782">782</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a4b63c73e7c2d6092331cb7bd3267b830" name="a4b63c73e7c2d6092331cb7bd3267b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63c73e7c2d6092331cb7bd3267b830">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element pointed to by the given valid iterator. </p>
<p >Behavior undefined if it is not valid. <code>it</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator of element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator one position past (i.e., "older") than <code>it</code>, before <code>*it</code> was removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00671">671</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8hpp_source.html#l01052">flow::net_flow::Event_set::remove_wanted_socket()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a4b63c73e7c2d6092331cb7bd3267b830_icgraph.svg" width="354" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2eeea34058e69e5dddb90bb92677cb92" name="a2eeea34058e69e5dddb90bb92677cb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eeea34058e69e5dddb90bb92677cb92">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it_newest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it_past_oldest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>). </p>
<p >Behavior undefined if given iterator is invalid. <code>it_newest</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it_newest</td><td>Iterator of first ("newest") element to erase. </td></tr>
    <tr><td class="paramname">it_past_oldest</td><td>Iterator of one past last ("oldest") element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>it_past_oldest</code> copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00679">679</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="aaeafee2318c0a3d173d005130ff58c88" name="aaeafee2318c0a3d173d005130ff58c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeafee2318c0a3d173d005130ff58c88">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element with the given key, if it exists. </p>
<p >Return value indicates various info of interest about what occurred or did not occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key such that its equal's (if found) element will be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased (0 or 1). </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00692">692</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a94baeef5c7506029339f81a77e7b8d37" name="a94baeef5c7506029339f81a77e7b8d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94baeef5c7506029339f81a77e7b8d37">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find the given key in the set. </p>
<p >Key presence is determined according to the <code>Pred</code> template parameter which determines equality of 2 given keys; and via the <code>Hash</code> template parameter that enables efficient hash-based lookup. The returned iterator (if valid) cannot be used to mutate the elements stored in the map.</p>
<p >As long as the key is not removed from the map, the iterator will continue to be valid.</p>
<dl class="section note"><dt>Note</dt><dd>Let <code>r</code> be the returned value. Since no <code>key</code>-associated value beyond <code>key</code> itself is stored in the structure, the fact that <code>*r == key</code> is not valuable: you already had <code>key</code> after all! It is only useful in pin-pointing the relative location in the chronological ordering; in being used as an argument to various erasing methods; and in checking for presence of the key in the set. For the latter, I recommend the following utility: </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866" title="Returns true if and only if the given key is present at least once in the given associative container...">util::key_exists()</a>, which uses this method to more concisely check for the presence of a key. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a089ee6d083911c14d0fd44075b90b452" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00620">620</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a517b9b0ac9d6ab2c56e27ba380f87180" name="a517b9b0ac9d6ab2c56e27ba380f87180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517b9b0ac9d6ab2c56e27ba380f87180">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the given key into the set. </p>
<p >If the key is already present in the set, does nothing. Return value indicates various info of interest about what occurred or did not occur. Key presence is determined according to the <code>Pred</code> template parameter which determines equality of 2 given keys; and via the <code>Hash</code> template parameter that enables efficient hash-based lookup. If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6c3c86dc0fa2ae968fad1764241352fe" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to attempt to insert. This value is copied, and the copy is inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair whose second element is <code>true</code> if and only if the insertion occurred; and whose first element is an iterator pointing to either the newly inserted element or already present one equal to <code>key</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00591">591</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, and <a class="el" href="event__set_8cpp_source.html#l01017">flow::net_flow::Node::event_set_check_baseline()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a517b9b0ac9d6ab2c56e27ba380f87180_icgraph.svg" width="2051" height="830"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0a37ac9af14d0061e5b44436f939bc5c" name="a0a37ac9af14d0061e5b44436f939bc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a37ac9af14d0061e5b44436f939bc5c">&#9670;&nbsp;</a></span>insert_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::insert_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a591977b7bbcb0112db06722a9c9180a3">Value</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4bae43bd9a1b68903af4b6f9452ccf9e" title="See Linked_hash_map::m_value_list. Essentially all of that applies here.">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aaac0d1e29ab268c967db182b30b766cc" title="See Linked_hash_map::m_keys_into_list_map. Essentially all of that applies here.">m_keys_into_list_map</a> so that <code>key</code>'s copy is inserted into the structure. </p>
<p >Pre-condition is that <code>key</code> is not in the structure (else behavior undefined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Same as in <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a517b9b0ac9d6ab2c56e27ba380f87180" title="Attempts to insert the given key into the set.">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as in <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a517b9b0ac9d6ab2c56e27ba380f87180" title="Attempts to insert the given key into the set.">insert()</a>.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00607">607</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ac1bfed582b7ee057afe92be2bbabb422" name="ac1bfed582b7ee057afe92be2bbabb422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bfed582b7ee057afe92be2bbabb422">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max number of elements that can be stored. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;</code> + <code>list&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00865">865</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ac2d182fa6a6b6814527477991bc6ca68" name="ac2d182fa6a6b6814527477991bc6ca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d182fa6a6b6814527477991bc6ca68">&#9670;&nbsp;</a></span>newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00740">740</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a698156501a7a0c1c1f623b90527b1254" name="a698156501a7a0c1c1f623b90527b1254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698156501a7a0c1c1f623b90527b1254">&#9670;&nbsp;</a></span>oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00796">796</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="add06f0744ac3838635500262c96282cd" name="add06f0744ac3838635500262c96282cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add06f0744ac3838635500262c96282cd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object making it equal to the given source, while the given source becomes as-if default-cted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied (unless it <em>is</em> <code>*this</code>; then no-op). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00579">579</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l01664">flow::util::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_add06f0744ac3838635500262c96282cd_cgraph.svg" width="306" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8fc7b499be6563aff0f8bded23c05fb0" name="a8fc7b499be6563aff0f8bded23c05fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc7b499be6563aff0f8bded23c05fb0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object with a copy of the given source. </p>
<p >We become equal to <code>src</code> but independent of it to the max extent possible (if you've got pointers stored in there, for example, the pointers are copied, not the values at those pointers). In addition, the hasher instance and equality predicate are copied from <code>src</code>. Finally, a reasonable attempt is made to also make the internal structure of the hash set to be similar to that of <code>src</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00540">540</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00478">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_keys_into_list_map</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00475">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_value_list</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__set_8hpp_source.html#l00525">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::Linked_hash_set()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a8fc7b499be6563aff0f8bded23c05fb0_icgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a736cffd41262e99cbff13c081edc15a3" name="a736cffd41262e99cbff13c081edc15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736cffd41262e99cbff13c081edc15a3">&#9670;&nbsp;</a></span>past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00824">824</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ab40f5659f15a52138f6dcd9f8ac92a59" name="ab40f5659f15a52138f6dcd9f8ac92a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40f5659f15a52138f6dcd9f8ac92a59">&#9670;&nbsp;</a></span>past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a38053f68629a24e2ead1be3e052e99b1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00768">768</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ab2caa69df6af34e5cc98e4be24203639" name="ab2caa69df6af34e5cc98e4be24203639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2caa69df6af34e5cc98e4be24203639">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::pop_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue-style pop (erase) of the back &ndash; a/k/a oldest &ndash; element. Behavior undefined if <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00715">715</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a8c1b763a78cae4f2636489b542685774" name="a8c1b763a78cae4f2636489b542685774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1b763a78cae4f2636489b542685774">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::pop_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue-style pop (erase) of the front &ndash; a/k/a newest &ndash; element. Behavior undefined if <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a048a8d78c4ae3bc45c8bcede6b0e2dc6" title="Returns true if and only if container is empty.">empty()</a>. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00708">708</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ab1696ca2455aeb36ba99387091373150" name="ab1696ca2455aeb36ba99387091373150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1696ca2455aeb36ba99387091373150">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a698156501a7a0c1c1f623b90527b1254" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a698156501a7a0c1c1f623b90527b1254" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00810">810</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="a92064c4a806fdddef54062bfe9b89250" name="a92064c4a806fdddef54062bfe9b89250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92064c4a806fdddef54062bfe9b89250">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7df080186975dae439759eb42e1eea83">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a736cffd41262e99cbff13c081edc15a3" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a736cffd41262e99cbff13c081edc15a3" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00838">838</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="ad2ce3ff8f57696dcb230f419775ab865" name="ad2ce3ff8f57696dcb230f419775ab865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ce3ff8f57696dcb230f419775ab865">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a63a280071f879fc40d0f62566d50fd76">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00852">852</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00649">flow::net_flow::Event_set::clear_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">flow::net_flow::Event_set::clear_wanted_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00613">flow::net_flow::Event_set::emit_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, and <a class="el" href="event__set_8cpp_source.html#l00493">flow::net_flow::Event_set::swap_wanted_sockets()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_ad2ce3ff8f57696dcb230f419775ab865_icgraph.svg" width="2052" height="867"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a46e27b1b9b75e5dc890af26f85956190" name="a46e27b1b9b75e5dc890af26f85956190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e27b1b9b75e5dc890af26f85956190">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>. </p>
<p >This is a constant-time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00729">729</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00478">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_keys_into_list_map</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00475">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::m_value_list</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00871">flow::util::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00613">flow::net_flow::Event_set::emit_result_sockets()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00871">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>, and <a class="el" href="event__set_8cpp_source.html#l00493">flow::net_flow::Event_set::swap_wanted_sockets()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a46e27b1b9b75e5dc890af26f85956190_cgraph.svg" width="279" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_a46e27b1b9b75e5dc890af26f85956190_icgraph.svg" width="347" height="215"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6c3c86dc0fa2ae968fad1764241352fe" name="a6c3c86dc0fa2ae968fad1764241352fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3c86dc0fa2ae968fad1764241352fe">&#9670;&nbsp;</a></span>touch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::touch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a57f3367e577133372e20341f4c4f6413">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a valid iterator into the structure, makes the pointed to element "newest" by moving it from wherever it is to be first in the iteration order. </p>
<p >Behavior undefined if iterator invalid.</p>
<p >The iterator continues to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to an element of the structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00650">650</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<a id="add178239cda109799d349bdcf8bb15a3" name="add178239cda109799d349bdcf8bb15a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add178239cda109799d349bdcf8bb15a3">&#9670;&nbsp;</a></span>touch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key. </p>
<p >Return value indicates various info of interest about what occurred or did not occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key was found (even if it was already "newest"); false if not found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00656">656</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac7fd808e839d422a3f74fbea57fe367e" name="ac7fd808e839d422a3f74fbea57fe367e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fd808e839d422a3f74fbea57fe367e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>val1.swap(val2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00871">871</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00729">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__set_ac7fd808e839d422a3f74fbea57fe367e_cgraph.svg" width="440" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaac0d1e29ab268c967db182b30b766cc" name="aaac0d1e29ab268c967db182b30b766cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac0d1e29ab268c967db182b30b766cc">&#9670;&nbsp;</a></span>m_keys_into_list_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab18a010dba2965436645418572ce6531">Key_to_value_iter_map</a>&gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::m_keys_into_list_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">Linked_hash_map::m_keys_into_list_map</a>. Essentially all of that applies here. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00478">478</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__set_8hpp_source.html#l00495">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::Linked_hash_set()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00540">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::operator=()</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00729">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>.</p>

</div>
</div>
<a id="a4bae43bd9a1b68903af4b6f9452ccf9e" name="a4bae43bd9a1b68903af4b6f9452ccf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bae43bd9a1b68903af4b6f9452ccf9e">&#9670;&nbsp;</a></span>m_value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad60bc54644375aff266f08a735e07610">Value_list</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key, Hash, Pred &gt;::m_value_list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">Linked_hash_map::m_value_list</a>. Essentially all of that applies here. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__set_8hpp_source.html#l00475">475</a> of file <a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__set_8hpp_source.html#l00495">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::Linked_hash_set()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00540">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::operator=()</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00729">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="linked__hash__set_8hpp_source.html">linked_hash_set.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 8 2024 11:50:38 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
