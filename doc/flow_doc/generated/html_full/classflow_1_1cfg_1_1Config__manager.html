<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::cfg::Config_manager&lt; S_d_value_set &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1cfg.html">cfg</a></li><li class="navelem"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1cfg_1_1Config__manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::cfg::Config_manager&lt; S_d_value_set &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of static config and dynamic config, each, via that number of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> types supplied by the user as template arguments.  
 <a href="classflow_1_1cfg_1_1Config__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::cfg::Config_manager&lt; S_d_value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager__inherit__graph.svg" width="178" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::cfg::Config_manager&lt; S_d_value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager__coll__graph.svg" width="1502" height="668"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque handle for managing a dynamic config change callback.  <a href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6768eb0c92bd11fd84986058903b10d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a> { <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed">S_ALLOW_INVALID_DEFAULTS</a>
 }</td></tr>
<tr class="memdesc:a6768eb0c92bd11fd84986058903b10d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type: indicates an <code>apply_*()</code> method must <em>allow</em> invalid defaults and only complain if the config source does not explicitly supply a valid value.  <a href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">More...</a><br /></td></tr>
<tr class="separator:a6768eb0c92bd11fd84986058903b10d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab501967b40259c1a29264af1ad17baf2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void()&gt;</td></tr>
<tr class="memdesc:ab501967b40259c1a29264af1ad17baf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a callback to execute on dynamic config change.  <a href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">More...</a><br /></td></tr>
<tr class="separator:ab501967b40259c1a29264af1ad17baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad59bfabf66e01922542629bae77508ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad59bfabf66e01922542629bae77508ad">Config_manager</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> nickname, typename <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; S_d_value_set &gt;::Declare_options_func &amp;&amp;... declare_opts_func_moved)</td></tr>
<tr class="memdesc:ad59bfabf66e01922542629bae77508ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ready to read initial config via <code>apply_*()</code> and other setup methods; and further capable of both static and dynamic config.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad59bfabf66e01922542629bae77508ad">More...</a><br /></td></tr>
<tr class="separator:ad59bfabf66e01922542629bae77508ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707">apply_static</a> (const fs::path &amp;static_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:a22bfec8082d0c7b5dff9ee7e98865707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this after construction to load the permanent set of static config from config sources including a static config file; if you are also using dynamic config, see <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> as a <em>potential</em> alternative.  <a href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707">More...</a><br /></td></tr>
<tr class="separator:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#af027c6f4b595f1f8ebbd6d41ad705f5e">apply_static</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;static_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#af027c6f4b595f1f8ebbd6d41ad705f5e">More...</a><br /></td></tr>
<tr class="separator:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304">apply_static_and_dynamic</a> (const fs::path &amp;cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use dynamic config, <em>and</em> you allow for initial values for dynamic options to be read from the same file as the static config values, then invoke this instead of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304">More...</a><br /></td></tr>
<tr class="separator:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a5d85fa5a1ed933c9b85444ddb9a416b1">apply_static_and_dynamic</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#a5d85fa5a1ed933c9b85444ddb9a416b1">More...</a><br /></td></tr>
<tr class="separator:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26712af2d38d3afbeb52d21b7012a03c"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a26712af2d38d3afbeb52d21b7012a03c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c">apply_dynamic</a> (const fs::path &amp;dynamic_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:a26712af2d38d3afbeb52d21b7012a03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the first or subsequent set of dynamic config from config source including a dynamic config file.  <a href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c">More...</a><br /></td></tr>
<tr class="separator:a26712af2d38d3afbeb52d21b7012a03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2503b020137aca00a8ee4b81fc921750"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a2503b020137aca00a8ee4b81fc921750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a2503b020137aca00a8ee4b81fc921750">apply_dynamic</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;dynamic_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit=true)</td></tr>
<tr class="memdesc:a2503b020137aca00a8ee4b81fc921750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; except that &ndash; applicably only to the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> without a preceding <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> &ndash; skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#a2503b020137aca00a8ee4b81fc921750">More...</a><br /></td></tr>
<tr class="separator:a2503b020137aca00a8ee4b81fc921750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ab5cefe86e6aaa0518d675f309907e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e">reject_candidates</a> ()</td></tr>
<tr class="memdesc:ac1ab5cefe86e6aaa0518d675f309907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.  <a href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e">More...</a><br /></td></tr>
<tr class="separator:ac1ab5cefe86e6aaa0518d675f309907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c7224711ef8a51c7005629e4eae6e7"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a76c7224711ef8a51c7005629e4eae6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7">all_static_values</a> (const Value_set **... value_set_or_null) const</td></tr>
<tr class="memdesc:a76c7224711ef8a51c7005629e4eae6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a pointer to each permanently set static config value set; the same pointers are emitted throughout for each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> static config slots.  <a href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7">More...</a><br /></td></tr>
<tr class="separator:a76c7224711ef8a51c7005629e4eae6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486">all_static_values_candidates</a> (const Value_set **... value_set_or_null) const</td></tr>
<tr class="memdesc:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then for any static value set for which values have been parsed and validated (but not yet applied) so far, a pointer to the parsed values <em>candidate</em> will be emitted instead.  <a href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486">More...</a><br /></td></tr>
<tr class="separator:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8431806f82bed676f5fedb3b64f67245"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a8431806f82bed676f5fedb3b64f67245"><td class="memTemplItemLeft" align="right" valign="top">const Value_set &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245">static_values</a> (size_t s_value_set_idx) const</td></tr>
<tr class="memdesc:a8431806f82bed676f5fedb3b64f67245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but obtains the static config in <em>one</em> specified slot as opposed to all of them.  <a href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245">More...</a><br /></td></tr>
<tr class="separator:a8431806f82bed676f5fedb3b64f67245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae034a71792f952256c18e385475627d1"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:ae034a71792f952256c18e385475627d1"><td class="memTemplItemLeft" align="right" valign="top">const Value_set &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1">static_values_candidate</a> (size_t s_value_set_idx) const</td></tr>
<tr class="memdesc:ae034a71792f952256c18e385475627d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then the parsed values <em>candidate</em> will be returned, instead, if values have been parsed and validated for the static value set but have not yet been applied.  <a href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1">More...</a><br /></td></tr>
<tr class="separator:ae034a71792f952256c18e385475627d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afb8620600dcb54d41211ef68859f93"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a6afb8620600dcb54d41211ef68859f93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93">all_dynamic_values</a> (typename Value_set::Const_ptr *... value_set_or_null) const</td></tr>
<tr class="memdesc:a6afb8620600dcb54d41211ef68859f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at <code>struct</code> is set permanently; while another call may return a different pointer if config is changed dynamically in the meantime (for that slot).  <a href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93">More...</a><br /></td></tr>
<tr class="separator:a6afb8620600dcb54d41211ef68859f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memTemplItemLeft" align="right" valign="top">Value_set::Const_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f">dynamic_values</a> (size_t d_value_set_idx) const</td></tr>
<tr class="memdesc:ac2239443cf48bfdaa78c95af935e1d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> but obtains the dynamic config in <em>one</em> specified slot as opposed to all of them.  <a href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f">More...</a><br /></td></tr>
<tr class="separator:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978295c03998af212b464061d780520b"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a978295c03998af212b464061d780520b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b">register_dynamic_change_listener</a> (size_t d_value_set_idx, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> &amp;&amp;on_dynamic_change_func_moved)</td></tr>
<tr class="memdesc:a978295c03998af212b464061d780520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the given callback; next time <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> detects at least one changed (or initially set) option value in the specified slot, it will execute this and any other previously registered such callbacks synchronously.  <a href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b">More...</a><br /></td></tr>
<tr class="separator:a978295c03998af212b464061d780520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d">unregister_dynamic_change_listener</a> (const <a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a> &amp;handle)</td></tr>
<tr class="memdesc:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously registered dynamic change callback.  <a href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d">More...</a><br /></td></tr>
<tr class="separator:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ae9775f51953805ea08086c276a78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d">state_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a19ae9775f51953805ea08086c276a78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of current values where applicable.  <a href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d">More...</a><br /></td></tr>
<tr class="separator:a19ae9775f51953805ea08086c276a78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220535219634c62ed2a580934c76c481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481">log_state</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:a220535219634c62ed2a580934c76c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> would print.  <a href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481">More...</a><br /></td></tr>
<tr class="separator:a220535219634c62ed2a580934c76c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c">help_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a human-targeted long-form usage message that includes all options with their descriptions and defaults.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c">More...</a><br /></td></tr>
<tr class="separator:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0192ddc2cc7302bdc8720ee56a395c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">log_help</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:a0192ddc2cc7302bdc8720ee56a395c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> would print.  <a href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">More...</a><br /></td></tr>
<tr class="separator:a0192ddc2cc7302bdc8720ee56a395c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a68da387dad566805b969aded698661cb"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a68da387dad566805b969aded698661cb">m_nickname</a></td></tr>
<tr class="memdesc:a68da387dad566805b969aded698661cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <code>nickname</code> ctor arg.  <a href="classflow_1_1cfg_1_1Config__manager.html#a68da387dad566805b969aded698661cb">More...</a><br /></td></tr>
<tr class="separator:a68da387dad566805b969aded698661cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8">S_N_VALUE_SETS</a> = sizeof...(S_d_value_set)</td></tr>
<tr class="memdesc:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of template params in this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> instantiation. It must be even and positive.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8">More...</a><br /></td></tr>
<tr class="separator:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c07f711e98435d00420277f1c20be75"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75">S_N_S_VALUE_SETS</a> = sizeof...(S_d_value_set) / 2</td></tr>
<tr class="memdesc:a9c07f711e98435d00420277f1c20be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of static value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s).  <a href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75">More...</a><br /></td></tr>
<tr class="separator:a9c07f711e98435d00420277f1c20be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c2d6efe1670e940badccb3fdea609"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a> = sizeof...(S_d_value_set) / 2</td></tr>
<tr class="memdesc:ac26c2d6efe1670e940badccb3fdea609"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dynamic value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s).  <a href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">More...</a><br /></td></tr>
<tr class="separator:ac26c2d6efe1670e940badccb3fdea609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa0d03f4dcf7be2c21023c4073ac68b85"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">Update_type</a> { <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85a9ed9d44ce5760f61ea506d5571343624">S_NONE</a>
, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85ab31234e7337465421b3bc64639994ca3">S_STATIC</a>
, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85a126ca201c7b5e56a78174fda3d16ff7a">S_STATIC_AND_DYNAMIC</a>
, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85a7612e6cb583f768c5df52e1c5d03a85e">S_DYNAMIC</a>
 }</td></tr>
<tr class="memdesc:aa0d03f4dcf7be2c21023c4073ac68b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful at least in the context of multi-source (<code>commit == false</code>) <code>apply_*()</code> methods, this distinguishes distinct possible public <code>apply_*()</code> methods.  <a href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">More...</a><br /></td></tr>
<tr class="separator:aa0d03f4dcf7be2c21023c4073ac68b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f366f4070a90740e27d73029852e55f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a> = boost::shared_ptr&lt; void &gt;</td></tr>
<tr class="memdesc:a6f366f4070a90740e27d73029852e55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>shared_ptr</code>-to-<code>void</code> type used to store variable-type values in internal containers.  <a href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">More...</a><br /></td></tr>
<tr class="separator:a6f366f4070a90740e27d73029852e55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a318e125f78cb7e471cae35e2651ab01f"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a318e125f78cb7e471cae35e2651ab01f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f">opt_set</a> (size_t value_set_idx)</td></tr>
<tr class="memdesc:a318e125f78cb7e471cae35e2651ab01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that obtains the <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> in the slot <code>m_s_d_opt_sets[value_set_idx]</code>, which stores an Option_set&lt;Value_set&gt;.  <a href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f">More...</a><br /></td></tr>
<tr class="separator:a318e125f78cb7e471cae35e2651ab01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe40d6451276e0d4c7c0867669791f9c"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:abe40d6451276e0d4c7c0867669791f9c"><td class="memTemplItemLeft" align="right" valign="top">Value_set *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#abe40d6451276e0d4c7c0867669791f9c">d_baseline_value_set</a> (size_t d_value_set_idx)</td></tr>
<tr class="memdesc:abe40d6451276e0d4c7c0867669791f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that obtains the baseline dynamic <code>Value_set</code> in the slot <code>m_d_baseline_value_sets[value_set_idx]</code>, which stores a <code>Value_set</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#abe40d6451276e0d4c7c0867669791f9c">More...</a><br /></td></tr>
<tr class="separator:abe40d6451276e0d4c7c0867669791f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54e2f1360834ece6fd06d34b387978c"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:af54e2f1360834ece6fd06d34b387978c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#af54e2f1360834ece6fd06d34b387978c">opt_set</a> (size_t value_set_idx) const</td></tr>
<tr class="memdesc:af54e2f1360834ece6fd06d34b387978c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>const</code> overload of the other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> helper.  <a href="classflow_1_1cfg_1_1Config__manager.html#af54e2f1360834ece6fd06d34b387978c">More...</a><br /></td></tr>
<tr class="separator:af54e2f1360834ece6fd06d34b387978c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9f7e2dd8973d5ff191eee1c2394cae"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a2c9f7e2dd8973d5ff191eee1c2394cae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a2c9f7e2dd8973d5ff191eee1c2394cae">option_set_canonicalize_or_reject</a> (<a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f">opt_set</a>, <a class="el" href="classbool.html">bool</a> canonicalize_else_reject, <a class="el" href="classbool.html">bool</a> *changed_or_null)</td></tr>
<tr class="memdesc:a2c9f7e2dd8973d5ff191eee1c2394cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that executes <code>opt_set-&gt;canonicalize_candidate()</code> or <code>opt_set-&gt;reject_candidate()</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a2c9f7e2dd8973d5ff191eee1c2394cae">More...</a><br /></td></tr>
<tr class="separator:a2c9f7e2dd8973d5ff191eee1c2394cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad320a74f83474c93cce385b0b9da887e"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:ad320a74f83474c93cce385b0b9da887e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad320a74f83474c93cce385b0b9da887e">apply_static_impl</a> (<a class="el" href="classbool.html">bool</a> allow_invalid_defaults, const fs::path &amp;static_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit)</td></tr>
<tr class="memdesc:ad320a74f83474c93cce385b0b9da887e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overloads.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad320a74f83474c93cce385b0b9da887e">More...</a><br /></td></tr>
<tr class="separator:ad320a74f83474c93cce385b0b9da887e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8864e575c78251d3b8e109f86f29b703"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a8864e575c78251d3b8e109f86f29b703"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8864e575c78251d3b8e109f86f29b703">apply_dynamic_impl</a> (<a class="el" href="classbool.html">bool</a> allow_invalid_defaults, const fs::path &amp;dynamic_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit)</td></tr>
<tr class="memdesc:a8864e575c78251d3b8e109f86f29b703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overloads.  <a href="classflow_1_1cfg_1_1Config__manager.html#a8864e575c78251d3b8e109f86f29b703">More...</a><br /></td></tr>
<tr class="separator:a8864e575c78251d3b8e109f86f29b703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62619206c49b1b39c887162d8b6a2305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a62619206c49b1b39c887162d8b6a2305">apply_static_and_dynamic_impl</a> (<a class="el" href="classbool.html">bool</a> allow_invalid_defaults, const fs::path &amp;cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;... final_validator_func, <a class="el" href="classbool.html">bool</a> commit)</td></tr>
<tr class="memdesc:a62619206c49b1b39c887162d8b6a2305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overloads.  <a href="classflow_1_1cfg_1_1Config__manager.html#a62619206c49b1b39c887162d8b6a2305">More...</a><br /></td></tr>
<tr class="separator:a62619206c49b1b39c887162d8b6a2305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7785bcdb7fae9ae7ef6f1919b1f8045"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:aa7785bcdb7fae9ae7ef6f1919b1f8045"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa7785bcdb7fae9ae7ef6f1919b1f8045">apply_static_or_dynamic_impl</a> (<a class="el" href="classbool.html">bool</a> dyn_else_st, const fs::path &amp;cfg_path, const boost::unordered_set&lt; std::string &gt; &amp;all_opt_names_or_empty, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func)</td></tr>
<tr class="memdesc:aa7785bcdb7fae9ae7ef6f1919b1f8045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work-horse helper that parses either <em>all</em> static value sets <em>or</em> <em>all</em> dynamic value sets from the specified file into <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> and returns <code>true</code> if and only if all have succeeded.  <a href="classflow_1_1cfg_1_1Config__manager.html#aa7785bcdb7fae9ae7ef6f1919b1f8045">More...</a><br /></td></tr>
<tr class="separator:aa7785bcdb7fae9ae7ef6f1919b1f8045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae0dfcdde91dcbdd6db4b05fac0112"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a3dae0dfcdde91dcbdd6db4b05fac0112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a3dae0dfcdde91dcbdd6db4b05fac0112">apply_impl</a> (<a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f">opt_set</a>, const Value_set *baseline_value_set_or_null, const fs::path &amp;cfg_path, const boost::unordered_set&lt; std::string &gt; &amp;all_opt_names_or_empty, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;final_validator_func)</td></tr>
<tr class="memdesc:a3dae0dfcdde91dcbdd6db4b05fac0112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work-horse helper that parses into one given <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> (from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>) from the specified file and returns <code>true</code> if and only if successful.  <a href="classflow_1_1cfg_1_1Config__manager.html#a3dae0dfcdde91dcbdd6db4b05fac0112">More...</a><br /></td></tr>
<tr class="separator:a3dae0dfcdde91dcbdd6db4b05fac0112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d2c5d3a9747a26a4e6233a0f1feed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#abe9d2c5d3a9747a26a4e6233a0f1feed">reject_candidates_if_update_type_changed</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">Update_type</a> this_update_type)</td></tr>
<tr class="memdesc:abe9d2c5d3a9747a26a4e6233a0f1feed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the top of <code>apply_*()</code> that guards against a call to <code>apply_Y()</code> following <code>apply_X(commit == false) == true</code> without a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them.  <a href="classflow_1_1cfg_1_1Config__manager.html#abe9d2c5d3a9747a26a4e6233a0f1feed">More...</a><br /></td></tr>
<tr class="separator:abe9d2c5d3a9747a26a4e6233a0f1feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859a36cccd8196d9648f67de8656360a"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a859a36cccd8196d9648f67de8656360a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a859a36cccd8196d9648f67de8656360a">save_dynamic_value_set_locked</a> (<a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f">opt_set</a>, size_t d_value_set_idx)</td></tr>
<tr class="memdesc:a859a36cccd8196d9648f67de8656360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Little helper that, having assumed <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab8463fe083d97fd4d4b49f7265726d2c" title="Mutex protecting m_d_value_sets.">m_d_value_sets_mutex</a> is locked, makes a newly allocated copy of the canonical dynamic config at the given slot and saves a (new) ref-counted pointer to it in the proper <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a> slot.  <a href="classflow_1_1cfg_1_1Config__manager.html#a859a36cccd8196d9648f67de8656360a">More...</a><br /></td></tr>
<tr class="separator:a859a36cccd8196d9648f67de8656360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57140907e43a66705625d391e85e3c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a57140907e43a66705625d391e85e3c52">invoke_dynamic_change_listeners</a> (size_t d_value_set_idx, <a class="el" href="classbool.html">bool</a> init) const</td></tr>
<tr class="memdesc:a57140907e43a66705625d391e85e3c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the registered listeners for the given dynamic config slot (synchronously).  <a href="classflow_1_1cfg_1_1Config__manager.html#a57140907e43a66705625d391e85e3c52">More...</a><br /></td></tr>
<tr class="separator:a57140907e43a66705625d391e85e3c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf1eca924be81654eaa4140814a816f"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:afbf1eca924be81654eaa4140814a816f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#afbf1eca924be81654eaa4140814a816f">state_to_ostream_impl</a> (size_t value_set_idx, std::ostream &amp;os) const</td></tr>
<tr class="memdesc:afbf1eca924be81654eaa4140814a816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> slot <code>value_set_idx</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#afbf1eca924be81654eaa4140814a816f">More...</a><br /></td></tr>
<tr class="separator:afbf1eca924be81654eaa4140814a816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be0e0697c1b106c7170795ee4a225e8"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a8be0e0697c1b106c7170795ee4a225e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8be0e0697c1b106c7170795ee4a225e8">help_to_ostream_impl</a> (size_t value_set_idx, std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a8be0e0697c1b106c7170795ee4a225e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> slot <code>value_set_idx</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a8be0e0697c1b106c7170795ee4a225e8">More...</a><br /></td></tr>
<tr class="separator:a8be0e0697c1b106c7170795ee4a225e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4e724d9d455ea31439c6832d0bc645bd"><td class="memItemLeft" align="right" valign="top">boost::array&lt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8">S_N_VALUE_SETS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd">m_s_d_opt_sets</a></td></tr>
<tr class="memdesc:a4e724d9d455ea31439c6832d0bc645bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static and dynamic value sets, in the same order as the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a> <code>S_d_value_set</code> template args, the specific type for each slot being: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;S_d_value_set&gt;</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd">More...</a><br /></td></tr>
<tr class="separator:a4e724d9d455ea31439c6832d0bc645bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a8745fe3fe54ede7f664b0a4cd8357"><td class="memItemLeft" align="right" valign="top">boost::array&lt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a46a8745fe3fe54ede7f664b0a4cd8357">m_d_baseline_value_sets</a></td></tr>
<tr class="memdesc:a46a8745fe3fe54ede7f664b0a4cd8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">The baseline dynamic value sets, in the same order as <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <em>dynamic</em> <code>S_d_value_set</code> template args, the specific type for each slot being <code>S_d_value_set</code>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a46a8745fe3fe54ede7f664b0a4cd8357">More...</a><br /></td></tr>
<tr class="separator:a46a8745fe3fe54ede7f664b0a4cd8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447aa1d42bc9f40af92ce5968c0edc82"><td class="memItemLeft" align="right" valign="top">boost::array&lt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82">m_d_value_sets</a></td></tr>
<tr class="memdesc:a447aa1d42bc9f40af92ce5968c0edc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dynamic config ref-counted handles returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82">More...</a><br /></td></tr>
<tr class="separator:a447aa1d42bc9f40af92ce5968c0edc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8463fe083d97fd4d4b49f7265726d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">util::Mutex_non_recursive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab8463fe083d97fd4d4b49f7265726d2c">m_d_value_sets_mutex</a></td></tr>
<tr class="memdesc:ab8463fe083d97fd4d4b49f7265726d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a>.  <a href="classflow_1_1cfg_1_1Config__manager.html#ab8463fe083d97fd4d4b49f7265726d2c">More...</a><br /></td></tr>
<tr class="separator:ab8463fe083d97fd4d4b49f7265726d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba012812d46fcc6588d4bb8c4d04c9"><td class="memItemLeft" align="right" valign="top">boost::array&lt; std::list&lt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> &gt;, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a08ba012812d46fcc6588d4bb8c4d04c9">m_on_dynamic_change_funcs</a></td></tr>
<tr class="memdesc:a08ba012812d46fcc6588d4bb8c4d04c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of callbacks to execute after <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a> members (the pointers) are next assigned: one per each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> dynamic config slots.  <a href="classflow_1_1cfg_1_1Config__manager.html#a08ba012812d46fcc6588d4bb8c4d04c9">More...</a><br /></td></tr>
<tr class="separator:a08ba012812d46fcc6588d4bb8c4d04c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e43bae09415b5a12a6b9e9f3e01756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0e43bae09415b5a12a6b9e9f3e01756">m_dynamic_values_set</a></td></tr>
<tr class="memdesc:aa0e43bae09415b5a12a6b9e9f3e01756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts <code>false</code>; set to <code>true</code> permanently on successful <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.  <a href="classflow_1_1cfg_1_1Config__manager.html#aa0e43bae09415b5a12a6b9e9f3e01756">More...</a><br /></td></tr>
<tr class="separator:aa0e43bae09415b5a12a6b9e9f3e01756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b46ed066f012a633ca16c400441ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">Update_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac74b46ed066f012a633ca16c400441ac">m_multi_src_update_in_progress</a></td></tr>
<tr class="memdesc:ac74b46ed066f012a633ca16c400441ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">In short, truthy if and only if a <code>commit == false</code> update is currently in progress, meaning there's an uncommitted <em>candidate</em> <code>Value_set</code> at the moment.  <a href="classflow_1_1cfg_1_1Config__manager.html#ac74b46ed066f012a633ca16c400441ac">More...</a><br /></td></tr>
<tr class="separator:ac74b46ed066f012a633ca16c400441ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplParams" colspan="2">template&lt;typename... S_d_value_set&gt; </td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a453d83bf1e8b57b1aaff511fbe913ecc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;val)</td></tr>
<tr class="memdesc:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream.  <a href="classflow_1_1cfg_1_1Config__manager.html#a453d83bf1e8b57b1aaff511fbe913ecc">More...</a><br /></td></tr>
<tr class="separator:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename... S_d_value_set&gt;<br />
class flow::cfg::Config_manager&lt; S_d_value_set &gt;</div><p >Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of static config and dynamic config, each, via that number of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> types supplied by the user as template arguments. </p>
<p >There is an even number of template args (or it will not compile); each successive pair contains, in order, a <em>static</em> <code>Value_set</code> followed by a <em>dynamic</em> one. It is possible, for each given pair, to use static config alone or dynamic config alone; in that case pass in <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> for the unused one:</p>
<div class="fragment"><div class="line"><span class="comment">// First config pair is static-only; second config pair -- for a separate application module perhaps --</span></div>
<div class="line"><span class="comment">// has both a static and dynamic parts.</span></div>
<div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager&lt;Static_config_general, Null_value_set, Static_socket_opts, Dynamic_socket_opts&gt;</a> ...;</div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Config__manager_html"><div class="ttname"><a href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a></div><div class="ttdoc">Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...</div><div class="ttdef"><b>Definition:</b> <a href="cfg__manager_8hpp_source.html#l00382">cfg_manager.hpp:384</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> for the probably-common use case when you have only static config and only one <code>struct</code> at that. <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> adapts <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> with a very simple API, avoiding parameter packs and any mention of various dynamic-config complexities.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Dynamic config support lacks crash rejection; though these features should be an incremental improvement around the existing code. By crash rejection I mean something like: config file X comes in; we rename it to X.unparsed; we try to parse it; program crashes &ndash; versus it's fine, so we rename it X.parsed, and next time X.parsed is what we presumably-safely parse after any restart. Similarly invalid config may not cause a crash but still shouldn't be repeatedly re-parsed (etc.). Exact design TBD and will be informed by previous work on other projects (by echan and ygoldfel at least).</dd></dl>
<h3>When (and how) to use this</h3>
<p >First see the namespace <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> doc header for a brief overview. If you have chosen to use <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> for (at least some of) your config needs, what is mandatory to use is the class template <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>. The choice is to use it directly (writing your own facilities around it) or to use this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to maintain a couple of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s for you in a straightforward way. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> supports that one straightforward way, and for daemon programs it may be a good choice. Otherwise, the idea behind <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is to be able to flexibly use them as needed (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> providing one such way).</p>
<p >Firstly, you may create a <code>const</code> (immutable) <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> via its constructor and then just use it to output a help message (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02" title="Logs what help_to_ostream() would print.">log_help()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a>). This could be used with your program's <code>--help</code> option or similar, and that's it (no parsing takes place).</p>
<div class="fragment"><div class="line"><span class="comment">// Example of a static-config-only Config_manager created just to log the help, and that&#39;s it.</span></div>
<div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager&lt;Static_value_set, Null_value_set&gt;</a></div>
<div class="line">  (<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), <span class="stringliteral">&quot;cfg&quot;</span>, &amp;static_cfg_declare_opts, <a class="code hl_function" href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">flow::cfg::null_declare_opts_func</a>())</div>
<div class="line">  .<a class="code hl_function" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">log_help</a>();</div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Config__manager_html_a0192ddc2cc7302bdc8720ee56a395c02"><div class="ttname"><a href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">flow::cfg::Config_manager::log_help</a></div><div class="ttdeci">void log_help(log::Sev sev=log::Sev::S_INFO) const</div><div class="ttdoc">Logs what help_to_ostream() would print.</div><div class="ttdef"><b>Definition:</b> <a href="cfg__manager_8hpp_source.html#l02619">cfg_manager.hpp:2619</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_af4db395042b065b00398cd59845dcb4d"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">flow::log::Log_context::get_logger</a></div><div class="ttdeci">Logger * get_logger() const</div><div class="ttdoc">Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> <a href="log_8cpp_source.html#l00224">log.cpp:224</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_adfe41c8484a878742976ddb84aa9e2d8"><div class="ttname"><a href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">flow::cfg::null_declare_opts_func</a></div><div class="ttdeci">Option_set&lt; Null_value_set &gt;::Declare_options_func null_declare_opts_func()</div><div class="ttdoc">Returns a value usable as declare_opts_func_moved Config_manager ctor arg for a Null_value_set value ...</div><div class="ttdef"><b>Definition:</b> <a href="cfg__manager_8cpp_source.html#l00026">cfg_manager.cpp:26</a></div></div>
</div><!-- fragment --><p >Orthogonally, of course, you may want to use it to parse things. In which case:</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> assumes the following setup:</p><ul>
<li>1 or more config sets, each applicable perhaps to a different module of your application/library/etc. For <em>each</em> config set, have 1 or both of the following. (Having neither is pointless; so do not. Officially behavior is undefined if you do this.)<ul>
<li>One set of values, such that it is read from config source(s) once; then no value therein ever changes again. Call this type <code>S_value_set</code> (S for static). <code>S_value_set</code> must be a type suitable for <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> as its <code>Value_set</code> template arg. See <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header. Spoiler alert: It essentially needs to be a <code>struct</code> of reasonably-copyable, reasonably-equality-comparable, stream-parseable, stream-printable scalars (possibly nested); it needs to declare its default values in a no-arg ctor; and it needs an option-declaring function that calls <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> for each data member therein. The latter function must be passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor.<ul>
<li>After ctor, static config stored herein will be at its default values. Call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> (or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>; see below) to read the static values (from a file, etc.).</li>
<li>This <code>S_value_set</code> is accessible by reference-to-immutable accessor <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> are essentially thread-safe, at least after <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, in that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> will always return a reference to the same <code>S_value_set</code> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> will always emit the same pointers, and the values within the <code>S_value_set</code>(s) shall never change.</li>
</ul>
</li>
</ul>
</li>
<li>A 2nd set of values, such that it is read from config source(s) at least once; but then potentially more times, and each time 0 or more of the values may be changed from the original setting. <code>D_value_set</code>, again, must be a type suitable for <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> as its <code>Value_set</code>.<ul>
<li>Initialize the first set of dynamic values by calling either <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> (if your setup allows for initial dynamic values to be supplied in the same config source(s) (e.g., same file) as static ones) <em>and</em> then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>; or <em>only</em> the latter.</li>
<li>After that initial <code>apply*_dynamic()</code>: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> returns a ref-counted pointer to the heap-allocated <code>D_value_set</code> canonical at that time. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> may return a different pointer each time (and will, if a dynamic change is detected); but the values <em>at</em> a given return pointer will <em>never</em> change. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> is an alternate approach but essentially the same idea.</li>
<li>Now, whenever you have reason to believe the dynamic config may have changed, call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> (after the first one) and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> are mutually thread-safe: they can be safely called concurrently with each other and/or themselves. Internally, an atomic pointer to <code>D_value_set</code> is stored; <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a></code> makes a single update to it &ndash; after a potentially lengthy successful parse of config source(s) &ndash; while <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> makes an atomic read followed by a pointer copy (and returns the copy). The ref-counted-ptr handle ensures the returned <code>D_value_set</code> survives as long as the user needs it, even if it's immediately replaced by new config within the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a>.</li>
<li>Since dynamic config can change at any time, it is up to the config user how they want to operate on the ref-counted handle obtained from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. If a potentially new value each time is fine, it's fine to simply do <code>cm.dynamic_values()-&gt;m_some_opt</code>. If one needs a consistent set of 2 or more values, or if one needs values to not change over time, then one can simply save <code>auto dyn_cfg = cm.dynamic_values()</code> and then access values through <code>dyn_cfg-&gt;</code> as long as consistency is desired. (Again: <code>*dyn_cfg</code> can never change, once <code>dyn_cfg</code> is returned through <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>.)</li>
</ul>
</li>
<li>You may also have hooks executed when dynamic config changes. This is a simple system: before any relevant <code>apply*_dynamic()</code> calls, call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> for each module that wants to be informed. Each callback so registered will be <em>synchronously</em> executed from <code>apply*_dynamic()</code>, when a relevant change is detected.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >To summarize: This is the assumed order of API calls on a given <code>*this</code>; other orders may lead to undefined behavior:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor.</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or (if using dynamic config, but even so still optional) <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.</li>
<li>If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.</li>
<li>Simultaneously/at various times (thread-safe w/r/t each other):<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> (always returns a reference to the same immutable <code>S_value_set</code>).</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> (always emits the same pointers to immutable <code>S_value_set</code>s).</li>
<li>If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> (if returned <code>x</code>, <code>*x</code> is immutable; but may return different <code>x</code>es over time). Alternatively: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>.</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> (changes ptr returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>).</li>
</ul>
</li>
<li>Config-using modules' destructors/deinitialization code.<ul>
<li>For each such module: Obviously it must run after the last <code>*ic_values()</code> call.</li>
<li>For each such module: It <em>must</em> run before <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> dtor.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> dtor.</li>
</ul>
<p >In addition, between <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor and dtor:</p><ul>
<li>(Optional) If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> (for each module interested in it); not thread-safe against concurrent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.<ul>
<li>Functions <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a></code>ed earlier may execute synchronously from within <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> and/or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.<ul>
<li>Such user functions may load async work elsewhere.</li>
<li>Ensure that thing onto which they load async work exists! See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> for useful patterns to ensure this.</li>
</ul>
</li>
</ul>
</li>
<li>(Optional) If a callback has been registered: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>; not thread-safe against concurrent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.<ul>
<li>Any callback which accesses something which can be invalidated SHOULD be unregistered before that thing becomes invalid. If there is a chance that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> might be called after it has become invalid, then the callback MUST be unregistered (otherwise, undefined behavior could be encountered when the invalid thing is accessed).</li>
</ul>
</li>
</ul>
<h3>Advanced feature: multi-source parsing and source skipping</h3>
<p >By default this feature is not in play, as the <code>bool commit</code> arg to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> defaults to <code>true</code>. The multi-source feature is enabled by the user setting it to <code>false</code> for some calls to <code>apply_*()</code>. To explain how it works consider one particular <code>Value_set</code> and an attempt to execute one of <code>apply_*()</code> methods w/r/t that <code>Value_set</code> (among potentially others to which the same discussion applies equally). For purposes of discussion assume it is a dynamic <code>Value_set</code>, and the operation in question is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>; the same points apply to static ones and the other two <code>apply_*()</code> calls except where noted below.</p>
<p >Suppose the canonical (as returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>) <code>Value_set</code> is in state B, the baseline state. (If <code>Value_set</code> is static, then B is the default state from default-cted <code>Value_set</code>, and the canonical-state accessors are <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.) Normally a single <em>update</em> consists of just one call to <code>apply_dynamic(commit = true)</code>:</p><ol type="1">
<li><code>R = apply_dynamic(P, F, true)</code>, where <code>P</code> is a file path, and <code>F</code> is your <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html#a5475ab0b6e93f2ccded2aa8690ace0a4" title="Short-hand for a function that takes a parsed config set (meaning all values are individually OK) and...">Final_validator_func::Type</a> function.</li>
</ol>
<p >If <code>F() == <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a></code>, then <code>R == false</code>; state stays at B. If it's <code>F() == S_ACCEPT</code> (and the individual options were all fine), then <code>R == true</code>; state becomes B'; and if B does not equal B' (a change was detected), then the dynamic changes listener(s) (from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>) are synchronously called before <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> returns. (That listener stuff does not apply to static <code>Value_set</code>s in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.)</p>
<p >That's the default behavior without engaging this feature. To engage the feature, one has to call <code>apply_dynamic(commit = false)</code> at least once. A single <em>update</em> now consists of 2+ calls to <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a></code>:</p><ol type="1">
<li><code>R = apply_dynamic(P1, F, false)</code>; if <code>!R</code>, update failed/exit algorithm; else:</li>
<li><code>R = apply_dynamic(P2, F, false)</code>; if <code>!R</code>, update failed/exit algorithm; else:</li>
<li>...</li>
<li><code>R = apply_dynamic(Pn, F, true)</code>; if <code>!R</code>, update failed/exit algorithm; else done. The <code>true</code> arg indicates the final call.</li>
</ol>
<p >(<code>F</code> can be different each time, though informally we suspect that would be unorthodox. It is allowed formally.)</p>
<p >Each <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call builds up a <em>candidate</em> <code>Value_set C</code> which is created (at the top of call 1) to equal baseline/initial state B and then potentially incrementally morphed by each <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call. Assuming no error (from individual validator or an <code>F() == S_FAIL</code>) at any stage, the effect on the <em>candidate</em> <code>Value_set C</code> is as follows:</p><ol type="1">
<li>If <code>F(Cnext) == S_ACCEPT</code>: Modify the <em>candidate</em> by overwriting it: <code>C = Cnext;</code>.</li>
<li>If <code>F(Cnext) == S_SKIP</code>: Keep the <em>candidate</em> <code>Value_set C</code> unchanged from its current value at entry to that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call. <code>Cnext</code> is discarded (so the incremental update to the candidate is <em>skipped</em>).</li>
</ol>
<p >However, and this is the key:</p><ul>
<li><code>apply_dynamic(..., false)</code> does <em>not</em> modify the canonical (as returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>, etc.) state. It remains equal to B. Hence no dynamic change listeners are invoked. However:</li>
<li>the final call &ndash; <code>apply_dynamic(..., true)</code> &ndash; makes the canonical state equal the <em>candidate</em> <code>Value_set C</code> that has been built up. Accordingly, before <code>apply_dynamic(..., true)</code> returns, if the canonical <code>Value_set B</code> differs from the candidate <code>Value_set C</code> that overwrites it, dynamic change listeners are invoked.</li>
</ul>
<p >(Hence the one-call update scenario (the vanilla one) is merely a degenerate case of the multi-call scenario; as then the last call is the only call and thus canonicalizes the candidate and calls dynamic change listeners if appropriate.)</p>
<p >If at any stage <code>F(Cnext)</code> yields <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a>, then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> returns <code>false</code>. This means the entire update has failed; the <em>candidate</em> is abandoned, and you should not make the subsequent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> calls that may be remaining in the update. The next such call will be taken to be the 1st of another update, with a fresh candidate C created to equal B.</p>
<p >Why use this? Why use 2+ files for a given update? Indeed you shouldn't, unless there is specifically a good reason. What might that be? The precipitating use case, and the basic one immediately obvious to the authors, is where exactly for 1 of the files the final-validator shall return <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567" title="The holistically-checked cumulative Value_set has no problems and shall be accepted into the candidat...">Final_validator_outcome::S_ACCEPT</a>, while for <em>all</em> others it will return <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>. For example, if your distributed network consists of 3 sections, and each machine knows to which section it belongs, and each file is aimed at exactly 1 of the 3 and thus specifies it as some option <code>if-section-is=</code> (possible values 1 or 2 or 3), then the final-validator func would:</p><ol type="1">
<li>Check <code>if-section-is</code> option and return SKIP if the machine's actual section does not match it. Else:</li>
<li>Ensure internal consistency of candidate <code>Value_set</code> (as usual).</li>
<li>Return FAIL or ACCEPT depending on the answer to that (as usual).</li>
</ol>
<p >Now you've enabled conditional config in a distributed deployment.</p>
<dl class="section warning"><dt>Warning</dt><dd>In this <em>conditional config</em> use case, it is likely best to declare any given conditional option using a <code>_NO_ACC</code> variation of your <code>FLOW_CFG_OPTION_SET_DECLARE_OPTION*()</code> option of choice; that is <code><a class="el" href="option__set_8hpp.html#a9187f169f3eaf596c0e7b0f9e7e34761" title="Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), except the option is marked as non-accumulating,...">FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC()</a></code> or similarly-postfixed variation. You probably do not want such an option's value to persist from an earlier file in the update to a later one; instead it should probably reset to its default "at the top" of each file; <code>_NO_ACC</code> variants will accomplish this.</dd></dl>
<p>That said the use of SKIP (for all but 1) is not mandatory in such a multi-file-update setup. You can never-SKIP, or you can ACCEPT (not-SKIP) 2+ files; it is conceivable those setups have use cases as well. Informally though we reason to you as follows:</p><ul>
<li>If you never SKIP, then why complicate matters by having updates consist of 2+ files in the first place? Isn't it simpler (for config deployment and other aspects of the system) to just keep it to 1?</li>
<li>If you ACCEPT (don't-SKIP) 2+ files, then merely looking at a given file will no longer easily show the resulting final config, as each individual update is now incremental in nature; a preceding file in the same update may have changed (versus baseline) some setting not mentioned in that particular file. This may prove to be confusing.<ul>
<li>If you ACCEPT (don't-SKIP) exactly 1 file, then this no longer the case, and things are simple enough again.</li>
<li>If you ACCEPT (don't-SKIP) 2+ files, then to mitigate the problem where the final config is not quite clear just by looking at the input files, it's simple to use <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481" title="Logs what state_to_ostream() would print.">log_state()</a> to direct the result to a file or the logs, for human viewing.</li>
</ul>
</li>
</ul>
<p >The above are informal recommendations for maximum simplicity or clarity, but it is entirely conceivable a more complex situation arises and requires they not be heeded.</p>
<h3>Relationship with the rest of your program/threads</h3>
<p >At this time <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> is deliberately simple in that it doesn't start any threads of its own; it doesn't watch file modifications to detect dynamic changes; and its methods can be called from any thread and always act entirely synchronously. (The only methods affected by thread considerations are <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> + <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>; they are intentionally thread-safe w/r/t each other.)</p>
<p >To the extent that it uses callbacks &ndash; again, only for dynamic config needs and only optionally &ndash; they, too, are executed synchronously. However, these callbacks can (of course) <code>.post()</code> work onto boost.asio <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">async::Concurrent_task_loop</a> or <a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html" title="A Concurrent_task_loop-related adapter-style class that represents a single-thread task loop; essenti...">async::Single_thread_task_loop</a>.</p>
<p >Informally: It is, however, possible and perhaps probable that one should build more facilities to detect cfg changes of various kinds; for this thread(s) may be useful. We suspect it is better to build class(es) that do that and make use of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> &ndash; not expand <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to do such things. Its simplicity and relative light weight and flexibility are good properties to conserve and not saddle with baggage (even optional baggage).</p>
<h3>Thread safety</h3>
<p >This is discussed in bits and pieces above and in various doc headers. Here is the overall picture however:</p><ul>
<li>Separate <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> objects are independent of each other, so there are no thread safety issues.</li>
<li>For a given <code>*this</code>:<ul>
<li>By default, no non-<code>const</code> method is safe to call concurrently with any other method. Except:</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> may be called concurrently with itself/each other or any other method including <code>apply_dynamic(commit = *)</code>, as long as either <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> has succeeded at least once prior.</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_d_value_set</td><td>An even number (at least 2) of settings <code>struct</code>s &ndash; see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header for requirements for each &ndash; in order static, dynamic, static, dynamic, .... Use <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> as needed; but do not use <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> for both the static and dynamic parameter in a given pair (e.g., <code>&lt;<a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>, <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>, ...&gt;</code> is both useless and formally disallowed).</td></tr>
  </table>
  </dd>
</dl>
<h3>Implementation notes</h3>
<p >I (ygoldfel) wrote this, originally, in 2 stages. At first it only supported exactly 2 template args: one static and one dynamic <code>Value_set</code>. In the next stage I turned it into a parameter pack, so that 4, 6, 8, ... args can be provided if desired &ndash; to support multiple configurable modules in the application. Before this I had done some basic parameter-pack coding, but undoubtedly <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> is my first foray into this level of sophistication. Certainly I welcome changes to improve clarity of the implementation and other suggestions. Generally speaking the code does strike me as complex, though there's a good case to be made to the effect of: That is just the nature of the beast. It's meta-programming: having the compiler perform loops, of a sort, at <em>compile time</em>. Because <code>S_d_value_set...</code> is not homogenous &ndash; within each adjacent pair of tparams the first and the second are <em>not</em> always treated equivalently &ndash; the code has to be tricky at times.</p>
<p >That said the usability of the API should not be affected by these details much. At times one has to supply additional <code>&lt;template args&gt;</code> &ndash; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> come to mind in particular &ndash; to help the compiler; but the compiler will complain about being unable to deduce the tparams, and then the next action for the user is straightforward.</p>
<h3>A particular trick explained</h3>
<p >In C++17 fold expressions are available (<a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a>), and we use them to create compile-time loops without the appalling coding/maintenance overhead of the meta-recursive pattern. (This replaces a much uglier trick involving a dummy <code>int[]</code> initializer, though that was still superior to doing the meta-recursive thing all over the place.)</p>
<p >Suppose, say, you want to call <code>f&lt;Value_set&gt;(idx, dyn_else_st)</code>, where <code>idx</code> runs through [0, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>), while <code>dyn_else_st</code> alternates between <code>false</code> (static) and <code>true</code> (dynamic). E.g., <code>f()</code> might parse the <code>idx</code>th slot of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> and do something extra if it's an odd (dynamic) slot. Note <code>f()</code> is a template parameterized on <code>Value_set</code>. Then:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> idx = 0;</div>
<div class="line"><span class="keywordtype">bool</span> dyn_else_st = <span class="keyword">false</span>;</div>
<div class="line">(</div>
<div class="line">  ..., <span class="comment">// This indicates the entire (..., expr) is a fold-expression, where...</span></div>
<div class="line">  (</div>
<div class="line">    <span class="comment">// ...the `S_d_value_set` in the following expression is the kernel of the param-pack expansion;</span></div>
<div class="line">    <span class="comment">// due to the fact the class template is: template&lt;typename... S_d_value_set&gt; class Config_manager</span></div>
<div class="line">    f&lt;S_d_value_set&gt;(idx, dyn_else_st),</div>
<div class="line">    ++idx,</div>
<div class="line">    dyn_else_st = !dyn_else_st)</div>
<div class="line">  )</div>
<div class="line">);</div>
</div><!-- fragment --><p ><code>(..., expr)</code> expands to, ultimately, <code>(expr1, expr2, ..., expr3)</code>, where each <code>expr...i...</code> is <code>expr</code> with the i-th <code>S_d_value_set</code>. In our case <code>expr...i...</code> is itself a comma-expression with 3 sub-expressions. Comma-expression evaluates left-to-right, so at runtime the side effects of each <code>expr...i...</code> are occurring at runtime; in this case this includes incrementing <code>idx</code> and repeatedly flipping <code>dyn_else_st</code>.</p>
<p >In the actual code, often we don't (just) call some helper <code>f&lt;&gt;()</code> but rather actually perform some steps in-line there instead &ndash; similarly to how this example does a couple of simple expressions after calling <code>f&lt;&gt;()</code>. The good thing is the reader need not jump to another function (and all that maintenance overhead). The bad thing is the language constructions within an expression in C++ (not a functional language) are limited. Loops aren't possible; <code>if ()</code>s have to be replaced by <code>?:</code> ternaries or <code>&amp;&amp;</code> or <code>||</code> expressions; and so on. It's not always the most readable thing, if one isn't used to it, but the author feels it's doable to get used to it, and it's worth it for the brevity. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00382">382</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab501967b40259c1a29264af1ad17baf2" name="ab501967b40259c1a29264af1ad17baf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab501967b40259c1a29264af1ad17baf2">&#9670;&nbsp;</a></span>On_dynamic_change_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::On_dynamic_change_func =  <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void ()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for a callback to execute on dynamic config change. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00400">400</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a6f366f4070a90740e27d73029852e55f" name="a6f366f4070a90740e27d73029852e55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f366f4070a90740e27d73029852e55f">&#9670;&nbsp;</a></span>Void_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::Void_ptr =  boost::shared_ptr&lt;void&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <code>shared_ptr</code>-to-<code>void</code> type used to store variable-type values in internal containers. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00963">963</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6768eb0c92bd11fd84986058903b10d4" name="a6768eb0c92bd11fd84986058903b10d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6768eb0c92bd11fd84986058903b10d4">&#9670;&nbsp;</a></span>allow_invalid_defaults_tag_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">flow::cfg::Config_manager::allow_invalid_defaults_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type: indicates an <code>apply_*()</code> method must <em>allow</em> invalid defaults and only complain if the config source does not explicitly supply a valid value. </p>
<p >Otherwise the defaults themselves are also stringently checked regardless of whether they are overridden. This setting applies only to individual-option-validators. <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html" title="Utility/traits type to concisely work with final-validation functions when calling methods like Confi...">Final_validator_func</a> validation is orthogonal to this. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed" name="a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed"></a>S_ALLOW_INVALID_DEFAULTS&#160;</td><td class="fielddoc"><p >Sole value for tag type <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00394">394</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="aa0d03f4dcf7be2c21023c4073ac68b85" name="aa0d03f4dcf7be2c21023c4073ac68b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d03f4dcf7be2c21023c4073ac68b85">&#9670;&nbsp;</a></span>Update_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">flow::cfg::Config_manager::Update_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Useful at least in the context of multi-source (<code>commit == false</code>) <code>apply_*()</code> methods, this distinguishes distinct possible public <code>apply_*()</code> methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0d03f4dcf7be2c21023c4073ac68b85a9ed9d44ce5760f61ea506d5571343624" name="aa0d03f4dcf7be2c21023c4073ac68b85a9ed9d44ce5760f61ea506d5571343624"></a>S_NONE&#160;</td><td class="fielddoc"><p >Indicates no <code>apply_*()</code> operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0d03f4dcf7be2c21023c4073ac68b85ab31234e7337465421b3bc64639994ca3" name="aa0d03f4dcf7be2c21023c4073ac68b85ab31234e7337465421b3bc64639994ca3"></a>S_STATIC&#160;</td><td class="fielddoc"><p >Indicates <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0d03f4dcf7be2c21023c4073ac68b85a126ca201c7b5e56a78174fda3d16ff7a" name="aa0d03f4dcf7be2c21023c4073ac68b85a126ca201c7b5e56a78174fda3d16ff7a"></a>S_STATIC_AND_DYNAMIC&#160;</td><td class="fielddoc"><p >Indicates <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0d03f4dcf7be2c21023c4073ac68b85a7612e6cb583f768c5df52e1c5d03a85e" name="aa0d03f4dcf7be2c21023c4073ac68b85a7612e6cb583f768c5df52e1c5d03a85e"></a>S_DYNAMIC&#160;</td><td class="fielddoc"><p >Indicates <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00969">969</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad59bfabf66e01922542629bae77508ad" name="ad59bfabf66e01922542629bae77508ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59bfabf66e01922542629bae77508ad">&#9670;&nbsp;</a></span>Config_manager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::Config_manager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; S_d_value_set &gt;::Declare_options_func &amp;&amp;...&#160;</td>
          <td class="paramname"><em>declare_opts_func_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ready to read initial config via <code>apply_*()</code> and other setup methods; and further capable of both static and dynamic config. </p>
<p >See class doc header for class life cycle instructions.</p>
<h3>Logging assumption</h3>
<p ><code>*logger_ptr</code> is a standard logging arg. Note, though, that the class will assume that log verbosity may not have yet been configured &ndash; since this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> may be the thing configuring it. Informal recommendations:</p><ul>
<li>You should let through INFO and WARNING messages in <code>*logger_ptr</code>.</li>
<li>If you plan to use <code>*this</code> only for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02" title="Logs what help_to_ostream() would print.">log_help()</a> (such as in your <code>--help</code> implementation), you should <em>not</em> let through TRACE-or-more-verbose.</li>
<li>Once (and if) you engage any actual parsing (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, etc.), TRACE may be helpful in debugging as usual.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">nickname</td><td>Brief string used for logging subsequently. </td></tr>
    <tr><td class="paramname">declare_opts_func_moved</td><td>For each <code>S_d_value_set</code>, in order, the declare-options callback as required by <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;S_d_value_set&gt;</code> constructor; see its doc header for instructions. For each <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>: use the function returned by <code><a class="el" href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8" title="Returns a value usable as declare_opts_func_moved Config_manager ctor arg for a Null_value_set value ...">null_declare_opts_func()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01419">1419</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="cfg__manager_8hpp_source.html#l01295">flow::cfg::Config_manager&lt; S_d_value_set &gt;::m_d_baseline_value_sets</a>, <a class="el" href="cfg__manager_8hpp_source.html#l01326">flow::cfg::Config_manager&lt; S_d_value_set &gt;::m_d_value_sets</a>, <a class="el" href="cfg__manager_8hpp_source.html#l00957">flow::cfg::Config_manager&lt; S_d_value_set &gt;::m_nickname</a>, <a class="el" href="cfg__manager_8hpp_source.html#l01265">flow::cfg::Config_manager&lt; S_d_value_set &gt;::m_s_d_opt_sets</a>, <a class="el" href="util_2util_8hpp_source.html#l00356">flow::util::ostream_op_string()</a>, <a class="el" href="cfg__manager_8hpp_source.html#l00412">flow::cfg::Config_manager&lt; S_d_value_set &gt;::S_N_S_VALUE_SETS</a>, and <a class="el" href="cfg__manager_8hpp_source.html#l00407">flow::cfg::Config_manager&lt; S_d_value_set &gt;::S_N_VALUE_SETS</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager_ad59bfabf66e01922542629bae77508ad_cgraph.svg" width="718" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6afb8620600dcb54d41211ef68859f93" name="a6afb8620600dcb54d41211ef68859f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afb8620600dcb54d41211ef68859f93">&#9670;&nbsp;</a></span>all_dynamic_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_dynamic_values </td>
          <td>(</td>
          <td class="paramtype">typename Value_set::Const_ptr *...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at <code>struct</code> is set permanently; while another call may return a different pointer if config is changed dynamically in the meantime (for that slot). </p>
<p >For each slot: If you require a consistent set of dynamic config over some period of time or over some code path, save a copy of the returned ref-counted pointer to the <code>Value_set</code> and keep accessing values in that immutable structure through that ref-counted pointer.</p>
<p >After the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>: It is safe to call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> concurrently with any number of itself or of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> and/or a call to <code>apply_dynamic(commit = *)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Have each <code>Value_set</code> derive from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html" title="Convenience class template that endows the given subclass T with nested aliases Ptr and Const_ptr ali...">util::Shared_ptr_alias_holder</a>, so that it is endowed with <code>Ptr</code> and <code>Const_ptr</code> ref-counted pointer type aliases, for your convenience and as required by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> and <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.</dd></dl>
<h3>Performance</h3>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> performance is no worse than: lock mutex, copy <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <code>shared_ptr</code>s, unlock mutex. See also Performance section of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 1, 3, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> in order. Likely you will need to explicitly specify them, as the compiler will probably not deduce them. E.g.: <code>cfg_mgr.all_dynamic_values&lt;D_cfg1, D_cfg2, <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>&gt;(&amp;d1, &amp;d2, 0)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>For each element in the param pack: <code>*value_set_or_null</code> is set to point to the immutable dynamic config set currently canonical in that slot; or that slot is ignored if <code>value_set_or_null</code> is null. Remember: <code>**value_set_or_null</code> is immutable; but another call may yield a different <code>*value_set_or_null</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02458">2458</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a76c7224711ef8a51c7005629e4eae6e7" name="a76c7224711ef8a51c7005629e4eae6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c7224711ef8a51c7005629e4eae6e7">&#9670;&nbsp;</a></span>all_static_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_static_values </td>
          <td>(</td>
          <td class="paramtype">const Value_set **...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a pointer to each permanently set static config value set; the same pointers are emitted throughout for each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> static config slots. </p>
<p >Tip: It should be sufficient to pass around only <code>const</code> refs (from the pointers obtained here) all around the app &ndash; no <code>Value_set</code> copying should be needed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 0, 2, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> in order. The compiler should be able to deduce them automatically from each <code>value_set_or_null</code> type; though when passing in null it may be then necessary to cast <code>nullptr</code> (or <code>0</code>) to the appropriate pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>For each element in the param pack: <code>*value_set_or_null</code> is set to point to the immutable static config set in that slot; or that slot is ignored if <code>value_set_or_null</code> is null. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02374">2374</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a616c39cdf1c6f7f4d2af3a3055edf486" name="a616c39cdf1c6f7f4d2af3a3055edf486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616c39cdf1c6f7f4d2af3a3055edf486">&#9670;&nbsp;</a></span>all_static_values_candidates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_static_values_candidates </td>
          <td>(</td>
          <td class="paramtype">const Value_set **...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then for any static value set for which values have been parsed and validated (but not yet applied) so far, a pointer to the parsed values <em>candidate</em> will be emitted instead. </p>
<p >If called from elsewhere, the behavior is equivalent to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. A values candidate consists of what has been parsed and validated (and not skipped via <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>) for the value set, but has not yet been applied such that it would be available through <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</p>
<p >This could be useful to provide static values to a final validator function for another value set which depends on them. During the execution of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, the validator function for each value set will be executed before any are canonicalized. This method can be used by a validator function to obtain the candidate values which have been parsed and validated (but have not yet been canonicalized) for a preceding static value set.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02398">2398</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a2503b020137aca00a8ee4b81fc921750" name="a2503b020137aca00a8ee4b81fc921750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2503b020137aca00a8ee4b81fc921750">&#9670;&nbsp;</a></span>apply_dynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>dynamic_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; except that &ndash; applicably only to the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> without a preceding <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> &ndash; skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. However &ndash; assuming <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> was not used, and this is the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> &ndash; the other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> will return <code>false</code> if a default is invalid, even if file <code>dynamic_cfg_path</code> explicitly sets it to a valid value. This tagged overload will not and let parsing continue. If <code>apply_static_and_dynamic(commit = true) == true</code> was used, or if <code>apply_dynamic(commit = true) == true</code> has been called before, then the overloads behave identically: defaults are not checked; it must occur just before the initial dynamic load or never. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02084">2084</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a26712af2d38d3afbeb52d21b7012a03c" name="a26712af2d38d3afbeb52d21b7012a03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26712af2d38d3afbeb52d21b7012a03c">&#9670;&nbsp;</a></span>apply_dynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_dynamic </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>dynamic_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the first or subsequent set of dynamic config from config source including a dynamic config file. </p>
<p >If you use dynamic config: You must invoke this, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, once before access via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>. After that, optionally invoke it whenever there is good reason to believe new dynamic config is available in the dynamic config source(s).</p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. If not using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, <em>and</em> this is the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> invoked, then see also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >After the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>: It is safe to call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> concurrently with any number of <code>[all_]<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a></code>. However behavior is undefined if one calls <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> concurrently with itself or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> (on the same <code>*this</code>).</p>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. WARNING(s) logged given failure.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> will be tolerant of unknown option names appearing in the config source, though it will log about them. The reasoning: Dynamic config must grapple with backward- and forward-compatibility.</p>
<p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<h3>Performance</h3>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> + <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> locking performance is no worse than: lock mutex, assign <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <code>shared_ptr</code>s, unlock mutex. The rest of the parse/validate/etc. code is outside any such critical section. See also Performance section of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> doc header.</p>
<p >Outside that locking critical section, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> may be expensive, in that it performs file input and some internal copying of option value sets and maps, plus detailed logging. It is, however, not typically called frequently. Just be aware it will block the calling thread, albeit still only for a split second in normal conditions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 1, 3, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_cfg_path</td><td>File to read. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>); and all relevant dynamic change listeners are synchronously called for each <code>Value_set</code> for which the cumulative candidate differs from the canonical state. <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>; no dynamic change listeners are invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source(s) and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (dynamic) config sets; and defaults were also all individually valid, in the case of initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>) have not been updated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02074">2074</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a8864e575c78251d3b8e109f86f29b703" name="a8864e575c78251d3b8e109f86f29b703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8864e575c78251d3b8e109f86f29b703">&#9670;&nbsp;</a></span>apply_dynamic_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_dynamic_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_invalid_defaults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>dynamic_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overloads. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_invalid_defaults</td><td><code>true</code> if and only if <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> used. </td></tr>
    <tr><td class="paramname">dynamic_cfg_path</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02095">2095</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>.</p>

</div>
</div>
<a id="a3dae0dfcdde91dcbdd6db4b05fac0112" name="a3dae0dfcdde91dcbdd6db4b05fac0112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dae0dfcdde91dcbdd6db4b05fac0112">&#9670;&nbsp;</a></span>apply_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *&#160;</td>
          <td class="paramname"><em>opt_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value_set *&#160;</td>
          <td class="paramname"><em>baseline_value_set_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_opt_names_or_empty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;&#160;</td>
          <td class="paramname"><em>final_validator_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Work-horse helper that parses into one given <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> (from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>) from the specified file and returns <code>true</code> if and only if successful. </p>
<p >The canonicalize/reject step is not performed: only parsing and (if that worked) <code>final_validator_func()</code>. Recall that <code>final_validator_func() == S_SKIP</code>, even though it will cause us to not have changed that <code>Value_set</code>'s <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">Option_set::values_candidate()</a>, is still considered success.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_set</td><td>An <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> result. </td></tr>
    <tr><td class="paramname">baseline_value_set_or_null</td><td>If null then ignored; else &ndash; just before attempting to parse and apply values from <code>cfg_path</code> &ndash; we will set <code>*opt_set</code> to contain a copy of <code>Value_set *baseline_value_set_or_null</code>. This is to ensure a consistent state after each dynamic config update as opposed to working incrementally. Note, also, it is ignored if opt_set-&gt;null() (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a3dae0dfcdde91dcbdd6db4b05fac0112" title="Work-horse helper that parses into one given Option_set in m_s_d_opt_sets (from opt_set()) from the s...">apply_impl()</a> will no-op in any case). </td></tr>
    <tr><td class="paramname">cfg_path</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa7785bcdb7fae9ae7ef6f1919b1f8045" title="Work-horse helper that parses either all static value sets or all dynamic value sets from the specifi...">apply_static_or_dynamic_impl()</a>. </td></tr>
    <tr><td class="paramname">all_opt_names_or_empty</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa7785bcdb7fae9ae7ef6f1919b1f8045" title="Work-horse helper that parses either all static value sets or all dynamic value sets from the specifi...">apply_static_or_dynamic_impl()</a>. Technically this need not include the ones actually parsed by <code>*opt_set</code>; but including them is harmless (and may be helpful to the caller for simplicity). </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01765">1765</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="option__set_8hpp_source.html#l01993">flow::cfg::Option_set&lt; Value_set &gt;::parse_direct_values()</a>, <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567">flow::cfg::S_ACCEPT</a>, <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316">flow::cfg::S_FAIL</a>, <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec">flow::cfg::S_SKIP</a>, <a class="el" href="option__set_8hpp_source.html#l01490">flow::cfg::Option_set&lt; Value_set &gt;::values()</a>, and <a class="el" href="option__set_8hpp_source.html#l01502">flow::cfg::Option_set&lt; Value_set &gt;::values_candidate()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager_a3dae0dfcdde91dcbdd6db4b05fac0112_cgraph.svg" width="364" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af027c6f4b595f1f8ebbd6d41ad705f5e" name="af027c6f4b595f1f8ebbd6d41ad705f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af027c6f4b595f1f8ebbd6d41ad705f5e">&#9670;&nbsp;</a></span>apply_static() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>static_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. The difference between the other <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a></code> and this overload is: The other overload will return <code>false</code> given an invalid default, even if file <code>static_cfg_path</code> explicitly sets it to a valid value. This tagged overload will not fail (return <code>false</code> for that reason) and will let parsing continue instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01581">1581</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a22bfec8082d0c7b5dff9ee7e98865707" name="a22bfec8082d0c7b5dff9ee7e98865707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bfec8082d0c7b5dff9ee7e98865707">&#9670;&nbsp;</a></span>apply_static() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>static_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke this after construction to load the permanent set of static config from config sources including a static config file; if you are also using dynamic config, see <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> as a <em>potential</em> alternative. </p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >After this runs and succeeds, assuming <code>commit == true</code>, you may use <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and/or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> to access the loaded values. After this runs and succeeds, but <code>commit == false</code>, you should call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> again 1+ times, with the last such call having <code>commit == true</code> and thus canonicalizing each progressively-built candidate <code>Value_set</code>, so that it becomes available via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</p>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. The next <code>apply_*()</code> call begins a fresh update.</p>
<p >Tip: On failure you may want to exit program with error; or you can continue knowing that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> will return a reference to default values (and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> will emit pointers to <code>Value_set</code>s with default values) according to <code>Value_set()</code> no-arg ctor (for each <code>Value_set</code>). WARNING(s) logged given failure.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> will <em>not</em> be tolerant of unknown option names appearing in the config source. The reasoning (and we might change our minds over time): It should be possible to deliver the proper set of static config along with the binary that supports it. However <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> is tolerant of unknown option names.</p>
<p >You must supply exactly <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> <code>final_validator_func</code>s. The compiler will likely require you to explicitly specify the <code>struct</code> types as explicit template args; e.g:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager&lt;S_config1, D_config1, S_config2, D_config2, Null_value_set, D_config3&gt;</a> cfg_mgr(...);</div>
<div class="line"><span class="comment">// Explicitly specify the static config struct types.  Provide that number of final-validate functions.</span></div>
<div class="line"><span class="comment">// Use null_final_validator_func() for the dummy Null_value_set in particular.</span></div>
<div class="line">cfg_mgr.apply_static&lt;S_config1, S_config2, <a class="code hl_struct" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a>&gt;</div>
<div class="line">  (file_path, &amp;s_decl_opts1, &amp;s_decl_opts2, <a class="code hl_function" href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">null_final_validator_func</a>());</div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_af1a4e0a153ec8216ead76450e900e386"><div class="ttname"><a href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">flow::cfg::null_final_validator_func</a></div><div class="ttdeci">Final_validator_func&lt; Null_value_set &gt;::Type null_final_validator_func()</div><div class="ttdoc">Returns a value usable as final_validator_func arg to Config_manager::apply_static() and others – for...</div><div class="ttdef"><b>Definition:</b> <a href="cfg__manager_8cpp_source.html#l00031">cfg_manager.cpp:31</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Null__value__set_html"><div class="ttname"><a href="structflow_1_1cfg_1_1Null__value__set.html">flow::cfg::Null_value_set</a></div><div class="ttdoc">Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...</div><div class="ttdef"><b>Definition:</b> <a href="cfg__manager_8hpp_source.html#l00070">cfg_manager.hpp:72</a></div></div>
</div><!-- fragment --><p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>final_validator_func()</code> can be made quite brief by using convenience macro <a class="el" href="cfg__manager__fwd_8hpp.html#a1e8c66781034dd50ad8e2de9c0c47e0e" title="Convenience macro particularly useful in the final_validator_func() callback taken by various Config_...">FLOW_CFG_OPT_CHECK_ASSERT()</a>. This will take care of most logging in most cases. </dd>
<dd>
For each <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>: use <code>final_validator_func = <a class="el" href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386" title="Returns a value usable as final_validator_func arg to Config_manager::apply_static() and others – for...">null_final_validator_func()</a></code>. </dd>
<dd>
A validator function will not be run if there is a failure to parse any preceding <code>Value_set</code> (including a failure of its associated validator function). </dd>
<dd>
A validator function may rely on <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1" title="Similar to static_values(), but if called from within a validator function passed to apply_static() o...">static_values_candidate()</a> providing the parsed (and validated) values candidate for any preceding static value set.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Add support for command line as a config source in addition to file(s), for static config in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">cfg::Config_manager</a> and <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">cfg::Static_config_manager</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 0, 2, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_cfg_path</td><td>File to read. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>For each arg: If parsing and individual-option-validation succeed, the method shall return success if <code>final_validator_func(V)</code> returns <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567" title="The holistically-checked cumulative Value_set has no problems and shall be accepted into the candidat...">Final_validator_outcome::S_ACCEPT</a> or <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>, where V is the parsed <code>Value_set</code>. (If <code>apply_static(commit = false) == true</code> call(s) preceded this one, V is the cumulative candidate from such call(s) so far, plus values parsed from <code>static_cfg_path</code> on top of that.) Informally: Please place individual-option validation into <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> invocations; only use <code>final_validator_func()</code> for internal consistency checks (if any) and skip conditions (if any). </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this call and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>). <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (static) config sets; and defaults were also all individually valid. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>) have not been updated. If <code>false</code> with <code>commit == false</code>, you should not call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> for the planned subsequent config sources: this update has failed, and any built-up candidate <code>Value_set</code>s are discarded. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01571">1571</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a5d85fa5a1ed933c9b85444ddb9a416b1" name="a5d85fa5a1ed933c9b85444ddb9a416b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d85fa5a1ed933c9b85444ddb9a416b1">&#9670;&nbsp;</a></span>apply_static_and_dynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_and_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. The difference between the other <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a></code> and this overload is: The other overload will return <code>false</code> given an invalid default, even if file <code>cfg_path</code> explicitly sets it to a valid value. This tagged overload will not fail (return <code>false</code> for that reason) and will let parsing continue instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01874">1874</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a9d9811d1b4aab2c4ea3e6813d4161304" name="a9d9811d1b4aab2c4ea3e6813d4161304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9811d1b4aab2c4ea3e6813d4161304">&#9670;&nbsp;</a></span>apply_static_and_dynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_and_dynamic </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use dynamic config, <em>and</em> you allow for initial values for dynamic options to be read from the same file as the static config values, then invoke this instead of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >With static config-only use case:</p><ul>
<li>Just <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> whenever needed.</li>
</ul>
<p >With dynamic-and-static config use case, <em>with</em> allowing baseline dynamic values to be set in static config file:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. &lt;&ndash; ATTN</li>
<li>Initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. (Typically it is allowed that there is no dynamic config file present yet though.)</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> whenever needed.<ul>
<li>Further <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, if dynamic config source(s) may have changed.</li>
</ul>
</li>
</ul>
<p >With dynamic-and-static config use case, <em>without</em> allowing baseline dynamic values to be set in static config file:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.</li>
<li>Initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> whenever needed.<ul>
<li>Further <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, if dynamic config source(s) may have changed.</li>
</ul>
</li>
</ul>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. WARNING(s) logged given failure.</p>
<p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<dl class="section note"><dt>Note</dt><dd>By definition this will not compile unless <code>final_validator_func</code> count equals <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>. However, unlike <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, there are no template args to explicitly supply.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_path</td><td>File to read for both static and dynamic config. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>; particularly the notes about how a validator function will not be run if there is a preceding failure and that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1" title="Similar to static_values(), but if called from within a validator function passed to apply_static() o...">static_values_candidate()</a> can be relied upon. </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <code>*ic_values()</code> or <code>all_*ic_values()</code>); and all dynamic change listeners are synchronously called. <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>; no dynamic change listeners are invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source(s) and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (static and dynamic) config sets; and defaults were also all individually valid. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <code>*ic_values()</code> or <code>*ic_values()</code>) have not been updated. If <code>false</code> with <code>commit == false</code>, you should not call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> for the planned subsequent config sources: this update has failed, and any built-up candidate <code>Value_set</code>s are discarded. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01865">1865</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a62619206c49b1b39c887162d8b6a2305" name="a62619206c49b1b39c887162d8b6a2305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62619206c49b1b39c887162d8b6a2305">&#9670;&nbsp;</a></span>apply_static_and_dynamic_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_and_dynamic_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_invalid_defaults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_invalid_defaults</td><td><code>true</code> if and only if <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> used. </td></tr>
    <tr><td class="paramname">cfg_path</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01884">1884</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>.</p>

</div>
</div>
<a id="ad320a74f83474c93cce385b0b9da887e" name="ad320a74f83474c93cce385b0b9da887e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad320a74f83474c93cce385b0b9da887e">&#9670;&nbsp;</a></span>apply_static_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_invalid_defaults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>static_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements all <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overloads. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_invalid_defaults</td><td><code>true</code> if and only if <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> used. </td></tr>
    <tr><td class="paramname">static_cfg_path</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01592">1592</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>.</p>

</div>
</div>
<a id="aa7785bcdb7fae9ae7ef6f1919b1f8045" name="aa7785bcdb7fae9ae7ef6f1919b1f8045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7785bcdb7fae9ae7ef6f1919b1f8045">&#9670;&nbsp;</a></span>apply_static_or_dynamic_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_or_dynamic_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dyn_else_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_opt_names_or_empty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Work-horse helper that parses either <em>all</em> static value sets <em>or</em> <em>all</em> dynamic value sets from the specified file into <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> and returns <code>true</code> if and only if all have succeeded. </p>
<p >(It stops on first failure.) The canonicalize/reject step is not performed: only parsing and (if that worked) <code>final_validator_func()</code>. Recall that <code>final_validator_func() == S_SKIP</code>, even though it will cause us to not have changed that <code>Value_set</code>'s <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">Option_set::values_candidate()</a>, is still considered success.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> depending on <code>dyn_else_st</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dyn_else_st</td><td>Basically whether <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> was called. </td></tr>
    <tr><td class="paramname">cfg_path</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> depending on <code>dyn_else_st</code>. </td></tr>
    <tr><td class="paramname">all_opt_names_or_empty</td><td>Empty if <em>any</em> option names may be present in file (such as to support dynamic config compatibility); otherwise must contain any option names that are allowed in this file (such as for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>). </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> depending on <code>dyn_else_st</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> depending on <code>dyn_else_st</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01720">1720</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="abe40d6451276e0d4c7c0867669791f9c" name="abe40d6451276e0d4c7c0867669791f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe40d6451276e0d4c7c0867669791f9c">&#9670;&nbsp;</a></span>d_baseline_value_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Value_set * <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::d_baseline_value_set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that obtains the baseline dynamic <code>Value_set</code> in the slot <code>m_d_baseline_value_sets[value_set_idx]</code>, which stores a <code>Value_set</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td><code>S_d_value_set</code> in dynamic slot <code>d_value_set_idx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>One of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <code>Value_set</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01499">1499</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="ac2239443cf48bfdaa78c95af935e1d0f" name="ac2239443cf48bfdaa78c95af935e1d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2239443cf48bfdaa78c95af935e1d0f">&#9670;&nbsp;</a></span>dynamic_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value_set::Const_ptr <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::dynamic_values </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> but obtains the dynamic config in <em>one</em> specified slot as opposed to all of them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>This must be <code>S_d_value_set</code> template param pack args in position <code>1 + 2 * d_value_set_idx</code> (so one of [1, 3, ..., <code>(2 * S_N_D_VALUE_SETS) - 1</code>]). You will need to explicitly specify this <code>tparam</code>. E.g.: <code>const auto cfg_ptr = cfg_mgr.dynamic_values&lt;D_cfg2&gt;(1)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>The dynamic config slot index; so one of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ref-counted pointer to the immutable dynamic config set currently canonical in that slot. Remember: if <code>p</code> returned, then <code>*p</code> is immutable; but another <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> call may return a different <code>p2</code> not equal to <code>p</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02491">2491</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="ad5cda6ace05e8bbe52a5129ed1c0720c" name="ad5cda6ace05e8bbe52a5129ed1c0720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cda6ace05e8bbe52a5129ed1c0720c">&#9670;&nbsp;</a></span>help_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::help_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a human-targeted long-form usage message that includes all options with their descriptions and defaults. </p>
<p >This is thread-safe against all concurrent methods on <code>*this</code> and can be invoked anytime after ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02589">2589</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a8be0e0697c1b106c7170795ee4a225e8" name="a8be0e0697c1b106c7170795ee4a225e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be0e0697c1b106c7170795ee4a225e8">&#9670;&nbsp;</a></span>help_to_ostream_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::help_to_ostream_impl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_set_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> slot <code>value_set_idx</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_idx</td><td>One of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>). </td></tr>
    <tr><td class="paramname">os</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02602">2602</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a57140907e43a66705625d391e85e3c52" name="a57140907e43a66705625d391e85e3c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57140907e43a66705625d391e85e3c52">&#9670;&nbsp;</a></span>invoke_dynamic_change_listeners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::invoke_dynamic_change_listeners </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the registered listeners for the given dynamic config slot (synchronously). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>One of [0,1, ... <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>). </td></tr>
    <tr><td class="paramname">init</td><td>For logging (as of this writing): whether this is due to the initial parsing of this dynamic config slot or a subsequent change. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02352">2352</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>.</p>

</div>
</div>
<a id="a0192ddc2cc7302bdc8720ee56a395c02" name="a0192ddc2cc7302bdc8720ee56a395c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0192ddc2cc7302bdc8720ee56a395c02">&#9670;&nbsp;</a></span>log_help()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::log_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> would print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Severity to use for the log message(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02619">2619</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00489">FLOW_LOG_WITH_CHECKING</a>.</p>

</div>
</div>
<a id="a220535219634c62ed2a580934c76c481" name="a220535219634c62ed2a580934c76c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220535219634c62ed2a580934c76c481">&#9670;&nbsp;</a></span>log_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::log_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> would print. </p>
<p >This is not thread-safe against several non-<code>const</code> methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Severity to use for the log message(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02577">2577</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00489">FLOW_LOG_WITH_CHECKING</a>.</p>

</div>
</div>
<a id="a318e125f78cb7e471cae35e2651ab01f" name="a318e125f78cb7e471cae35e2651ab01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318e125f78cb7e471cae35e2651ab01f">&#9670;&nbsp;</a></span>opt_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; * <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::opt_set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_set_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that obtains the <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> in the slot <code>m_s_d_opt_sets[value_set_idx]</code>, which stores an Option_set&lt;Value_set&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td><code>S_d_value_set</code> in slot <code>value_set_idx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_idx</td><td>One of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01487">1487</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="af54e2f1360834ece6fd06d34b387978c" name="af54e2f1360834ece6fd06d34b387978c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54e2f1360834ece6fd06d34b387978c">&#9670;&nbsp;</a></span>opt_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; * <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::opt_set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>const</code> overload of the other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> helper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_idx</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01511">1511</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a2c9f7e2dd8973d5ff191eee1c2394cae" name="a2c9f7e2dd8973d5ff191eee1c2394cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9f7e2dd8973d5ff191eee1c2394cae">&#9670;&nbsp;</a></span>option_set_canonicalize_or_reject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::option_set_canonicalize_or_reject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *&#160;</td>
          <td class="paramname"><em>opt_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>canonicalize_else_reject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>changed_or_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that executes <code>opt_set-&gt;canonicalize_candidate()</code> or <code>opt_set-&gt;reject_candidate()</code>. </p>
<p >Used in meta-programming. Apply when parsing <code>*opt_set</code>, assuming <code>commit == true</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_set</td><td>An <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> result. </td></tr>
    <tr><td class="paramname">canonicalize_else_reject</td><td>Specifies whether to... well, you know. </td></tr>
    <tr><td class="paramname">changed_or_null</td><td>If not null and canonicalizing (not rejecting), <code>*changed_or_null</code> is set to whether the <code>canonicalize_candidate()</code> detected at least one option's value changed from the previous canonical state. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01518">1518</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="option__set_8hpp_source.html#l02042">flow::cfg::Option_set&lt; Value_set &gt;::canonicalize_candidate()</a>, <a class="el" href="option__set_8hpp_source.html#l01484">flow::cfg::Option_set&lt; Value_set &gt;::null()</a>, and <a class="el" href="option__set_8hpp_source.html#l02075">flow::cfg::Option_set&lt; Value_set &gt;::reject_candidate()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager_a2c9f7e2dd8973d5ff191eee1c2394cae_cgraph.svg" width="564" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a978295c03998af212b464061d780520b" name="a978295c03998af212b464061d780520b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978295c03998af212b464061d780520b">&#9670;&nbsp;</a></span>register_dynamic_change_listener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt;::On_dynamic_change_func_handle <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::register_dynamic_change_listener </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_dynamic_change_func_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the given callback; next time <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> detects at least one changed (or initially set) option value in the specified slot, it will execute this and any other previously registered such callbacks synchronously. </p>
<p >The callbacks will be called after the pointers to be returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> have all been updated.</p>
<p >This is not thread-safe against concurrent calls to itself; nor against concurrent <code>apply_dynamic(commit = true)</code> (against <code>apply_dynamic(commit = false)</code> is okay), <code>apply_static_and_dynamic(commit = true)</code> (against <code>apply_static_and_dynamic(commit = false)</code> is okay), or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The callback may optionally be unregistered by using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>. This <em>should</em> be done before anything that the callback accesses is invalidated. If there is a chance that <code>apply*_dynamic()</code> might be called later, then the callback <em>must</em> be unregistered before anything that it accesses is invalidated, otherwise there could be undefined behavior when the callback accesses something which is invalid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. </td></tr>
    <tr><td class="paramname">on_dynamic_change_func_moved</td><td><a class="el" href="classflow_1_1Function.html">Function</a> to call synchronously from the next <code>apply*_dynamic()</code> that detects a change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unregister the callback. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01537">1537</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>.</p>

</div>
</div>
<a id="ac1ab5cefe86e6aaa0518d675f309907e" name="ac1ab5cefe86e6aaa0518d675f309907e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ab5cefe86e6aaa0518d675f309907e">&#9670;&nbsp;</a></span>reject_candidates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::reject_candidates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress. </p>
<p >If one is not in-progress, INFO-log but otherwise no-op.</p>
<p >This method only has effect following <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> that</p><ul>
<li>returned <code>true</code>; and</li>
<li>had arg <code>commit == false</code>.</li>
</ul>
<p >That is, if there are pending <em>candidate</em> <code>Value_set</code>s that have not yet been upgraded to canonical status via a <code>commit == true</code> <code>apply_*()</code> call, this call discards them, making it as-if no such call(s) were made in the first place.</p>
<p >Informally we do not expect this to be commonly used; typically <code>apply_*()</code> will automatically do this upon encountering an error (in individual option validation or due to <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a>). However if there is some outside reason to abort an ongoing, so-far-successful multi-source update this method will similarly do it. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02285">2285</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>.</p>

</div>
</div>
<a id="abe9d2c5d3a9747a26a4e6233a0f1feed" name="abe9d2c5d3a9747a26a4e6233a0f1feed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9d2c5d3a9747a26a4e6233a0f1feed">&#9670;&nbsp;</a></span>reject_candidates_if_update_type_changed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::reject_candidates_if_update_type_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">Update_type</a>&#160;</td>
          <td class="paramname"><em>this_update_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for the top of <code>apply_*()</code> that guards against a call to <code>apply_Y()</code> following <code>apply_X(commit == false) == true</code> without a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them. </p>
<p >If this is detected, it effectively "inserts" the "missing" <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> call &ndash; plus an INFO message.</p>
<p >Post-condition: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac74b46ed066f012a633ca16c400441ac" title="In short, truthy if and only if a commit == false update is currently in progress,...">m_multi_src_update_in_progress</a> equals <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85a9ed9d44ce5760f61ea506d5571343624" title="Indicates no apply_*() operation.">Update_type::S_NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_update_type</td><td>The type (not NONE, or behavior undefined &ndash; assert may trip) of <code>apply_*()</code> calling us. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02315">2315</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>.</p>

</div>
</div>
<a id="a859a36cccd8196d9648f67de8656360a" name="a859a36cccd8196d9648f67de8656360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859a36cccd8196d9648f67de8656360a">&#9670;&nbsp;</a></span>save_dynamic_value_set_locked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::save_dynamic_value_set_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; *&#160;</td>
          <td class="paramname"><em>opt_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Little helper that, having assumed <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab8463fe083d97fd4d4b49f7265726d2c" title="Mutex protecting m_d_value_sets.">m_d_value_sets_mutex</a> is locked, makes a newly allocated copy of the canonical dynamic config at the given slot and saves a (new) ref-counted pointer to it in the proper <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a> slot. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_set</td><td>An <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> result (dynamic slot). </td></tr>
    <tr><td class="paramname">d_value_set_idx</td><td>One of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02337">2337</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a19ae9775f51953805ea08086c276a78d" name="a19ae9775f51953805ea08086c276a78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ae9775f51953805ea08086c276a78d">&#9670;&nbsp;</a></span>state_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::state_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of current values where applicable. </p>
<p >This is not thread-safe against several non-<code>const</code> methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02504">2504</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="afbf1eca924be81654eaa4140814a816f" name="afbf1eca924be81654eaa4140814a816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf1eca924be81654eaa4140814a816f">&#9670;&nbsp;</a></span>state_to_ostream_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::state_to_ostream_impl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_set_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> slot <code>value_set_idx</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_idx</td><td>One of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>). </td></tr>
    <tr><td class="paramname">os</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02517">2517</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a8431806f82bed676f5fedb3b64f67245" name="a8431806f82bed676f5fedb3b64f67245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8431806f82bed676f5fedb3b64f67245">&#9670;&nbsp;</a></span>static_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set &amp; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::static_values </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but obtains the static config in <em>one</em> specified slot as opposed to all of them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>This must be <code>S_d_value_set</code> template param pack args in position <code>2 * s_value_set_idx</code> (so one of [0, 2, ..., <code>(2 * S_N_S_VALUE_SETS) - 2</code>]). You will need to explicitly specify this <code>tparam</code>. E.g.: <code>const auto cfg_ptr = cfg_mgr.static_values&lt;S_cfg2&gt;(1)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s_value_set_idx</td><td>The static config slot index; so one of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The immutable, permanently set static config value set in the <code>s_value_set_idx</code> slot. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02428">2428</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="ae034a71792f952256c18e385475627d1" name="ae034a71792f952256c18e385475627d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae034a71792f952256c18e385475627d1">&#9670;&nbsp;</a></span>static_values_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set &amp; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::static_values_candidate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then the parsed values <em>candidate</em> will be returned, instead, if values have been parsed and validated for the static value set but have not yet been applied. </p>
<p >Otherwise, the behavior is equivalent to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s_value_set_idx</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02437">2437</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a4e0dfe1e8f57d974a775f1320bd9856d" name="a4e0dfe1e8f57d974a775f1320bd9856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0dfe1e8f57d974a775f1320bd9856d">&#9670;&nbsp;</a></span>unregister_dynamic_change_listener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::unregister_dynamic_change_listener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously registered dynamic change callback. </p>
<p >See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>.</p>
<p >This is not thread-safe against concurrent calls to itself; nor against concurrent <code>apply_dynamic(commit = true)</code> (against <code>apply_dynamic(commit = false)</code> is okay), <code>apply_static_and_dynamic(commit = true)</code> (against <code>apply_static_and_dynamic(commit = false)</code> is okay), or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle which was returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> when the callback was registered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01558">1558</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="cfg__manager_8hpp_source.html#l01386">flow::cfg::Config_manager&lt; S_d_value_set &gt;::On_dynamic_change_func_handle::m_d_value_set_idx</a>, and <a class="el" href="cfg__manager_8hpp_source.html#l01393">flow::cfg::Config_manager&lt; S_d_value_set &gt;::On_dynamic_change_func_handle::m_pos</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a453d83bf1e8b57b1aaff511fbe913ecc" name="a453d83bf1e8b57b1aaff511fbe913ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453d83bf1e8b57b1aaff511fbe913ecc">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_d_value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02637">2637</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="cfg__manager_8hpp_source.html#l00957">flow::cfg::Config_manager&lt; S_d_value_set &gt;::m_nickname</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a46a8745fe3fe54ede7f664b0a4cd8357" name="a46a8745fe3fe54ede7f664b0a4cd8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a8745fe3fe54ede7f664b0a4cd8357">&#9670;&nbsp;</a></span>m_d_baseline_value_sets</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt;<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a>&gt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_d_baseline_value_sets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The baseline dynamic value sets, in the same order as <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <em>dynamic</em> <code>S_d_value_set</code> template args, the specific type for each slot being <code>S_d_value_set</code>. </p>
<p >The actual type stored is <code>shared_ptr&lt;void&gt;</code>, with each slot's held pointer actually being <code>S_d_value_set*</code>. The same type erasure technique used in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> is used here. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#abe40d6451276e0d4c7c0867669791f9c" title="Helper that obtains the baseline dynamic Value_set in the slot m_d_baseline_value_sets[value_set_idx]...">d_baseline_value_set()</a> obtains the actual <code>S_d_value_set</code> at a given slot, performing the required casting.</p>
<p >A null pointer is stored if the corresponding <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> is <code>null()</code> (a placeholder with 0 settings).</p>
<h3>Rationale / explanation</h3>
<p >Suppose a dynamic <code>Value_set</code> is to be parsed from file F potentially repeatedly, as dynamic updates come in. Then its <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> from <code>m_s_d_opt_sets[]</code> would <code>parse_config_file(F)</code> each time. However, if that is all we did, then the updates would stack on top of each other incrementally: if one looks at F's contents at a given time, one cannot tell what the <code>Value_set</code> in memory would contain upon parsing it; it would depend on any preceding updates. That's bad: the resulting memory <code>Value_set</code> must be consistent, regardless of what F contained in preceding updates. Therefore, a certain <em>baseline</em> state for that <code>Value_set</code> must be loaded into the <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> just before the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">Option_set::parse_config_file()</a> call in each update.</p>
<p >This stores each dynamic slot's baseline <code>Value_set</code> state to load as just described.</p>
<p >After construction this payload is just the default-cted <code>Value_set()</code>. If the user chooses to execute a one-time <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then that payload is replaced by the state after having parsed that baseline state. Note, for context, that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> would be presumably loading <em>not</em> from file F (which can change repeatedly, as dynamic updates come in) but some other file B, typically storing both static value sets' contents as well as the baseline dynamic value sets'. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01295">1295</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>.</p>

</div>
</div>
<a id="a447aa1d42bc9f40af92ce5968c0edc82" name="a447aa1d42bc9f40af92ce5968c0edc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447aa1d42bc9f40af92ce5968c0edc82">&#9670;&nbsp;</a></span>m_d_value_sets</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt;<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a>&gt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_d_value_sets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dynamic config ref-counted handles returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>. </p>
<p >Each one is a ref-counted pointer to an immutable <em>copy</em> of the canonical <code>S_d_value_set</code> in that <em>dynamic</em> slot of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> (namely <code>m_s_d_opt_sets[2 * d_idx + 1]</code>, where <code>d_idx</code> is in [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>)).</p>
<p >The actual type stored is <code>shared_ptr&lt;void&gt;</code>, with each slot's held pointer actually being <code>S_d_value_set::Const_ptr*</code>. The same type erasure technique used in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a> is used here.</p>
<p >Protected by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab8463fe083d97fd4d4b49f7265726d2c" title="Mutex protecting m_d_value_sets.">m_d_value_sets_mutex</a>.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> set these; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> get them.</p>
<h3>Rationale</h3>
<p >Why is this necessary? Why not just expose a pointer to immutable <code>S_d_value_set</code> directly inside <code>m_s_d_opt_sets[d_idx]</code> as we do (via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>) for the static config? Answer: Because with dynamic config it is important that the user be able to retain (if even for a short time, perhaps to complete some operation &ndash; <em>during</em> which <code>*this</code> might process a dynamic update via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>) an immutable <code>S_d_value_set</code>. Since by definition that's not possible with dynamic config updates, we must create a copy. At that point it becomes natural to wrap it in a <code>shared_ptr</code>, so that only <em>one</em> copy is necessary in the entire application &ndash; and it'll disappear once (1) the canonical config has been updated, replacing <code>m_d_value_sets[]</code>, and (2) all user code has dropped the remaining refs to it.</p>
<p >The ref-counted-pointer-to-dynamic-config is a common pattern. The only thing we add that might not be obvious is having the canonical copy be separate from the one we expose via the pointer publicly. The latter is the natural consequence of the fact that the <code>Value_set</code> managed by <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> lives inside the <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code> and is not wrapped by any <code>shared_ptr</code>. However <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f" title="Convenience method that heap-allocates a copy of the internally stored values() and wraps in a ref-co...">Option_set::mutable_values_copy()</a> does provide easy access to a <code>shared_ptr</code>-wrapped copy thereof... so we use it. The perf cost is that of a value-set copy at <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> time which is negligible in the grand scheme of things. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01326">1326</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>.</p>

</div>
</div>
<a id="ab8463fe083d97fd4d4b49f7265726d2c" name="ab8463fe083d97fd4d4b49f7265726d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8463fe083d97fd4d4b49f7265726d2c">&#9670;&nbsp;</a></span>m_d_value_sets_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">util::Mutex_non_recursive</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_d_value_sets_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex protecting <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a>. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01329">1329</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="aa0e43bae09415b5a12a6b9e9f3e01756" name="aa0e43bae09415b5a12a6b9e9f3e01756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e43bae09415b5a12a6b9e9f3e01756">&#9670;&nbsp;</a></span>m_dynamic_values_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_dynamic_values_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts <code>false</code>; set to <code>true</code> permanently on successful <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01345">1345</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="ac74b46ed066f012a633ca16c400441ac" name="ac74b46ed066f012a633ca16c400441ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b46ed066f012a633ca16c400441ac">&#9670;&nbsp;</a></span>m_multi_src_update_in_progress</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85">Update_type</a> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_multi_src_update_in_progress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In short, truthy if and only if a <code>commit == false</code> update is currently in progress, meaning there's an uncommitted <em>candidate</em> <code>Value_set</code> at the moment. </p>
<p >More precisely:</p><ul>
<li>If the last-invoked <code>apply_*()</code> method (1) returned <code>false</code>, or (2) returned <code>true</code> but with arg <code>commit == true</code>, or (3) has never been called, or (4) was followed at any point by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a>, then this equals <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#aa0d03f4dcf7be2c21023c4073ac68b85a9ed9d44ce5760f61ea506d5571343624" title="Indicates no apply_*() operation.">Update_type::S_NONE</a>. I.e., no multi-source update is currently in progress. Otherwise:</li>
<li>This indicates which <code>apply_*(commit = true) == true</code> method (multi-source update type) it was. To the extent the exact type is irrelevant, its being not NONE indicates a multi-source update is in progress.</li>
</ul>
<p >Inside an <code>apply_*()</code> method, this is updated to its new value after parsing into <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a>. Thus during the bulk of such a method's processing we can easily determine whether this is step 1 of a (potentially multi-source) update &ndash; rather than step 2+ &ndash; as this will equal NONE in the former case only.</p>
<p >When this is not-NONE, an <code>apply_*()</code> impl shall skip a couple of steps it would otherwise perform:</p><ul>
<li>Individually-validating the default <code>Value_set()</code> values: Skip, as the first <code>apply_*()</code> in the sequence would have already done it. So it's a waste of compute/entropy.</li>
<li><code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a></code> applying <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a46a8745fe3fe54ede7f664b0a4cd8357" title="The baseline dynamic value sets, in the same order as S_N_D_VALUE_SETS dynamic S_d_value_set template...">m_d_baseline_value_sets</a> onto to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a>: Skip, as the first <code>apply_*()</code> in the sequence would have already done it. So doing it again would be not only redundant but also destructive, overwriting any incremental changes made in preceding 1+ <code>apply_*()</code> calls.</li>
</ul>
<p >It would have been enough for it to be a <code>bool</code> for those tests. It is an <code>enum</code> to be able to detect calling <code>apply_X()</code> after <code>apply_Y(commit = false) == true</code> without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> in-between. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01373">1373</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a68da387dad566805b969aded698661cb" name="a68da387dad566805b969aded698661cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da387dad566805b969aded698661cb">&#9670;&nbsp;</a></span>m_nickname</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <code>nickname</code> ctor arg. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00957">957</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>, and <a class="el" href="cfg__manager_8hpp_source.html#l02637">flow::cfg::Config_manager&lt; S_d_value_set &gt;::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a08ba012812d46fcc6588d4bb8c4d04c9" name="a08ba012812d46fcc6588d4bb8c4d04c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ba012812d46fcc6588d4bb8c4d04c9">&#9670;&nbsp;</a></span>m_on_dynamic_change_funcs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt;std::list&lt;<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a>&gt;, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609">S_N_D_VALUE_SETS</a>&gt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_on_dynamic_change_funcs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of callbacks to execute after <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a> members (the pointers) are next assigned: one per each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> dynamic config slots. </p>
<p >Note we do <em>not</em> assign a given slot's <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a> pointer, unless at least one option has changed within the associated canonical value set in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e724d9d455ea31439c6832d0bc645bd" title="The static and dynamic value sets, in the same order as the S_N_VALUE_SETS S_d_value_set template arg...">m_s_d_opt_sets</a>.</p>
<h3>Rationale</h3>
<p >A <code>list&lt;&gt;</code> is used here so that iterators to callbacks can be stored in <code><a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html" title="Opaque handle for managing a dynamic config change callback.">On_dynamic_change_func_handle</a></code>s without the possibility of them being invalidated by insertions to or removals from the list (which would be the case if <code>vector&lt;&gt;</code> were used). </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01342">1342</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a4e724d9d455ea31439c6832d0bc645bd" name="a4e724d9d455ea31439c6832d0bc645bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e724d9d455ea31439c6832d0bc645bd">&#9670;&nbsp;</a></span>m_s_d_opt_sets</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt;<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6f366f4070a90740e27d73029852e55f">Void_ptr</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8">S_N_VALUE_SETS</a>&gt; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::m_s_d_opt_sets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The static and dynamic value sets, in the same order as the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a> <code>S_d_value_set</code> template args, the specific type for each slot being: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;S_d_value_set&gt;</code>. </p>
<p >This is the main data store managed by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a>. Each static <code>S_d_value_set</code> (the even slots) is the entirety of data having to do with that piece of static config. Each dynamic <code>S_d_value_set</code> (the odd slots) is the <em>canonical</em> dynamic config; and a pointer to a <em>copy</em> thereof is also maintained in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a447aa1d42bc9f40af92ce5968c0edc82" title="The dynamic config ref-counted handles returned by all_dynamic_values().">m_d_value_sets</a>.</p>
<p >The slots, in order, are hence:</p><ul>
<li>Index [0]: static slot 0,</li>
<li>Index [1]: dynamic slot 0,</li>
<li>Index [2]: static slot 1,</li>
<li>Index [3]: dynamic slot 1,</li>
<li>...</li>
<li>Index [<code>.size() - 2</code>]: static slot <code>S_N_S_VALUE_SETS - 1</code>.</li>
<li>Index [<code>.size() - 1</code>]: dynamic slot <code>S_N_D_VALUE_SETS - 1</code>.</li>
</ul>
<p >The actual type stored is <code>shared_ptr&lt;void&gt;</code>, with each slot's held pointer actually being an <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;S_d_value_set&gt;*</code>. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a318e125f78cb7e471cae35e2651ab01f" title="Helper that obtains the Option_set in the slot m_s_d_opt_sets[value_set_idx], which stores an Option_...">opt_set()</a> obtains the actual <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code> at a given slot, performing the required casting.</p>
<h3>Rationale</h3>
<p >Why use an array of <code>shared_ptr&lt;void&gt;</code>, which requires a <code>static_cast</code> anytime we need to actually access a config set? The more compile-time/meta-programm-y approach I (ygoldfel) could conceive of was to use <code>tuple&lt;S_d_value_set...&gt;</code>. That would be quite elegant and lightning-fast (though compilation might be very slow). However then, if I understand correctly, that would prevent any kind of runtime iteration through them. This might be absolutely fine, if every slot were treated identically, but in the current setup it's static, dynamic, static, dynamic, .... Therefore, by moving some processing to runtime instead of compile-time we gain flexibility. (Do note my disclaimer in Implementation section in class doc header &ndash; indicating this is my first foray into advanced meta-programming like this. So perhaps I lack imagination/experience.)</p>
<p >So then <code>shared_ptr&lt;void&gt;</code> actually stores an <code>S_d_value_set*</code> &ndash; <code>S_d_value_set</code> being a different type for each slot in the array. This uses the type erasure pattern of standard C++ smart pointers, wherein because <code>static_cast&lt;void*&gt;(T*)</code> is allowed for any type <code>T</code>, <code>shared_ptr&lt;void&gt;</code> deleter will properly <code>delete</code> the <code>T*</code>, as long as the <code>shared_ptr</code> ctor is passed a <code>T*</code> raw pointer. Do note this is type-safe only if our code knows to cast to the proper <code>T*</code> when the pointer is accessed.</p>
<p >Why <code>shared_ptr</code> &ndash; not <code>unique_ptr</code> (which is nominally faster in that there's no ref-counting)? Answer: <code>unique_ptr</code> is apparently deliberately simple and lacks aliasing and type-erasure constructors. <code>unique_ptr&lt;T&gt;</code> can only delete a <code>T</code> with the default deleter; and <code>T</code> being <code>void</code> therefore won't compile. It is probably possible to hack it with a custom deleter &ndash; but this seemed like overkill, as these handles are never used except inside an <code>array</code>, so reference counting shouldn't even happen and thus cost any perf cycles outside of <code>*this</code> ctor and dtor.</p>
<p >An alternative, which is somewhat more type-safe in that it would have resulted in an RTTI exception if the wrong type-cast were used on the stored value, was <code>any</code>. However <code>any</code> is slower, involving <code>virtual</code> lookups (at least in a naive implementation of <code>any</code>). </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l01265">1265</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>.</p>

</div>
</div>
<a id="ac26c2d6efe1670e940badccb3fdea609" name="ac26c2d6efe1670e940badccb3fdea609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c2d6efe1670e940badccb3fdea609">&#9670;&nbsp;</a></span>S_N_D_VALUE_SETS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::S_N_D_VALUE_SETS = sizeof...(S_d_value_set) / 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of dynamic value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s). </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00414">414</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a9c07f711e98435d00420277f1c20be75" name="a9c07f711e98435d00420277f1c20be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c07f711e98435d00420277f1c20be75">&#9670;&nbsp;</a></span>S_N_S_VALUE_SETS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::S_N_S_VALUE_SETS = sizeof...(S_d_value_set) / 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of static value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s). </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00412">412</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>.</p>

</div>
</div>
<a id="ad49d54a2ae34b14c276cf3de05c3c4f8" name="ad49d54a2ae34b14c276cf3de05c3c4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49d54a2ae34b14c276cf3de05c3c4f8">&#9670;&nbsp;</a></span>S_N_VALUE_SETS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::S_N_VALUE_SETS = sizeof...(S_d_value_set)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of template params in this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> instantiation. It must be even and positive. </p>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l00407">407</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="cfg__manager_8hpp_source.html#l01420">flow::cfg::Config_manager&lt; S_d_value_set &gt;::Config_manager()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cfg/<a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a></li>
<li>cfg/<a class="el" href="cfg__manager__fwd_8hpp_source.html">cfg_manager_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 8 2024 20:30:16 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
