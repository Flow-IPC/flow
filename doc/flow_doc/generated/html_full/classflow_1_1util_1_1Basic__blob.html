<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Basic_blob&lt; Allocator, SHARING &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Basic__blob-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Basic_blob&lt; Allocator, SHARING &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A hand-optimized and API-tweaked replacement for <code>vector&lt;uint8_t&gt;</code>, i.e., buffer of bytes inside an allocated area of equal or larger size; also optionally supports limited garbage-collected memory pool functionality and SHM-friendly custom-allocator support.  
 <a href="classflow_1_1util_1_1Basic__blob.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::util::Basic_blob&lt; Allocator, SHARING &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob__coll__graph.svg" width="495" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html">Deleter_raw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal deleter functor used if and only if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> is <code>false</code> and therefore only with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7" title="The smart-pointer type used for buf_ptr(); a custom-allocator-and-SHM-friendly impl and parameterizat...">Buf_ptr</a> being <code>boost::interprocess::shared_ptr</code> or deleter-parameterized <code>unique_ptr</code>.  <a href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c54edf49fbe9fddab9cc5d927a414d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> = <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td></tr>
<tr class="memdesc:a9c54edf49fbe9fddab9cc5d927a414d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for values, which in this case are unsigned bytes.  <a href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">More...</a><br /></td></tr>
<tr class="separator:a9c54edf49fbe9fddab9cc5d927a414d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48015fe46d5378c44b32203efb1004da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a48015fe46d5378c44b32203efb1004da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for index into blob or length of blob or sub-blob.  <a href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">More...</a><br /></td></tr>
<tr class="separator:a48015fe46d5378c44b32203efb1004da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74e3a7aea427d0525d178dd20c8249"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aaf74e3a7aea427d0525d178dd20c8249">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:aaf74e3a7aea427d0525d178dd20c8249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s.  <a href="classflow_1_1util_1_1Basic__blob.html#aaf74e3a7aea427d0525d178dd20c8249">More...</a><br /></td></tr>
<tr class="separator:aaf74e3a7aea427d0525d178dd20c8249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dff0960e669cc5406dbd23e77ea2a68"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> *</td></tr>
<tr class="memdesc:a2dff0960e669cc5406dbd23e77ea2a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type.  <a href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">More...</a><br /></td></tr>
<tr class="separator:a2dff0960e669cc5406dbd23e77ea2a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044dc7168cc24ffd44eaee00c26f524"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> const *</td></tr>
<tr class="memdesc:a1044dc7168cc24ffd44eaee00c26f524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">More...</a><br /></td></tr>
<tr class="separator:a1044dc7168cc24ffd44eaee00c26f524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff4bef1f4a45b9b25bd6526bad09c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> = Allocator</td></tr>
<tr class="memdesc:a0cff4bef1f4a45b9b25bd6526bad09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the allocator type specified at compile-time. Its element type is our <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2" title="Short-hand for values, which in this case are unsigned bytes.">value_type</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">More...</a><br /></td></tr>
<tr class="separator:a0cff4bef1f4a45b9b25bd6526bad09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1b37167cbd48e84a386d4bc8250405"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5a1b37167cbd48e84a386d4bc8250405">pointer</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a></td></tr>
<tr class="memdesc:a5a1b37167cbd48e84a386d4bc8250405"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to element.  <a href="classflow_1_1util_1_1Basic__blob.html#a5a1b37167cbd48e84a386d4bc8250405">More...</a><br /></td></tr>
<tr class="separator:a5a1b37167cbd48e84a386d4bc8250405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca88676fcece7f4e0638f03dde50a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa8ca88676fcece7f4e0638f03dde50a4">const_pointer</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a></td></tr>
<tr class="memdesc:aa8ca88676fcece7f4e0638f03dde50a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const</code> element.  <a href="classflow_1_1util_1_1Basic__blob.html#aa8ca88676fcece7f4e0638f03dde50a4">More...</a><br /></td></tr>
<tr class="separator:aa8ca88676fcece7f4e0638f03dde50a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ae3b27af30c101b76962bd3614bd3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a653ae3b27af30c101b76962bd3614bd3">reference</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;</td></tr>
<tr class="memdesc:a653ae3b27af30c101b76962bd3614bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to element.  <a href="classflow_1_1util_1_1Basic__blob.html#a653ae3b27af30c101b76962bd3614bd3">More...</a><br /></td></tr>
<tr class="separator:a653ae3b27af30c101b76962bd3614bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f04107f9a3ade2452da8ab918df635c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3f04107f9a3ade2452da8ab918df635c">const_reference</a> = const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;</td></tr>
<tr class="memdesc:a3f04107f9a3ade2452da8ab918df635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const</code> element.  <a href="classflow_1_1util_1_1Basic__blob.html#a3f04107f9a3ade2452da8ab918df635c">More...</a><br /></td></tr>
<tr class="separator:a3f04107f9a3ade2452da8ab918df635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e569514744af0b2de11956730f4d156"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e569514744af0b2de11956730f4d156">iterator</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a></td></tr>
<tr class="memdesc:a5e569514744af0b2de11956730f4d156"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type.  <a href="classflow_1_1util_1_1Basic__blob.html#a5e569514744af0b2de11956730f4d156">More...</a><br /></td></tr>
<tr class="separator:a5e569514744af0b2de11956730f4d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32fd764935aededc6c83fc0c718150f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab32fd764935aededc6c83fc0c718150f">const_iterator</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a></td></tr>
<tr class="memdesc:ab32fd764935aededc6c83fc0c718150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type.  <a href="classflow_1_1util_1_1Basic__blob.html#ab32fd764935aededc6c83fc0c718150f">More...</a><br /></td></tr>
<tr class="separator:ab32fd764935aededc6c83fc0c718150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14e3553c1c199496002caf3dee010056"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a14e3553c1c199496002caf3dee010056">Basic_blob</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;alloc_raw_src={})</td></tr>
<tr class="memdesc:a14e3553c1c199496002caf3dee010056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs blob with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a14e3553c1c199496002caf3dee010056">More...</a><br /></td></tr>
<tr class="separator:a14e3553c1c199496002caf3dee010056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0538a883af59877a877b1021391c2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#afe0538a883af59877a877b1021391c2c">Basic_blob</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr, const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;alloc_raw_src={})</td></tr>
<tr class="memdesc:afe0538a883af59877a877b1021391c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs blob with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> equal to the given <code>size</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#afe0538a883af59877a877b1021391c2c">More...</a><br /></td></tr>
<tr class="separator:afe0538a883af59877a877b1021391c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051426e2408461f549db19c36d59861"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa051426e2408461f549db19c36d59861">Basic_blob</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a> coa_tag, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr, const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;alloc_raw_src={})</td></tr>
<tr class="memdesc:aa051426e2408461f549db19c36d59861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to similar-sig ctor except, if <code>size &gt; 0</code>, all <code>size</code> elements are performantly initialized to zero.  <a href="classflow_1_1util_1_1Basic__blob.html#aa051426e2408461f549db19c36d59861">More...</a><br /></td></tr>
<tr class="separator:aa051426e2408461f549db19c36d59861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0276d17ed96b9a78b5b2c5b805543b0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0276d17ed96b9a78b5b2c5b805543b0d">Basic_blob</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) noexcept</td></tr>
<tr class="memdesc:a0276d17ed96b9a78b5b2c5b805543b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor, constructing a blob exactly internally equal to pre-call <code>moved_src</code>, while the latter is made to be exactly as if it were just constructed as <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>{nullptr}</code> (allocator subtleties aside).  <a href="classflow_1_1util_1_1Basic__blob.html#a0276d17ed96b9a78b5b2c5b805543b0d">More...</a><br /></td></tr>
<tr class="separator:a0276d17ed96b9a78b5b2c5b805543b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be8177591815e8a6d678be3d091712c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6be8177591815e8a6d678be3d091712c">Basic_blob</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a6be8177591815e8a6d678be3d091712c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, constructing a blob logically equal to <code>src</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a6be8177591815e8a6d678be3d091712c">More...</a><br /></td></tr>
<tr class="separator:a6be8177591815e8a6d678be3d091712c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3803c59b8229214884bc85e284ad3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac5a3803c59b8229214884bc85e284ad3">~Basic_blob</a> ()</td></tr>
<tr class="memdesc:ac5a3803c59b8229214884bc85e284ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that drops <code>*this</code> ownership of the allocated internal buffer if any, as by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also.  <a href="classflow_1_1util_1_1Basic__blob.html#ac5a3803c59b8229214884bc85e284ad3">More...</a><br /></td></tr>
<tr class="separator:ac5a3803c59b8229214884bc85e284ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deb969f7f8798b8a08a914e132c0f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f">assign</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) noexcept</td></tr>
<tr class="memdesc:a7deb969f7f8798b8a08a914e132c0f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f">More...</a><br /></td></tr>
<tr class="separator:a7deb969f7f8798b8a08a914e132c0f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8208b62142b55c94993da20336e7a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab8208b62142b55c94993da20336e7a94">operator=</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src) noexcept</td></tr>
<tr class="memdesc:ab8208b62142b55c94993da20336e7a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator (no logging): equivalent to <code>assign(std::move(moved_src), nullptr)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#ab8208b62142b55c94993da20336e7a94">More...</a><br /></td></tr>
<tr class="separator:ab8208b62142b55c94993da20336e7a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7e43fd524a64b2e5a01c44c13772bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9a7e43fd524a64b2e5a01c44c13772bb">assign</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a9a7e43fd524a64b2e5a01c44c13772bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment: assuming <code>(this != &amp;src) &amp;&amp; (!blobs_sharing(*this, src))</code>, makes <code>*this</code> logically equal to <code>src</code>; but behavior undefined if a reallocation would be necessary to do this.  <a href="classflow_1_1util_1_1Basic__blob.html#a9a7e43fd524a64b2e5a01c44c13772bb">More...</a><br /></td></tr>
<tr class="separator:a9a7e43fd524a64b2e5a01c44c13772bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b321098978c1827bcb724a3a329677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab8b321098978c1827bcb724a3a329677">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src)</td></tr>
<tr class="memdesc:ab8b321098978c1827bcb724a3a329677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (no logging): equivalent to <code>assign(src, nullptr)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#ab8b321098978c1827bcb724a3a329677">More...</a><br /></td></tr>
<tr class="separator:ab8b321098978c1827bcb724a3a329677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460191bd2541002b6668ce6c08489099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099">swap</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;other, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) noexcept</td></tr>
<tr class="memdesc:a460191bd2541002b6668ce6c08489099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>, or no-op if <code>this == &amp;other</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099">More...</a><br /></td></tr>
<tr class="separator:a460191bd2541002b6668ce6c08489099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e4668320845ae522165b2095f5097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097">share</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) const</td></tr>
<tr class="memdesc:a5e4e4668320845ae522165b2095f5097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to <code>!zero()</code> blobs, this returns an identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it.  <a href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097">More...</a><br /></td></tr>
<tr class="separator:a5e4e4668320845ae522165b2095f5097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7da4387ef57fe4384fcf928de45dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2">share_after_split_left</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a2c7da4387ef57fe4384fcf928de45dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to <code>!zero()</code> blobs, this shifts <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> by <code>size</code> to the right without changing <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; and returns a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> containing the shifted-past values that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it.  <a href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2">More...</a><br /></td></tr>
<tr class="separator:a2c7da4387ef57fe4384fcf928de45dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a0b1bc225e328e95a590c92fe75c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a35a0b1bc225e328e95a590c92fe75c24">share_after_split_right</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a35a0b1bc225e328e95a590c92fe75c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>, except <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> shifts by <code>size</code> to the left (instead of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> to the right), and the split-off <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> contains the *right-most*</code>size` elements (instead of the left-most).  <a href="classflow_1_1util_1_1Basic__blob.html#a35a0b1bc225e328e95a590c92fe75c24">More...</a><br /></td></tr>
<tr class="separator:a35a0b1bc225e328e95a590c92fe75c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad602b1fc24bf9e93a59e4d4fc4de12d"><td class="memTemplParams" colspan="2">template&lt;typename Emit_blob_func &gt; </td></tr>
<tr class="memitem:aad602b1fc24bf9e93a59e4d4fc4de12d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d">share_after_split_equally</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classbool.html">bool</a> headless_pool, Emit_blob_func &amp;&amp;emit_blob_func, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:aad602b1fc24bf9e93a59e4d4fc4de12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to successively performing <code>share_after_split_left(size)</code> until <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code>; the resultings <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s are emitted via <code>emit_blob_func()</code> callback in the order they're split off from the left.  <a href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d">More...</a><br /></td></tr>
<tr class="separator:aad602b1fc24bf9e93a59e4d4fc4de12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed7e8cdbb3ea75b924e18b0ab329f7"><td class="memTemplParams" colspan="2">template&lt;typename Blob_container &gt; </td></tr>
<tr class="memitem:a86ed7e8cdbb3ea75b924e18b0ab329f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a86ed7e8cdbb3ea75b924e18b0ab329f7">share_after_split_equally_emit_seq</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classbool.html">bool</a> headless_pool, Blob_container *out_blobs, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a86ed7e8cdbb3ea75b924e18b0ab329f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s into the given container via <code>push_back()</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a86ed7e8cdbb3ea75b924e18b0ab329f7">More...</a><br /></td></tr>
<tr class="separator:a86ed7e8cdbb3ea75b924e18b0ab329f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98079a5b3ee23af3d6938cf4ad65c75"><td class="memTemplParams" colspan="2">template&lt;typename Blob_ptr_container &gt; </td></tr>
<tr class="memitem:ac98079a5b3ee23af3d6938cf4ad65c75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac98079a5b3ee23af3d6938cf4ad65c75">share_after_split_equally_emit_ptr_seq</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classbool.html">bool</a> headless_pool, Blob_ptr_container *out_blobs, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:ac98079a5b3ee23af3d6938cf4ad65c75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code>Ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>s into the given container via <code>push_back()</code>, where the type <code>Ptr&lt;&gt;</code> is determined via <code>Blob_ptr_container::value_type</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#ac98079a5b3ee23af3d6938cf4ad65c75">More...</a><br /></td></tr>
<tr class="separator:ac98079a5b3ee23af3d6938cf4ad65c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770438e824467e6dac1c7c0b060acfb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a770438e824467e6dac1c7c0b060acfb8">assign_copy</a> (const boost::asio::const_buffer &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a770438e824467e6dac1c7c0b060acfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces logical contents with a copy of the given non-overlapping area anywhere in memory.  <a href="classflow_1_1util_1_1Basic__blob.html#a770438e824467e6dac1c7c0b060acfb8">More...</a><br /></td></tr>
<tr class="separator:a770438e824467e6dac1c7c0b060acfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f377987183d36b0ff5ebb9605d8aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a37f377987183d36b0ff5ebb9605d8aae">emplace_copy</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> dest, const boost::asio::const_buffer &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a37f377987183d36b0ff5ebb9605d8aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>src</code> buffer directly onto equally sized area within <code>*this</code> at location <code>dest</code>; <code>*this</code> must have sufficient <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> to accomodate all of the data copied.  <a href="classflow_1_1util_1_1Basic__blob.html#a37f377987183d36b0ff5ebb9605d8aae">More...</a><br /></td></tr>
<tr class="separator:a37f377987183d36b0ff5ebb9605d8aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc24100c45d41d25ca658afe5e1421d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#afc24100c45d41d25ca658afe5e1421d7">sub_copy</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> src, const boost::asio::mutable_buffer &amp;dest, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) const</td></tr>
<tr class="memdesc:afc24100c45d41d25ca658afe5e1421d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opposite of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a37f377987183d36b0ff5ebb9605d8aae" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> in every way, copying a sub-blob onto a target memory area.  <a href="classflow_1_1util_1_1Basic__blob.html#afc24100c45d41d25ca658afe5e1421d7">More...</a><br /></td></tr>
<tr class="separator:afc24100c45d41d25ca658afe5e1421d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a474024d9fdef67dfc5c0f5f5bd69e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a> () const</td></tr>
<tr class="memdesc:af7a474024d9fdef67dfc5c0f5f5bd69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored, namely <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>.  <a href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">More...</a><br /></td></tr>
<tr class="separator:af7a474024d9fdef67dfc5c0f5f5bd69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31de2c03648cd51b05c0d2a823ca0e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3">start</a> () const</td></tr>
<tr class="memdesc:ad31de2c03648cd51b05c0d2a823ca0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset between <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> and the start of the internally allocated buffer.  <a href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3">More...</a><br /></td></tr>
<tr class="separator:ad31de2c03648cd51b05c0d2a823ca0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325630d29505488391aa4d50dae962b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8">empty</a> () const</td></tr>
<tr class="memdesc:a325630d29505488391aa4d50dae962b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8">More...</a><br /></td></tr>
<tr class="separator:a325630d29505488391aa4d50dae962b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc03a7a025f362a819b984fbf1e33b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8">capacity</a> () const</td></tr>
<tr class="memdesc:a3cc03a7a025f362a819b984fbf1e33b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buffer is internally allocated.  <a href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8">More...</a><br /></td></tr>
<tr class="separator:a3cc03a7a025f362a819b984fbf1e33b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1a42c486710c48086b0cff01e7bb9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e">zero</a> () const</td></tr>
<tr class="memdesc:a2e1a42c486710c48086b0cff01e7bb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if a buffer is allocated and owned; <code>true</code> otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e">More...</a><br /></td></tr>
<tr class="separator:a2e1a42c486710c48086b0cff01e7bb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7105de11c7a24dc9012cef8ad38f448d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d">reserve</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8">capacity</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a7105de11c7a24dc9012cef8ad38f448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that an internal buffer of at least <code>capacity</code> elements is allocated and owned; disallows growing an existing buffer; never shrinks an existing buffer; if a buffer is allocated, it is no larger than <code>capacity</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d">More...</a><br /></td></tr>
<tr class="separator:a7105de11c7a24dc9012cef8ad38f448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6727d577edca0bcda03fea4684e07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a96e6727d577edca0bcda03fea4684e07">reserve</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8">capacity</a>, <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a> coa_tag, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a96e6727d577edca0bcda03fea4684e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to similar-sig overload except, if a <code>capacity</code>-sized buffer is allocated, then all <code>size</code> elements are performantly initialized to zero.  <a href="classflow_1_1util_1_1Basic__blob.html#a96e6727d577edca0bcda03fea4684e07">More...</a><br /></td></tr>
<tr class="separator:a96e6727d577edca0bcda03fea4684e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69df8d881b78c282f4d9d20898009b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e">make_zero</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a69df8d881b78c282f4d9d20898009b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> by dropping <code>*this</code> ownership of the allocated internal buffer if any; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also.  <a href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e">More...</a><br /></td></tr>
<tr class="separator:a69df8d881b78c282f4d9d20898009b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9733bbfa054e0621fe1573d8b0bc65e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6">resize</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> start_or_unchanged=<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">S_UNCHANGED</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:a9733bbfa054e0621fe1573d8b0bc65e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == size</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == start</code>; no values in pre-call range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> are changed; any values <em>added</em> to that range by the call are not initialized to zero or otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6">More...</a><br /></td></tr>
<tr class="separator:a9733bbfa054e0621fe1573d8b0bc65e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8521772d170f4fd4aa03aa32f35264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#afd8521772d170f4fd4aa03aa32f35264">resize</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a> coa_tag, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> start_or_unchanged=<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">S_UNCHANGED</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr)</td></tr>
<tr class="memdesc:afd8521772d170f4fd4aa03aa32f35264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to similar-sig overload except, if a <code>capacity</code>-sized buffer is allocated, then all <code>size</code> elements are performantly initialized to zero.  <a href="classflow_1_1util_1_1Basic__blob.html#afd8521772d170f4fd4aa03aa32f35264">More...</a><br /></td></tr>
<tr class="separator:afd8521772d170f4fd4aa03aa32f35264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f0be2b65b9b6c95baeedb71d220a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2">start_past_prefix</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> prefix_size)</td></tr>
<tr class="memdesc:a318f0be2b65b9b6c95baeedb71d220a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restructures blob to consist of an internally allocated buffer and a <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, end)</code> range starting at offset <code>prefix_size</code> within that buffer.  <a href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2">More...</a><br /></td></tr>
<tr class="separator:a318f0be2b65b9b6c95baeedb71d220a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1fd4dcf77dc5034a8f5d361ab952d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4e1fd4dcf77dc5034a8f5d361ab952d">start_past_prefix_inc</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aaf74e3a7aea427d0525d178dd20c8249">difference_type</a> prefix_size_inc)</td></tr>
<tr class="memdesc:ae4e1fd4dcf77dc5034a8f5d361ab952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2" title="Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...">start_past_prefix()</a> but shifts the <em>current</em> prefix position by the given <em>incremental</em> value (positive or negative).  <a href="classflow_1_1util_1_1Basic__blob.html#ae4e1fd4dcf77dc5034a8f5d361ab952d">More...</a><br /></td></tr>
<tr class="separator:ae4e1fd4dcf77dc5034a8f5d361ab952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9629fb98e682890db3e0ba6e4508b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7b9629fb98e682890db3e0ba6e4508b4">clear</a> ()</td></tr>
<tr class="memdesc:a7b9629fb98e682890db3e0ba6e4508b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>resize(0, start())</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a7b9629fb98e682890db3e0ba6e4508b4">More...</a><br /></td></tr>
<tr class="separator:a7b9629fb98e682890db3e0ba6e4508b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd9502b9019f404805baf1f4d92b479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4bd9502b9019f404805baf1f4d92b479">erase</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> first, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> past_last)</td></tr>
<tr class="memdesc:a4bd9502b9019f404805baf1f4d92b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the minimal number of operations to make range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> unchanged except for lacking sub-range <code>[first, past_last)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a4bd9502b9019f404805baf1f4d92b479">More...</a><br /></td></tr>
<tr class="separator:a4bd9502b9019f404805baf1f4d92b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43cdaa3d2f1756eab77c403d56fa314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314">begin</a> ()</td></tr>
<tr class="memdesc:aa43cdaa3d2f1756eab77c403d56fa314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to mutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314">More...</a><br /></td></tr>
<tr class="separator:aa43cdaa3d2f1756eab77c403d56fa314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3bc8a5b83ec050657d7bf223afee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0">const_begin</a> () const</td></tr>
<tr class="memdesc:a28e3bc8a5b83ec050657d7bf223afee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to immutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0">More...</a><br /></td></tr>
<tr class="separator:a28e3bc8a5b83ec050657d7bf223afee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b2a514db458f7a3132cde858fdb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a791b2a514db458f7a3132cde858fdb73">begin</a> () const</td></tr>
<tr class="memdesc:a791b2a514db458f7a3132cde858fdb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a791b2a514db458f7a3132cde858fdb73">More...</a><br /></td></tr>
<tr class="separator:a791b2a514db458f7a3132cde858fdb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b0eed31140d4e783a9ac1b5c8eb3d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1">end</a> ()</td></tr>
<tr class="memdesc:af1b0eed31140d4e783a9ac1b5c8eb3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer one past mutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> is possible.  <a href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1">More...</a><br /></td></tr>
<tr class="separator:af1b0eed31140d4e783a9ac1b5c8eb3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483eae7eea132ca8d1a9600ecf34deb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0">const_end</a> () const</td></tr>
<tr class="memdesc:a483eae7eea132ca8d1a9600ecf34deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer one past immutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> is possible.  <a href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0">More...</a><br /></td></tr>
<tr class="separator:a483eae7eea132ca8d1a9600ecf34deb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753dc7799aaae363568e4d37453d115a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a753dc7799aaae363568e4d37453d115a">end</a> () const</td></tr>
<tr class="memdesc:a753dc7799aaae363568e4d37453d115a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a753dc7799aaae363568e4d37453d115a">More...</a><br /></td></tr>
<tr class="separator:a753dc7799aaae363568e4d37453d115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e39c285a93685a13fe735accfad85f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af4e39c285a93685a13fe735accfad85f">const_front</a> () const</td></tr>
<tr class="memdesc:af4e39c285a93685a13fe735accfad85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable first element.  <a href="classflow_1_1util_1_1Basic__blob.html#af4e39c285a93685a13fe735accfad85f">More...</a><br /></td></tr>
<tr class="separator:af4e39c285a93685a13fe735accfad85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261cbb3a78fb7b2ec9228209d1f6418"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad261cbb3a78fb7b2ec9228209d1f6418">const_back</a> () const</td></tr>
<tr class="memdesc:ad261cbb3a78fb7b2ec9228209d1f6418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable last element.  <a href="classflow_1_1util_1_1Basic__blob.html#ad261cbb3a78fb7b2ec9228209d1f6418">More...</a><br /></td></tr>
<tr class="separator:ad261cbb3a78fb7b2ec9228209d1f6418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894cb043b1a6ab840349b12a4cfcf7b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a894cb043b1a6ab840349b12a4cfcf7b2">front</a> () const</td></tr>
<tr class="memdesc:a894cb043b1a6ab840349b12a4cfcf7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af4e39c285a93685a13fe735accfad85f" title="Returns reference to immutable first element.">const_front()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a894cb043b1a6ab840349b12a4cfcf7b2">More...</a><br /></td></tr>
<tr class="separator:a894cb043b1a6ab840349b12a4cfcf7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d5b212dce4f859f4d31de9380bc89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3c1d5b212dce4f859f4d31de9380bc89">back</a> () const</td></tr>
<tr class="memdesc:a3c1d5b212dce4f859f4d31de9380bc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad261cbb3a78fb7b2ec9228209d1f6418" title="Returns reference to immutable last element.">const_back()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a3c1d5b212dce4f859f4d31de9380bc89">More...</a><br /></td></tr>
<tr class="separator:a3c1d5b212dce4f859f4d31de9380bc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa3e57770d4f71fb831029a268c568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a72fa3e57770d4f71fb831029a268c568">front</a> ()</td></tr>
<tr class="memdesc:a72fa3e57770d4f71fb831029a268c568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable first element.  <a href="classflow_1_1util_1_1Basic__blob.html#a72fa3e57770d4f71fb831029a268c568">More...</a><br /></td></tr>
<tr class="separator:a72fa3e57770d4f71fb831029a268c568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcb1315b5262bfe443e2a2d8dae751d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5fcb1315b5262bfe443e2a2d8dae751d">back</a> ()</td></tr>
<tr class="memdesc:a5fcb1315b5262bfe443e2a2d8dae751d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable last element.  <a href="classflow_1_1util_1_1Basic__blob.html#a5fcb1315b5262bfe443e2a2d8dae751d">More...</a><br /></td></tr>
<tr class="separator:a5fcb1315b5262bfe443e2a2d8dae751d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0536ea4661e19b0779dee1defd69e236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0536ea4661e19b0779dee1defd69e236">const_data</a> () const</td></tr>
<tr class="memdesc:a0536ea4661e19b0779dee1defd69e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a0536ea4661e19b0779dee1defd69e236">More...</a><br /></td></tr>
<tr class="separator:a0536ea4661e19b0779dee1defd69e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f388fcb1ebced9e4ca7f971a0b2961f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7f388fcb1ebced9e4ca7f971a0b2961f">data</a> ()</td></tr>
<tr class="memdesc:a7f388fcb1ebced9e4ca7f971a0b2961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a7f388fcb1ebced9e4ca7f971a0b2961f">More...</a><br /></td></tr>
<tr class="separator:a7f388fcb1ebced9e4ca7f971a0b2961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7c1a50ca44fee90fde751bf9b8740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa2f7c1a50ca44fee90fde751bf9b8740">cbegin</a> () const</td></tr>
<tr class="memdesc:aa2f7c1a50ca44fee90fde751bf9b8740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#aa2f7c1a50ca44fee90fde751bf9b8740">More...</a><br /></td></tr>
<tr class="separator:aa2f7c1a50ca44fee90fde751bf9b8740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85053a0809c0d649bfc515ad4f1bfcb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a85053a0809c0d649bfc515ad4f1bfcb6">cend</a> () const</td></tr>
<tr class="memdesc:a85053a0809c0d649bfc515ad4f1bfcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a85053a0809c0d649bfc515ad4f1bfcb6">More...</a><br /></td></tr>
<tr class="separator:a85053a0809c0d649bfc515ad4f1bfcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee3b2c46e9290e1af7b517d52966ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0ee3b2c46e9290e1af7b517d52966ded">valid_iterator</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> it) const</td></tr>
<tr class="memdesc:a0ee3b2c46e9290e1af7b517d52966ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if: <code>this-&gt;derefable_iterator(it) || (it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a0ee3b2c46e9290e1af7b517d52966ded">More...</a><br /></td></tr>
<tr class="separator:a0ee3b2c46e9290e1af7b517d52966ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad440ccd596c9f5db5aedccbe09996a71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad440ccd596c9f5db5aedccbe09996a71">derefable_iterator</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> it) const</td></tr>
<tr class="memdesc:ad440ccd596c9f5db5aedccbe09996a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the given iterator points to an element within this blob's <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> elements.  <a href="classflow_1_1util_1_1Basic__blob.html#ad440ccd596c9f5db5aedccbe09996a71">More...</a><br /></td></tr>
<tr class="separator:ad440ccd596c9f5db5aedccbe09996a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e0aef110c4ab5f335d633e9a96abb"><td class="memItemLeft" align="right" valign="top">boost::asio::const_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c7e0aef110c4ab5f335d633e9a96abb">const_buffer</a> () const</td></tr>
<tr class="memdesc:a7c7e0aef110c4ab5f335d633e9a96abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience accessor returning an immutable boost.asio buffer "view" into the entirety of the blob.  <a href="classflow_1_1util_1_1Basic__blob.html#a7c7e0aef110c4ab5f335d633e9a96abb">More...</a><br /></td></tr>
<tr class="separator:a7c7e0aef110c4ab5f335d633e9a96abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72a747faa93798e39e26e4ff9c5dd60"><td class="memItemLeft" align="right" valign="top">boost::asio::mutable_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af72a747faa93798e39e26e4ff9c5dd60">mutable_buffer</a> ()</td></tr>
<tr class="memdesc:af72a747faa93798e39e26e4ff9c5dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c7e0aef110c4ab5f335d633e9a96abb" title="Convenience accessor returning an immutable boost.asio buffer &quot;view&quot; into the entirety of the blob.">const_buffer()</a> but the returned view is mutable.  <a href="classflow_1_1util_1_1Basic__blob.html#af72a747faa93798e39e26e4ff9c5dd60">More...</a><br /></td></tr>
<tr class="separator:af72a747faa93798e39e26e4ff9c5dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52f23edf1e536ba6c4b80271de7ff9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad52f23edf1e536ba6c4b80271de7ff9e">get_allocator</a> () const</td></tr>
<tr class="memdesc:ad52f23edf1e536ba6c4b80271de7ff9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the internally cached <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> as set by a constructor or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> or assignment-operator, whichever happened last.  <a href="classflow_1_1util_1_1Basic__blob.html#ad52f23edf1e536ba6c4b80271de7ff9e">More...</a><br /></td></tr>
<tr class="separator:ad52f23edf1e536ba6c4b80271de7ff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab573b02e01cc92a58935e5d1210ff54f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">S_SHARING</a> = SHARING</td></tr>
<tr class="memdesc:ab573b02e01cc92a58935e5d1210ff54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of template parameter <code>SHARING</code> (for generic programming).  <a href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">More...</a><br /></td></tr>
<tr class="separator:ab573b02e01cc92a58935e5d1210ff54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8988597460efcd777ec1b9c433ed81fc"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">S_UNCHANGED</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>(-1)</td></tr>
<tr class="memdesc:a8988597460efcd777ec1b9c433ed81fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value indicating an unchanged <code>size_type</code> value; such as in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">More...</a><br /></td></tr>
<tr class="separator:a8988597460efcd777ec1b9c433ed81fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2b69eef6b4af966e224275d297e9c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c">S_IS_VANILLA_ALLOC</a> = std::is_same_v&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, std::allocator&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>&gt;&gt;</td></tr>
<tr class="memdesc:a81e2b69eef6b4af966e224275d297e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> underlying allocator template is simply <code>std::allocator</code>; <code>false</code> otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c">More...</a><br /></td></tr>
<tr class="separator:a81e2b69eef6b4af966e224275d297e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a53826c1f5638db3a138192b87adde7fa"><td class="memTemplParams" colspan="2">template&lt;typename Emit_blob_func , typename Share_after_split_left_func &gt; </td></tr>
<tr class="memitem:a53826c1f5638db3a138192b87adde7fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a53826c1f5638db3a138192b87adde7fa">share_after_split_equally_impl</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classbool.html">bool</a> headless_pool, Emit_blob_func &amp;&amp;emit_blob_func, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, Share_after_split_left_func &amp;&amp;share_after_split_left_func)</td></tr>
<tr class="memdesc:a53826c1f5638db3a138192b87adde7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> but capable of emitting not just <code>*this</code> type (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;...&gt;</code>) but any sub-class (such as <code>Blob</code>/<code>Sharing_blob</code>) provided a functor like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning an object of that appropriate type.  <a href="classflow_1_1util_1_1Basic__blob.html#a53826c1f5638db3a138192b87adde7fa">More...</a><br /></td></tr>
<tr class="separator:a53826c1f5638db3a138192b87adde7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3fb3bc67bf8c4388d893208f7af0fdac"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">Flow_log_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3fb3bc67bf8c4388d893208f7af0fdac">S_LOG_COMPONENT</a> = Flow_log_component::S_UTIL</td></tr>
<tr class="memdesc:a3fb3bc67bf8c4388d893208f7af0fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">flow::log::Component</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a3fb3bc67bf8c4388d893208f7af0fdac">More...</a><br /></td></tr>
<tr class="separator:a3fb3bc67bf8c4388d893208f7af0fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a5b84fa4bce20b49c3ac0e7d87926cbf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">Buf_ptr</a> = std::conditional_t&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c">S_IS_VANILLA_ALLOC</a>, std::conditional_t&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">S_SHARING</a>, boost::shared_ptr&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>[]&gt;, boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>[]&gt; &gt;, std::conditional_t&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">S_SHARING</a>, boost::interprocess::shared_ptr&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html">Deleter_raw</a> &gt;, boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html">Deleter_raw</a> &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a5b84fa4bce20b49c3ac0e7d87926cbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The smart-pointer type used for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a>; a custom-allocator-and-SHM-friendly impl and parameterization is used if necessary; otherwise a more typical concrete type is used.  <a href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">More...</a><br /></td></tr>
<tr class="separator:a5b84fa4bce20b49c3ac0e7d87926cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adca2859a32cd701671bb82e7fb9bbc5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">Buf_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e">buf_ptr</a> ()</td></tr>
<tr class="memdesc:adca2859a32cd701671bb82e7fb9bbc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For convenience/expressiveness, the pointer-to-main-buf for <code>*this</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e">More...</a><br /></td></tr>
<tr class="separator:adca2859a32cd701671bb82e7fb9bbc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbddaed4c6c9970c19b54ecfa71da93"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">Buf_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4cbddaed4c6c9970c19b54ecfa71da93">buf_ptr</a> () const</td></tr>
<tr class="memdesc:a4cbddaed4c6c9970c19b54ecfa71da93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ref-to-immutable counterpart to the other overload.  <a href="classflow_1_1util_1_1Basic__blob.html#a4cbddaed4c6c9970c19b54ecfa71da93">More...</a><br /></td></tr>
<tr class="separator:a4cbddaed4c6c9970c19b54ecfa71da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bdf2ee9e562400a0476282c8c66ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0">alloc_raw</a> ()</td></tr>
<tr class="memdesc:af6bdf2ee9e562400a0476282c8c66ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For convenience/expressiveness, the allocator object for <code>*this</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0">More...</a><br /></td></tr>
<tr class="separator:af6bdf2ee9e562400a0476282c8c66ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66553c783ea601b074454860e2ec16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9b66553c783ea601b074454860e2ec16">alloc_raw</a> () const</td></tr>
<tr class="memdesc:a9b66553c783ea601b074454860e2ec16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ref-to-immutable counterpart to the other overload.  <a href="classflow_1_1util_1_1Basic__blob.html#a9b66553c783ea601b074454860e2ec16">More...</a><br /></td></tr>
<tr class="separator:a9b66553c783ea601b074454860e2ec16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f45c6f17074d8261147f89925516d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5f45c6f17074d8261147f89925516d55">reserve_impl</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8">capacity</a>, <a class="el" href="classbool.html">bool</a> clear_on_alloc, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a5f45c6f17074d8261147f89925516d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> overloads.  <a href="classflow_1_1util_1_1Basic__blob.html#a5f45c6f17074d8261147f89925516d55">More...</a><br /></td></tr>
<tr class="separator:a5f45c6f17074d8261147f89925516d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765bce38dfebc12f631278f072c5f9ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a765bce38dfebc12f631278f072c5f9ec">resize_impl</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e">size</a>, <a class="el" href="classbool.html">bool</a> clear_on_alloc, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> start_or_unchanged, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a765bce38dfebc12f631278f072c5f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> overloads.  <a href="classflow_1_1util_1_1Basic__blob.html#a765bce38dfebc12f631278f072c5f9ec">More...</a><br /></td></tr>
<tr class="separator:a765bce38dfebc12f631278f072c5f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1ff257357de700de5006304b80301d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aed1ff257357de700de5006304b80301d">swap_impl</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;other, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr) noexcept</td></tr>
<tr class="memdesc:aed1ff257357de700de5006304b80301d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The body of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>, except for the part that swaps (or decides not to swap) <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#aed1ff257357de700de5006304b80301d">More...</a><br /></td></tr>
<tr class="separator:aed1ff257357de700de5006304b80301d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3721b8885dce4d5c7ef9fb9b72b9db3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3721b8885dce4d5c7ef9fb9b72b9db3a">iterator_sans_const</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a> it)</td></tr>
<tr class="memdesc:a3721b8885dce4d5c7ef9fb9b72b9db3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator-to-mutable equivalent to given iterator-to-immutable.  <a href="classflow_1_1util_1_1Basic__blob.html#a3721b8885dce4d5c7ef9fb9b72b9db3a">More...</a><br /></td></tr>
<tr class="separator:a3721b8885dce4d5c7ef9fb9b72b9db3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a60e111d587a33ff23eacf3e264d8ffc8"><td class="memItemLeft" align="right" valign="top">boost::compressed_pair&lt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">Buf_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a60e111d587a33ff23eacf3e264d8ffc8">m_alloc_and_buf_ptr</a></td></tr>
<tr class="memdesc:a60e111d587a33ff23eacf3e264d8ffc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined &ndash; to enable empty base-class optimization (EBO) &ndash; storage for the two data items, refs to which are returned by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> respectively.  <a href="classflow_1_1util_1_1Basic__blob.html#a60e111d587a33ff23eacf3e264d8ffc8">More...</a><br /></td></tr>
<tr class="separator:a60e111d587a33ff23eacf3e264d8ffc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e7333542e30de2cb2fa4fe35f723b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#abd9e7333542e30de2cb2fa4fe35f723b">m_capacity</a></td></tr>
<tr class="memdesc:abd9e7333542e30de2cb2fa4fe35f723b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#abd9e7333542e30de2cb2fa4fe35f723b" title="See capacity(); but m_capacity is meaningless (and containing unknown value) if !buf_ptr() (i....">m_capacity</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>).  <a href="classflow_1_1util_1_1Basic__blob.html#abd9e7333542e30de2cb2fa4fe35f723b">More...</a><br /></td></tr>
<tr class="separator:abd9e7333542e30de2cb2fa4fe35f723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27366fedbc0305c31d5fdcea10fbc7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a27366fedbc0305c31d5fdcea10fbc7f3">m_start</a></td></tr>
<tr class="memdesc:a27366fedbc0305c31d5fdcea10fbc7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a27366fedbc0305c31d5fdcea10fbc7f3" title="See start(); but m_start is meaningless (and containing unknown value) if !buf_ptr() (i....">m_start</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>).  <a href="classflow_1_1util_1_1Basic__blob.html#a27366fedbc0305c31d5fdcea10fbc7f3">More...</a><br /></td></tr>
<tr class="separator:a27366fedbc0305c31d5fdcea10fbc7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f3eaa5050a55a5c6e66e5e80e2060b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a47f3eaa5050a55a5c6e66e5e80e2060b">m_size</a></td></tr>
<tr class="memdesc:a47f3eaa5050a55a5c6e66e5e80e2060b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a47f3eaa5050a55a5c6e66e5e80e2060b" title="See size(); but m_size is meaningless (and containing unknown value) if !buf_ptr() (i....">m_size</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>).  <a href="classflow_1_1util_1_1Basic__blob.html#a47f3eaa5050a55a5c6e66e5e80e2060b">More...</a><br /></td></tr>
<tr class="separator:a47f3eaa5050a55a5c6e66e5e80e2060b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a25c63cd23dd19d7899c773f257d0f397"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </td></tr>
<tr class="memitem:a25c63cd23dd19d7899c773f257d0f397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a25c63cd23dd19d7899c773f257d0f397">blobs_sharing</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;blob1, const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;blob2)</td></tr>
<tr class="memdesc:a25c63cd23dd19d7899c773f257d0f397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if both given objects are not <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, and they either co-own a common underlying buffer, or <em>are</em> the same object.  <a href="classflow_1_1util_1_1Basic__blob.html#a25c63cd23dd19d7899c773f257d0f397">More...</a><br /></td></tr>
<tr class="separator:a25c63cd23dd19d7899c773f257d0f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf5004897129150111e57f3521341cb"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </td></tr>
<tr class="memitem:a9bf5004897129150111e57f3521341cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9bf5004897129150111e57f3521341cb">swap</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;blob1, <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;blob2, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=nullptr) noexcept</td></tr>
<tr class="memdesc:a9bf5004897129150111e57f3521341cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>blob1.swap(blob2)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a9bf5004897129150111e57f3521341cb">More...</a><br /></td></tr>
<tr class="separator:a9bf5004897129150111e57f3521341cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Allocator, <a class="el" href="classbool.html">bool</a> SHARING&gt;<br />
class flow::util::Basic_blob&lt; Allocator, SHARING &gt;</div><p >A hand-optimized and API-tweaked replacement for <code>vector&lt;uint8_t&gt;</code>, i.e., buffer of bytes inside an allocated area of equal or larger size; also optionally supports limited garbage-collected memory pool functionality and SHM-friendly custom-allocator support. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Blob__with__log__context.html" title="Basic_blob that works in regular heap (and is itself placed in heap or stack) and memorizes a log::Lo...">Blob_with_log_context</a> (and especially aliases <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a> and <a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>), our non-polymorphic sub-class which adds some ease of use in exchange for a small <a class="el" href="namespaceflow_1_1perf.html" title="Flow module containing tools for profiling and optimization.">perf</a> trade-off. (More info below under "Logging.") </dd>
<dd>
<a class="el" href="namespaceflow_1_1util.html#a2c085aa47872fe7e4dbba0703e23923c" title="Short-hand for a Basic_blob that allocates/deallocates in regular heap and is itself assumed to be st...">Blob_sans_log_context</a> + <a class="el" href="namespaceflow_1_1util.html#a0edd9dd6bf51e7457477123b419f5bf6" title="Identical to Blob_sans_log_context but with sharing feature compile-time-enabled.">Sharing_blob_sans_log_context</a>, each simply an alias to <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;std::allocator, B&gt;</code> (with <code>B = false</code> or <code>true</code> respectively), in a fashion vaguely similar to what <code>string</code> is to <code>basic_string</code> (a little). This is much like <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>, in that it is a non-template concrete type; but does not take or store a <code>Logger*</code>.</dd></dl>
<p>The rationale for its existence mirrors its essential differences from <code>vector&lt;uint8_t&gt;</code> which are as follows. To summarize, though, it exists to guarantee specific performance by reducing implementation uncertainty via lower-level operations; and force user to explicitly authorize any allocation to ensure thoughtfully performant use. Update: Plus, it adds non-prefix-sub-buffer feature, which can be useful for zero-copy deserialization. Update: Plus, it adds a simple form of garbage-collected memory pools, useful for operating multiple <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s that share a common over-arching memory area (buffer). Update: Plus, it adds SHM-friendly custom allocator support. (While all <code>vector</code> impls support custom allocators, only some later versions of gcc <code>std::vector</code> work with shared-memory (SHM) allocators and imperfectly at that. <code>boost::container::vector</code> a/k/a <code>boost::interprocess::vector</code> is fully SHM-friendly.)</p>
<ul>
<li>It adds a feature over <code>vector&lt;uint8_t&gt;</code>: The logical contents <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> can optionally begin not at the start of the internally allocated buffer but somewhere past it. In other words, the logical buffer is not necessarily a prefix of the internal allocated buffer. This feature is critical when one wants to use some sub-buffer of a buffer without reallocating a smaller buffer and copying the sub-buffer into it. For example, if we read a DATA packet the majority of which is the payload, which begins a few bytes from the start &ndash; past a short header &ndash; it may be faster to keep passing around the whole thing with move semantics but use only the payload part, after logically deserializing it (a/k/a zero-copy deserialization semantics). Of course one can do this with <code>vector</code> as well; but one would need to always remember the prefix length even after deserializing, at which point such details would be ideally forgotten instead. So this API is significantly more pleasant in that case. Moreover it can then be used generically more easily, alongside other containers.</li>
<li>Its performance is guaranteed by internally executing low-level operations such as <code>memcpy()</code> directly instead of hoping that using a higher-level abstraction will ultimately do the same.<ul>
<li>In particular, the iterator types exposed by the API <em>are</em> pointers instead of introducing any performance uncertainty by possibly using wrapper/proxy iterator class.</li>
<li>In particular (unless explicitly requested via optional <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> tag) no element or memory area is <em>ever</em> initialized to zero(es) or any other particular filler value(s). (This is surprisingly difficult to avoid with STL containers! Google it. Though, e.g., boost.container does provide a <code>default_init_t</code> extension to various APIs like <code>.<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a></code>.) If an allocation does occur, the area is left as-is unless user specifies a source memory area from which to copy data.<ul>
<li>However, if you <em>do</em> desire the zeroing of memory immediately upon allocation, you may request it via <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> tag arg to size-taking ctor, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>. This is in many cases faster than an explicit <code>memset()</code> or <code>fill_n()</code> of your own; so do you use it; it is not mere syntactic sugar.</li>
</ul>
</li>
<li>Note that I am making no assertion about <code>vector</code> being slow; the idea is to guarantee <em>we</em> aren't by removing any <em>question</em> about it; it's entirely possible a given <code>vector</code> is equally fast, but it cannot be guaranteed by standard except in terms of complexity guarantees (which is usually pretty good but not everything).<ul>
<li>That said a quick story about <code>std::vector&lt;uint8_t&gt;</code> (in gcc-8.3 anyway): I (ygoldfel) once used it with a custom allocator (which worked in shared memory) and stored a megabytes-long buffer in one. Its destructor, I noticed, spent milliseconds (with 2022 hardware) &ndash; outside the actual dealloc call. Reason: It was iterating over every (1-byte) element and invoking its (non-existent/trivial) destructor. It did not specialize to avoid this, intentionally so according to a comment, when using a custom allocator. <code>boost::container::vector&lt;uint8_t&gt;</code> lacked this problem; but nevertheless it shows generally written containers can have hidden such perf quirks.</li>
</ul>
</li>
</ul>
</li>
<li>To help achieve the previous bullet point, as well as to keep the code simple, the class does not parameterize on element type; it stores unsigned bytes, period (though <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2" title="Short-hand for values, which in this case are unsigned bytes.">Basic_blob::value_type</a> is good to use if you need to refer to that type in code generically). Perhaps the same could be achieved by specialization, but we don't need the parameterization in the first place.</li>
<li>Unlike <code>vector</code>, it has an explicit state where there is no underlying buffer; in this case <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>. Also in that case, <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code> (and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>). <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> is the case on default-constructed object of this class. The reason for this is I am never sure, at least, what a default-constructed <code>vector</code> looks like internally; a null buffer always seemed like a reasonable starting point worth guaranteeing explicitly.</li>
<li>If <code>!zero()</code>:<ul>
<li><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> deallocates any allocated buffer and ensures <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>, as if upon default construction.</li>
<li>Like <code>vector</code>, it keeps an allocated memory chunk of size M, at the start of which is the logical buffer of size <code>N &lt;= M</code>, where <code>N == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and <code>M == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>. However, <code>M &gt;= 1</code> always.<ul>
<li>There is the aforementioned added feature wherein the logical buffer begins to the right of the allocated buffer, namely at index <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code>. In this case <code>M &gt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and the buffer range is in indices <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code> of the allocated buffer. By default <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>, as in <code>vector</code>, but this can be changed via the 2nd, optional, argument to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>.</li>
</ul>
</li>
<li>Like <code>vector</code>, <code>reserve(Mnew)</code>, with <code>Mnew &lt;= M</code>, does nothing. However, unlike <code>vector</code>, the same call is <em>illegal</em> when <code>Mnew &gt; M &gt;= 1</code>. However, any <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> call <em>is</em> allowed when <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>. Therefore, if the user is intentionally okay with the performance implications of a reallocation, they can call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> and <em>then</em> force the reallocating <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> call.</li>
<li>Like <code>vector</code>, <code>resize(Nnew)</code> merely guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == Nnew</code>; which means that it is essentially equivalent to <code>reserve(Nnew)</code> followed by setting internal N member to Nnew. However, remember that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> therefore keeps all the behaviors of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, including that it cannot grow the buffer (only allocate it when <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>).<ul>
<li>If changing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> from default, then: <code>resize(Nnew, Snew)</code> means <code>reserve(Nnew + Snew)</code>, plus saving internal N and S members.</li>
</ul>
</li>
</ul>
</li>
<li>The <em>only</em> way to allocate is to (directly or indirectly) call <code>reserve(Mnew)</code> when <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>. Moreover, <em>exactly</em> Mnew bytes elements are allocated and no more (unlike with <code>vector</code>, where the policy used is not known). Moreover, if <code>reserve(Mnew)</code> is called indirectly (by another method of the class), <code>Mnew</code> arg is set to no greater than size necessary to complete the operation (again, by contrast, it is unknown what <code>vector</code> does w/r/t capacity policy).</li>
<li>The rest of the API is common-sense but generally kept to only what has been necessary to date, in on-demand fashion.</li>
</ul>
<h3>Optional, simple garbage-collected shared ownership functionality</h3>
<p >The following feature was added quite some time after <code>Blob</code> was first introduced and matured. However it seamlessly subsumes all of the above basic functionality with full backwards compatibility. It can also be disabled (and is by default) by setting <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> to <code>false</code> at compile-time. (This gains back a little bit of perf namely by turning an internal <code>shared_ptr</code> to <code>unique_ptr</code>.)</p>
<p >The feature itself is simple: Suppose one has a blob A, constructed or otherwise <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a></code>d or <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a></code>d so as to have <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code>; meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> &gt;= 1</code>. Now suppose one calls the core method of this <em>pool</em> feature: <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> which returns a new blob B. B will have the same exact <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> &ndash; and, in fact, the pointer <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7f388fcb1ebced9e4ca7f971a0b2961f" title="Equivalent to begin().">data()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> (i.e., the underlying buffer start pointer, buffer being <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> long). That is, B now shares the underlying memory buffer with A. Normally, that underlying buffer would be deallocated when either <code>A.make_zero()</code> is called, or A is destructed. Now that it's shared by A and B, however, the buffer is deallocated only once <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destruction occurs for <em>both</em> A and B. That is, there is an internal (thread-safe) ref-count that must reach 0.</p>
<p >Both A and B may now again be <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>d into further sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s. This further increments the ref-count of original buffer; all such <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s C, D, ... must now either <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destruct, at which point the dealloc occurs.</p>
<p >In that way the buffer &ndash; or <em>pool</em> &ndash; is <em>garbage-collected</em> as a whole, with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (and APIs like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and ctors that call it) initially allocating and setting internal ref-count to 1, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> incrementing it, and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac5a3803c59b8229214884bc85e284ad3" title="Destructor that drops *this ownership of the allocated internal buffer if any, as by make_zero(); if ...">~Basic_blob()</a> decrementing it (and deallocating when ref-count=0).</p>
<h3>Application of shared ownership: Simple pool-of-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s functionality</h3>
<p >The other aspect of this feature is its pool-of-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s application. All of the sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s A, B, ... retain all the aforementioned features including the ability to use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4e1fd4dcf77dc5034a8f5d361ab952d" title="Like start_past_prefix() but shifts the current prefix position by the given incremental value (posit...">start_past_prefix_inc()</a>, etc., to control the location of the logical sub-range [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) within the underlying buffer (pool). E.g., suppose A was 10 bytes, with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> = 0</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> = 10</code>; then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> B is also that way. Now <code>B.start_past_prefix_inc(5); A.resize(5);</code> makes it so that A = the 1st 5 bytes of the pool, B the last 5 bytes (and they don't overlap &ndash; can even be concurrently modified safely). In that way A and B are now independent <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s &ndash; potentially passed, say, to independent TCP-receive calls, each of which reads up to 5 bytes &ndash; that share an over-arching pool.</p>
<p >The API <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> is a convenience operation that splits a <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>'s [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) area into 2 areas of specified length, then returns a new <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> representing the first area in the split and modifies <code>*this</code> to represent the remainder (the 2nd area). This simply performs the op described in the preceding paragraph. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a35a0b1bc225e328e95a590c92fe75c24" title="Identical to share_after_split_left(), except this-&gt;end() shifts by size to the left (instead of this...">share_after_split_right()</a> is similar but acts symmetrically from the right. Lastly <code>share_after_split_equally*()</code> splits a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> into several equally-sized (except the last one potentially) sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s of size N, where N is an arg. (It can be thought of as just calling <code>share_after_split_left(N)</code> repeatedly, then returning a sequence of the resulting post-split <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.)</p>
<p >To summarize: The <code>share_after_split*()</code> APIs are useful to divide (potentially progressively) a pool into non-overlapping <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s within a pool while ensuring the pool continues to exist while <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s refer to any part of it (but no later). Meanwhile direct use of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and <code>start_past_prefix*()</code> allows for overlapping such sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >Note that deallocation occurs regardless of which areas of that pool the relevant <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s represent, and whether they overlap or not (and, for that matter, whether they even together make up the entire pool or leave "gaps" in-between). The whole pool is deallocated the moment the last of the co-owning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s performs either <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac5a3803c59b8229214884bc85e284ad3" title="Destructor that drops *this ownership of the allocated internal buffer if any, as by make_zero(); if ...">~Basic_blob()</a> &ndash; the values of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> at the time are not relevant.</p>
<h3>Custom allocator (and SHared Memory) support</h3>
<p >Like STL containers this one optionally takes a custom allocator type (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>) as a compile-time parameter instead of using the regular heap (<code>std::allocator</code>). Unlike many STL container implementations, including at least older <code>std::vector</code>, it supports SHM-storing allocators without a constant cross-process vaddr scheme. (Some do support this but with surprising perf flaws when storing raw integers/bytes. boost.container <code>vector</code> has solid support but lacks various other properties of <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.) While a detailed discussion is outside our scope here, the main point is internally <code>*this</code> stores no raw <code>value_type*</code> but rather <code>Allocator_raw::pointer</code> &ndash; which in many cases <em>is</em> <code>value_type*</code>; but for advanced applications like SHM it might be a fancy-pointer like <code>boost::interprocess::offset_ptr&lt;value_type&gt;</code>. For general education check out boost.interprocess docs covering storage of STL containers in SHM. (However note that the allocators provided by that library are only one option even for SHM storage alone; e.g., they are stateful, and often one would like a stateless &ndash; zero-size &ndash; allocator. Plus there are other limitations to boost.interprocess SHM support, robust though it is.)</p>
<dl class="section note"><dt>Note</dt><dd>In the somewhat-exotic case wherein <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateful (therefore not <code>std::allocator</code> default), such that it is possible for two objects of that type to value-compare as not-equal, the following rules apply. Propagation of allocators via move-ct, copy-ct, move-assign, copy-assign, or swap follows standard rules (see cppreference.com or the like for those). This is normal. However the following is different from at least some standard containers and derivatives (e.g., boost.container ones), at least potentially: Even if an aforementioned op <em>did</em> propagate the allocator object from the source <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>, any existing buffer (meaning <code>!zero()</code>) shall be deallocated using the same allocator object that allocated it originally (hence in this scenario there are now 2 allocator objects stored in <code>*this</code>). A reallocation with the new allocator object will <em>not</em> be forced. (Among other considerations this means that original allocator's resources &ndash; the source pool or whatever it is &ndash; must stay alive until the deallocation does occur according to the simple above-documented rules of when that must happen.) The rationale is that <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> is biased toward simple, predictable behavior w/r/t deallocs and allocs occurring, even in the fact of exotic <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad52f23edf1e536ba6c4b80271de7ff9e" title="Returns a copy of the internally cached Allocator_raw as set by a constructor or assign() or assignme...">get_allocator()</a> changes.</dd></dl>
<h3>Logging</h3>
<p >When and if <code>*this</code> logs, it is with <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b" title="Message indicates any condition that may occur with great frequency (thus verbose if logged).">log::Sev::S_TRACE</a> severity or more verbose.</p>
<p >Unlike many other Flow API classes this one does not derive from <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">log::Log_context</a> nor take a <code>Logger*</code> in ctor (and store it). Instead each API method/ctor/function capable of logging takes an optional (possibly null) <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a> pointer. If supplied it's used by that API alone (with some minor async exceptions). If you would like more typical Flow-style logging API then use our non-polymorphic sub-class <a class="el" href="classflow_1_1util_1_1Blob__with__log__context.html" title="Basic_blob that works in regular heap (and is itself placed in heap or stack) and memorizes a log::Lo...">Blob_with_log_context</a> (more likely aliases <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>, <a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>). However consider the following first.</p>
<p >Why this design? Answer:</p><ul>
<li><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> is meant to be lean, both in terms of RAM used and processor cycles spent. Storing a <code>Logger*</code> takes some space; and storing it, copying/moving it, etc., takes a little compute. In a low-level API like <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> this is potentially nice to avoid when not actively needed. (That said the logging can be extremely useful when debugging and/or profiling RAM use + allocations.)<ul>
<li>This isn't a killer. The original <code>Blob</code> (before <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> existed) stored a <code>Logger*</code>, and it was fine. However:</li>
</ul>
</li>
<li>Storing a <code>Logger*</code> is always okay when <code>*this</code> itself is stored in regular heap or on the stack. However, <code>*this</code> itself may be stored in SHM; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> parameterization (see above regarding "Custom allocator") suggests as much (i.e., if the buffer is stored in SHM, we might be too). In that case <code>Logger*</code> does not, usually, make sense. As of this writing <code>Logger</code> in process 1 has no relationship with any <code>Logger</code> in process 2; and even if the <code>Logger</code> were stored in SHM itself, <code>Logger</code> would need to be supplied via an in-SHM fancy-pointer, not <code>Logger*</code>, typically. The latter is a major can of worms and not supported by <a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a> in any case as of this writing.<ul>
<li>Therefore, even if we don't care about RAM/perf implications of storing <code>Logger*</code> with the blob, at least in some real applications it makes no sense.</li>
</ul>
</li>
</ul>
<p ><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a> provides this support while ensuring <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> (no longer a template parameter in its case) is the vanilla <code>std::allocator</code>. The trade-off is as noted just above.</p>
<h3>Thread safety</h3>
<p >Before <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> (or <code>share_*()</code>) is called: Essentially: Thread safety is the same as for <code>vector&lt;uint8_t&gt;</code>.</p>
<p >Without <code>share*()</code> any two <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> objects refer to separate areas in memory; hence it is safe to access <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> A concurrently with accessing <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> B in any fashion (read, write).</p>
<p >However: If 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s A and B co-own a pool, via a <code>share*()</code> chain, then concurrent write and read/write to A and B respectively are thread-safe if and only if their [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) ranges don't overlap. Otherwise, naturally, one would be writing to an area while it is being read simultaneously &ndash; not safe.</p>
<p >Tip: When working in <code>share*()</code> mode, exclusive use of <code>share_after_split*()</code> is a great way to guarantee no 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s ever overlap. Meanwhile one must be careful when using <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> directly and/or subsequently sliding the range around via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <code>start_past_prefix*()</code>: <code>A.share()</code> and A not only (originally) overlap but simply represent the same area of memory; and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and co. can turn a non-overlapping range into an overlapping one (encroaching on someone else's "territory" within the pool).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000147">Todo:</a></b></dt><dd>Write a class template, perhaps <code>Tight_blob&lt;Allocator, bool&gt;</code>, which would be identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> but forego the framing features, namely <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, thus storing only the RAII array pointer <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7f388fcb1ebced9e4ca7f971a0b2961f" title="Equivalent to begin().">data()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>; rewrite <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> in terms of this <code>Tight_blob</code>. This simple container type has had some demand in practice, and <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> can and should be cleanly built on top of it (perhaps even as an IS-A subclass).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>An allocator, with <code>value_type</code> equal to our <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2" title="Short-hand for values, which in this case are unsigned bytes.">value_type</a>, per the standard C++1x <code>Allocator</code> concept. In most uses this shall be left at the default <code>std::allocator&lt;value_type&gt;</code> which allocates in standard heap (<code>new[]</code>, <code>delete[]</code>). A custom allocator may be used instead. SHM-storing allocators, and generally allocators for which <code>pointer</code> is not simply <code>value_type*</code> but rather a fancy-pointer (see cppreference.com) are correctly supported. (Note this may not be the case for your compiler's <code>std::vector</code>.) </td></tr>
    <tr><td class="paramname">SHARING</td><td>If <code>true</code>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> and all derived methods, plus <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a25c63cd23dd19d7899c773f257d0f397" title="Returns true if and only if both given objects are not zero() == true, and they either co-own a commo...">blobs_sharing()</a>, can be instantiated (invoked in compiled code). If <code>false</code> they cannot (<code>static_assert()</code> will trip), but the resulting <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> concrete class will be slightly more performant (internally, a <code>shared_ptr</code> becomes instead a <code>unique_ptr</code> which means smaller allocations and no ref-count logic invoked). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00275">275</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0cff4bef1f4a45b9b25bd6526bad09c7" name="a0cff4bef1f4a45b9b25bd6526bad09c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cff4bef1f4a45b9b25bd6526bad09c7">&#9670;&nbsp;</a></span>Allocator_raw</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Allocator_raw =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for the allocator type specified at compile-time. Its element type is our <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2" title="Short-hand for values, which in this case are unsigned bytes.">value_type</a>. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00296">296</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a5b84fa4bce20b49c3ac0e7d87926cbf7" name="a5b84fa4bce20b49c3ac0e7d87926cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b84fa4bce20b49c3ac0e7d87926cbf7">&#9670;&nbsp;</a></span>Buf_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Buf_ptr =  std::conditional_t&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c">S_IS_VANILLA_ALLOC</a>, std::conditional_t&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">S_SHARING</a>, boost::shared_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>[]&gt;, boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>[]&gt; &gt;, std::conditional_t&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f">S_SHARING</a>, boost::interprocess::shared_ptr &lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html">Deleter_raw</a>&gt;, boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html">Deleter_raw</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The smart-pointer type used for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a>; a custom-allocator-and-SHM-friendly impl and parameterization is used if necessary; otherwise a more typical concrete type is used. </p>
<p >The following discussion assumes the more complex case wherein <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> is <code>true</code>. We discuss the simpler converse case below that.</p>
<p >Two things affect how <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> shall behave:</p><ul>
<li>Which type this resolves-to depending on <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> (ultimately <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>). This affects many key things but most relevantly how it is dereferenced. Namely:<ul>
<li>Typical <code>shared_ptr</code> (used with vanilla allocator) will internally store simply a raw <code>value_type*</code> and dereference trivially. This, however, will not work with some custom allocators, particularly SHM-heap ones (without a constant cross-process vaddr scheme), wherein a raw <code>T*</code> meaningful in the original process is meaningless in another.<ul>
<li><code>boost::shared_ptr</code> and <code>std::shared_ptr</code> both have custom-allocator support via <code>allocate_shared()</code> and co. However, as of this writing, they are not SHM-friendly; or another way of putting it is they don't support custom allocators fully: <code>Allocator::pointer</code> is ignored; it is assumed to essentially be raw <code>value_type*</code>, in that the <code>shared_ptr</code> internally stores a raw pointer. boost.interprocess refers to this as the impetus for implementing the following:</li>
</ul>
</li>
<li><code>boost::interprocess::shared_ptr</code> (used with custom allocator) will internally store an instance of <code>Allocator_raw::pointer</code> (to <code>value_type</code>) instead. To dereference it, its operators such as <code>*</code> and <code>-&gt;</code> (etc.) will execute to properly translate to a raw <code>T*</code>. The aforementioned <code>pointer</code> may simply be <code>value_type*</code> again; in which case there is no difference to the standard <code>shared_ptr</code> situation; but it can instead be a fancy-pointer (actual technical term, yes, in cppreference.com et al), in which case some custom code will run to translate some internal data members (which have process-agnostic values) inside the fancy-pointer to a raw <code>T*</code>. For example <code>boost::interprocess::offset_ptr&lt;value_type&gt;</code> does this by adding a stored offset to its own <code>this</code>.</li>
</ul>
</li>
<li>How it is reset to a newly allocated buffer in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (when needed).<ul>
<li>Typical <code>shared_ptr</code> is efficiently assigned using a <code>make_shared()</code> variant. However, here we store a pointer to an array, not a single value (hence <code>&lt;value_type[]&gt;</code>); and we specifically want to avoid any 0-initialization of the elements (per one of <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>'s promises). See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> which uses a <code>make_shared()</code> variant that accomplishes all this.</li>
<li><code>boost::interprocess::shared_ptr</code> is reset differently due to a couple of restrictions, as it is made to be usable in SHM (SHared Memory), specifically, plus it seems to refrain from tacking on every normal <code>shared_ptr</code> feature. To wit: 1, <code>virtual</code> cannot be used; therefore the deleter type must be declared at compile-time. 2, it has no special support for a native-array element-type (<code>value_type[]</code>). Therefore it leaves that part up to the user: the buffer must be pre-allocated by the user (and passed to <code>.reset()</code>); there is no <code>make_shared()</code> equivalent (which also means somewhat lower perf, as aux data and user buffer are separately allocated and stored). Accordingly deletion is left to the user, as there is no default deleter; one must be supplied. Thus:<ul>
<li>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>; it calls <code>.reset()</code> as explained here, including using <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a> to pre-allocate.</li>
<li>See <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html" title="Internal deleter functor used if and only if S_IS_VANILLA_ALLOC is false and therefore only with Buf_...">Deleter_raw</a>, the deleter functor type an instance of which is saved by the <code>shared_ptr</code> to invoke when ref-count reaches 0.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >Other than that, it's a <code>shared_ptr</code>; it works as usual.</p>
<h3>Why use typical <code>shared_ptr</code> at all? Won't the fancy-allocator-supporting one work for the vanilla case?</h3>
<p >Yes, it would work. And there would be less code without this dichotomy (although the differences are, per above, local to this alias definition; and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> where it allocates buffer). There are however reasons why typical <code>shared_ptr</code> (we choose <code>boost::shared_ptr</code> over <code>std::shared_ptr</code>; that discussion is elsewhere, but basically <code>boost::shared_ptr</code> is solid and full-featured/mature, though either choice would've worked). They are at least:</p><ul>
<li>It is much more frequently used, preceding and anticipating its acceptance into the STL standard, so maturity and performance are likelier.</li>
<li>Specifically it supports a perf-enhancing use mode: using <code>make_shared()</code> (and similar) instead of <code>.reset(&lt;raw ptr&gt;)</code> (or similar ctor) replaces 2 allocs (1 for user data, 1 for aux data/ref-count) with 1 (for both).</li>
<li>If verbose logging in the deleter is desired, its <code>virtual</code>-based type-erased deleter semantics make that quite easy to achieve.</li>
</ul>
<h3>The case where <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> is <code>false</code></h3>
<p >Firstly: if so then the method &ndash; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> &ndash; that would <em>ever</em> increment <code>Buf_ptr::use_count()</code> beyond 1 is simply not compiled. Therefore using any type of <code>shared_ptr</code> is a waste of RAM (on the ref-count) and cycles (on aux memory allocation and ref-count math), albeit a minor one. Hence we use <code>unique_ptr</code> in that case instead. Even so, the above <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> dichotomy still applies but is quite a bit simpler to handle; it's a degenerate case in a way.</p><ul>
<li>Typical <code>unique_ptr</code> already stores <code>Deleter::pointer</code> instead of <code>value_ptr*</code>. Therefore We can use it for both cases; in the vanilla case supplying no <code>Deleter</code> template param (the default <code>Deleter</code> has <code>pointer = value_ptr*</code>); otherwise supplying <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html" title="Internal deleter functor used if and only if S_IS_VANILLA_ALLOC is false and therefore only with Buf_...">Deleter_raw</a> whose <a class="el" href="classflow_1_1util_1_1Basic__blob_1_1Deleter__raw.html#a03d84a79bc93b2835ddb284e8c8d4e50" title="For boost::interprocess::shared_ptr and unique_ptr compliance (hence the irregular capitalization).">Deleter_raw::pointer</a> comes from <code>Allocator_raw::pointer</code>. This also, same as with <code>boost::interprocess::shared_ptr</code>, takes care of the dealloc upon being nullified or destroyed.</li>
<li>As for initialization:<ul>
<li>With <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> at <code>true</code>: Similarly to using a special array-friendly <code>make_shared()</code> variant, we use a special array-friendly <code>make_unique()</code> variant.</li>
<li>Otherwise: As with <code>boost::interprocess::shared_ptr</code> we cannot <code>make_*()</code> &ndash; though AFAIK without any perf penalty (there is no aux data) &ndash; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> must be quite careful to also replace <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a></code>'s deleter (which <code>.reset()</code> does not do... while <code>boost::interprocess::shared_ptr</code> does). </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01495">1495</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a1044dc7168cc24ffd44eaee00c26f524" name="a1044dc7168cc24ffd44eaee00c26f524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044dc7168cc24ffd44eaee00c26f524">&#9670;&nbsp;</a></span>Const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Const_iterator =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a> const *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00293">293</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ab32fd764935aededc6c83fc0c718150f" name="ab32fd764935aededc6c83fc0c718150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32fd764935aededc6c83fc0c718150f">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_iterator =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00311">311</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="aa8ca88676fcece7f4e0638f03dde50a4" name="aa8ca88676fcece7f4e0638f03dde50a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ca88676fcece7f4e0638f03dde50a4">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_pointer =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>const</code> element. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00303">303</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a3f04107f9a3ade2452da8ab918df635c" name="a3f04107f9a3ade2452da8ab918df635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f04107f9a3ade2452da8ab918df635c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_reference =  const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>const</code> element. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00307">307</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="aaf74e3a7aea427d0525d178dd20c8249" name="aaf74e3a7aea427d0525d178dd20c8249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf74e3a7aea427d0525d178dd20c8249">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for difference of <code>size_type</code>s. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00287">287</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a2dff0960e669cc5406dbd23e77ea2a68" name="a2dff0960e669cc5406dbd23e77ea2a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dff0960e669cc5406dbd23e77ea2a68">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Iterator =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into a mutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00290">290</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a5e569514744af0b2de11956730f4d156" name="a5e569514744af0b2de11956730f4d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e569514744af0b2de11956730f4d156">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::iterator =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00309">309</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a5a1b37167cbd48e84a386d4bc8250405" name="a5a1b37167cbd48e84a386d4bc8250405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1b37167cbd48e84a386d4bc8250405">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::pointer =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to element. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00301">301</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a653ae3b27af30c101b76962bd3614bd3" name="a653ae3b27af30c101b76962bd3614bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ae3b27af30c101b76962bd3614bd3">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::reference =  <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to element. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00305">305</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a48015fe46d5378c44b32203efb1004da" name="a48015fe46d5378c44b32203efb1004da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48015fe46d5378c44b32203efb1004da">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for index into blob or length of blob or sub-blob. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00284">284</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a9c54edf49fbe9fddab9cc5d927a414d2" name="a9c54edf49fbe9fddab9cc5d927a414d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c54edf49fbe9fddab9cc5d927a414d2">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::value_type =  <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for values, which in this case are unsigned bytes. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00281">281</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a14e3553c1c199496002caf3dee010056" name="a14e3553c1c199496002caf3dee010056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e3553c1c199496002caf3dee010056">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc_raw_src</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs blob with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>. </p>
<p >Note this means no buffer is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_raw_src</td><td>Allocator to copy and store in <code>*this</code> for all buffer allocations/deallocations. If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateless, then this has size zero, so nothing is copied at runtime, and by definition it is to equal <code>Allocator_raw{}</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01670">1670</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="afe0538a883af59877a877b1021391c2c" name="afe0538a883af59877a877b1021391c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0538a883af59877a877b1021391c2c">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc_raw_src</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs blob with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> equal to the given <code>size</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>. </p>
<p >Performance note: elements are not initialized to zero or any other value. A new over-arching buffer (pool) is therefore allocated.</p>
<dl class="section see"><dt>See also</dt><dd>a similar ctor that takes <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> tag arg, if you <em>do</em> want the elements to be zero-initialized. Doing so is often faster than your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar).</dd></dl>
<p>Corner case note: a post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0)</code>. Note, also, that the latter is <em>not</em> a universal invariant (see <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> doc header).</p>
<p >Formally: If <code>size &gt;= 1</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>A non-negative desired size. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
    <tr><td class="paramname">alloc_raw_src</td><td>Allocator to copy and store in <code>*this</code> for all buffer allocations/deallocations. If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateless, then this has size zero, so nothing is copied at runtime, and by definition it is to equal <code>Allocator_raw{}</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01680">1680</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l02361">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::resize()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l02086">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_afe0538a883af59877a877b1021391c2c_cgraph.svg" width="328" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa051426e2408461f549db19c36d59861" name="aa051426e2408461f549db19c36d59861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa051426e2408461f549db19c36d59861">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a>&#160;</td>
          <td class="paramname"><em>coa_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc_raw_src</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to similar-sig ctor except, if <code>size &gt; 0</code>, all <code>size</code> elements are performantly initialized to zero. </p>
<p >Using this ctor form, instead of using the non-init one followed by your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar), is likely to be significantly faster in at least some cases. It is <em>not</em> mere syntactic sugar.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> also have <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> forms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coa_tag</td><td>API-choosing tag <a class="el" href="namespaceflow_1_1util.html#ad2ab789927de51b4f2fd1d448aff0ab3" title="Tag value indicating init-with-zeroes-on-alloc policy.">util::CLEAR_ON_ALLOC</a>. </td></tr>
    <tr><td class="paramname">size</td><td>See similar ctor. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See similar ctor. </td></tr>
    <tr><td class="paramname">alloc_raw_src</td><td>See similar ctor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01689">1689</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l02361">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::resize()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l02086">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_aa051426e2408461f549db19c36d59861_cgraph.svg" width="328" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0276d17ed96b9a78b5b2c5b805543b0d" name="a0276d17ed96b9a78b5b2c5b805543b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0276d17ed96b9a78b5b2c5b805543b0d">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor, constructing a blob exactly internally equal to pre-call <code>moved_src</code>, while the latter is made to be exactly as if it were just constructed as <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>{nullptr}</code> (allocator subtleties aside). </p>
<p >Performance: constant-time, at most copying a few scalars.</p>
<dl class="section note"><dt>Note</dt><dd>It is important this be <code>noexcept</code>, if a copying counterpart to us exists in this class; otherwise (e.g.) <code>vector&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code> will, on realloc, default to copying <code>*this</code>es around instead of moving: a terrible (in its stealthiness) perf loss.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>The object whose internals to move to <code>*this</code> and replace with a blank-constructed object's internals. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01711">1711</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a6be8177591815e8a6d678be3d091712c" name="a6be8177591815e8a6d678be3d091712c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be8177591815e8a6d678be3d091712c">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor, constructing a blob logically equal to <code>src</code>. </p>
<p >More formally, guarantees post-condition wherein <code>[this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> range is equal by value (including length) to <code>src</code> equivalent range but no memory overlap. A post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>. Performance: see copying assignment operator.</p>
<p >Corner case note: the range equality guarantee includes the degenerate case where that range is empty, meaning we simply guarantee post-condition <code>src.empty() == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a></code>.</p>
<p >Corner case note 2: post-condition: <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a></code> (note <code>src.zero()</code> state is not necessarily preserved in <code>*this</code>).</p>
<p >Note: This is <code>explicit</code>, which is atypical for a copy constructor, to generate compile errors in hard-to-see (and often unintentional) instances of copying. Copies of <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> should be quite intentional and explicit. (One example where one might forget about a copy would be when using a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> argument without <code>cref</code> or <code>ref</code> in a <code>bind()</code>; or when capturing by value, not by ref, in a lambda.)</p>
<p >Formally: If <code>src.size() &gt;= 1</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Object whose range of bytes of length <code>src.size()</code> starting at <code>src.begin()</code> is copied into <code>*this</code>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01698">1698</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l02459">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::assign_copy()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l02771">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::const_buffer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a6be8177591815e8a6d678be3d091712c_cgraph.svg" width="328" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac5a3803c59b8229214884bc85e284ad3" name="ac5a3803c59b8229214884bc85e284ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a3803c59b8229214884bc85e284ad3">&#9670;&nbsp;</a></span>~Basic_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::~<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor that drops <code>*this</code> ownership of the allocated internal buffer if any, as by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also. </p>
<p >Recall that other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s can only gain co-ownership via <code>share*()</code>; hence if one does not use that feature, the destructor will in fact deallocate the buffer (if any).</p>
<p >Formally: If <code>!zero()</code>, then the internal ownership ref-count is decremented by 1, and if it reaches 0, then a buffer is deallocated.</p>
<h3>Logging</h3>
<p >This will not log, as it is not possible to pass a <code>Logger*</code> to a dtor without storing it (which we avoid for reasons outlined in class doc header). Use <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a> if it is important to log in this situation (although there are some minor trade-offs). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af6bdf2ee9e562400a0476282c8c66ff0" name="af6bdf2ee9e562400a0476282c8c66ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bdf2ee9e562400a0476282c8c66ff0">&#9670;&nbsp;</a></span>alloc_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">::Allocator_raw</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::alloc_raw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For convenience/expressiveness, the allocator object for <code>*this</code>. </p>
<p >The actual datum is inside a <code>compressed_pair</code> for reasons explained elsewhere, and it is annoying/ugly having to specify that detail all over the code. So one can just use this reference-returning accessor.</p>
<h3>Documentation for the datum referred-to by the return value</h3>
<p >Copy of the allocator supplied by the user (though, if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateless, it is typically defaulted to <code>Allocator_raw{}</code>), as set by a constructor or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> or assignment-operator, whichever happened last. Used exclusively when allocating and deallocating <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> in the <em>next</em> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (potentially).</p>
<p >By the rules of <code>Allocator_aware_container</code> (see cppreference.com):</p><ul>
<li>If <code>*this</code> is move-cted: datum move-cted from source datum counterpart.</li>
<li>If <code>*this</code> is move-assigned: datum move-assigned from source datum counterpart if <code>std::allocator_traits&lt;Allocator_raw&gt;::propagate_on_container_move_assignment::value == true</code> (else untouched).</li>
<li>If <code>*this</code> is copy-cted: datum set to <code>std::allocator_traits&lt;Allocator_raw&gt;::select_on_container_copy_construction()</code> (pass-in source datum counterpart).</li>
<li>If <code>*this</code> is copy-assigned: datum copy-assigned if <code>std::allocator_traits&lt;Allocator_raw&gt;::propagate_on_container_copy_assignment::value == true</code> (else untouched).</li>
<li>If <code>*this</code> is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a></code>ed: datum ADL-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a></code>ed with source datum counterpart if <code>std::allocator_traits&lt;Allocator_raw&gt;::propagate_on_container_swap::value == true</code> (else untouched).</li>
<li>Otherwise this is supplied via a non-copy/move ctor arg by user.</li>
</ul>
<h3>Specially treated value</h3>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is <code>std::allocator&lt;value_type&gt;</code> (as supposed to <code>something_else&lt;value_type&gt;</code>), then this datum (while guaranteed set to the zero-sized copy of <code>std::allocator&lt;value_type&gt;()</code>) is never in practice touched (outside of the above-mentioned moves/copies/swaps, though they also do nothing in reality for this stateless allocator). This value by definition means we are to allocate on the regular heap; and as of this writing for perf/other reasons we choose to use a vanilla <code>*_ptr</code> with its default alloc-dealloc APIs (which perform <code>new[]</code>-<code>delete[]</code> respectively); we do not pass-in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a> anywhere. See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7" title="The smart-pointer type used for buf_ptr(); a custom-allocator-and-SHM-friendly impl and parameterizat...">Buf_ptr</a> doc header for more. If we did pass it in to <code>allocate_shared*()</code> or <code>boost::interprocess::shared_ptr::reset</code> the end result would be functionally the same (<code>std::allocator::[de]allocate()</code> would get called; these call <code>new[]</code>/<code>delete[]</code>).</p>
<h3>Relationship between this datum and the allocator/deleter in <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a></code></h3>
<p >(This is only applicable if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> is <code>false</code>.) <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> caches this datum internally in its centrally linked data. Ordinarily, then, they compare as equal. In the corner case where (1) move-assign or copy-assign or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a> was used on <code>*this</code>, <em>and</em> (2) <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateful and <em>can</em> compare unequal (e.g., <code>boost::interprocess::allocator</code>): they may come to compare as unequal. It is, however, not (in our case) particularly important: this datum affects the <em>next</em> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (potentially); the thing stored in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> affects the logic when the underlying buffer is next deallocated. The two don't depend on each other.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02803">2803</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l01728">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::assign()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_af6bdf2ee9e562400a0476282c8c66ff0_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9b66553c783ea601b074454860e2ec16" name="a9b66553c783ea601b074454860e2ec16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66553c783ea601b074454860e2ec16">&#9670;&nbsp;</a></span>alloc_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">::Allocator_raw</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::alloc_raw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ref-to-immutable counterpart to the other overload. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02810">2810</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a7deb969f7f8798b8a08a914e132c0f9f" name="a7deb969f7f8798b8a08a914e132c0f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7deb969f7f8798b8a08a914e132c0f9f">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p >Allocator subtleties aside and assuming <code>this != &amp;moved_src</code> it is equivalent to: <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; this-&gt;swap(moved_src, logger_ptr)</code>. (If <code>this == &amp;moved_src</code>, this is a no-op.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01797">1797</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a9a7e43fd524a64b2e5a01c44c13772bb" name="a9a7e43fd524a64b2e5a01c44c13772bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7e43fd524a64b2e5a01c44c13772bb">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment: assuming <code>(this != &amp;src) &amp;&amp; (!blobs_sharing(*this, src))</code>, makes <code>*this</code> logically equal to <code>src</code>; but behavior undefined if a reallocation would be necessary to do this. </p>
<p >(If <code>this == &amp;src</code>, this is a no-op. If not but <code>blobs_sharing(*this, src) == true</code>, see "Sharing blobs" below. This is assumed to not be the case in further discussion.)</p>
<p >More formally: no-op if <code>this == &amp;src</code>; "Sharing blobs" behavior if not so, but <code>src</code> shares buffer with <code>*this</code>; otherwise: Guarantees post-condition wherein <code>[this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> range is equal by value (including length) to <code>src</code> equivalent range but no memory overlap. Post-condition: <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> either does not change or equals <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth is not allowed: behavior is undefined if <code>src.size()</code> exceeds pre-call <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>, unless <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> pre-call. Performance: at most a memory area of size <code>src.size()</code> is copied and some scalars updated; a memory area of that size is allocated only if required; no ownership drop or deallocation occurs.</p>
<p >Corner case note: the range equality guarantee includes the degenerate case where that range is empty, meaning we simply guarantee post-condition <code>src.empty() == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a></code>.</p>
<p >Corner case note 2: post-condition: if <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code> then <code>this.zero()</code> has the same value as at entry to this call. In other words, no deallocation occurs, even if <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code> post-condition holds; at most internally a scalar storing size is assigned 0. (You may force deallocation in that case via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> post-call, but this means you'll have to intentionally perform that relatively slow op.)</p>
<p >As with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, IF pre-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code>, THEN pre-condition <code>src.size() &lt;= this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> must hold, or behavior is undefined (i.e., as noted above, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth is not allowed except from 0). Therefore, NO REallocation occurs! However, also as with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, if you want to intentionally allow such a REallocation, then simply first call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; then execute the <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a></code> copy as planned. This is an intentional restriction forcing caller to explicitly allow a relatively slow reallocation op.</p>
<p >Formally: If <code>src.size() &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<h3>Sharing blobs</h3>
<p >If <code>blobs_sharing(*this, src) == true</code>, meaning the target and source are operating on the same buffer, then behavior is undefined (assertion may trip). Rationale for this design is as follows. The possibilities were:</p><ol type="1">
<li>Undefined behavior/assertion.</li>
<li>Just adjust <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> and <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code> to match <code>src</code>; continue co-owning the underlying buffer; copy no data.</li>
<li><code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a></code> &ndash; losing <code>*this</code> ownership, while <code>src</code> keeps it &ndash; and then allocate a new buffer and copy <code>src</code> data into it.</li>
</ol>
<p >Choosing between these is tough, as this is an odd corner case. 3 is not criminal, but generally no method ever forces <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> behavior, always leaving it to the user to consciously do, so it seems prudent to keep to that practice (even though this case is a bit different from, say, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> &ndash; since <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> here has no chance to deallocate anything, only decrement ref-count). 2 is performant and slick but suggests a special behavior in a corner case; this <em>feels</em> slightly ill-advised in a standard copy assignment operator. Therefore it seems better to crash-and-burn (choice 1), in the same way an attempt to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>-higher a non-zero() blob would crash and burn, forcing the user to explicitly execute what they want. After all, 3 is done by simply calling <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> first; and 2 is possible with a simple <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> call; and the <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a25c63cd23dd19d7899c773f257d0f397" title="Returns true if and only if both given objects are not zero() == true, and they either co-own a commo...">blobs_sharing()</a> check is both easy and performant.</p>
<dl class="section warning"><dt>Warning</dt><dd>A post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>; meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> at entry is ignored and reset to 0; the entire (co-)owned buffer &ndash; if any &ndash; is potentially used to store the copied values. In particular, if one plans to work on a sub-blob of a shared pool (see class doc header), then using this assignment op is not advised. Use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a37f377987183d36b0ff5ebb9605d8aae" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> instead; or perform your own copy onto <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af72a747faa93798e39e26e4ff9c5dd60" title="Same as const_buffer() but the returned view is mutable.">mutable_buffer()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Object whose range of bytes of length <code>src.size()</code> starting at <code>src.begin()</code> is copied into <code>*this</code>. Behavior is undefined if pre-condition is <code>!zero()</code>, and this memory area overlaps at any point with the memory area of same size in <code>*this</code> (unless that size is zero &ndash; a degenerate case). (This can occur only via the use of <code>share*()</code> &ndash; otherwise <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s always refer to separate areas.) Also behavior undefined if pre-condition is <code>!zero()</code>, and <code>*this</code> (co-)owned buffer is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01728">1728</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l02803">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::alloc_raw()</a>, <a class="el" href="basic__blob_8hpp_source.html#l02070">flow::util::blobs_sharing()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l02771">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::const_buffer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a9a7e43fd524a64b2e5a01c44c13772bb_cgraph.svg" width="347" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a770438e824467e6dac1c7c0b060acfb8" name="a770438e824467e6dac1c7c0b060acfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770438e824467e6dac1c7c0b060acfb8">&#9670;&nbsp;</a></span>assign_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::assign_copy </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces logical contents with a copy of the given non-overlapping area anywhere in memory. </p>
<p >More formally: This is exactly equivalent to copy-assignment (<code>*this = b</code>), where <code>const <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> b</code> owns exactly the memory area given by <code>src</code>. However, note the newly relevant restriction documented for <code>src</code> parameter below (no overlap allowed).</p>
<p >All characteristics are as written for the copy assignment operator, including "Formally" and the warning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source memory area. Behavior is undefined if pre-condition is <code>!zero()</code>, and this memory area overlaps at any point with the memory area of same size at <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>. Otherwise it can be anywhere at all. Also behavior undefined if pre-condition is <code>!zero()</code>, and <code>*this</code> (co-)owned buffer is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements copied, namely <code>src.size()</code>, or simply <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02459">2459</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l01698">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Basic_blob()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a770438e824467e6dac1c7c0b060acfb8_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5fcb1315b5262bfe443e2a2d8dae751d" name="a5fcb1315b5262bfe443e2a2d8dae751d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcb1315b5262bfe443e2a2d8dae751d">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable last element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02642">2642</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a3c1d5b212dce4f859f4d31de9380bc89" name="a3c1d5b212dce4f859f4d31de9380bc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d5b212dce4f859f4d31de9380bc89">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad261cbb3a78fb7b2ec9228209d1f6418" title="Returns reference to immutable last element.">const_back()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02657">2657</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="aa43cdaa3d2f1756eab77c403d56fa314" name="aa43cdaa3d2f1756eab77c403d56fa314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43cdaa3d2f1756eab77c403d56fa314">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to mutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02671">2671</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l02070">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::blobs_sharing()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_aa43cdaa3d2f1756eab77c403d56fa314_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a791b2a514db458f7a3132cde858fdb73" name="a791b2a514db458f7a3132cde858fdb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b2a514db458f7a3132cde858fdb73">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02709">2709</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="adca2859a32cd701671bb82e7fb9bbc5e" name="adca2859a32cd701671bb82e7fb9bbc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca2859a32cd701671bb82e7fb9bbc5e">&#9670;&nbsp;</a></span>buf_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">::Buf_ptr</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::buf_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For convenience/expressiveness, the pointer-to-main-buf for <code>*this</code>. </p>
<p >The actual datum is inside a <code>compressed_pair</code> for reasons explained elsewhere, and it is annoying/ugly having to specify that detail all over the code. So one can just use this reference-returning accessor.</p>
<h3>Documentation for the datum referred-to by the return value</h3>
<p >Pointer to currently allocated buffer of size <a class="el" href="classflow_1_1util_1_1Basic__blob.html#abd9e7333542e30de2cb2fa4fe35f723b" title="See capacity(); but m_capacity is meaningless (and containing unknown value) if !buf_ptr() (i....">m_capacity</a>; null if and only if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>. Buffer is auto-freed at destruction; or in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; but only if by that point any <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>-generated other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s have done the same. Otherwise the ref-count is merely decremented. In the case of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> being <code>false</code>, one can think of this ref-count as being always at most 1; since <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> is not compiled, and as a corollary a <code>unique_ptr</code> is used to avoid perf costs. Thus <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> and dtor always dealloc in that case.</p>
<p >For performance, we never initialize the values in the array to zeroes or otherwise. This contrasts with <code>vector</code> and most other standard or Boost containers which use an <code>allocator</code> to allocate any internal buffer, and most allocators default-construct (which means assign 0 in case of <code>uint8_t</code>) any elements within allocated buffers, immediately upon the actual allocation on heap. As noted in doc header, this behavior is surprisingly difficult to avoid (involving custom allocators and such).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02790">2790</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a4cbddaed4c6c9970c19b54ecfa71da93" name="a4cbddaed4c6c9970c19b54ecfa71da93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbddaed4c6c9970c19b54ecfa71da93">&#9670;&nbsp;</a></span>buf_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">::Buf_ptr</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::buf_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ref-to-immutable counterpart to the other overload. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02797">2797</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a3cc03a7a025f362a819b984fbf1e33b8" name="a3cc03a7a025f362a819b984fbf1e33b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc03a7a025f362a819b984fbf1e33b8">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buffer is internally allocated. </p>
<p >Some formal invariants: <code>(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0) == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a></code>; <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> &lt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>.</p>
<p >See important notes on <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> policy in the class doc header.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02104">2104</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="aa2f7c1a50ca44fee90fde751bf9b8740" name="aa2f7c1a50ca44fee90fde751bf9b8740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f7c1a50ca44fee90fde751bf9b8740">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<p >Exists as standard container method (hence the odd formatting).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02716">2716</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a85053a0809c0d649bfc515ad4f1bfcb6" name="a85053a0809c0d649bfc515ad4f1bfcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85053a0809c0d649bfc515ad4f1bfcb6">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </p>
<p >Exists as standard container method (hence the odd formatting).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02730">2730</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a7b9629fb98e682890db3e0ba6e4508b4" name="a7b9629fb98e682890db3e0ba6e4508b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9629fb98e682890db3e0ba6e4508b4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>resize(0, start())</code>. </p>
<p >Note that the value returned by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> will <em>not</em> change due to this call. Only <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> (and the corresponding internally stored datum) may change. If one desires to reset <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> directly (but if one plans to work on a sub-Basic_blob of a shared pool &ndash; see class doc header &ndash; please think twice first). </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02423">2423</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ad261cbb3a78fb7b2ec9228209d1f6418" name="ad261cbb3a78fb7b2ec9228209d1f6418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261cbb3a78fb7b2ec9228209d1f6418">&#9670;&nbsp;</a></span>const_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable last element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02626">2626</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a28e3bc8a5b83ec050657d7bf223afee0" name="a28e3bc8a5b83ec050657d7bf223afee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3bc8a5b83ec050657d7bf223afee0">&#9670;&nbsp;</a></span>const_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to immutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02664">2664</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a7c7e0aef110c4ab5f335d633e9a96abb" name="a7c7e0aef110c4ab5f335d633e9a96abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7e0aef110c4ab5f335d633e9a96abb">&#9670;&nbsp;</a></span>const_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::const_buffer <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience accessor returning an immutable boost.asio buffer "view" into the entirety of the blob. </p>
<p >Equivalent to <code>const_buffer(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0536ea4661e19b0779dee1defd69e236" title="Equivalent to const_begin().">const_data()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02771">2771</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l01728">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::assign()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l01698">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Basic_blob()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a7c7e0aef110c4ab5f335d633e9a96abb_icgraph.svg" width="328" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0536ea4661e19b0779dee1defd69e236" name="a0536ea4661e19b0779dee1defd69e236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0536ea4661e19b0779dee1defd69e236">&#9670;&nbsp;</a></span>const_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> const  * <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a28e3bc8a5b83ec050657d7bf223afee0" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02737">2737</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a483eae7eea132ca8d1a9600ecf34deb0" name="a483eae7eea132ca8d1a9600ecf34deb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483eae7eea132ca8d1a9600ecf34deb0">&#9670;&nbsp;</a></span>const_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer one past immutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> is possible. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02695">2695</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="af4e39c285a93685a13fe735accfad85f" name="af4e39c285a93685a13fe735accfad85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e39c285a93685a13fe735accfad85f">&#9670;&nbsp;</a></span>const_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::const_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable first element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02618">2618</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a7f388fcb1ebced9e4ca7f971a0b2961f" name="a7f388fcb1ebced9e4ca7f971a0b2961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f388fcb1ebced9e4ca7f971a0b2961f">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> * <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02744">2744</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ad440ccd596c9f5db5aedccbe09996a71" name="ad440ccd596c9f5db5aedccbe09996a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad440ccd596c9f5db5aedccbe09996a71">&#9670;&nbsp;</a></span>derefable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::derefable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the given iterator points to an element within this blob's <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> elements. </p>
<p >In particular, this is always <code>false</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>; and also when <code>it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator/pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02757">2757</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00296">flow::util::in_closed_open_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_ad440ccd596c9f5db5aedccbe09996a71_cgraph.svg" width="322" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a37f377987183d36b0ff5ebb9605d8aae" name="a37f377987183d36b0ff5ebb9605d8aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f377987183d36b0ff5ebb9605d8aae">&#9670;&nbsp;</a></span>emplace_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::emplace_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>src</code> buffer directly onto equally sized area within <code>*this</code> at location <code>dest</code>; <code>*this</code> must have sufficient <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> to accomodate all of the data copied. </p>
<p >Performance: The only operation performed is a copy from <code>src</code> to <code>dest</code> using the fastest reasonably available technique.</p>
<p >None of the following changes: <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; nor the location (or size) of internally stored buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination location within this blob. This must be in <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>]</code>; and, unless <code>src.size() == 0</code>, must not equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> either. </td></tr>
    <tr><td class="paramname">src</td><td>Source memory area. Behavior is undefined if this memory area overlaps at any point with the memory area of same size at <code>dest</code> (unless that size is zero &ndash; a degenerate case). Otherwise it can be anywhere at all, even partially or fully within <code>*this</code>. Also behavior undefined if <code>*this</code> blob is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location in this blob just past the last element copied; <code>dest</code> if none copied; in particular <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is a possible value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02478">2478</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a37f377987183d36b0ff5ebb9605d8aae_cgraph.svg" width="316" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a325630d29505488391aa4d50dae962b8" name="a325630d29505488391aa4d50dae962b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325630d29505488391aa4d50dae962b8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is <code>true</code>; but if this is <code>true</code>, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02098">2098</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="af1b0eed31140d4e783a9ac1b5c8eb3d1" name="af1b0eed31140d4e783a9ac1b5c8eb3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b0eed31140d4e783a9ac1b5c8eb3d1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer one past mutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> is possible. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02702">2702</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a753dc7799aaae363568e4d37453d115a" name="a753dc7799aaae363568e4d37453d115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753dc7799aaae363568e4d37453d115a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02723">2723</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a4bd9502b9019f404805baf1f4d92b479" name="a4bd9502b9019f404805baf1f4d92b479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd9502b9019f404805baf1f4d92b479">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>past_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the minimal number of operations to make range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> unchanged except for lacking sub-range <code>[first, past_last)</code>. </p>
<p >Performance/behavior: At most, this copies the range <code>[past_last, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> to area starting at <code>first</code>; and then adjusts internally stored size member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Pointer to first element to erase. It must be dereferenceable, or behavior is undefined (assertion may trip). Corollary: invoking <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4bd9502b9019f404805baf1f4d92b479" title="Performs the minimal number of operations to make range [begin(), end()) unchanged except for lacking...">erase()</a></code> when <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code> is undefined behavior. </td></tr>
    <tr><td class="paramname">past_last</td><td>Pointer to one past the last element to erase. If <code>past_last &lt;= first</code>, call is a no-op. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator equal to <code>first</code>. (This matches standard expectation for container <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4bd9502b9019f404805baf1f4d92b479" title="Performs the minimal number of operations to make range [begin(), end()) unchanged except for lacking...">erase()</a></code> return value: iterator to element past the last one erased. In this contiguous sequence that simply equals <code>first</code>, since everything starting with <code>past_last</code> slides left onto <code>first</code>. In particular: If <code>past_last()</code> equaled <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> at entry, then the new <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is returned: everything starting with <code>first</code> was erased and thus <code>first == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> now. If nothing is erased <code>first</code> is still returned.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02582">2582</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a72fa3e57770d4f71fb831029a268c568" name="a72fa3e57770d4f71fb831029a268c568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fa3e57770d4f71fb831029a268c568">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable first element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02634">2634</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a894cb043b1a6ab840349b12a4cfcf7b2" name="a894cb043b1a6ab840349b12a4cfcf7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894cb043b1a6ab840349b12a4cfcf7b2">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af4e39c285a93685a13fe735accfad85f" title="Returns reference to immutable first element.">const_front()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02650">2650</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ad52f23edf1e536ba6c4b80271de7ff9e" name="ad52f23edf1e536ba6c4b80271de7ff9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52f23edf1e536ba6c4b80271de7ff9e">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">::Allocator_raw</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::get_allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the internally cached <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> as set by a constructor or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> or assignment-operator, whichever happened last. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02784">2784</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a3721b8885dce4d5c7ef9fb9b72b9db3a" name="a3721b8885dce4d5c7ef9fb9b72b9db3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3721b8885dce4d5c7ef9fb9b72b9db3a">&#9670;&nbsp;</a></span>iterator_sans_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2dff0960e669cc5406dbd23e77ea2a68">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::iterator_sans_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator-to-mutable equivalent to given iterator-to-immutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Self-explanatory. No assumptions are made about <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0ee3b2c46e9290e1af7b517d52966ded" title="Returns true if and only if: this-&gt;derefable_iterator(it) || (it == this-&gt;const_end()).">valid_iterator()</a> or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad440ccd596c9f5db5aedccbe09996a71" title="Returns true if and only if the given iterator points to an element within this blob&#39;s size() element...">derefable_iterator()</a> status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to same location as <code>it</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02765">2765</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a69df8d881b78c282f4d9d20898009b5e" name="a69df8d881b78c282f4d9d20898009b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69df8d881b78c282f4d9d20898009b5e">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> by dropping <code>*this</code> ownership of the allocated internal buffer if any; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also. </p>
<p >Recall that other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s can only gain co-ownership via <code>share*()</code>; hence if one does not use that feature, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> will in fact deallocate the buffer (if any).</p>
<p >That post-condition can also be thought of as <code>*this</code> becoming indistinguishable from a default-constructed <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.</p>
<p >Performance/behavior: Assuming <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is not already <code>true</code>, this will deallocate <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> sized buffer and save a null pointer.</p>
<p >The many operations that involve <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> in their doc headers will explain importance of this method: As a rule, no method except <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> allows one to request an ownership-drop or deallocation of the existing buffer, even if this would be necessary for a larger buffer to be allocated. Therefore, if you intentionally want to allow such an operation, you CAN, but then you MUST explicitly call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> first.</p>
<p >Formally: If <code>!zero()</code>, then the internal ownership ref-count is decremented by 1, and if it reaches 0, then a buffer is deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02431">2431</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a69df8d881b78c282f4d9d20898009b5e_cgraph.svg" width="316" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af72a747faa93798e39e26e4ff9c5dd60" name="af72a747faa93798e39e26e4ff9c5dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72a747faa93798e39e26e4ff9c5dd60">&#9670;&nbsp;</a></span>mutable_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::mutable_buffer <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::mutable_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c7e0aef110c4ab5f335d633e9a96abb" title="Convenience accessor returning an immutable boost.asio buffer &quot;view&quot; into the entirety of the blob.">const_buffer()</a> but the returned view is mutable. </p>
<p >Equivalent to <code>mutable_buffer(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7f388fcb1ebced9e4ca7f971a0b2961f" title="Equivalent to begin().">data()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02777">2777</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ab8208b62142b55c94993da20336e7a94" name="ab8208b62142b55c94993da20336e7a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8208b62142b55c94993da20336e7a94">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator (no logging): equivalent to <code>assign(std::move(moved_src), nullptr)</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It is important this be <code>noexcept</code>, if a copying counterpart to us exists in this class; otherwise (e.g.) <code>vector&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code> will, on realloc, default to copying <code>*this</code>es around instead of moving: a terrible (in its stealthiness) perf loss.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> (move overload). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01828">1828</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l02835">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Deleter_raw::Deleter_raw()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_ab8208b62142b55c94993da20336e7a94_icgraph.svg" width="360" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab8b321098978c1827bcb724a3a329677" name="ab8b321098978c1827bcb724a3a329677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b321098978c1827bcb724a3a329677">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator (no logging): equivalent to <code>assign(src, nullptr)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> (copy overload). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01790">1790</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a96e6727d577edca0bcda03fea4684e07" name="a96e6727d577edca0bcda03fea4684e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e6727d577edca0bcda03fea4684e07">&#9670;&nbsp;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a>&#160;</td>
          <td class="paramname"><em>coa_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to similar-sig overload except, if a <code>capacity</code>-sized buffer is allocated, then all <code>size</code> elements are performantly initialized to zero. </p>
<p >Using this overload, instead of using the non-init one followed by your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar), is likely to be significantly faster in at least some cases. It is <em>not</em> mere syntactic sugar.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size</a></code>-taking ctor also have <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> forms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coa_tag</td><td>API-choosing tag <a class="el" href="namespaceflow_1_1util.html#ad2ab789927de51b4f2fd1d448aff0ab3" title="Tag value indicating init-with-zeroes-on-alloc policy.">util::CLEAR_ON_ALLOC</a>. </td></tr>
    <tr><td class="paramname">capacity</td><td>See similar overload. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See similar overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02122">2122</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a7105de11c7a24dc9012cef8ad38f448d" name="a7105de11c7a24dc9012cef8ad38f448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7105de11c7a24dc9012cef8ad38f448d">&#9670;&nbsp;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that an internal buffer of at least <code>capacity</code> elements is allocated and owned; disallows growing an existing buffer; never shrinks an existing buffer; if a buffer is allocated, it is no larger than <code>capacity</code>. </p>
<dl class="section see"><dt>See also</dt><dd>a similar overload that takes <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> tag arg, if you <em>do</em> want the elements to be zero-initialized. Doing so is often faster than your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar).</dd></dl>
<p><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> may be called directly but should be formally understood to be called by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a770438e824467e6dac1c7c0b060acfb8" title="Replaces logical contents with a copy of the given non-overlapping area anywhere in memory.">assign_copy()</a>, copy assignment operator, copy constructor. In all cases, the value passed to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> is exactly the size needed to perform the particular task &ndash; no more (and no less). As such, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> policy is key to knowing how the class behaves elsewhere. See class doc header for discussion in larger context.</p>
<p >Performance/behavior: If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is true pre-call, <code>capacity</code> sized buffer is allocated. Otherwise, no-op if <code>capacity &lt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> pre-call. Behavior is undefined if <code>capacity &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> pre-call (again, unless <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0</code>). In other words, no deallocation occurs, and an allocation occurs only if necessary. Growing an existing buffer is disallowed. However, if you want to intentionally REallocate, then simply first check for <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code> and call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> if that holds; then execute the <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a></code> as planned. This is an intentional restriction forcing caller to explicitly allow a relatively slow reallocation op. You'll note a similar suggestion for the other <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>-using methods/operators.</p>
<p >Formally: If <code>capacity &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Non-negative desired minimum capacity. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02116">2116</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a5f45c6f17074d8261147f89925516d55" name="a5f45c6f17074d8261147f89925516d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f45c6f17074d8261147f89925516d55">&#9670;&nbsp;</a></span>reserve_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::reserve_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>clear_on_alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> overloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_alloc</td><td>Whether the <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> overload or the other one was called. </td></tr>
    <tr><td class="paramname">capacity</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02128">2128</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a5f45c6f17074d8261147f89925516d55_cgraph.svg" width="316" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afd8521772d170f4fd4aa03aa32f35264" name="afd8521772d170f4fd4aa03aa32f35264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8521772d170f4fd4aa03aa32f35264">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html">Clear_on_alloc</a>&#160;</td>
          <td class="paramname"><em>coa_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>start_or_unchanged</em> = <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">S_UNCHANGED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to similar-sig overload except, if a <code>capacity</code>-sized buffer is allocated, then all <code>size</code> elements are performantly initialized to zero. </p>
<p >Using this overload, instead of using the non-init one followed by your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar), is likely to be significantly faster in at least some cases. It is <em>not</em> mere syntactic sugar.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size</a></code>-taking ctor also have <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> forms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coa_tag</td><td>API-choosing tag <a class="el" href="namespaceflow_1_1util.html#ad2ab789927de51b4f2fd1d448aff0ab3" title="Tag value indicating init-with-zeroes-on-alloc policy.">util::CLEAR_ON_ALLOC</a>. </td></tr>
    <tr><td class="paramname">size</td><td>See similar overload. </td></tr>
    <tr><td class="paramname">start_or_unchanged</td><td>See similar overload. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See similar overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02368">2368</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a9733bbfa054e0621fe1573d8b0bc65e6" name="a9733bbfa054e0621fe1573d8b0bc65e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9733bbfa054e0621fe1573d8b0bc65e6">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>start_or_unchanged</em> = <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc">S_UNCHANGED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == size</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == start</code>; no values in pre-call range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> are changed; any values <em>added</em> to that range by the call are not initialized to zero or otherwise. </p>
<p >From other invariants and behaviors described, you'll realize this essentially means <code>reserve(size + start)</code> followed by saving <code>size</code> and <code>start</code> into internal size members. The various implications of this can be deduced by reading the related methods' doc headers. The key is to understand how <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> works, including what it disallows (growth in size of an existing buffer).</p>
<p >Formally: If <code>size &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="section see"><dt>See also</dt><dd>a similar overload that takes <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> tag arg, if you <em>do</em> want the elements to be zero-initialized. Doing so is often faster than your own explicit <code>memset(X.data(), 0, X.size())</code> (or similar).</dd></dl>
<h3>Leaving <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> unmodified</h3>
<p ><code>start</code> is taken to be the value of arg <code>start_or_unchanged</code>; unless the latter is set to special value <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>; in which case <code>start</code> is taken to equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>. Since the default is indeed <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>, the oft-encountered expression <code>resize(N)</code> will adjust only <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> and leave <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> unmodified &ndash; often the desired behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Non-negative desired value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>. </td></tr>
    <tr><td class="paramname">start_or_unchanged</td><td>Non-negative desired value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>; or special value <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8988597460efcd777ec1b9c433ed81fc" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>. See above. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02361">2361</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l01681">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Basic_blob()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a9733bbfa054e0621fe1573d8b0bc65e6_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a765bce38dfebc12f631278f072c5f9ec" name="a765bce38dfebc12f631278f072c5f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765bce38dfebc12f631278f072c5f9ec">&#9670;&nbsp;</a></span>resize_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::resize_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>clear_on_alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>start_or_unchanged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> overloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_alloc</td><td>Whether the <a class="el" href="structflow_1_1util_1_1Clear__on__alloc.html" title="Tag type used at least in Basic_blob and Blob_with_log_context to specify that an allocated buffer be...">Clear_on_alloc</a> overload or the other one was called. </td></tr>
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>. </td></tr>
    <tr><td class="paramname">start_or_unchanged</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02375">2375</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a5e4e4668320845ae522165b2095f5097" name="a5e4e4668320845ae522165b2095f5097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e4668320845ae522165b2095f5097">&#9670;&nbsp;</a></span>share()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to <code>!zero()</code> blobs, this returns an identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it. </p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>: it is nonsensical to co-own nothing; just use the default ctor then.</p>
<p >The returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> is identical in that not only does it share the same memory area (hence same <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>) but has identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> (and hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>). If you'd like to work on a different part of the allocated buffer, please consider <code>share_after_split*()</code> instead; the pool-of-sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s paradigm suggested in the class doc header is probably best accomplished using those methods and not <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>.</p>
<p >You can also adjust various sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4e1fd4dcf77dc5034a8f5d361ab952d" title="Like start_past_prefix() but shifts the current prefix position by the given incremental value (posit...">start_past_prefix_inc()</a>, etc., directly &ndash; after <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> returns.</p>
<p >Formally: Before this returns, the internal ownership ref-count (shared among <code>*this</code> and the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>) is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> to <code>*this</code> that shares the underlying allocated buffer. See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01917">1917</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a5e4e4668320845ae522165b2095f5097_cgraph.svg" width="316" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad602b1fc24bf9e93a59e4d4fc4de12d" name="aad602b1fc24bf9e93a59e4d4fc4de12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad602b1fc24bf9e93a59e4d4fc4de12d">&#9670;&nbsp;</a></span>share_after_split_equally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<div class="memtemplate">
template&lt;typename Emit_blob_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_equally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Emit_blob_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>emit_blob_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to successively performing <code>share_after_split_left(size)</code> until <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code>; the resultings <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s are emitted via <code>emit_blob_func()</code> callback in the order they're split off from the left. </p>
<p >In other words this partitions a non-zero() <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code> &ndash; perhaps typically used as a pool &ndash; into equally-sized (except possibly the last one) adjacent sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >A post-condition is that <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code> (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>). In addition, if <code>headless_pool == true</code>, then <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> is also a post-condition; i.e., the pool is "headless": it disappears once all the resulting sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s drop their ownership (as well as any other co-owning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s). Otherwise, <code>*this</code> will continue to share the pool despite <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> becoming 0. (Of course, even then, one is free to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destroy <code>*this</code> &ndash; the former, before returning, is all that <code>headless_pool == true</code> really adds.)</p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> == true</code> (including if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, but even if not) or if <code>size == 0</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a86ed7e8cdbb3ea75b924e18b0ab329f7" title="share_after_split_equally() wrapper that places Basic_blobs into the given container via push_back().">share_after_split_equally_emit_seq()</a> for a convenience wrapper to emit to, say, <code>vector&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>. </dd>
<dd>
<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac98079a5b3ee23af3d6938cf4ad65c75" title="share_after_split_equally() wrapper that places Ptr&lt;Basic_blob&gt;s into the given container via push_ba...">share_after_split_equally_emit_ptr_seq()</a> for a convenience wrapper to emit to, say, <code>vector&lt;unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;&gt;</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Emit_blob_func</td><td>A callback compatible with signature <code>void F(Basic_blob&amp;&amp; blob_moved)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> of each successive out-Basic_blob, except the last one. Behavior undefined (assertion may trip) if not positive. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>Whether to perform <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a></code> just before returning. See above. </td></tr>
    <tr><td class="paramname">emit_blob_func</td><td><code>F</code> such that <code>F(std::move(blob))</code> shall be called with each successive sub-Basic_blob. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02024">2024</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ac98079a5b3ee23af3d6938cf4ad65c75" name="ac98079a5b3ee23af3d6938cf4ad65c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98079a5b3ee23af3d6938cf4ad65c75">&#9670;&nbsp;</a></span>share_after_split_equally_emit_ptr_seq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<div class="memtemplate">
template&lt;typename Blob_ptr_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_equally_emit_ptr_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blob_ptr_container *&#160;</td>
          <td class="paramname"><em>out_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code>Ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>s into the given container via <code>push_back()</code>, where the type <code>Ptr&lt;&gt;</code> is determined via <code>Blob_ptr_container::value_type</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Blob_ptr_container</td><td>Something with method compatible with <code>push_back(Ptr&amp;&amp; blob_ptr_moved)</code>, where <code>Ptr</code> is <code>Blob_ptr_container::value_type</code>, and <code>Ptr{new <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>}</code> can be created. <code>Ptr</code> is to be a smart pointer type such as <code>unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code> or <code>shared_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">out_blobs</td><td><code>out_blobs-&gt;push_back()</code> shall be executed 1+ times. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02051">2051</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a86ed7e8cdbb3ea75b924e18b0ab329f7" name="a86ed7e8cdbb3ea75b924e18b0ab329f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ed7e8cdbb3ea75b924e18b0ab329f7">&#9670;&nbsp;</a></span>share_after_split_equally_emit_seq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<div class="memtemplate">
template&lt;typename Blob_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_equally_emit_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blob_container *&#160;</td>
          <td class="paramname"><em>out_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s into the given container via <code>push_back()</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Blob_container</td><td>Something with method compatible with <code>push_back(Basic_blob&amp;&amp; blob_moved)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">out_blobs</td><td><code>out_blobs-&gt;push_back()</code> shall be executed 1+ times. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02037">2037</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a53826c1f5638db3a138192b87adde7fa" name="a53826c1f5638db3a138192b87adde7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53826c1f5638db3a138192b87adde7fa">&#9670;&nbsp;</a></span>share_after_split_equally_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<div class="memtemplate">
template&lt;typename Emit_blob_func , typename Share_after_split_left_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_equally_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Emit_blob_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>emit_blob_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Share_after_split_left_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>share_after_split_left_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impl of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> but capable of emitting not just <code>*this</code> type (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;...&gt;</code>) but any sub-class (such as <code>Blob</code>/<code>Sharing_blob</code>) provided a functor like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning an object of that appropriate type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Emit_blob_func</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>; however it is to take the type to emit which can be <code>*this</code> <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> or a sub-class. </td></tr>
    <tr><td class="paramname">Share_after_split_left_func</td><td>A callback with signature identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning the same type emitted by <code>Emit_blob_func</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">emit_blob_func</td><td>See <code>Emit_blob_func</code>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aad602b1fc24bf9e93a59e4d4fc4de12d" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">share_after_split_left_func</td><td>See <code>Share_after_split_left_func</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01995">1995</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a53826c1f5638db3a138192b87adde7fa_cgraph.svg" width="375" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2c7da4387ef57fe4384fcf928de45dd2" name="a2c7da4387ef57fe4384fcf928de45dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7da4387ef57fe4384fcf928de45dd2">&#9670;&nbsp;</a></span>share_after_split_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to <code>!zero()</code> blobs, this shifts <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> by <code>size</code> to the right without changing <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; and returns a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> containing the shifted-past values that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it. </p>
<p >More formally, this is identical to simply <code>auto b = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>; b.resize(size); start_past_prefix_inc(size);</code>.</p>
<p >This is useful when working in the pool-of-sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s paradigm. This and other <code>share_after_split*()</code> methods are usually better to use rather than <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> directly (for that paradigm).</p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>.</p>
<p >Corner case: If <code>size &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, then it is taken to equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>.</p>
<p >Degenerate case: If <code>size</code> (or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>, whichever is smaller) is 0, then this method is identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>. Probably you don't mean to call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> in that case, but it's your decision.</p>
<p >Degenerate case: If <code>size == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a></code> (and not 0), then <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a></code> becomes <code>true</code> &ndash; though <code>*this</code> continues to share the underlying buffer despite [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) becoming empty. Typically this would only be done as, perhaps, the last iteration of some progressively-splitting loop; but it's your decision.</p>
<p >Formally: Before this returns, the internal ownership ref-count (shared among <code>*this</code> and the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>) is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> of the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>; and the number of elements by which <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> is shifted right (hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> is incremented). Any value exceeding <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> is taken to equal it. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split-off-on-the-left <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares the underlying allocated buffer with <code>*this</code>. See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01946">1946</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a2c7da4387ef57fe4384fcf928de45dd2_cgraph.svg" width="324" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a35a0b1bc225e328e95a590c92fe75c24" name="a35a0b1bc225e328e95a590c92fe75c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a0b1bc225e328e95a590c92fe75c24">&#9670;&nbsp;</a></span>share_after_split_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::share_after_split_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>, except <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> shifts by <code>size</code> to the left (instead of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> to the right), and the split-off <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> contains the *right-most*</code>size` elements (instead of the left-most). </p>
<p >More formally, this is identical to simply <code>auto lt_size = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> - size; auto b = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>; resize(lt_size); b.start_past_prefix_inc(lt_size);</code>. Cf. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> formal definition and note the symmetry.</p>
<p >All other characteristics are as written for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2c7da4387ef57fe4384fcf928de45dd2" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> of the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>; and the number of elements by which <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> is shifted left (hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> is decremented). Any value exceeding <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> is taken to equal it. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split-off-on-the-right <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares the underlying allocated buffer with <code>*this</code>. See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01970">1970</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a35a0b1bc225e328e95a590c92fe75c24_cgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af7a474024d9fdef67dfc5c0f5f5bd69e" name="af7a474024d9fdef67dfc5c0f5f5bd69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a474024d9fdef67dfc5c0f5f5bd69e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored, namely <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is 0; but if this is 0, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02086">2086</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l01681">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Basic_blob()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_af7a474024d9fdef67dfc5c0f5f5bd69e_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad31de2c03648cd51b05c0d2a823ca0e3" name="ad31de2c03648cd51b05c0d2a823ca0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31de2c03648cd51b05c0d2a823ca0e3">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset between <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> and the start of the internally allocated buffer. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is 0; but if this is 0, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02092">2092</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l02070">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::blobs_sharing()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_ad31de2c03648cd51b05c0d2a823ca0e3_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a318f0be2b65b9b6c95baeedb71d220a2" name="a318f0be2b65b9b6c95baeedb71d220a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f0be2b65b9b6c95baeedb71d220a2">&#9670;&nbsp;</a></span>start_past_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::start_past_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>&#160;</td>
          <td class="paramname"><em>prefix_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restructures blob to consist of an internally allocated buffer and a <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, end)</code> range starting at offset <code>prefix_size</code> within that buffer. </p>
<p >More formally, it is a simple <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> wrapper that ensures the internally allocated buffer remains unchanged or, if none is currently large enough to store <code>prefix_size</code> elements, is allocated to be of size <code>prefix_size</code>; and that <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == prefix_size</code>.</p>
<p >All of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>'s behavior, particularly any restrictions about <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth, applies, so in particular remember you may need to first <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a69df8d881b78c282f4d9d20898009b5e" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> if the internal buffer would need to be REallocated to satisfy the above requirements.</p>
<p >In practice, with current <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7105de11c7a24dc9012cef8ad38f448d" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (and thus <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>) restrictions &ndash; which are intentional &ndash; this method is most useful if you already have a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> with internally allocated buffer of size <em>at least</em> <code>n == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> (and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code> for simplicity), and you'd like to treat this buffer as containing no-longer-relevant prefix of length S (which becomes new value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>) and have <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> be readjusted down accordingly, while <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a> == n</code> remains unchaged. If the buffer also contains irrelevant data <em>past</em> a certain offset N, you can first make it irrelevant via <code>resize(N)</code> (then call <code>start_past_prefix(S)</code> as just described):</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> b;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// b now has start() == 0, size() == M.</span></div>
<div class="line"><span class="comment">// We want all elements outside [S, N] to be irrelevant, where S &gt; 0, N &lt; M.</span></div>
<div class="line"><span class="comment">// (E.g., first S are a frame prefix, while all bytes past N are a frame postfix, and we want just the frame</span></div>
<div class="line"><span class="comment">// without any reallocating or copying.)</span></div>
<div class="line">b.<a class="code hl_function" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6">resize</a>(N);</div>
<div class="line">b.<a class="code hl_function" href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2">start_past_prefix</a>(S);</div>
<div class="line"><span class="comment">// Now, [b.begin(), b.end()) are the frame bytes, and no copying/allocation/deallocation has occurred.</span></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a></div><div class="ttdoc">A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...</div><div class="ttdef"><b>Definition:</b> <a href="basic__blob_8hpp_source.html#l00275">basic_blob.hpp:276</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html_a318f0be2b65b9b6c95baeedb71d220a2"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2">flow::util::Basic_blob::start_past_prefix</a></div><div class="ttdeci">void start_past_prefix(size_type prefix_size)</div><div class="ttdoc">Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...</div><div class="ttdef"><b>Definition:</b> <a href="basic__blob_8hpp_source.html#l02406">basic_blob.hpp:2406</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html_a9733bbfa054e0621fe1573d8b0bc65e6"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6">flow::util::Basic_blob::resize</a></div><div class="ttdeci">void resize(size_type size, size_type start_or_unchanged=S_UNCHANGED, log::Logger *logger_ptr=nullptr)</div><div class="ttdoc">Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...</div><div class="ttdef"><b>Definition:</b> <a href="basic__blob_8hpp_source.html#l02361">basic_blob.hpp:2361</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix_size</td><td>Desired prefix length. <code>prefix_size == 0</code> is allowed and is a degenerate case equivalent to: <code>resize(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>, 0)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02406">2406</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ae4e1fd4dcf77dc5034a8f5d361ab952d" name="ae4e1fd4dcf77dc5034a8f5d361ab952d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e1fd4dcf77dc5034a8f5d361ab952d">&#9670;&nbsp;</a></span>start_past_prefix_inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::start_past_prefix_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aaf74e3a7aea427d0525d178dd20c8249">difference_type</a>&#160;</td>
          <td class="paramname"><em>prefix_size_inc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a318f0be2b65b9b6c95baeedb71d220a2" title="Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...">start_past_prefix()</a> but shifts the <em>current</em> prefix position by the given <em>incremental</em> value (positive or negative). </p>
<p >Identical to <code>start_past_prefix(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + prefix_size_inc)</code>.</p>
<p >Behavior is undefined for negative <code>prefix_size_inc</code> whose magnitue exceeds <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> (assertion may trip).</p>
<p >Behavior is undefined in case of positive <code>prefix_size_inc</code> that results in overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix_size_inc</td><td>Positive, negative (or zero) increment, so that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> is changed to <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + prefix_size_inc</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02416">2416</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="afc24100c45d41d25ca658afe5e1421d7" name="afc24100c45d41d25ca658afe5e1421d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc24100c45d41d25ca658afe5e1421d7">&#9670;&nbsp;</a></span>sub_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::sub_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::mutable_buffer &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opposite of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a37f377987183d36b0ff5ebb9605d8aae" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> in every way, copying a sub-blob onto a target memory area. </p>
<p >Note that the size of that target buffer (<code>dest.size()</code>) determines how much of <code>*this</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source location within this blob. This must be in <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>]</code>; and, unless <code>dest.size() == 0</code>, must not equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> either. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination memory area. Behavior is undefined if this memory area overlaps at any point with the memory area of same size at <code>src</code> (unless that size is zero &ndash; a degenerate case). Otherwise it can be anywhere at all, even partially or fully within <code>*this</code>. Also behavior undefined if <code>src + dest.size()</code> is past end of <code>*this</code> blob (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location in this blob just past the last element copied; <code>src</code> if none copied; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is a possible value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02540">2540</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_afc24100c45d41d25ca658afe5e1421d7_cgraph.svg" width="316" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a460191bd2541002b6668ce6c08489099" name="a460191bd2541002b6668ce6c08489099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460191bd2541002b6668ce6c08489099">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>, or no-op if <code>this == &amp;other</code>. </p>
<p >Performance: at most this involves swapping a few scalars which is constant-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01886">1886</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l01910">flow::util::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l02850">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::Deleter_raw::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a460191bd2541002b6668ce6c08489099_cgraph.svg" width="300" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a460191bd2541002b6668ce6c08489099_icgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aed1ff257357de700de5006304b80301d" name="aed1ff257357de700de5006304b80301d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1ff257357de700de5006304b80301d">&#9670;&nbsp;</a></span>swap_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::swap_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The body of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>, except for the part that swaps (or decides not to swap) <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a>. </p>
<p >As of this writing used by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7deb969f7f8798b8a08a914e132c0f9f" title="Move assignment.">assign()</a> (move overload) which perform mutually different steps w/r/t <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a460191bd2541002b6668ce6c08489099" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01834">1834</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="basic__blob_8hpp_source.html#l01910">flow::util::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_aed1ff257357de700de5006304b80301d_cgraph.svg" width="300" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0ee3b2c46e9290e1af7b517d52966ded" name="a0ee3b2c46e9290e1af7b517d52966ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee3b2c46e9290e1af7b517d52966ded">&#9670;&nbsp;</a></span>valid_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::valid_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1044dc7168cc24ffd44eaee00c26f524">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if: <code>this-&gt;derefable_iterator(it) || (it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a483eae7eea132ca8d1a9600ecf34deb0" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator/pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02750">2750</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00280">flow::util::in_closed_range()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a0ee3b2c46e9290e1af7b517d52966ded_cgraph.svg" width="322" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2e1a42c486710c48086b0cff01e7bb9e" name="a2e1a42c486710c48086b0cff01e7bb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a42c486710c48086b0cff01e7bb9e">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::zero</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>false</code> if a buffer is allocated and owned; <code>true</code> otherwise. </p>
<p >See important notes on how this relates to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a325630d29505488391aa4d50dae962b8" title="Returns size() == 0.">empty()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> in those methods' doc headers. See also other important notes in class doc header.</p>
<p >Note that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code> for any default-constructed <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02110">2110</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="basic__blob_8hpp_source.html#l02070">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::blobs_sharing()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a2e1a42c486710c48086b0cff01e7bb9e_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a25c63cd23dd19d7899c773f257d0f397" name="a25c63cd23dd19d7899c773f257d0f397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c63cd23dd19d7899c773f257d0f397">&#9670;&nbsp;</a></span>blobs_sharing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> blobs_sharing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if both given objects are not <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, and they either co-own a common underlying buffer, or <em>are</em> the same object. </p>
<p >Note: by the nature of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">Basic_blob::share()</a>, a <code>true</code> returned value is orthogonal to whether <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">Basic_blob::start()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">Basic_blob::size()</a> values are respectively equal; <code>true</code> may be returned even if their [<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aa43cdaa3d2f1756eab77c403d56fa314" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>, <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af1b0eed31140d4e783a9ac1b5c8eb3d1" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code>) ranges don't overlap at all &ndash; as long as the allocated buffer is co-owned by the 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >If <code>&amp;blob1 != &amp;blob2</code>, <code>true</code> indicates <code>blob1</code> was obtained from <code>blob2</code> via a chain of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5e4e4668320845ae522165b2095f5097" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">Basic_blob::share()</a> (or wrapper thereof) calls, or vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob1</td><td>Object. </td></tr>
    <tr><td class="paramname">blob2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>blob1</code> and <code>blob2</code> both operate on the same underlying buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l02070">2070</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l02671">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::begin()</a>, <a class="el" href="basic__blob_8hpp_source.html#l02092">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::start()</a>, and <a class="el" href="basic__blob_8hpp_source.html#l02110">flow::util::Basic_blob&lt; Allocator, SHARING &gt;::zero()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Basic__blob_a25c63cd23dd19d7899c773f257d0f397_cgraph.svg" width="328" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9bf5004897129150111e57f3521341cb" name="a9bf5004897129150111e57f3521341cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf5004897129150111e57f3521341cb">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, SHARING &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>blob1.swap(blob2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob1</td><td>Object. </td></tr>
    <tr><td class="paramname">blob2</td><td>Object. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01910">1910</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a60e111d587a33ff23eacf3e264d8ffc8" name="a60e111d587a33ff23eacf3e264d8ffc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e111d587a33ff23eacf3e264d8ffc8">&#9670;&nbsp;</a></span>m_alloc_and_buf_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compressed_pair&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7">Buf_ptr</a>&gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::m_alloc_and_buf_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combined &ndash; to enable empty base-class optimization (EBO) &ndash; storage for the two data items, refs to which are returned by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> respectively. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> doc headers for actual documentation for these two important items (especially <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a>).</dd></dl>
<h3>Rationale</h3>
<p >Please look into EBO to grok this. That aside &ndash; just think of <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af6bdf2ee9e562400a0476282c8c66ff0" title="For convenience/expressiveness, the allocator object for *this.">alloc_raw()</a></code> as essentially an <code>m_alloc_raw</code> data member, <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a></code> as an <code>m_buf_ptr</code> data member. They are only stored in this pair thingie due to an obscure, but perf-affecting, C++ technicality. The aforementioned ref-returning accessors avoid having to write <code>m_alloc_and_buf_ptr.second</code> and <code>.first</code> all over the place. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01652">1652</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="abd9e7333542e30de2cb2fa4fe35f723b" name="abd9e7333542e30de2cb2fa4fe35f723b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9e7333542e30de2cb2fa4fe35f723b">&#9670;&nbsp;</a></span>m_capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::m_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3cc03a7a025f362a819b984fbf1e33b8" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#abd9e7333542e30de2cb2fa4fe35f723b" title="See capacity(); but m_capacity is meaningless (and containing unknown value) if !buf_ptr() (i....">m_capacity</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>). </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01655">1655</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a47f3eaa5050a55a5c6e66e5e80e2060b" name="a47f3eaa5050a55a5c6e66e5e80e2060b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f3eaa5050a55a5c6e66e5e80e2060b">&#9670;&nbsp;</a></span>m_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::m_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af7a474024d9fdef67dfc5c0f5f5bd69e" title="Returns number of elements stored, namely end() - begin().">size()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a47f3eaa5050a55a5c6e66e5e80e2060b" title="See size(); but m_size is meaningless (and containing unknown value) if !buf_ptr() (i....">m_size</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>). </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01661">1661</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a27366fedbc0305c31d5fdcea10fbc7f3" name="a27366fedbc0305c31d5fdcea10fbc7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27366fedbc0305c31d5fdcea10fbc7f3">&#9670;&nbsp;</a></span>m_start</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::m_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ad31de2c03648cd51b05c0d2a823ca0e3" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>; but <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a27366fedbc0305c31d5fdcea10fbc7f3" title="See start(); but m_start is meaningless (and containing unknown value) if !buf_ptr() (i....">m_start</a> is meaningless (and containing unknown value) if <code>!buf_ptr()</code> (i.e., <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2e1a42c486710c48086b0cff01e7bb9e" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>). </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01658">1658</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a81e2b69eef6b4af966e224275d297e9c" name="a81e2b69eef6b4af966e224275d297e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e2b69eef6b4af966e224275d297e9c">&#9670;&nbsp;</a></span>S_IS_VANILLA_ALLOC</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::S_IS_VANILLA_ALLOC = std::is_same_v&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7">Allocator_raw</a>, std::allocator&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c54edf49fbe9fddab9cc5d927a414d2">value_type</a>&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> underlying allocator template is simply <code>std::allocator</code>; <code>false</code> otherwise. </p>
<p >Note that if this is <code>true</code>, it may be worth using <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>, instead of its <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;std::allocator&gt;</code> super-class; at the cost of a marginally larger RAM footprint (an added <code>Logger*</code>) you'll get a more convenient set of logging API knobs (namely <code>Logger*</code> stored permanently from construction; and there will be no need to supply it as arg to subsequent APIs when logging is desired).</p>
<h3>Implications of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> being <code>false</code></h3>
<p >This is introduced in our class doc header. Briefly however:</p><ul>
<li>The underlying buffer, if any, and possibly some small aux data shall be allocated via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>, not simply the regular heap's <code>new[]</code> and/or <code>new</code>.<ul>
<li>They shall be deallocated, if needed, via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0cff4bef1f4a45b9b25bd6526bad09c7" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>, not simply the regular heap's <code>delete[]</code> and/or <code>delete</code>.</li>
</ul>
</li>
<li>Because storing a pointer to <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a> may be meaningless when storing in an area allocated by some custom allocators (particularly SHM-heap ones), we shall not auto-TRACE-log on dealloc.<ul>
<li>This caveat applies only if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> is <code>true</code>.</li>
</ul>
</li>
</ul>
<ul>
<li>(If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a>) Accordingly the ref-counted buffer pointer <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adca2859a32cd701671bb82e7fb9bbc5e" title="For convenience/expressiveness, the pointer-to-main-buf for *this.">buf_ptr()</a> shall be a <code>boost::interprocess::shared_ptr</code> instead of a vanilla <code>shared_ptr</code>; the latter may be faster and more full-featured, but it is likely to internally store a raw <code>T*</code>; we need one that stores an <code>Allocator_raw::pointer</code> instead; e.g., a fancy-pointer type (like <code>boost::interprocess::offset_ptr</code>) when dealing with SHM-heaps (typically).<ul>
<li>If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a81e2b69eef6b4af966e224275d297e9c" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> is <code>true</code>, then we revert to the faster/more-mature/full-featured <code>shared_ptr</code>. In particular it is faster (if used with <code>make_shared()</code> and similar) by storing the user buffer and aux data/ref-count in one contiguously-allocated buffer.</li>
</ul>
</li>
<li>(If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab573b02e01cc92a58935e5d1210ff54f" title="Value of template parameter SHARING (for generic programming).">S_SHARING</a> is <code>false</code>) It's a typical <code>unique_ptr</code> template either way (because it supports non-raw-pointer storage out of the box) but:<ul>
<li>A custom deleter is necessary similarly to the above.<ul>
<li>Its <code>pointer</code> member alias crucially causes the <code>unique_ptr</code> to store an <code>Allocator_raw::pointer</code> instead of a <code>value_type*</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a5b84fa4bce20b49c3ac0e7d87926cbf7" title="The smart-pointer type used for buf_ptr(); a custom-allocator-and-SHM-friendly impl and parameterizat...">Buf_ptr</a> doc header regarding the latter two bullet points. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00359">359</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a3fb3bc67bf8c4388d893208f7af0fdac" name="a3fb3bc67bf8c4388d893208f7af0fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb3bc67bf8c4388d893208f7af0fdac">&#9670;&nbsp;</a></span>S_LOG_COMPONENT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">Flow_log_component</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::S_LOG_COMPONENT = Flow_log_component::S_UTIL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Our <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">flow::log::Component</a>. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l01219">1219</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="ab573b02e01cc92a58935e5d1210ff54f" name="ab573b02e01cc92a58935e5d1210ff54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573b02e01cc92a58935e5d1210ff54f">&#9670;&nbsp;</a></span>S_SHARING</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::S_SHARING = SHARING</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of template parameter <code>SHARING</code> (for generic programming). </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00316">316</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<a id="a8988597460efcd777ec1b9c433ed81fc" name="a8988597460efcd777ec1b9c433ed81fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8988597460efcd777ec1b9c433ed81fc">&#9670;&nbsp;</a></span>S_UNCHANGED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , <a class="el" href="classbool.html">bool</a> SHARING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, SHARING &gt;::S_UNCHANGED = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a48015fe46d5378c44b32203efb1004da">size_type</a>(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special value indicating an unchanged <code>size_type</code> value; such as in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9733bbfa054e0621fe1573d8b0bc65e6" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>. </p>

<p class="definition">Definition at line <a class="el" href="basic__blob_8hpp_source.html#l00319">319</a> of file <a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="basic__blob_8hpp_source.html">basic_blob.hpp</a></li>
<li>util/<a class="el" href="blob__fwd_8hpp_source.html">blob_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 15 2026 00:49:02 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
