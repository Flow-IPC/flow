<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Scheduled_task_handle_state Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html">Scheduled_task_handle_state</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structflow_1_1util_1_1Scheduled__task__handle__state-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Scheduled_task_handle_state Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal-use data store used by <code>schedule[d]_task_*()</code>, each object containing the state relevant to a single call to either <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">schedule_task_from_now()</a> or <a class="el" href="namespaceflow_1_1util.html#aad8c8f7335eb892350dc386cb4be397e" title="Identical to schedule_task_from_now() except the time is specified in absolute terms.">schedule_task_at()</a>.  
 <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::util::Scheduled_task_handle_state:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1util_1_1Scheduled__task__handle__state__inherit__graph.svg" width="146" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::util::Scheduled_task_handle_state:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1util_1_1Scheduled__task__handle__state__coll__graph.svg" width="500" height="348"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af86e69ee260b73f608ba24eef871fb88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af86e69ee260b73f608ba24eef871fb88">Scheduled_task_handle_state</a> (<a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">Unique_id_holder::id_t</a> id, <a class="el" href="classbool.html">bool</a> single_threaded, <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">Task_engine</a> *task_engine, <a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">Scheduled_task</a> &amp;&amp;body_moved)</td></tr>
<tr class="memdesc:af86e69ee260b73f608ba24eef871fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs it to the initial state, wherein it has neither fired nor been canceled.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af86e69ee260b73f608ba24eef871fb88">More...</a><br /></td></tr>
<tr class="separator:af86e69ee260b73f608ba24eef871fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af99c7b9c66dc509b5d4fd9ae27ecc22b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">Unique_id_holder::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af99c7b9c66dc509b5d4fd9ae27ecc22b">m_id</a></td></tr>
<tr class="memdesc:af99c7b9c66dc509b5d4fd9ae27ecc22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ID for logging.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af99c7b9c66dc509b5d4fd9ae27ecc22b">More...</a><br /></td></tr>
<tr class="separator:af99c7b9c66dc509b5d4fd9ae27ecc22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23a4cae508bdfc5fd8316eb798e3acb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">Scheduled_task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb">m_body</a></td></tr>
<tr class="memdesc:ae23a4cae508bdfc5fd8316eb798e3acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to execute when (and if) the timer fires, or short-fires.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb">More...</a><br /></td></tr>
<tr class="separator:ae23a4cae508bdfc5fd8316eb798e3acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eb85a490f1386423fe4a6a32979a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">Task_engine</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af3eb85a490f1386423fe4a6a32979a93">m_task_engine</a></td></tr>
<tr class="memdesc:af3eb85a490f1386423fe4a6a32979a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the task-executing engine (<code>Task_engine</code>) onto which to post tasks, including (if applicable) <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a>.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af3eb85a490f1386423fe4a6a32979a93">More...</a><br /></td></tr>
<tr class="separator:af3eb85a490f1386423fe4a6a32979a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521f4d604b987b3bd81ad8a0d0e82836"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">Mutex_non_recursive</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a521f4d604b987b3bd81ad8a0d0e82836">m_mutex_unless_single_threaded</a></td></tr>
<tr class="memdesc:a521f4d604b987b3bd81ad8a0d0e82836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89" title="Flag indicating whether or not the following is true: A wrapper task around m_body is about to fire v...">m_fired</a>, <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f" title="Flag indicating whether or not the following is true: From this point on, m_body will absolutely not ...">m_canceled</a>, and <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a5934d785b54bb71e739c262b6db8dda9" title="The underlying timer object – paired with m_task_engine – used to actually wait in the background and...">m_timer</a> from the moment <code>m_timer.async_wait()</code> is called.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a521f4d604b987b3bd81ad8a0d0e82836">More...</a><br /></td></tr>
<tr class="separator:a521f4d604b987b3bd81ad8a0d0e82836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934d785b54bb71e739c262b6db8dda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a5934d785b54bb71e739c262b6db8dda9">m_timer</a></td></tr>
<tr class="memdesc:a5934d785b54bb71e739c262b6db8dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying timer object &ndash; paired with <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af3eb85a490f1386423fe4a6a32979a93" title="Pointer to the task-executing engine (Task_engine) onto which to post tasks, including (if applicable...">m_task_engine</a> &ndash; used to actually wait in the background and ultimately execute (if applicable) a wrapper around <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a>.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a5934d785b54bb71e739c262b6db8dda9">More...</a><br /></td></tr>
<tr class="separator:a5934d785b54bb71e739c262b6db8dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06a06b15726040cd71d1755267d4b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89">m_fired</a></td></tr>
<tr class="memdesc:ae06a06b15726040cd71d1755267d4b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether or not the following is true: A wrapper task around <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> is about to fire very soon or has already been fired.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89">More...</a><br /></td></tr>
<tr class="separator:ae06a06b15726040cd71d1755267d4b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb9de1eece77c015e23504a758b4a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f">m_canceled</a></td></tr>
<tr class="memdesc:a2bb9de1eece77c015e23504a758b4a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether or not the following is true: From this point on, <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> will absolutely not be executed.  <a href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f">More...</a><br /></td></tr>
<tr class="separator:a2bb9de1eece77c015e23504a758b4a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Internal-use data store used by <code>schedule[d]_task_*()</code>, each object containing the state relevant to a single call to either <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">schedule_task_from_now()</a> or <a class="el" href="namespaceflow_1_1util.html#aad8c8f7335eb892350dc386cb4be397e" title="Identical to schedule_task_from_now() except the time is specified in absolute terms.">schedule_task_at()</a>. </p>
<p >The user accesses these via the opaque type <a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e" title="Black-box type that represents a handle to a scheduled task as scheduled by schedule_task_at() or sch...">util::Scheduled_task_handle</a> which is just <code>shared_ptr&lt;&gt;</code> around this <code>struct</code>.</p>
<p >Internally, it's (1) storage for the underlying <a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6" title="boost.asio timer.">util::Timer</a> itself, the task body, etc.; (2) a simple state machine with 3 possible states: <code>!(m_canceled || m_fired)</code> (initial); <code>m_canceled &amp;&amp; (!m_fired)</code> (final state 1); <code>m_fired &amp;&amp; (!m_canceled)</code> (final state 2). Obviously the state machine can only move from the initial state to exactly one of the final states. Less obviously these members must be synchronized in any multi-threaded situation. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00042">42</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af86e69ee260b73f608ba24eef871fb88" name="af86e69ee260b73f608ba24eef871fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86e69ee260b73f608ba24eef871fb88">&#9670;&nbsp;</a></span>Scheduled_task_handle_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Scheduled_task_handle_state::Scheduled_task_handle_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">Unique_id_holder::id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">Task_engine</a> *&#160;</td>
          <td class="paramname"><em>task_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">Scheduled_task</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs it to the initial state, wherein it has neither fired nor been canceled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>See <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af99c7b9c66dc509b5d4fd9ae27ecc22b" title="Unique ID for logging.">m_id</a>. </td></tr>
    <tr><td class="paramname">single_threaded</td><td>See <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">schedule_task_from_now()</a>. </td></tr>
    <tr><td class="paramname">task_engine</td><td>See <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">schedule_task_from_now()</a>. </td></tr>
    <tr><td class="paramname">body_moved</td><td>See <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">schedule_task_from_now()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8cpp_source.html#l00027">27</a> of file <a class="el" href="sched__task__handle__state_8cpp_source.html">sched_task_handle_state.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae23a4cae508bdfc5fd8316eb798e3acb" name="ae23a4cae508bdfc5fd8316eb798e3acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23a4cae508bdfc5fd8316eb798e3acb">&#9670;&nbsp;</a></span>m_body</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">Scheduled_task</a> flow::util::Scheduled_task_handle_state::m_body</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to execute when (and if) the timer fires, or short-fires. </p>
<p >Note that successful cancellation will prevent this from being executed. Reminder that the function takes one argument, <code>bool short_fire</code>, explained elsewhere. This will execute either 0 times or 1 time. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00053">53</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="a2bb9de1eece77c015e23504a758b4a9f" name="a2bb9de1eece77c015e23504a758b4a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb9de1eece77c015e23504a758b4a9f">&#9670;&nbsp;</a></span>m_canceled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::util::Scheduled_task_handle_state::m_canceled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicating whether or not the following is true: From this point on, <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> will absolutely not be executed. </p>
<p >This starts <code>false</code> and, at most, can change once to <code>true</code>; in the latter case <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89" title="Flag indicating whether or not the following is true: A wrapper task around m_body is about to fire v...">m_fired</a> is then guaranteed to remain <code>false</code>.</p>
<p >It (and <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89" title="Flag indicating whether or not the following is true: A wrapper task around m_body is about to fire v...">m_fired</a>) is used as a barrier: once <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> is marked as canceled, it cannot be re-canceled or rescheduled; hence attempts to do so are ignored once either flag reaches <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00091">91</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="ae06a06b15726040cd71d1755267d4b89" name="ae06a06b15726040cd71d1755267d4b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06a06b15726040cd71d1755267d4b89">&#9670;&nbsp;</a></span>m_fired</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::util::Scheduled_task_handle_state::m_fired</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicating whether or not the following is true: A wrapper task around <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> is about to fire very soon or has already been fired. </p>
<p >This starts <code>false</code> and, at most, can change once to <code>true</code>; in the latter case <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f" title="Flag indicating whether or not the following is true: From this point on, m_body will absolutely not ...">m_canceled</a> is then guaranteed to remain <code>false</code>.</p>
<p >It (and <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f" title="Flag indicating whether or not the following is true: From this point on, m_body will absolutely not ...">m_canceled</a>) is used as a barrier: once <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a> is on track to be immediately executed, it cannot be canceled or rescheduled; hence attempts to do so are ignored once either flag reaches <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00081">81</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="af99c7b9c66dc509b5d4fd9ae27ecc22b" name="af99c7b9c66dc509b5d4fd9ae27ecc22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99c7b9c66dc509b5d4fd9ae27ecc22b">&#9670;&nbsp;</a></span>m_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">Unique_id_holder::id_t</a> flow::util::Scheduled_task_handle_state::m_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique ID for logging. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00046">46</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="a521f4d604b987b3bd81ad8a0d0e82836" name="a521f4d604b987b3bd81ad8a0d0e82836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521f4d604b987b3bd81ad8a0d0e82836">&#9670;&nbsp;</a></span>m_mutex_unless_single_threaded</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">Mutex_non_recursive</a>&gt; flow::util::Scheduled_task_handle_state::m_mutex_unless_single_threaded</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex protecting <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae06a06b15726040cd71d1755267d4b89" title="Flag indicating whether or not the following is true: A wrapper task around m_body is about to fire v...">m_fired</a>, <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a2bb9de1eece77c015e23504a758b4a9f" title="Flag indicating whether or not the following is true: From this point on, m_body will absolutely not ...">m_canceled</a>, and <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#a5934d785b54bb71e739c262b6db8dda9" title="The underlying timer object – paired with m_task_engine – used to actually wait in the background and...">m_timer</a> from the moment <code>m_timer.async_wait()</code> is called. </p>
<p >Those members are safe to touch before that, as no other threads have knowledge of <code>this</code> until then. However, in <code>single_threaded</code> mode this pointer is left null, and no mutex is necessary or used (perf measure). </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00065">65</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="af3eb85a490f1386423fe4a6a32979a93" name="af3eb85a490f1386423fe4a6a32979a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3eb85a490f1386423fe4a6a32979a93">&#9670;&nbsp;</a></span>m_task_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">Task_engine</a>* const flow::util::Scheduled_task_handle_state::m_task_engine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the task-executing engine (<code>Task_engine</code>) onto which to post tasks, including (if applicable) <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a>. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00058">58</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<a id="a5934d785b54bb71e739c262b6db8dda9" name="a5934d785b54bb71e739c262b6db8dda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5934d785b54bb71e739c262b6db8dda9">&#9670;&nbsp;</a></span>m_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">Timer</a> flow::util::Scheduled_task_handle_state::m_timer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying timer object &ndash; paired with <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#af3eb85a490f1386423fe4a6a32979a93" title="Pointer to the task-executing engine (Task_engine) onto which to post tasks, including (if applicable...">m_task_engine</a> &ndash; used to actually wait in the background and ultimately execute (if applicable) a wrapper around <a class="el" href="structflow_1_1util_1_1Scheduled__task__handle__state.html#ae23a4cae508bdfc5fd8316eb798e3acb" title="The function to execute when (and if) the timer fires, or short-fires.">m_body</a>. </p>

<p class="definition">Definition at line <a class="el" href="sched__task__handle__state_8hpp_source.html#l00071">71</a> of file <a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>util/detail/<a class="el" href="sched__task__handle__state_8hpp_source.html">sched_task_handle_state.hpp</a></li>
<li>util/detail/<a class="el" href="sched__task__handle__state_8cpp_source.html">sched_task_handle_state.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 10 2024 01:42:58 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
