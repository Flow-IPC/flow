<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Low_lvl_packet Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html">Low_lvl_packet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="structflow_1_1net__flow_1_1Low__lvl__packet-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Low_lvl_packet Struct Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level packet structure and serves as the super-type for all specific packet types, represented by derived <code>struct</code>s like <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc.  
 <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Low_lvl_packet:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet__inherit__graph.svg" width="570" height="347"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Low_lvl_packet:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet__coll__graph.svg" width="1558" height="702"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Aux__raw__data.html">Aux_raw_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper data store type for storing binary data needed by <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>, when certains bits are not already represented by the public data members present in <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Aux__raw__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html">Packet_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, unmodifiable data store that contains the properties unique to each packet type a/k/a concrete sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab735867345855ad43e5e3ff788cf5a9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">Const_buffer</a> = boost::asio::const_buffer</td></tr>
<tr class="memdesc:ab735867345855ad43e5e3ff788cf5a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for boost.asio immutable buffer, which essentially is a pointer to and length of a memory area.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">More...</a><br /></td></tr>
<tr class="separator:ab735867345855ad43e5e3ff788cf5a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e16e9c355c6d5e2acff5f9bdc24f397"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> = std::vector&lt; <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">Const_buffer</a> &gt;</td></tr>
<tr class="memdesc:a6e16e9c355c6d5e2acff5f9bdc24f397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for sequence of immutable buffers; i.e., a sequence of 1 or more scattered areas in memory.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">More...</a><br /></td></tr>
<tr class="separator:a6e16e9c355c6d5e2acff5f9bdc24f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872044469cfa05a3abf3f9ab1c7cf03b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a872044469cfa05a3abf3f9ab1c7cf03b">security_token_t</a> = uint64_t</td></tr>
<tr class="memdesc:a872044469cfa05a3abf3f9ab1c7cf03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for <code>m_security_token</code> member of a couple different packet types.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a872044469cfa05a3abf3f9ab1c7cf03b">More...</a><br /></td></tr>
<tr class="separator:a872044469cfa05a3abf3f9ab1c7cf03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e7750d22415a381e23112062f7ca74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a11e7750d22415a381e23112062f7ca74">rexmit_id_t</a> = <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td></tr>
<tr class="memdesc:a11e7750d22415a381e23112062f7ca74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to store the retransmission count in DATA and ACK packets.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a11e7750d22415a381e23112062f7ca74">More...</a><br /></td></tr>
<tr class="separator:a11e7750d22415a381e23112062f7ca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ff17bec742d9e363aea2ecd23f2f72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">rcv_wnd_t</a> = uint32_t</td></tr>
<tr class="memdesc:a01ff17bec742d9e363aea2ecd23f2f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to store the size of <code>m_rcv_wnd</code> member in a couple of different packet types.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">More...</a><br /></td></tr>
<tr class="separator:a01ff17bec742d9e363aea2ecd23f2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;</a></td></tr>
<tr class="memitem:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> = boost::shared_ptr&lt; Low_lvl_packet &gt;</td></tr>
<tr class="memdesc:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to mutable values of type <code>Target_type::element_type</code> (a-la <code>T*</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">More...</a><br /></td></tr>
<tr class="separator:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a> = Const_target_ptr</td></tr>
<tr class="memdesc:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to immutable values of type <code>Target_type::element_type</code> (a-la <code>T const *</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">More...</a><br /></td></tr>
<tr class="separator:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2b4697824bd3ca88970c67d9a1f3e76"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76">serialize_to_raw_data</a> (<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *raw_bufs) const =0</td></tr>
<tr class="memdesc:aa2b4697824bd3ca88970c67d9a1f3e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the current logical packet data from <code>*this</code> into the given <code>Const_buffer_sequence</code>, which is a sequence of pointers and lengths of existing scattered areas in memory, presumably for transmission over the wire to a compatible serializing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76">More...</a><br /></td></tr>
<tr class="separator:aa2b4697824bd3ca88970c67d9a1f3e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856c405aa18f4f54a35515786befea8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a5856c405aa18f4f54a35515786befea8">serialize_to_raw_data_and_log</a> (<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *raw_bufs) const</td></tr>
<tr class="memdesc:a5856c405aa18f4f54a35515786befea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> but adds log-level-appropriate logging after the operation.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a5856c405aa18f4f54a35515786befea8">More...</a><br /></td></tr>
<tr class="separator:a5856c405aa18f4f54a35515786befea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09f0f187521ec2275885d68b7f6e734a"><td class="memTemplParams" colspan="2">template&lt;typename Low_lvl_packet_sub &gt; </td></tr>
<tr class="memitem:a09f0f187521ec2275885d68b7f6e734a"><td class="memTemplItemLeft" align="right" valign="top">static boost::shared_ptr&lt; Low_lvl_packet_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a">create_uninit_packet</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a09f0f187521ec2275885d68b7f6e734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs packet with uninitialized (essentially random) values, of the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type specified as the template parameter (<a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc.).  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a">More...</a><br /></td></tr>
<tr class="separator:a09f0f187521ec2275885d68b7f6e734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64981689c6d162131889bd90ef003279"><td class="memTemplParams" colspan="2">template&lt;typename Low_lvl_packet_sub &gt; </td></tr>
<tr class="memitem:a64981689c6d162131889bd90ef003279"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a64981689c6d162131889bd90ef003279">create_uninit_packet_base</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a64981689c6d162131889bd90ef003279"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple convenience method that casts the result of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a" title="Constructs packet with uninitialized (essentially random) values, of the Low_lvl_packet sub-type spec...">create_uninit_packet()</a> from <code>shared_ptr&lt;T&gt;</code>, where <code>T</code> is a sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>, to <code>shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>&gt;</code> a/k/a Ptr.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a64981689c6d162131889bd90ef003279">More...</a><br /></td></tr>
<tr class="separator:a64981689c6d162131889bd90ef003279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d7dae0c4b4402aed22a25d595ed30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30">create_from_raw_data_packet</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *raw_packet, <a class="el" href="classbool.html">bool</a> prefer_no_move)</td></tr>
<tr class="memdesc:a186d7dae0c4b4402aed22a25d595ed30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs packet on the heap with values determined by the given raw binary data as presumably received from the wire and originally serialized by a compatible serializing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30">More...</a><br /></td></tr>
<tr class="separator:a186d7dae0c4b4402aed22a25d595ed30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c9c6b04502d73defb803c1efabdf63"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a37c9c6b04502d73defb803c1efabdf63">type_id_to_str</a> (const std::type_index &amp;type_id)</td></tr>
<tr class="memdesc:a37c9c6b04502d73defb803c1efabdf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a brief (a few characters) string description of the given packet type given as <code>type_index(typeid(p))</code>, where <code>p</code> is a reference to an instance of a concrete <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a37c9c6b04502d73defb803c1efabdf63">More...</a><br /></td></tr>
<tr class="separator:a37c9c6b04502d73defb803c1efabdf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;</a></td></tr>
<tr class="memitem:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides syntactic-sugary way to perform a <code>static_pointer_cast&lt;&gt;</code> from a compatible smart pointer type <code>From_ptr</code>, typically <code>From_ptr::element_type</code> being in the same class hierarchy as <code>Target_ptr::element_type</code>.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">More...</a><br /></td></tr>
<tr class="separator:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but adds <code>const</code>-ness (immutability) to the pointed-to type.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">More...</a><br /></td></tr>
<tr class="separator:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">dynamic_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">More...</a><br /></td></tr>
<tr class="separator:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">dynamic_const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8" title="Identical to ptr_cast() but adds const-ness (immutability) to the pointed-to type.">const_ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">More...</a><br /></td></tr>
<tr class="separator:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:acc2a10d19e8e54c88518ad2e02a08b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#acc2a10d19e8e54c88518ad2e02a08b68">m_opt_rexmit_on</a></td></tr>
<tr class="memdesc:acc2a10d19e8e54c88518ad2e02a08b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option indicating whether this connection is using retransmission or not.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#acc2a10d19e8e54c88518ad2e02a08b68">More...</a><br /></td></tr>
<tr class="separator:acc2a10d19e8e54c88518ad2e02a08b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7152648c0098491512da590b47b464"><td class="memItemLeft" ><a id="a3e7152648c0098491512da590b47b464" name="a3e7152648c0098491512da590b47b464"></a>
struct {</td></tr>
<tr class="memitem:ab7d7924ff8e60ae6733dd4524e33e147"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;&#160;&#160;<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae5bd1ed0883b4827d8a81d70c10fd271">m_src_port</a></td></tr>
<tr class="memdesc:ab7d7924ff8e60ae6733dd4524e33e147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow-protocol port # of socket in sending <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae5bd1ed0883b4827d8a81d70c10fd271">More...</a><br /></td></tr>
<tr class="separator:ab7d7924ff8e60ae6733dd4524e33e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9929c35cd9cd16fe85bc46674d51c189"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;&#160;&#160;<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a786030d997a7602733a6a4422cb34274">m_dst_port</a></td></tr>
<tr class="memdesc:a9929c35cd9cd16fe85bc46674d51c189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow-protocol port # of socket in receiving <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a786030d997a7602733a6a4422cb34274">More...</a><br /></td></tr>
<tr class="separator:a9929c35cd9cd16fe85bc46674d51c189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7152648c0098491512da590b47b464"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>m_packed</b></td></tr>
<tr class="memdesc:a3e7152648c0098491512da590b47b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed group affected by <code>#pragma pack</code>. <br /></td></tr>
<tr class="separator:a3e7152648c0098491512da590b47b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4fd9ce69e293477e96fbad0a2298ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; std::ostream &amp;(std::ostream &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a7f4fd9ce69e293477e96fbad0a2298ed">m_type_ostream_manip</a></td></tr>
<tr class="memdesc:a7f4fd9ce69e293477e96fbad0a2298ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet's type ("ACK", "RST", etc.).  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a7f4fd9ce69e293477e96fbad0a2298ed">More...</a><br /></td></tr>
<tr class="separator:a7f4fd9ce69e293477e96fbad0a2298ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e64b049838a690384a899209ffca7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; std::ostream &amp;(std::ostream &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae3e64b049838a690384a899209ffca7b">m_verbose_ostream_manip</a></td></tr>
<tr class="memdesc:ae3e64b049838a690384a899209ffca7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet info suitable for DATA log level.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae3e64b049838a690384a899209ffca7b">More...</a><br /></td></tr>
<tr class="separator:ae3e64b049838a690384a899209ffca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bbdc4968a82877de3d7bcba3597c2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; std::ostream &amp;(std::ostream &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a89bbdc4968a82877de3d7bcba3597c2c">m_concise_ostream_manip</a></td></tr>
<tr class="memdesc:a89bbdc4968a82877de3d7bcba3597c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet info suitable for TRACE log level.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a89bbdc4968a82877de3d7bcba3597c2c">More...</a><br /></td></tr>
<tr class="separator:a89bbdc4968a82877de3d7bcba3597c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4a0585d1abae63af891161f1719bc582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a4a0585d1abae63af891161f1719bc582">Low_lvl_packet</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a4a0585d1abae63af891161f1719bc582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs packet with uninitialized (essentially random) values.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a4a0585d1abae63af891161f1719bc582">More...</a><br /></td></tr>
<tr class="separator:a4a0585d1abae63af891161f1719bc582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b199700e34d3cc17a7653d7bbb134b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ac7b199700e34d3cc17a7653d7bbb134b">serialize_common_header_to_raw_data</a> (<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *raw_bufs) const</td></tr>
<tr class="memdesc:ac7b199700e34d3cc17a7653d7bbb134b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> implementations in sub-types that encodes the header common to all packet types, starting with the packet type ID leading that header.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ac7b199700e34d3cc17a7653d7bbb134b">More...</a><br /></td></tr>
<tr class="separator:ac7b199700e34d3cc17a7653d7bbb134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9143f0b9dd4ae9d8c5ace666d5539"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a47e9143f0b9dd4ae9d8c5ace666d5539">to_ostream</a> (std::ostream &amp;os, <a class="el" href="classbool.html">bool</a> verbose=false) const</td></tr>
<tr class="memdesc:a47e9143f0b9dd4ae9d8c5ace666d5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a multi-line representation of <code>*this</code> to an output stream.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a47e9143f0b9dd4ae9d8c5ace666d5539">More...</a><br /></td></tr>
<tr class="separator:a47e9143f0b9dd4ae9d8c5ace666d5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a57c06fd2d0b1c3ac058c13f9081067f0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a57c06fd2d0b1c3ac058c13f9081067f0">native_is_big_endian</a> ()</td></tr>
<tr class="memdesc:a57c06fd2d0b1c3ac058c13f9081067f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, at compile time, if and only if the native memory representation is big-endian, meaning, for example, the value <code>uint32_t(1)</code> is stored as the bytes, in order, 0x00 0x00 0x00 0x01, and not the reverse.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a57c06fd2d0b1c3ac058c13f9081067f0">More...</a><br /></td></tr>
<tr class="separator:a57c06fd2d0b1c3ac058c13f9081067f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a720372b60ae7b7ee23c9f2d6775c7de1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a720372b60ae7b7ee23c9f2d6775c7de1">type_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a720372b60ae7b7ee23c9f2d6775c7de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a brief representation of <code>typeid(*this)</code> &ndash; i.e., the packet type (ACK, RST, etc.) &ndash; to an output stream.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a720372b60ae7b7ee23c9f2d6775c7de1">More...</a><br /></td></tr>
<tr class="separator:a720372b60ae7b7ee23c9f2d6775c7de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6a0e32bfe5616843746319533ca2c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a5c6a0e32bfe5616843746319533ca2c1">deserialize_type_specific_data_from_raw_data_packet</a> (<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">Const_buffer</a> *raw_buf, <a class="el" href="classbool.html">bool</a> prefer_no_move, <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *raw_packet)=0</td></tr>
<tr class="memdesc:a5c6a0e32bfe5616843746319533ca2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>virtual</code> helper for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a> that fills out the fields of <code>*this</code> that are <em>not</em> in <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> but rather in the sub-type.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a5c6a0e32bfe5616843746319533ca2c1">More...</a><br /></td></tr>
<tr class="separator:a5c6a0e32bfe5616843746319533ca2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a6b3de1eb7a337002440ecd1ab0ad058f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6b3de1eb7a337002440ecd1ab0ad058f">type_id_native_to_raw</a> (const std::type_info &amp;type_id)</td></tr>
<tr class="memdesc:a6b3de1eb7a337002440ecd1ab0ad058f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that looks up the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html#a167901d7c0f96f240dd789027ad99dc5" title="The type ID value, in serialized order, to be used in each serialization of all packets of this type.">Packet_type_info::m_raw_type_id</a> value for the given <code>typeid(p)</code>, where <code>p</code> refers to an instance of a concrete sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6b3de1eb7a337002440ecd1ab0ad058f">More...</a><br /></td></tr>
<tr class="separator:a6b3de1eb7a337002440ecd1ab0ad058f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1295f44e5a4ebdece11ed6d0eea0fbaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Aux__raw__data.html">Aux_raw_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a1295f44e5a4ebdece11ed6d0eea0fbaa">m_aux_raw_data</a></td></tr>
<tr class="memdesc:a1295f44e5a4ebdece11ed6d0eea0fbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxilliary data area necessary for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> to work.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a1295f44e5a4ebdece11ed6d0eea0fbaa">More...</a><br /></td></tr>
<tr class="separator:a1295f44e5a4ebdece11ed6d0eea0fbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a521afb86aaf334b871c9226ce503c508"><td class="memItemLeft" align="right" valign="top">static const boost::unordered_map&lt; std::type_index, <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html">Packet_type_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a521afb86aaf334b871c9226ce503c508">S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</a></td></tr>
<tr class="memdesc:a521afb86aaf334b871c9226ce503c508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from native <code>typeid()</code>, a/k/a packet type (for all possible packet types), to the set of properties of that packet type.  <a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a521afb86aaf334b871c9226ce503c508">More...</a><br /></td></tr>
<tr class="separator:a521afb86aaf334b871c9226ce503c508"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Internal <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> <code>struct</code> that encapsulates the Flow-protocol low-level packet structure and serves as the super-type for all specific packet types, represented by derived <code>struct</code>s like <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc. </p>
<p >This <code>struct</code> and its sub-<code>struct</code> hierarchy are not too complex but nevertheless are somewhat unorthodox, combining a few different paradigms. So it's worth explaining these paradigms.</p>
<h3>Paradigm: Data store</h3>
<p >This is a <code>struct</code> holding the conceptual contents of a packet. <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> stores common values like <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#acc2a10d19e8e54c88518ad2e02a08b68" title="Option indicating whether this connection is using retransmission or not.">m_opt_rexmit_on</a>, <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae5bd1ed0883b4827d8a81d70c10fd271" title="Flow-protocol port # of socket in sending Node.">m_src_port</a>, and a few more. Each sub-<code>struct</code> stores further values specific to each packet type; for example, as of this writing, <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#ad76ae289cd958d62bb5cd29b9f9e894d" title="The payload.">Data_packet::m_data</a> contains the data payload of a DATA packet; this would not apply, for example, to another sub-<code>struct</code> like <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, because an RST stores no binary blob like that.</p>
<p >Since it's a simple data store, the applicable data members (in this <code>struct</code> and the sub-types) are both public AND non-<code>const</code>. They can be read and written at will, thus changing or reading the logical contents of the packet.</p>
<h3>Paradigm: Polymorphic type</h3>
<p >While a simple data store, it also represents a hierarchy of possible packet types, and indeed a number of important polymorphic operations are included. Some are private/internal, and some are public. A public method may not appear polymorphic by its signature, but in that case usually its implementation uses non-public <code>virtual</code> methods to accomplish its tasks. Specifically, the key APIs are:</p>
<ul>
<li><code>create_uninit_packet&lt;T&gt;()</code>: This creates an uninitialized sub-object of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>, of actual type <code>T</code>, where <code>T</code> derives from <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>. This returns a <code>shared_ptr&lt;T&gt;</code>, and any actual constructor used to implement this factory method is non-public, so the only way for a user to create a <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> is to get at a ref-counted pointer to it &ndash; not a raw, unprotected pointer. If storing only <code>shared_ptr&lt;T&gt;</code> or <code>Ptr</code> values, deletion is not something to worry about, as it will happen automatically.<ul>
<li>Same with the other factory methods described just below. Direct access to <code>Low_lvl_packet*</code> or <code>T*</code>, where <code>T</code> derives from <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>, is not allowed (but this is not enforced at compile time and, at best, via <code>assert()</code>s at runtime).</li>
</ul>
</li>
<li><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a>: Given a raw serialized packet, this factory method constructs a <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> of the appropriate polymorphic sub-type, filling it at all levels with the data deserialized for the input binary blob. Internally, it uses some private, <code>virtual</code> action to get this to work. At any rate, this method is used to crete a logical representation of a packet off the wire.</li>
<li><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>: The opposite operation: convert existing object to raw data sendable over the wire. This uses a high-performance scatter-gather paradigm of producing a sequence of pointers and lengths to already existing data areas, avoiding copying. This thing is <code>virtual</code> and applies to any <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-object.</li>
</ul>
<p >(Reminder: As with all polymorphism and <code>shared_ptr</code>, you may need <code>static_pointer_cast&lt;&gt;</code> to up- and down-cast between <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> and subclasses. Also <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">Low_lvl_packet::ptr_cast()</a></code> up-casts even syntactically-sugarier-ly.)</p>
<p >The two basic flows are:</p><ul>
<li>Call <code>create_uninit_packet&lt;T&gt;()</code> to construct a sub-<code>struct</code> of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>, returned as a ref-counted pointer to <code>T</code>. Fill out all the fields manually, accessing object via aforemetioned smart pointer. Call <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. Pass result of latter to a boost.asio network-sending routine to send over wire. Ensure you pass a <code>Ptr</code> to the completion handler passed to that routine, so that the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> survives while being sent. The handler can let the <code>Ptr</code> go out of scope, likely <code>delete</code>ing the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>.</li>
<li>Receive raw packet over wire. Call <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a> to yield a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Low_lvl_packet::Ptr</a> pointing to new <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-object with all fields filled out. Read the fields as needed to process the packet; store the <code>Ptr</code> if necessary; eventually removing it from all data structures will drop ref-count to zero, and it will be auto-<code>delete</code>d.</li>
</ul>
<h3>Other utlities</h3>
<p >A number of (typically polymorphic) facilities exist, mainly to log these objects to <code>ostream</code>s, including when logging with <a class="el" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8" title="Logs a TRACE message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...">FLOW_LOG_TRACE()</a> and <a class="el" href="log_8hpp.html#a07561c1c3f16b6c2c7335a09e25298c9" title="Logs a DATA message into flow::log::Logger *get_logger() with flow::log::Component get_log_component(...">FLOW_LOG_DATA()</a>.</p>
<ul>
<li><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae3e64b049838a690384a899209ffca7b" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet info suitable for DATA log level...">m_verbose_ostream_manip</a> and <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a89bbdc4968a82877de3d7bcba3597c2c" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet info suitable for TRACE log leve...">m_concise_ostream_manip</a> are <code>const</code> data members that can be output via the usual <code>&lt;&lt;</code> operator to <code>ostream</code>s in order to output verbose and concise descriptions of any <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> (of any sub-<code>struct</code> type, polymorphically).</li>
<li><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a7f4fd9ce69e293477e96fbad0a2298ed" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet&#39;s type (&quot;ACK&quot;,...">m_type_ostream_manip</a> can be similarly used to output just the packet type of any given <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> (producing strings like <code>"ACK"</code> or <code>"RST"</code>).</li>
</ul>
<p >The implementation of these is typically some polymorphic <code>virtual</code> magic, but the use is straightforward using these <code>ostream</code> manipulator data members.</p>
<h2>Implementation notes </h2>
<h3>History of approaches</h3>
<p >Originally the implementation used the boost.serialization library for packet serialization, but it turned out to consume way too much CPU time which consequently limited the maximum throughput at high speeds. The next implementation used the traditional approach based on "packed" structures (structures without any padding), in one big <code>struct <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a></code>. However, I deemed the latter setup too C-like (yet simultaneously not C-like enough, in that no unions were used, hence RAM was wasted despite the C-like approach). Ultimately, the current version of the implementation came about, with its polymorphic <code>struct</code> hierarchy and abstract <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> <code>struct</code> (which, in the previous iteration, simply contained everything about every type, complete with an <code>enum Type</code> instead of using C++'s built-in <code>typeid</code>, as the current version uses).</p>
<p >While the above evolution was more about coding style philosophy (from a single type and a type selector <code>enum</code> to a polymorphic hierarchy and <code>typeid</code>), the other evolution concerned the way serialization (for sending over the write) worked. At first, as mentioned, there were the logical values (which were public and non-<code>const</code>), and there were private packed <code>struct</code>s into which the logical values were placed (with transformation for endianness and other things) at serialization time; finally then assembling a newly allocated single binary buffer, those packed <code>struct</code>s copied into it. Not bad &ndash; rather verbose having all those types defined, but not bad &ndash; but it did involve a new buffer and linear-time copying into that buffer. This seemed like a shame.</p>
<p >This led to the final improvement, which was to turn the serialization function into one that generates a <code>boost::asio::const_buffer_sequence</code>, basically a sequence of pointers and associated lengths of areas already present in memory. In most cases (with a couple small exceptions), the stored public data members (e.g., <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae5bd1ed0883b4827d8a81d70c10fd271" title="Flow-protocol port # of socket in sending Node.">m_src_port</a> and <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#ad76ae289cd958d62bb5cd29b9f9e894d" title="The payload.">Data_packet::m_data</a>) could simply have their addresses and lengths taken and placed into the <code>const_buffer_sequence</code> &ndash; no buffer copying involved. This should achieve a nice performance improvement. The removal of things like <code>struct Common_header</code> and <code>struct Ack_header</code> is a good bonus coding-wise, too.</p>
<p >(There is a caveat there. While no issue for the true performance culprits, namely <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#ad76ae289cd958d62bb5cd29b9f9e894d" title="The payload.">Data_packet::m_data</a>, the various multi-byte integer values like <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae5bd1ed0883b4827d8a81d70c10fd271" title="Flow-protocol port # of socket in sending Node.">m_src_port</a> technically have to undergo endianness conversion during serialization. So technically simply taking an address and size is not enough; the value needs to be flipped <em>potentially</em>. In reality, though, all relevant architectures are such that we chose identical network byte order as memory byte order, making no flipping necessary in practice. Of course, if we spread to an architecture where this is not true, everything will explode. However, a compile-time assertion would warn us of this, and a nearby comment will instruct on how to deal with the problem, in the unlikely case it were to appear. [Little-endian is rather universal these days.])</p>
<h3>Packed structures, stored integers, and alignment</h3>
<p >When 2 or more contiguous data members are used in serializing (<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> or overridden version), they are packed together via <code>"#pragma pack"</code>. (Note that this affect entire <code>struct</code>s at a time only; hence we need to use some anonymously-typed grouping <code>struct</code>s named <code>m_packed</code>.)</p>
<p >Numeric values are stored as unsigned integers, which is the most portable choice for serializing. Booleans are serialized as bytes for compactness.</p>
<p >Some effort is made to keep fields aligned along word edges when serializing. There is not too much of that as of this writing, but we should remain vigilant as packet formats become more complex over time.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>With C++11, some lines of code could be eliminated by using <code>using</code> for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-types to inherit the constructor(s) of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>. (For some of the sub-types an explicit constructor would still be necessary, but it would just shadow the inherited one, which is fine and still saves lines in the other sub-types.) However, for now I've left it as-is, partially to be friendly to the Doxygen documentation generator, and partially to make the interface easy to read. Still, it may be better the other way. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00164">164</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab735867345855ad43e5e3ff788cf5a9a" name="ab735867345855ad43e5e3ff788cf5a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab735867345855ad43e5e3ff788cf5a9a">&#9670;&nbsp;</a></span>Const_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">flow::net_flow::Low_lvl_packet::Const_buffer</a> =  boost::asio::const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for boost.asio immutable buffer, which essentially is a pointer to and length of a memory area. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>Consider moving alias <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a" title="Short-hand for boost.asio immutable buffer, which essentially is a pointer to and length of a memory ...">Low_lvl_packet::Const_buffer</a> to <code>util</code> namespace or even outside it, as it is used commonly (or <code>boost::asio::const_buffer</code> is used where <code>Const_buffer</code> could be used for readability). </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00179">179</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a6e16e9c355c6d5e2acff5f9bdc24f397" name="a6e16e9c355c6d5e2acff5f9bdc24f397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e16e9c355c6d5e2acff5f9bdc24f397">&#9670;&nbsp;</a></span>Const_buffer_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">flow::net_flow::Low_lvl_packet::Const_buffer_sequence</a> =  std::vector&lt;<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">Const_buffer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for sequence of immutable buffers; i.e., a sequence of 1 or more scattered areas in memory. </p>
<p >This is a model of the <code>ConstBufferSequence</code> model in boost.asio, which means a <code>const</code> reference to this can be passed to boost.asio scatter-gathering send functions such as <code>Udp_socket::async_send_to()</code>; the scattered buffers represented by an instance of this type will be, at high performance, gathered into a single UDP datagram and sent over the wire if possible. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00188">188</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a01ff17bec742d9e363aea2ecd23f2f72" name="a01ff17bec742d9e363aea2ecd23f2f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ff17bec742d9e363aea2ecd23f2f72">&#9670;&nbsp;</a></span>rcv_wnd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a01ff17bec742d9e363aea2ecd23f2f72">flow::net_flow::Low_lvl_packet::rcv_wnd_t</a> =  uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to store the size of <code>m_rcv_wnd</code> member in a couple of different packet types. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00202">202</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a11e7750d22415a381e23112062f7ca74" name="a11e7750d22415a381e23112062f7ca74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e7750d22415a381e23112062f7ca74">&#9670;&nbsp;</a></span>rexmit_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a11e7750d22415a381e23112062f7ca74">flow::net_flow::Low_lvl_packet::rexmit_id_t</a> =  <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to store the retransmission count in DATA and ACK packets. </p>
<p >Why 8 bits? This handles up 255 retransmissions, which is long after we'd kill the connection anyway. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00199">199</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a872044469cfa05a3abf3f9ab1c7cf03b" name="a872044469cfa05a3abf3f9ab1c7cf03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872044469cfa05a3abf3f9ab1c7cf03b">&#9670;&nbsp;</a></span>security_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a872044469cfa05a3abf3f9ab1c7cf03b">flow::net_flow::Low_lvl_packet::security_token_t</a> =  uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for <code>m_security_token</code> member of a couple different packet types. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00191">191</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a0585d1abae63af891161f1719bc582" name="a4a0585d1abae63af891161f1719bc582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0585d1abae63af891161f1719bc582">&#9670;&nbsp;</a></span>Low_lvl_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Low_lvl_packet::Low_lvl_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs packet with uninitialized (essentially random) values. </p>
<p >This is not public, because a <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> is meaningless without being of some specific sub-type referring to an actual packet (e.g., <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc.). (The presence of pure virtual methods would probably accomplish this too, but it's nice to be explicit.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use subsequently. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00054">54</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__packet_8cpp_source.html#l01053">type_to_ostream()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a4a0585d1abae63af891161f1719bc582_cgraph.svg" width="492" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a186d7dae0c4b4402aed22a25d595ed30" name="a186d7dae0c4b4402aed22a25d595ed30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d7dae0c4b4402aed22a25d595ed30">&#9670;&nbsp;</a></span>create_from_raw_data_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> flow::net_flow::Low_lvl_packet::create_from_raw_data_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *&#160;</td>
          <td class="paramname"><em>raw_packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>prefer_no_move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs packet on the heap with values determined by the given raw binary data as presumably received from the wire and originally serialized by a compatible serializing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >The returned value is a reference-counted pointer with a reference count of 1 (i.e., no other references to underlying object have been saved anywhere by the time method returns).</p>
<p >It is the opposite of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> but not symmetrically efficient; where the latter produces a sequence of pointers/lengths of already present areas of memory (no copying), the present method copies the raw data into a new structure and is thus less efficient.</p>
<p >Suppose <code>ptr</code> is returned. Then <code>*ptr</code> is of polymorphic type <code>Low_lvl_packet*</code> but actually is of some specific sub-type (like <code>Ack_packet*</code>). <code>typeid(*ptr)</code> can be used to determine the exact type. In particular one can write things like: <code>bool is_ack = typeid(*ptr) == typeid(Ack_packet)</code>. Of course, in many cases one may call one of a number of virtual methods of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> to get type-specific polymorphic behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a7f4fd9ce69e293477e96fbad0a2298ed" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet&#39;s type (&quot;ACK&quot;,...">m_type_ostream_manip()</a> for easy way to output human-readable version of <code>typeid(*ptr).name()</code>, where <code>ptr</code> is the value returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_packet</td><td>Pointer to entire packet raw buffer as received over the wire. Upon return, the state of <code>*raw_packet</code> is not known; and caller retains ownership of it (e.g., can read another datagram into it if desired). As of this writing it will either remain unchanged or be emptied (via a move elsewhere) &ndash; but ideally code without relying on either specific outcome. </td></tr>
    <tr><td class="paramname">prefer_no_move</td><td>If <code>true</code>, the method should (if at all reasonable) not alter <code>raw_packet-&gt;capacity()</code> (in particular it should not use move semantics to send its contents to another data structure); otherwise it should be free to do so (i.e., if it considers doing so beneficial for performance reasons). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>Will be used to log within this method as well as be saved as the <code>Logger*</code> in the new <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> created and returned (if any). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null pointer on failure; otherwise pointer to an object of some sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00381">381</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00481">flow::util::buffers_dump_string()</a>, <a class="el" href="log_8hpp_source.html#l00242">FLOW_LOG_DATA</a>, <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00532">FLOW_LOG_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00228">flow::log::Log_context::get_log_component()</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00571">m_aux_raw_data</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00447">flow::net_flow::Low_lvl_packet::Aux_raw_data::m_opt_rexmit_on_raw</a>, <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a3e7152648c0098491512da590b47b464">m_packed</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00454">flow::net_flow::Low_lvl_packet::Aux_raw_data::m_reserved2</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00119">type_id_native_to_raw()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">flow::net_flow::Node::handle_incoming()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a186d7dae0c4b4402aed22a25d595ed30_cgraph.svg" width="514" height="270"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a186d7dae0c4b4402aed22a25d595ed30_icgraph.svg" width="951" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a09f0f187521ec2275885d68b7f6e734a" name="a09f0f187521ec2275885d68b7f6e734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f0f187521ec2275885d68b7f6e734a">&#9670;&nbsp;</a></span>create_uninit_packet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Low_lvl_packet_sub &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; Low_lvl_packet_sub &gt; flow::net_flow::Low_lvl_packet::create_uninit_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs packet with uninitialized (essentially random) values, of the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type specified as the template parameter (<a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>, etc.). </p>
<p >Since any constructor is not public, this is the only way to instantiate a blank <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-object.</p>
<p >Compiler template parameter inference should make the following work, so the template parameter can be omitted.:</p>
<div class="fragment"><div class="line">shared_ptr&lt;Ack_packet&gt; = <a class="code hl_function" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a">create_uninit_packet</a>(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>());</div>
<div class="line"><span class="comment">// ^-- Low_lvl_packet_sub was inferred to be Ack_packet based on the left hand side of the assignment.</span></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_af4db395042b065b00398cd59845dcb4d"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">flow::log::Log_context::get_logger</a></div><div class="ttdeci">Logger * get_logger() const</div><div class="ttdoc">Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> <a href="log_8cpp_source.html#l00223">log.cpp:223</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Low__lvl__packet_html_a09f0f187521ec2275885d68b7f6e734a"><div class="ttname"><a href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a">flow::net_flow::Low_lvl_packet::create_uninit_packet</a></div><div class="ttdeci">static boost::shared_ptr&lt; Low_lvl_packet_sub &gt; create_uninit_packet(log::Logger *logger_ptr)</div><div class="ttdoc">Constructs packet with uninitialized (essentially random) values, of the Low_lvl_packet sub-type spec...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01388">low_lvl_packet.hpp:1388</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Low_lvl_packet_sub</td><td>Any type deriving from <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use subsequently in the new object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ref-counted pointer to newly created object of the specified type. If you need an up-cast pointer, use <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a64981689c6d162131889bd90ef003279" title="A simple convenience method that casts the result of create_uninit_packet() from shared_ptr&lt;T&gt;,...">create_uninit_packet_base()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l01388">1388</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a64981689c6d162131889bd90ef003279" name="a64981689c6d162131889bd90ef003279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64981689c6d162131889bd90ef003279">&#9670;&nbsp;</a></span>create_uninit_packet_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Low_lvl_packet_sub &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> flow::net_flow::Low_lvl_packet::create_uninit_packet_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple convenience method that casts the result of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a" title="Constructs packet with uninitialized (essentially random) values, of the Low_lvl_packet sub-type spec...">create_uninit_packet()</a> from <code>shared_ptr&lt;T&gt;</code>, where <code>T</code> is a sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>, to <code>shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>&gt;</code> a/k/a Ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a" title="Constructs packet with uninitialized (essentially random) values, of the Low_lvl_packet sub-type spec...">create_uninit_packet()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a09f0f187521ec2275885d68b7f6e734a" title="Constructs packet with uninitialized (essentially random) values, of the Low_lvl_packet sub-type spec...">create_uninit_packet()</a> (but cast to a type compatible with the polymorphic base type). </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l01399">1399</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a64981689c6d162131889bd90ef003279_cgraph.svg" width="372" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5c6a0e32bfe5616843746319533ca2c1" name="a5c6a0e32bfe5616843746319533ca2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6a0e32bfe5616843746319533ca2c1">&#9670;&nbsp;</a></span>deserialize_type_specific_data_from_raw_data_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> flow::net_flow::Low_lvl_packet::deserialize_type_specific_data_from_raw_data_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a">Const_buffer</a> *&#160;</td>
          <td class="paramname"><em>raw_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>prefer_no_move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *&#160;</td>
          <td class="paramname"><em>raw_packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>virtual</code> helper for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a> that fills out the fields of <code>*this</code> that are <em>not</em> in <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> but rather in the sub-type. </p>
<p ><code>*raw_buf</code> must represent the area of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a>'s <code>*raw_buf</code> argument immediately following the Common Header, which is the area deserialized into <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> proper. Hence <code>*raw_buf</code> must point to and contain the length of the rest of that input buffer. The present method must then deserialize it into the sub-object's own fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_buf</td><td>Pointer to immutable buffer just past the input raw packet data's Common Header area. Note that while the underlying area is immutable (hence the type <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ab735867345855ad43e5e3ff788cf5a9a" title="Short-hand for boost.asio immutable buffer, which essentially is a pointer to and length of a memory ...">Const_buffer</a>!), <code>*raw_buf</code> itself may be modified (i.e., the area to which it will refer on exit is undefined). </td></tr>
    <tr><td class="paramname">prefer_no_move</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a>. </td></tr>
    <tr><td class="paramname">raw_packet</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a>. <code>raw_buf</code> must start somewhere within it and be sized to go exactly to its end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a> should return <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Ptr()</a></code> (error); <code>true</code> if deserialization successful. </dd></dl>

<p>Implemented in <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html#aee4a61d5e344959abc89ee83ae105c8a">flow::net_flow::Syn_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html#a1ce651745da7f488ec0bcf3d4f3467a9">flow::net_flow::Syn_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html#a15bb98c2c3c00dc2c2db7f76a932d65c">flow::net_flow::Syn_ack_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#ac2a390c4cb7abfeec7c658c866dbfc06">flow::net_flow::Data_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html#a5af95ad4de8253b613d55a99d41cb430">flow::net_flow::Ack_packet</a>, and <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html#ae1292deb7eec0f01d3ff111977ff5693">flow::net_flow::Rst_packet</a>.</p>

</div>
</div>
<a id="a57c06fd2d0b1c3ac058c13f9081067f0" name="a57c06fd2d0b1c3ac058c13f9081067f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c06fd2d0b1c3ac058c13f9081067f0">&#9670;&nbsp;</a></span>native_is_big_endian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> flow::net_flow::Low_lvl_packet::native_is_big_endian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, at compile time, if and only if the native memory representation is big-endian, meaning, for example, the value <code>uint32_t(1)</code> is stored as the bytes, in order, 0x00 0x00 0x00 0x01, and not the reverse. </p>
<p >Can be used in a compile-time check such as <code>static_assert()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l01404">1404</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="ac7b199700e34d3cc17a7653d7bbb134b" name="ac7b199700e34d3cc17a7653d7bbb134b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b199700e34d3cc17a7653d7bbb134b">&#9670;&nbsp;</a></span>serialize_common_header_to_raw_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Low_lvl_packet::serialize_common_header_to_raw_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *&#160;</td>
          <td class="paramname"><em>raw_bufs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> implementations in sub-types that encodes the header common to all packet types, starting with the packet type ID leading that header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_bufs</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. Header fields are encoded and appended to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. The total # of bytes encoded and appended to <code>*raw_bufs</code> by the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00159">159</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__packet_8hpp_source.html#l00571">m_aux_raw_data</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00222">m_opt_rexmit_on</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00447">flow::net_flow::Low_lvl_packet::Aux_raw_data::m_opt_rexmit_on_raw</a>, <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a3e7152648c0098491512da590b47b464">m_packed</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00454">flow::net_flow::Low_lvl_packet::Aux_raw_data::m_reserved2</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00119">type_id_native_to_raw()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_ac7b199700e34d3cc17a7653d7bbb134b_cgraph.svg" width="376" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa2b4697824bd3ca88970c67d9a1f3e76" name="aa2b4697824bd3ca88970c67d9a1f3e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b4697824bd3ca88970c67d9a1f3e76">&#9670;&nbsp;</a></span>serialize_to_raw_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t flow::net_flow::Low_lvl_packet::serialize_to_raw_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *&#160;</td>
          <td class="paramname"><em>raw_bufs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the current logical packet data from <code>*this</code> into the given <code>Const_buffer_sequence</code>, which is a sequence of pointers and lengths of existing scattered areas in memory, presumably for transmission over the wire to a compatible serializing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >It is the opposite of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a186d7dae0c4b4402aed22a25d595ed30" title="Constructs packet on the heap with values determined by the given raw binary data as presumably recei...">create_from_raw_data_packet()</a> but not symmetrically efficient; where the latter copies the raw data into a new structure, the present method produces a sequence of pointers/lengths of already present areas of memory (no copying) and is thus more efficient.</p>
<p >The input <code>*raw_bufs</code> is appended to and is <em>not</em> cleared by this method. Thus one may use this method to produce a larger buffer sequence of which the serialization of <code>*this</code> is only a part (possibly in the middle somewhere).</p>
<p >Behavior is undefined if one modifies <code>*this</code> after calling the present method. It is safer to run this on a <code>const <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a></code> rather than a mutable <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This efficiency comes with an important caveat: the generated additions to <code>*raw_bufs</code> will remain valid <em>only</em> while <code>*this</code> exists. If its destructor runs, the buffers added here will become invalid, and accessing them will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_bufs</td><td>Pointer to the sequence of <code>Const_buffer</code>s into which we will append pointers/lengths of serialized data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the data references to which have been appended to <code>*raw_bufs</code>; Already present data are not included. </dd></dl>

<p>Implemented in <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html#af72461ac0c304cd5ea2bb3fca2b3a444">flow::net_flow::Syn_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html#a98fae8deebcd22c8397f2585de18ce9d">flow::net_flow::Syn_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html#a817e22c18b67db0e2e4794b962e4365d">flow::net_flow::Syn_ack_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#add582f24dd9442f987f2c458e4b5d3d7">flow::net_flow::Data_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html#a878162c8ec16ab4ee1b3ea4bbe4b51c0">flow::net_flow::Ack_packet</a>, and <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html#a06e98008f816699dcd5c8890914a6b3f">flow::net_flow::Rst_packet</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00130">serialize_to_raw_data_and_log()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_aa2b4697824bd3ca88970c67d9a1f3e76_icgraph.svg" width="335" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5856c405aa18f4f54a35515786befea8" name="a5856c405aa18f4f54a35515786befea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856c405aa18f4f54a35515786befea8">&#9670;&nbsp;</a></span>serialize_to_raw_data_and_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Low_lvl_packet::serialize_to_raw_data_and_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a6e16e9c355c6d5e2acff5f9bdc24f397">Const_buffer_sequence</a> *&#160;</td>
          <td class="paramname"><em>raw_bufs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> but adds log-level-appropriate logging after the operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_bufs</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00130">130</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00481">flow::util::buffers_dump_string()</a>, <a class="el" href="log_8hpp_source.html#l00372">FLOW_LOG_DATA_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00228">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00223">flow::log::Log_context::get_logger()</a>, <a class="el" href="low__lvl__packet_8hpp_source.html#l00245">m_type_ostream_manip</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, and <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76">serialize_to_raw_data()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a5856c405aa18f4f54a35515786befea8_cgraph.svg" width="506" height="270"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a47e9143f0b9dd4ae9d8c5ace666d5539" name="a47e9143f0b9dd4ae9d8c5ace666d5539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e9143f0b9dd4ae9d8c5ace666d5539">&#9670;&nbsp;</a></span>to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::Low_lvl_packet::to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a multi-line representation of <code>*this</code> to an output stream. </p>
<p >Unless the sub-type needs to add no information of its own (as of this writing, the case for <a class="el" href="structflow_1_1net__flow_1_1Rst__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level RST packet.">Rst_packet</a>), this implementation (of this virtual method) is only present as a utility for the sub-types. The sub-type is recommended to first call this implementation; then add type-specific lines afterwards, ending with a newline. Following this recommendation will result in uniform, decent-looking overall output.</p>
<dl class="section note"><dt>Note</dt><dd>This is protected, because it is meant only to be used in the implementation of the <code>ostream</code> manipulators <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#ae3e64b049838a690384a899209ffca7b" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet info suitable for DATA log level...">m_verbose_ostream_manip</a> and <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a89bbdc4968a82877de3d7bcba3597c2c" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet info suitable for TRACE log leve...">m_concise_ostream_manip</a>, which are public and to be used by users of this type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to use. Normally I'd make this a pointer, but this non-constant reference is fairly typical in STL and the world in general, for <code>ostream</code> in particular. </td></tr>
    <tr><td class="paramname">verbose</td><td>If <code>false</code>, output suitable for TRACE level logging is produced; otherwise for DATA level logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html#a11ded0bc8596fb4adc815c5322e7ad26">flow::net_flow::Syn_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html#a9c98a61096d86196c073a232e432d03b">flow::net_flow::Syn_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html#a0f2665713bcedc20db1365412630ff6f">flow::net_flow::Syn_ack_ack_packet</a>, <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#a0bfa19b23164c8189c05d3c2417cf23b">flow::net_flow::Data_packet</a>, and <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html#a49659e0e672d324ad17e2f4240604b49">flow::net_flow::Ack_packet</a>.</p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00912">912</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00925">flow::net_flow::Syn_packet::to_ostream()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00947">flow::net_flow::Syn_ack_packet::to_ostream()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00958">flow::net_flow::Syn_ack_ack_packet::to_ostream()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00968">flow::net_flow::Data_packet::to_ostream()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00996">flow::net_flow::Ack_packet::to_ostream()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a47e9143f0b9dd4ae9d8c5ace666d5539_icgraph.svg" width="367" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6b3de1eb7a337002440ecd1ab0ad058f" name="a6b3de1eb7a337002440ecd1ab0ad058f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3de1eb7a337002440ecd1ab0ad058f">&#9670;&nbsp;</a></span>type_id_native_to_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> &amp; flow::net_flow::Low_lvl_packet::type_id_native_to_raw </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that looks up the <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html#a167901d7c0f96f240dd789027ad99dc5" title="The type ID value, in serialized order, to be used in each serialization of all packets of this type.">Packet_type_info::m_raw_type_id</a> value for the given <code>typeid(p)</code>, where <code>p</code> refers to an instance of a concrete sub-type of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a>. </p>
<p >Note that is returns a reference, and indeed the referred to memory will remain valid and unmodified throughout the program's runtime. Therefore, it can be used for serialization without copying.</p>
<h3>Implementation note</h3>
<p >It would be nice to make this <code>constexpr</code>, as then it can be used in <code>switch()</code> statement conditionals. Unfortunately, at least as of C++17, this is not possible with our current implementation: <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a521afb86aaf334b871c9226ce503c508" title="Mapping from native typeid(), a/k/a packet type (for all possible packet types), to the set of proper...">S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</a> is an <code>unordered_map</code> (as of this writing), and that is not a "literal" type (in other words, lookups in it are not done at compile time, even when for a human it would seem clearly possible... iterators and such are involved, and that goes beyond what <code>constexpr</code> evaluation can do).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_id</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a37c9c6b04502d73defb803c1efabdf63" title="Returns a brief (a few characters) string description of the given packet type given as type_index(ty...">type_id_to_str()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a constant area of memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00119">119</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__packet_8hpp_source.html#l00558">S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00381">create_from_raw_data_packet()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00159">serialize_common_header_to_raw_data()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a6b3de1eb7a337002440ecd1ab0ad058f_icgraph.svg" width="956" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a37c9c6b04502d73defb803c1efabdf63" name="a37c9c6b04502d73defb803c1efabdf63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c9c6b04502d73defb803c1efabdf63">&#9670;&nbsp;</a></span>type_id_to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; flow::net_flow::Low_lvl_packet::type_id_to_str </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>type_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a brief (a few characters) string description of the given packet type given as <code>type_index(typeid(p))</code>, where <code>p</code> is a reference to an instance of a concrete <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_id</td><td>See above. If the <code>p</code> points to a value of some other type, behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a string without newlines or other whitespace: "DATA", "ACK", "SYN_ACK_ACK", etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l00108">108</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__packet_8hpp_source.html#l00558">S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="info_8cpp_source.html#l00489">flow::net_flow::Peer_socket_info::output_pkt_count_key()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l01053">type_to_ostream()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a37c9c6b04502d73defb803c1efabdf63_icgraph.svg" width="968" height="164"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a720372b60ae7b7ee23c9f2d6775c7de1" name="a720372b60ae7b7ee23c9f2d6775c7de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720372b60ae7b7ee23c9f2d6775c7de1">&#9670;&nbsp;</a></span>type_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::net_flow::Low_lvl_packet::type_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a brief representation of <code>typeid(*this)</code> &ndash; i.e., the packet type (ACK, RST, etc.) &ndash; to an output stream. </p>
<p >See also <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a37c9c6b04502d73defb803c1efabdf63" title="Returns a brief (a few characters) string description of the given packet type given as type_index(ty...">type_id_to_str()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is private, because it is meant only to be used in the implementation of the <code>ostream</code> manipulator <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a7f4fd9ce69e293477e96fbad0a2298ed" title="ostream manipulator (argument to ostream &lt;&lt;) that will output packet&#39;s type (&quot;ACK&quot;,...">m_type_ostream_manip</a>, which is public and to be used by users of this type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream to use. Normally I'd make this a pointer, but this non-constant reference is fairly typical in STL and the world in general, for <code>ostream</code> in particular. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8cpp_source.html#l01053">1053</a> of file <a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__packet_8cpp_source.html#l00108">type_id_to_str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00054">Low_lvl_packet()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a720372b60ae7b7ee23c9f2d6775c7de1_cgraph.svg" width="316" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Low__lvl__packet_a720372b60ae7b7ee23c9f2d6775c7de1_icgraph.svg" width="316" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1295f44e5a4ebdece11ed6d0eea0fbaa" name="a1295f44e5a4ebdece11ed6d0eea0fbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1295f44e5a4ebdece11ed6d0eea0fbaa">&#9670;&nbsp;</a></span>m_aux_raw_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Aux__raw__data.html">Aux_raw_data</a> flow::net_flow::Low_lvl_packet::m_aux_raw_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxilliary data area necessary for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a> to work. </p>
<p >This is explained in doc header for <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Aux__raw__data.html" title="Helper data store type for storing binary data needed by serialize_to_raw_data(), when certains bits ...">Aux_raw_data</a>.</p>
<p >It is declared <code>mutable</code>, because the conceptual state contained within a <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> is expressed via its public non-<code>const</code> data members. <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#a1295f44e5a4ebdece11ed6d0eea0fbaa" title="Auxilliary data area necessary for serialize_to_raw_data() to work.">m_aux_raw_data</a> is merely a helper data store for the <code>const</code> method <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html#aa2b4697824bd3ca88970c67d9a1f3e76" title="Serializes the current logical packet data from *this into the given Const_buffer_sequence,...">serialize_to_raw_data()</a>. Since that method is <code>const</code>, this should be <code>mutable</code>, like a performance cache of sorts, only not exactly. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00571">571</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00381">create_from_raw_data_packet()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00159">serialize_common_header_to_raw_data()</a>.</p>

</div>
</div>
<a id="a89bbdc4968a82877de3d7bcba3597c2c" name="a89bbdc4968a82877de3d7bcba3597c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bbdc4968a82877de3d7bcba3597c2c">&#9670;&nbsp;</a></span>m_concise_ostream_manip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt;std::ostream&amp; (std::ostream&amp;)&gt; flow::net_flow::Low_lvl_packet::m_concise_ostream_manip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet info suitable for TRACE log level. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00251">251</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a786030d997a7602733a6a4422cb34274" name="a786030d997a7602733a6a4422cb34274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786030d997a7602733a6a4422cb34274">&#9670;&nbsp;</a></span>m_dst_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Low_lvl_packet::m_dst_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flow-protocol port # of socket in receiving <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00233">233</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="acc2a10d19e8e54c88518ad2e02a08b68" name="acc2a10d19e8e54c88518ad2e02a08b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2a10d19e8e54c88518ad2e02a08b68">&#9670;&nbsp;</a></span>m_opt_rexmit_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Low_lvl_packet::m_opt_rexmit_on</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option indicating whether this connection is using retransmission or not. </p>
<p >This value must not change over the course of a connection and is provided in each packet for simpler deserialization (so that the latter can proceed completely without having to check the connection properties).</p>
<p >For a given connection handshake, the SYN receiver should either disconnect/RST or respond with SYN_ACK. If it responds with SYN_ACK, it indicates agreement to abide by this option for the rest of the connection. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00222">222</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00655">flow::net_flow::Data_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00785">flow::net_flow::Ack_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00159">serialize_common_header_to_raw_data()</a>.</p>

</div>
</div>
<a id="ae5bd1ed0883b4827d8a81d70c10fd271" name="ae5bd1ed0883b4827d8a81d70c10fd271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bd1ed0883b4827d8a81d70c10fd271">&#9670;&nbsp;</a></span>m_src_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Low_lvl_packet::m_src_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flow-protocol port # of socket in sending <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00231">231</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a7f4fd9ce69e293477e96fbad0a2298ed" name="a7f4fd9ce69e293477e96fbad0a2298ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4fd9ce69e293477e96fbad0a2298ed">&#9670;&nbsp;</a></span>m_type_ostream_manip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt;std::ostream&amp; (std::ostream&amp;)&gt; flow::net_flow::Low_lvl_packet::m_type_ostream_manip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet's type ("ACK", "RST", etc.). </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00245">245</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00513">flow::net_flow::Syn_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00565">flow::net_flow::Syn_ack_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00614">flow::net_flow::Syn_ack_ack_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00655">flow::net_flow::Data_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00785">flow::net_flow::Ack_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00893">flow::net_flow::Rst_packet::deserialize_type_specific_data_from_raw_data_packet()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00130">serialize_to_raw_data_and_log()</a>.</p>

</div>
</div>
<a id="ae3e64b049838a690384a899209ffca7b" name="ae3e64b049838a690384a899209ffca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e64b049838a690384a899209ffca7b">&#9670;&nbsp;</a></span>m_verbose_ostream_manip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt;std::ostream&amp; (std::ostream&amp;)&gt; flow::net_flow::Low_lvl_packet::m_verbose_ostream_manip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>ostream</code> manipulator (argument to <code>ostream &lt;&lt;</code>) that will output packet info suitable for DATA log level. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00248">248</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

</div>
</div>
<a id="a521afb86aaf334b871c9226ce503c508" name="a521afb86aaf334b871c9226ce503c508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521afb86aaf334b871c9226ce503c508">&#9670;&nbsp;</a></span>S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::unordered_map&lt; std::type_index, <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet_1_1Packet__type__info.html">Low_lvl_packet::Packet_type_info</a> &gt; flow::net_flow::Low_lvl_packet::S_NATIVE_TYPE_ID_TO_PACKET_TYPE_INFO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping from native <code>typeid()</code>, a/k/a packet type (for all possible packet types), to the set of properties of that packet type. </p>
<p >The keys are every possible value of <code>type_index(typeid(p))</code>, where <code>p</code> is a reference to an instance of any concrete <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type.</p>
<h3>Implementation note</h3>
<p >An alternative way to implement this mechanism (as of this writing, raw type IDs and brief string descriptions per packet type) is to use <code>virtual</code> liberally, combined with a <code>switch</code> if needed. (Note, also, that a way to index &ndash; such as in an <code>unordered</code> container &ndash; by packet type is necessary elsewhere. We use <code>type_index(typeid()))</code> now, but a [worse] alternative is to have <code>virtual</code> type IDs returned for each <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> sub-type.) I could explain at length all the reasons why the chosen way is superior, but let me just give you the conclusion: I originally tried it the <code>virtual/switch</code> way. Instead of the raw type IDs and string descriptions being conveniently encapsulated in the present map (where there's little to no chance of conflicting values), they were distributed across <code>virtual</code> implementations. This was less maintainable; nor did it improve OO style, since the raw type ID values (at least) were still inter-dependent (were not allowed to conflict) in any case. The present solution does not pretend the actual contents of these values are of no interest to <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> itself (as opposed to the sub-types), and in not having to pretend this, all related code is quite a bit more compact and a bit more maintainable as well. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__packet_8hpp_source.html#l00558">558</a> of file <a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__packet_8cpp_source.html#l00119">type_id_native_to_raw()</a>, and <a class="el" href="low__lvl__packet_8cpp_source.html#l00108">type_id_to_str()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>net_flow/detail/<a class="el" href="low__lvl__packet_8hpp_source.html">low_lvl_packet.hpp</a></li>
<li>net_flow/detail/<a class="el" href="low__lvl__packet_8cpp_source.html">low_lvl_packet.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 19 2024 02:12:48 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
