<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::cfg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1cfg.html">cfg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">flow::cfg Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flow module that facilitates configuring modules, such as applications and APIs, via statically and/or dynamically parsed sets of name/value pairs from config sources like files and command lines.  
<a href="namespaceflow_1_1cfg.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceflow_1_1cfg_1_1fs"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg_1_1fs.html">fs</a></td></tr>
<tr class="memdesc:namespaceflow_1_1cfg_1_1fs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>namespace <a class="el" href="namespaceboost_1_1filesystem.html" title="We may add some ADL-based overloads into this namespace outside flow.">boost::filesystem</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceflow_1_1cfg_1_1opts"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg_1_1opts.html">opts</a></td></tr>
<tr class="memdesc:namespaceflow_1_1cfg_1_1opts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>namespace boost::program_options</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of static config and dynamic config, each, via that number of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> types supplied by the user as template arguments.  <a href="classflow_1_1cfg_1_1Config__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Dynamic__cfg__context.html">Dynamic_cfg_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which facilitates managing access to a dynamic configuration.  <a href="classflow_1_1cfg_1_1Dynamic__cfg__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility/traits type to concisely work with final-validation functions when calling methods like <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">Config_manager::apply_static()</a>.  <a href="structflow_1_1cfg_1_1Final__validator__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty <code>struct</code> suitable as a <code>*_value_set</code> template arg for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a>, when a slot requires a <code>Value_set</code>, but you have no config to actually parse there.  <a href="structflow_1_1cfg_1_1Null__value__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a given simple config-holding object, of the type <code>Value_set</code>, a template argument to this class template.  <a href="classflow_1_1cfg_1_1Option__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html">Option_set_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-templated base for <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.  <a href="classflow_1_1cfg_1_1Option__set__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html">Static_config_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a></code>-related adapter-style class that manages a simple config setup involving a single (though arbitrarily complex) <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> config store type <code>Value_set</code>, meant to be used only in static fashion.  <a href="classflow_1_1cfg_1_1Static__config__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a80b3319f3d3a657837d0d8b28d22ccc3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3">Final_validator_outcome</a> { <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567">S_ACCEPT</a>
, <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec">S_SKIP</a>
, <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316">S_FAIL</a>
 }</td></tr>
<tr class="memdesc:a80b3319f3d3a657837d0d8b28d22ccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result enumeration for a Final_validator_func::Type function which is used by a Config_manager user when parsing a config source (ex: file).  <a href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3">More...</a><br /></td></tr>
<tr class="separator:a80b3319f3d3a657837d0d8b28d22ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af310e567f2763a9736eda686030e6311"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:af310e567f2763a9736eda686030e6311"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#af310e567f2763a9736eda686030e6311">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; &amp;val)</td></tr>
<tr class="memdesc:af310e567f2763a9736eda686030e6311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> to a standard output stream.  <a href="namespaceflow_1_1cfg.html#af310e567f2763a9736eda686030e6311">More...</a><br /></td></tr>
<tr class="separator:af310e567f2763a9736eda686030e6311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696eee859b6e3f0fc0b6473a1d2836b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0">value_set_member_id_to_opt_name</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> member_id)</td></tr>
<tr class="memdesc:a696eee859b6e3f0fc0b6473a1d2836b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility, used by <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> internally but made available as a public API in case it is useful, that converts a string containing a conventionally formatted data member name into the corresponding auto-determined config option name.  <a href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0">More...</a><br /></td></tr>
<tr class="separator:a696eee859b6e3f0fc0b6473a1d2836b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaf432a612183beab72175831aaa960"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:aafaf432a612183beab72175831aaa960"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960">value_set_member_id_to_opt_name_keyed</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> member_id, const Key &amp;key)</td></tr>
<tr class="memdesc:aafaf432a612183beab72175831aaa960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0" title="Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...">value_set_member_id_to_opt_name()</a> but used by <a class="el" href="option__set_8hpp.html#a4fef7c1a28ef3510f71fae708c647590" title="Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), but with support for setting a value at a containe...">FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED()</a> internally (also made available as a public API in case it is useful), that does the job of <a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0" title="Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...">value_set_member_id_to_opt_name()</a> in addition to substituting the last <code>[...]</code> fragment with a dot separator, followed by the <code>ostream</code> encoding of <code>key</code>.  <a href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960">More...</a><br /></td></tr>
<tr class="separator:aafaf432a612183beab72175831aaa960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5ff766e52aae24e6d5c876b3b26e96"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a1f5ff766e52aae24e6d5c876b3b26e96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a> (std::ostream &amp;os, const Value &amp;val)</td></tr>
<tr class="memdesc:a1f5ff766e52aae24e6d5c876b3b26e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a value of type <code>Value</code> to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages.  <a href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">More...</a><br /></td></tr>
<tr class="separator:a1f5ff766e52aae24e6d5c876b3b26e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3782f31b7c020d7b08e250e89198ad4"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:ac3782f31b7c020d7b08e250e89198ad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#ac3782f31b7c020d7b08e250e89198ad4">value_to_ostream</a> (std::ostream &amp;os, const boost::chrono::duration&lt; Rep, Period &gt; &amp;val)</td></tr>
<tr class="memdesc:ac3782f31b7c020d7b08e250e89198ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that serializes a value of <code>chrono</code>-based <code>duration</code> including <code>Fine_duration</code> &ndash; which is recommended to use for Option_set-configured time durations &ndash; to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages.  <a href="namespaceflow_1_1cfg.html#ac3782f31b7c020d7b08e250e89198ad4">More...</a><br /></td></tr>
<tr class="separator:ac3782f31b7c020d7b08e250e89198ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d8d4f33601a06cb7bc109b22800387"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:a66d8d4f33601a06cb7bc109b22800387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a66d8d4f33601a06cb7bc109b22800387">value_to_ostream</a> (std::ostream &amp;os, const std::vector&lt; Element &gt; &amp;val)</td></tr>
<tr class="memdesc:a66d8d4f33601a06cb7bc109b22800387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that serializes a list value (with <code>Element</code> type itself similarly serializable) to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages.  <a href="namespaceflow_1_1cfg.html#a66d8d4f33601a06cb7bc109b22800387">More...</a><br /></td></tr>
<tr class="separator:a66d8d4f33601a06cb7bc109b22800387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe41c8484a878742976ddb84aa9e2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a> &gt;::Declare_options_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">null_declare_opts_func</a> ()</td></tr>
<tr class="memdesc:adfe41c8484a878742976ddb84aa9e2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value usable as <code>declare_opts_func_moved</code> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor arg for a <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> value set.  <a href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">More...</a><br /></td></tr>
<tr class="separator:adfe41c8484a878742976ddb84aa9e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4e0a153ec8216ead76450e900e386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">null_final_validator_func</a> ()</td></tr>
<tr class="memdesc:af1a4e0a153ec8216ead76450e900e386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value usable as <code>final_validator_func</code> arg to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">Config_manager::apply_static()</a> and others &ndash; for a <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> value set.  <a href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">More...</a><br /></td></tr>
<tr class="separator:af1a4e0a153ec8216ead76450e900e386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplParams" colspan="2">template&lt;typename... S_d_value_set&gt; </td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a453d83bf1e8b57b1aaff511fbe913ecc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;val)</td></tr>
<tr class="memdesc:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream.  <a href="namespaceflow_1_1cfg.html#a453d83bf1e8b57b1aaff511fbe913ecc">More...</a><br /></td></tr>
<tr class="separator:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2b6ae24d103455dda888e796830b7d"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a1d2b6ae24d103455dda888e796830b7d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1cfg.html#a1d2b6ae24d103455dda888e796830b7d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html">Static_config_manager</a>&lt; Value_set &gt; &amp;val)</td></tr>
<tr class="memdesc:a1d2b6ae24d103455dda888e796830b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> to a standard output stream.  <a href="namespaceflow_1_1cfg.html#a1d2b6ae24d103455dda888e796830b7d">More...</a><br /></td></tr>
<tr class="separator:a1d2b6ae24d103455dda888e796830b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac2f99fdb8f743e12d8f92553292dc8d6"><td class="memItemLeft" align="right" valign="top"><a id="ac2f99fdb8f743e12d8f92553292dc8d6" name="ac2f99fdb8f743e12d8f92553292dc8d6"></a>
const boost::regex&#160;</td><td class="memItemRight" valign="bottom"><b>VALUE_SET_MEMBER_ID_TO_OPT_NAME_KEYED_REGEX</b></td></tr>
<tr class="memdesc:ac2f99fdb8f743e12d8f92553292dc8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal constant for <a class="el" href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960" title="Similar to value_set_member_id_to_opt_name() but used by FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED() i...">value_set_member_id_to_opt_name_keyed()</a>. <br /></td></tr>
<tr class="separator:ac2f99fdb8f743e12d8f92553292dc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Flow module that facilitates configuring modules, such as applications and APIs, via statically and/or dynamically parsed sets of name/value pairs from config sources like files and command lines. </p>
<p >(It is also possible to use a subset of the provided features to simplify option-related tasks even without parsing them from a file/etc.)</p>
<h3>Main concepts: your <code>Value_set</code>s and <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">flow::cfg::Option_set</a></h3>
<p >"Configuration" has lots of possible meanings, and <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> certainly doesn't cover any huge range of what could be called configuration. Instead it is focused on a fairly common basic object type: a straightforward <code>struct</code> of essentially scalar values. (Composition/nested <code>struct</code>s are also supported, but don't worry about it yet.) Such <code>struct</code>s are often passed around larger programs and used to configure various modules. It is typically a given that each type V for a data member in such a <code>struct</code>:</p><ul>
<li>is copyable in a resonable way;</li>
<li>is comparable via <code>==</code> in a reasonable way.</li>
</ul>
<p >It is also reasonable that each member has some default value, set in the <code>struct</code> no-args ctor, so that the full set of values in a default-cted instance of the <code>struct</code> represents a reasonable overall config for the corresponding module.</p>
<p >It is also often desirable to print dumps of the current contents of such a <code>struct</code>. In that case we add the requirement on each type V:</p><ul>
<li>it has a standard <code>ostream</code> output <code>&lt;&lt;</code> operator.</li>
</ul>
<p >Often (though not always) one needs to <em>parse</em> into the member of this <code>struct</code>, from a stream/file or perhaps command line (one or more <em>config sources</em>). If this is indeed required then add the requirement on each V:</p><ul>
<li>it has a standard <code>istream</code> input <code>&gt;&gt;</code> operator.</li>
</ul>
<p >Sometimes such a <code>struct</code> is essentially <em>static</em>, meaning once the values are filled out (manually, or from a config source), they shouldn't change. More rarely they are <em>dynamic</em>, meaning values can change from time to time, particularly on outside events like a SIGHUP triggering reading values from a file. In the latter case it is typical to wrap them in <code>shared_ptr</code>s; then a piece of code can save a copy of such a handle to an immutable instance of the <code>struct</code>, wherein it can rely on a consistent set of config, even while dynamic config updates will cause more such instances to be generated over time. Hence add this requirement on the <code>struct</code> itself:</p><ul>
<li>it should derive from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html" title="Convenience class template that endows the given subclass T with nested aliases Ptr and Const_ptr ali...">util::Shared_ptr_alias_holder</a>, so as to gain <code>Ptr</code> and <code>Const_ptr</code> aliases (to <code>shared_ptr&lt;&gt;</code>).</li>
</ul>
<p >Call the <code>struct</code> type satisfying the above requirements <code>Value_set</code>. All facilities dealing with such value sets are templates parameterized on <code>Value_set</code>. Generally speaking it is straightforward to satisfy these requirements; for example they hold for ~all built-in scalar types, plus <code>chrono::duration</code>, <code>std::string</code>, and many more oft-used types; and deriving from <code>Shared_ptr_alias_holder</code> is just a line or two.</p>
<p >Maintaining a <code>Value_set</code> like that is straighforward, but the things one wants to do with with an <em>entire</em> <code>Value_set</code> &ndash; as opposed to individual members in it &ndash; tend to be laborious, anti-consistent, and error-prone to do. To wit:</p><ul>
<li>stream output (tediously list members along with laborious and inconsistent <code>ostream&lt;&lt;</code> logic);</li>
<li>parsing (it's just hard &ndash; and even with boost.program_options there's a ton of boiler-plate to write and tons of degrees of freedom);<ul>
<li>documenting the available settings/meanings/semantics to the user (help message);</li>
</ul>
</li>
<li>comparison <code>==</code> (tediously list <code>==</code> checks for each member);</li>
<li>validation/checking for valid values (tedious <code>if</code> statements and even more tedious stream output.</li>
</ul>
<p >Just about the only thing that <em>is</em> easy is simply accessing the values in a <code>Value_set</code>. Indeed, this is the one "feature" built-into <code>Value_set</code> that we want to leave available at all costs; it is concise, compile-time-checked, and fast (all of which is less true or untrue of, say, a <code>map&lt;string, boost::any&gt;</code> and similar solutions).</p>
<p >The main value of <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a>, as of this writing, is the <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> class template. <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> adds concise ways of doing all of the above in a streamlined way. Even if you need not actually parse your <code>Value_set</code> from a file, it still lets you concisely output, compare, validate the <code>Value_set</code>s themselves.</p>
<p >Therefore see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header. Do realize that it is expected to be common-place to have multiple <code>Value_set</code> types &ndash; and therefore separate <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code> instances for each. A server program, for example, might start with just a <code>Static_value_set</code> for initial, immutable config; and later add a <code>Dynamic_value_set</code> for settings that can change since startup. Flow itself has <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>, wherein (e.g.) <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> has a set of socket options, some static and some dynamically changeable once a connection is open; hence it might have a <code>struct</code> for dynamic socket options and another for static.</p>
<h3><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a></h3>
<p >An <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is designed to be used in flexible combination with other <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s. The variations on how one might use them are equally as unpredictable and varied as how one might use <code>Value_set</code>-type <code>struct</code>s.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> is an optional feature built on a couple of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s, one for dynamic and one for static config. It exists to provide a simple but often-sufficient config manager for use by a server process. Create one of these, fill out your process's overall static and dynamic config <code>struct</code>s, and you should be able to have a working config system with minimal boiler-plate, based on a static config file and command line; and a separate dynamic config file (with the optional ability to set initial dynamic setting values from the static config sources).</p>
<p >If <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> is insufficient, one can build their own system on top of <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> class template, the main feature of <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a>. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a80b3319f3d3a657837d0d8b28d22ccc3" name="a80b3319f3d3a657837d0d8b28d22ccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b3319f3d3a657837d0d8b28d22ccc3">&#9670;&nbsp;</a></span>Final_validator_outcome</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3">flow::cfg::Final_validator_outcome</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result enumeration for a <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html#a5475ab0b6e93f2ccded2aa8690ace0a4" title="Short-hand for a function that takes a parsed config set (meaning all values are individually OK) and...">Final_validator_func::Type</a> function which is used by a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> user when parsing a config source (ex: file). </p>
<p >In short such a function can consider the file as one to skip entirely, as okay to accept, or as erroneous. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567" name="a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567"></a>S_ACCEPT&#160;</td><td class="fielddoc"><p >The holistically-checked cumulative <code>Value_set</code> has no problems and shall be accepted into the candidate <code>Value_set</code>; if this is the final config-source (ex: file), that candidate shall be canonicalized. </p>
<p ><code>apply_*()</code> shall return <code>true</code> (success). </p>
</td></tr>
<tr><td class="fieldname"><a id="a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" name="a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec"></a>S_SKIP&#160;</td><td class="fielddoc"><p >The holistically-checked cumulative <code>Value_set</code> has contents such that the validator function decided that the <em>current</em> <code>apply_*()</code> shall have no effect, meaning the <code>Value_set</code> candidate shall remain unchanged from just-before that <em>current</em> <code>apply_*()</code>; if this is the final config-source (ex: file), that unchanged candidate shall be canonicalized. </p>
<p ><code>apply_*()</code> shall return <code>true</code> (success).</p>
<p ><code>S_SKIP</code> shall also have this effect on all subsequently scanned <code>Value_set</code>s in the same <code>apply_static()</code>, <code>apply_dynamic()</code>, or <code>apply_static_and_dynamic()</code> call; that is to say one SKIPped <code>Value_set</code> causes all subsequent ones to behave as-if they too were SKIPped. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" name="a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316"></a>S_FAIL&#160;</td><td class="fielddoc"><p >The holistically-checked cumulative <code>Value_set</code> has invalid contents; the candidate shall be rejected, and <code>apply_*()</code> shall return <code>false</code> (failure). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cfg__manager__fwd_8hpp_source.html#l00043">43</a> of file <a class="el" href="cfg__manager__fwd_8hpp_source.html">cfg_manager_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adfe41c8484a878742976ddb84aa9e2d8" name="adfe41c8484a878742976ddb84aa9e2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe41c8484a878742976ddb84aa9e2d8">&#9670;&nbsp;</a></span>null_declare_opts_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a> &gt;::Declare_options_func flow::cfg::null_declare_opts_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value usable as <code>declare_opts_func_moved</code> <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor arg for a <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> value set. </p>
<p >Naturally it does nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8cpp_source.html#l00026">26</a> of file <a class="el" href="cfg__manager_8cpp_source.html">cfg_manager.cpp</a>.</p>

</div>
</div>
<a id="af1a4e0a153ec8216ead76450e900e386" name="af1a4e0a153ec8216ead76450e900e386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4e0a153ec8216ead76450e900e386">&#9670;&nbsp;</a></span>null_final_validator_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a> &gt;::Type flow::cfg::null_final_validator_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value usable as <code>final_validator_func</code> arg to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">Config_manager::apply_static()</a> and others &ndash; for a <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> value set. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8cpp_source.html#l00031">31</a> of file <a class="el" href="cfg__manager_8cpp_source.html">cfg_manager.cpp</a>.</p>

<p class="reference">References <a class="el" href="cfg__manager_8hpp_source.html#l02712">flow::cfg::Final_validator_func&lt; Value_set &gt;::null()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1cfg_af1a4e0a153ec8216ead76450e900e386_cgraph.svg" width="340" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a453d83bf1e8b57b1aaff511fbe913ecc" name="a453d83bf1e8b57b1aaff511fbe913ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453d83bf1e8b57b1aaff511fbe913ecc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_d_value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cfg__manager_8hpp_source.html#l02718">2718</a> of file <a class="el" href="cfg__manager_8hpp_source.html">cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="af310e567f2763a9736eda686030e6311" name="af310e567f2763a9736eda686030e6311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af310e567f2763a9736eda686030e6311">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::cfg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes (briefly) an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="option__set_8hpp_source.html#l02154">2154</a> of file <a class="el" href="option__set_8hpp_source.html">option_set.hpp</a>.</p>

</div>
</div>
<a id="a1d2b6ae24d103455dda888e796830b7d" name="a1d2b6ae24d103455dda888e796830b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2b6ae24d103455dda888e796830b7d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; flow::cfg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html">Static_config_manager</a>&lt; Value_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="static__cfg__manager_8hpp_source.html#l00340">340</a> of file <a class="el" href="static__cfg__manager_8hpp_source.html">static_cfg_manager.hpp</a>.</p>

</div>
</div>
<a id="a696eee859b6e3f0fc0b6473a1d2836b0" name="a696eee859b6e3f0fc0b6473a1d2836b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696eee859b6e3f0fc0b6473a1d2836b0">&#9670;&nbsp;</a></span>value_set_member_id_to_opt_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::cfg::value_set_member_id_to_opt_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>member_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility, used by <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> internally but made available as a public API in case it is useful, that converts a string containing a conventionally formatted data member name into the corresponding auto-determined config option name. </p>
<dl class="section note"><dt>Note</dt><dd>An example for convenience, accurate as of the time of this writing: <code>m_cool_object.m_cool_sub_object-&gt;m_badass_sub_guy.m_cool_option_name</code> transforms to <code>cool-object.cool-sub-object.badass-sub-guy.cool-option-name</code>.</dd></dl>
<p>The format for the contents of <code>member_id</code> shall be as follows: It shall consist of one or more identifiers following the Flow coding guide, each starting with <code>m_</code>, concatenated with C++ object separator sequences, each sequence chosen to be either <code>.</code> (object dereference) or <code>-&gt;</code> (pointer dereference). <code>m_</code> for each identifier is optional for this function &ndash; though the coding guide requires it as of this writing anyway.</p>
<p >Note that boost.program_options allows config files (when used as config sources, e.g, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">Option_set::parse_config_file()</a>) to declare a <code>[config-section]</code> which results in each <code>option-name</code> listed in that section to be treated as-if named <code>config-section.option-name</code>. This has synergy with nested objects within a config value set being separated by dots also (or <code>-&gt;</code> if desired for orthogonal reasons, such as if a smart pointer is used).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_id</td><td>Identifier, perhaps obtained via the preprocessor <code>#feature</code> from an argument to a functional macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="option__set_8cpp_source.html#l00038">38</a> of file <a class="el" href="option__set_8cpp_source.html">option_set.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="option__set_8hpp_source.html#l02237">value_set_member_id_to_opt_name_keyed()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1cfg_a696eee859b6e3f0fc0b6473a1d2836b0_icgraph.svg" width="422" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aafaf432a612183beab72175831aaa960" name="aafaf432a612183beab72175831aaa960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaf432a612183beab72175831aaa960">&#9670;&nbsp;</a></span>value_set_member_id_to_opt_name_keyed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::cfg::value_set_member_id_to_opt_name_keyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>member_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0" title="Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...">value_set_member_id_to_opt_name()</a> but used by <a class="el" href="option__set_8hpp.html#a4fef7c1a28ef3510f71fae708c647590" title="Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), but with support for setting a value at a containe...">FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED()</a> internally (also made available as a public API in case it is useful), that does the job of <a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0" title="Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...">value_set_member_id_to_opt_name()</a> in addition to substituting the last <code>[...]</code> fragment with a dot separator, followed by the <code>ostream</code> encoding of <code>key</code>. </p>
<dl class="section note"><dt>Note</dt><dd>An example for convenience, accurate as of the time of this writing: <code>m_cool_object.m_cool_sub_object-&gt;m_badass_sub_guy[cool_key].m_cool_option_name</code>, with <code>cool_key == 3</code>, transforms to <code>cool-object.cool-sub-object.badass-sub-guy.3.cool-option-name</code>.</dd></dl>
<p>Behavior is undefined if the <code>[...]</code> part doesn't exist or is preceded or succeeded by nothing. In reality for things to work as expected that part should also be followed by a C++ object separator as in <a class="el" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0" title="Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...">value_set_member_id_to_opt_name()</a> doc header; so, e.g., <code>m_blah[idx]-&gt;m_blah</code> or <code>m_blah[idx].m_blah</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>An <code>ostream&lt;&lt;</code>able type. Common: <code>size_t</code> and <code>std::string</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member_id</td><td>Identifier, perhaps obtained via the preprocessor <code>#</code> feature from an argument to a functional macro. </td></tr>
    <tr><td class="paramname">key</td><td>The value to splice in when replacing the key fragment inside <code>[]</code> (after the inserted <code>.</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="option__set_8hpp_source.html#l02237">2237</a> of file <a class="el" href="option__set_8hpp_source.html">option_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00356">flow::util::ostream_op_string()</a>, <a class="el" href="option__set_8cpp_source.html#l00038">value_set_member_id_to_opt_name()</a>, and <a class="el" href="namespaceflow_1_1cfg.html#ac2f99fdb8f743e12d8f92553292dc8d6">VALUE_SET_MEMBER_ID_TO_OPT_NAME_KEYED_REGEX</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1cfg_aafaf432a612183beab72175831aaa960_cgraph.svg" width="771" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac3782f31b7c020d7b08e250e89198ad4" name="ac3782f31b7c020d7b08e250e89198ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3782f31b7c020d7b08e250e89198ad4">&#9670;&nbsp;</a></span>value_to_ostream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::cfg::value_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that serializes a value of <code>chrono</code>-based <code>duration</code> including <code>Fine_duration</code> &ndash; which is recommended to use for Option_set-configured time durations &ndash; to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages. </p>
<p >As of this writing it improves upon the default <code>ostream&lt;&lt;</code> behavior by converting to coarser units without losing precision (e.g., not <code>"9000000000 ns"</code> but <code>"9 s"</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>chrono::duration</code>. </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>chrono::duration</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="option__set_8hpp_source.html#l02166">2166</a> of file <a class="el" href="option__set_8hpp_source.html">option_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00356">flow::util::ostream_op_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1cfg_ac3782f31b7c020d7b08e250e89198ad4_cgraph.svg" width="654" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a66d8d4f33601a06cb7bc109b22800387" name="a66d8d4f33601a06cb7bc109b22800387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d8d4f33601a06cb7bc109b22800387">&#9670;&nbsp;</a></span>value_to_ostream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::cfg::value_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that serializes a list value (with <code>Element</code> type itself similarly serializable) to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>Any type for which <code>value_to_ostream(Element_type)</code> is available; but as of this writing it cannot itself be <code>std::vector&lt;&gt;</code> (no lists of lists). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="option__set_8hpp_source.html#l02222">2222</a> of file <a class="el" href="option__set_8hpp_source.html">option_set.hpp</a>.</p>

</div>
</div>
<a id="a1f5ff766e52aae24e6d5c876b3b26e96" name="a1f5ff766e52aae24e6d5c876b3b26e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5ff766e52aae24e6d5c876b3b26e96">&#9670;&nbsp;</a></span>value_to_ostream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::cfg::value_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a value of type <code>Value</code> to the given <code>ostream</code> suitably for output in Option_set-related output to user such as in help messages. </p>
<p >The generic version simply forwards to <code>ostream&lt;&lt;</code> operator; but specializations/overloads can massage/customize the output more suitably for usability. The user may provide their own specializations or overload on top of any already provided.</p>
<dl class="section see"><dt>See also</dt><dd>E.g.: the <code>Value = chrono::duration</code> overload. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Type of <code>val</code>. For this generic implementation <code>ostream &lt;&lt; Value</code> operator must exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="option__set_8hpp_source.html#l02160">2160</a> of file <a class="el" href="option__set_8hpp_source.html">option_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="option__set_8hpp_source.html#l01640">flow::cfg::Option_set&lt; Value_set &gt;::declare_option_for_help()</a>, <a class="el" href="option__set_8hpp_source.html#l01669">flow::cfg::Option_set_base::declare_option_for_output()</a>, <a class="el" href="option__set_8hpp_source.html#l01565">flow::cfg::Option_set&lt; Value_set &gt;::declare_option_for_parsing()</a>, and <a class="el" href="option__set_8hpp_source.html#l01611">flow::cfg::Option_set_base::throw_on_invalid_func()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1cfg_a1f5ff766e52aae24e6d5c876b3b26e96_icgraph.svg" width="562" height="259"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 20 2024 04:45:33 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
