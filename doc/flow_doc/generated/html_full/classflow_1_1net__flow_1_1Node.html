<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classflow_1_1net__flow_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer.  
 <a href="classflow_1_1net__flow_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node__inherit__graph.svg" width="487" height="191"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node__coll__graph.svg" width="2079" height="1960"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to a port in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd93ba39d6a9cdee60c2ad7da1085902"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">Node</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_endpoint, <a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *net_env_sim=0, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts=<a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>())</td></tr>
<tr class="memdesc:acd93ba39d6a9cdee60c2ad7da1085902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">More...</a><br /></td></tr>
<tr class="separator:acd93ba39d6a9cdee60c2ad7da1085902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c53c4848ea976b075a0b56f33eb118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">~Node</a> () override</td></tr>
<tr class="memdesc:a16c53c4848ea976b075a0b56f33eb118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">More...</a><br /></td></tr>
<tr class="separator:a16c53c4848ea976b075a0b56f33eb118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae148cec361b59237996a4b30c6624b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a> () const</td></tr>
<tr class="memdesc:aae148cec361b59237996a4b30c6624b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is operating.  <a href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">More...</a><br /></td></tr>
<tr class="separator:aae148cec361b59237996a4b30c6624b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">local_low_lvl_endpoint</a> () const</td></tr>
<tr class="memdesc:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">More...</a><br /></td></tr>
<tr class="separator:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c8393930110e2aa0823583e37cabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a893c8393930110e2aa0823583e37cabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an active connect to the specified remote Flow server.  <a href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">More...</a><br /></td></tr>
<tr class="separator:a893c8393930110e2aa0823583e37cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but sends, as part of the connection handshake, the user-supplied metadata, which the other side can access via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> after accepting the connection.  <a href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">More...</a><br /></td></tr>
<tr class="separator:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">More...</a><br /></td></tr>
<tr class="separator:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (blocking connect, with supplied metadata).  <a href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">More...</a><br /></td></tr>
<tr class="separator:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect(to, duration::max(), err_code, opt)s</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">More...</a><br /></td></tr>
<tr class="separator:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1043586a0e6413b1118d6c090bf89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6db1043586a0e6413b1118d6c090bf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2" title="A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...">sync_connect_with_metadata()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">More...</a><br /></td></tr>
<tr class="separator:a6db1043586a0e6413b1118d6c090bf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2cd6a6c328a2d5381308258d35d95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">listen</a> (<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts=0)</td></tr>
<tr class="memdesc:a3c2cd6a6c328a2d5381308258d35d95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a server on the given local Flow port and returns <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which can be used to accept subsequent incoming connections to this server.  <a href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">More...</a><br /></td></tr>
<tr class="separator:a3c2cd6a6c328a2d5381308258d35d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100464cf0126dbbad39bde1c90a774f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">event_set_create</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ad100464cf0126dbbad39bde1c90a774f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> state with no sockets/events stored; returns this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">More...</a><br /></td></tr>
<tr class="separator:ad100464cf0126dbbad39bde1c90a774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1124027c715d674f113f2d961e4c6861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">interrupt_all_waits</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a1124027c715d674f113f2d961e4c6861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blocking operation's outcome was being interrupted.  <a href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">More...</a><br /></td></tr>
<tr class="separator:a1124027c715d674f113f2d961e4c6861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779cc2429651696df1bca8de73534f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">set_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2779cc2429651696df1bca8de73534f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>) with the given options set.  <a href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">More...</a><br /></td></tr>
<tr class="separator:a2779cc2429651696df1bca8de73534f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b9c2b9a8a969f5e3715341c433aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">options</a> () const</td></tr>
<tr class="memdesc:a159b9c2b9a8a969f5e3715341c433aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s option set and returns that copy.  <a href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">More...</a><br /></td></tr>
<tr class="separator:a159b9c2b9a8a969f5e3715341c433aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7b471dd6cd3e3570930b48d30e577"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a> () const</td></tr>
<tr class="memdesc:a4bd7b471dd6cd3e3570930b48d30e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes of user data per received or sent block on connections generated from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, unless this value is overridden in the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (or friend).  <a href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">More...</a><br /></td></tr>
<tr class="separator:a4bd7b471dd6cd3e3570930b48d30e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1ecd7c03349fcb26b9692d300a759463"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">S_NUM_PORTS</a> = Port_space::S_NUM_PORTS</td></tr>
<tr class="memdesc:a1ecd7c03349fcb26b9692d300a759463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow ports in the port space, including <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">More...</a><br /></td></tr>
<tr class="separator:a1ecd7c03349fcb26b9692d300a759463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b913c5c759a465a9fcaa637ddaea99"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">S_NUM_SERVICE_PORTS</a> = Port_space::S_NUM_SERVICE_PORTS</td></tr>
<tr class="memdesc:aa1b913c5c759a465a9fcaa637ddaea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "service" ports (ones that can be reserved by number with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>).  <a href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">More...</a><br /></td></tr>
<tr class="separator:aa1b913c5c759a465a9fcaa637ddaea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aadcad6c19587cd0d788570194b2afd"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">S_NUM_EPHEMERAL_PORTS</a> = Port_space::S_NUM_EPHEMERAL_PORTS</td></tr>
<tr class="memdesc:a7aadcad6c19587cd0d788570194b2afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "ephemeral" ports (ones reserved locally at random with <code>Node::listen(S_PORT_ANY)</code> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>).  <a href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">More...</a><br /></td></tr>
<tr class="separator:a7aadcad6c19587cd0d788570194b2afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b593d90c246cb2e35fc6a0834e6876"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">S_FIRST_SERVICE_PORT</a> = Port_space::S_FIRST_SERVICE_PORT</td></tr>
<tr class="memdesc:a96b593d90c246cb2e35fc6a0834e6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest service port, making the range of service ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">S_NUM_SERVICE_PORTS</a> - 1].  <a href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">More...</a><br /></td></tr>
<tr class="separator:a96b593d90c246cb2e35fc6a0834e6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1021e099c70c1a6e192e65f86debf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">S_FIRST_EPHEMERAL_PORT</a> = Port_space::S_FIRST_EPHEMERAL_PORT</td></tr>
<tr class="memdesc:aa1d1021e099c70c1a6e192e65f86debf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">S_NUM_EPHEMERAL_PORTS</a> - 1].  <a href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">More...</a><br /></td></tr>
<tr class="separator:aa1d1021e099c70c1a6e192e65f86debf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memTemplParams" colspan="2">template&lt;typename Peer_socket_impl_type &gt; </td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">sock_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to newly created <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or sub-instance like <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>, depending on the template parameter.  <a href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">More...</a><br /></td></tr>
<tr class="separator:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a"><td class="memTemplParams" colspan="2">template&lt;typename Server_socket_impl_type &gt; </td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">serv_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts)</td></tr>
<tr class="memdesc:ab330b19f4039bab074251111789b568a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c" title="Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...">sock_create_forward_plus_ctor_args()</a> but for Server_sockets.  <a href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">More...</a><br /></td></tr>
<tr class="separator:ab330b19f4039bab074251111789b568a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ab13749ccdf4ab44445f21c77296ffa13"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a> = 0</td></tr>
<tr class="memdesc:ab13749ccdf4ab44445f21c77296ffa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type and value to supply as user-supplied metadata in SYN, if user chooses to use <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a></code> instead of <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">More...</a><br /></td></tr>
<tr class="separator:ab13749ccdf4ab44445f21c77296ffa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a4f175a1923aeef5eee39bd726e88c93a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">Udp_socket</a> = boost::asio::ip::udp::socket</td></tr>
<tr class="memdesc:a4f175a1923aeef5eee39bd726e88c93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for UDP socket.  <a href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">More...</a><br /></td></tr>
<tr class="separator:a4f175a1923aeef5eee39bd726e88c93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44af106f110963a465065a7ea19185a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3">Timer_ptr</a> = boost::shared_ptr&lt; <a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">util::Timer</a> &gt;</td></tr>
<tr class="memdesc:a44af106f110963a465065a7ea19185a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">boost.asio timer wrapped in a ref-counted pointer.  <a href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3">More...</a><br /></td></tr>
<tr class="separator:a44af106f110963a465065a7ea19185a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2fe94f0b1064d35ce99c58bc95dc0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">Signal_set</a> = boost::asio::signal_set</td></tr>
<tr class="memdesc:a1c2fe94f0b1064d35ce99c58bc95dc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a signal set.  <a href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">More...</a><br /></td></tr>
<tr class="separator:a1c2fe94f0b1064d35ce99c58bc95dc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4903f254cff9d2605ace404174203138"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">Options_mutex</a> = <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Peer_socket::Options_mutex</a></td></tr>
<tr class="memdesc:a4903f254cff9d2605ace404174203138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for high-performance, non-reentrant, exclusive mutex used to lock <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">More...</a><br /></td></tr>
<tr class="separator:a4903f254cff9d2605ace404174203138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c8679c70ac9c7dda394fdf335aaed7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">Options_lock</a> = <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Peer_socket::Options_lock</a></td></tr>
<tr class="memdesc:a97c8679c70ac9c7dda394fdf335aaed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for lock that acquires exclusive access to an <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138" title="Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.">Options_mutex</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">More...</a><br /></td></tr>
<tr class="separator:a97c8679c70ac9c7dda394fdf335aaed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc902bc41381d21f4ca2d4073bb617c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">Socket_id_to_socket_map</a> = boost::unordered_map&lt; <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &gt;</td></tr>
<tr class="memdesc:abfc902bc41381d21f4ca2d4073bb617c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from the connection ID (= remote-local socket pair) to the local <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> that is the local portion of the connection.  <a href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">More...</a><br /></td></tr>
<tr class="separator:abfc902bc41381d21f4ca2d4073bb617c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">Port_to_server_map</a> = boost::unordered_map&lt; <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> &gt;</td></tr>
<tr class="memdesc:a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from the local Flow port to the local <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> listening on that port.  <a href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">More...</a><br /></td></tr>
<tr class="separator:a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff19033bff73d4f51766a9575c01f883"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">Event_sets</a> = boost::unordered_set&lt; <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> &gt;</td></tr>
<tr class="memdesc:aff19033bff73d4f51766a9575c01f883"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects.  <a href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">More...</a><br /></td></tr>
<tr class="separator:aff19033bff73d4f51766a9575c01f883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5b056ed753b832458f44f537acfe86d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7">worker_run</a> (const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> low_lvl_endpoint)</td></tr>
<tr class="memdesc:a5b056ed753b832458f44f537acfe86d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread W (main event loop) body.  <a href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7">More...</a><br /></td></tr>
<tr class="separator:a5b056ed753b832458f44f537acfe86d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa894fd58b246c2a8d6c7c7d25a8748cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa894fd58b246c2a8d6c7c7d25a8748cb">this_thread_init_logger_setup</a> (const std::string &amp;thread_type, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger=0)</td></tr>
<tr class="memdesc:aa894fd58b246c2a8d6c7c7d25a8748cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to invoke for each thread in which this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> executes, whether or not it starts that thread, that applies certain common settings to all subsequent logging from that thread.  <a href="classflow_1_1net__flow_1_1Node.html#aa894fd58b246c2a8d6c7c7d25a8748cb">More...</a><br /></td></tr>
<tr class="separator:aa894fd58b246c2a8d6c7c7d25a8748cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2595f47710ddb06cfb22b6710b7286e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e">validate_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts, <a class="el" href="classbool.html">bool</a> init, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:ab2595f47710ddb06cfb22b6710b7286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a new set of <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> intended to replace (or initialize) a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>, ensures that these new option values are legal.  <a href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e">More...</a><br /></td></tr>
<tr class="separator:ab2595f47710ddb06cfb22b6710b7286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa99dc4800a49b7b958b585717eb50b"><td class="memTemplParams" colspan="2">template&lt;typename Opt_type &gt; </td></tr>
<tr class="memitem:a8aa99dc4800a49b7b958b585717eb50b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b">validate_static_option</a> (const Opt_type &amp;new_val, const Opt_type &amp;old_val, const std::string &amp;opt_id, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a8aa99dc4800a49b7b958b585717eb50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that compares <code>new_val</code> to <code>old_val</code> and, if they are not equal, logs and returns an error; used to ensure static options are not changed.  <a href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b">More...</a><br /></td></tr>
<tr class="separator:a8aa99dc4800a49b7b958b585717eb50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9511f3ba50d19f2c32a8de94f0a306e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9511f3ba50d19f2c32a8de94f0a306e8">validate_option_check</a> (<a class="el" href="classbool.html">bool</a> check, const std::string &amp;check_str, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a9511f3ba50d19f2c32a8de94f0a306e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that, if the given condition is false, logs and returns an error; used to check for option value validity when setting options.  <a href="classflow_1_1net__flow_1_1Node.html#a9511f3ba50d19f2c32a8de94f0a306e8">More...</a><br /></td></tr>
<tr class="separator:a9511f3ba50d19f2c32a8de94f0a306e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c42121d48a55a43a48e3a84bd10595"><td class="memTemplParams" colspan="2">template&lt;typename Opt_type &gt; </td></tr>
<tr class="memitem:a43c42121d48a55a43a48e3a84bd10595"><td class="memTemplItemLeft" align="right" valign="top">Opt_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">opt</a> (const Opt_type &amp;opt_val_ref) const</td></tr>
<tr class="memdesc:a43c42121d48a55a43a48e3a84bd10595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a copy of the value of a given option in a thread-safe manner.  <a href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">More...</a><br /></td></tr>
<tr class="separator:a43c42121d48a55a43a48e3a84bd10595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8466d9c810da5edea443d665b24dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb">perform_regular_infrequent_tasks</a> (<a class="el" href="classbool.html">bool</a> reschedule)</td></tr>
<tr class="memdesc:aee8466d9c810da5edea443d665b24dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat logging and schedules the next time this should happen.  <a href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb">More...</a><br /></td></tr>
<tr class="separator:aee8466d9c810da5edea443d665b24dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade12d2ebbd88b62432089a3a071b9514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ade12d2ebbd88b62432089a3a071b9514">async_low_lvl_recv</a> ()</td></tr>
<tr class="memdesc:ade12d2ebbd88b62432089a3a071b9514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers so that during the current or next <code>m_task_engine.run()</code>, the latter will wait for a receivable UDP packet and, when one is available, will call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ade12d2ebbd88b62432089a3a071b9514">More...</a><br /></td></tr>
<tr class="separator:ade12d2ebbd88b62432089a3a071b9514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9909cd2b2a77c57da9e35fcef0f8a4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5">low_lvl_recv_and_handle</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> sys_err_code)</td></tr>
<tr class="memdesc:a9909cd2b2a77c57da9e35fcef0f8a4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the pre-condition that <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> has a UDP packet available for reading, or that there was an error in waiting for this pre-condition.  <a href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5">More...</a><br /></td></tr>
<tr class="separator:a9909cd2b2a77c57da9e35fcef0f8a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ecbad1ff3a8d2fe4b3ad1c474f7513"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513">handle_incoming_with_simulation</a> (<a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *packet_data, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint, <a class="el" href="classbool.html">bool</a> is_sim_duplicate_packet=false)</td></tr>
<tr class="memdesc:a90ecbad1ff3a8d2fe4b3ad1c474f7513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> that calls <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a> on the not-yet-deserialized low-level packet just read off the UDP socket, but first handles simulation of various network conditions like latency, loss, and duplication.  <a href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513">More...</a><br /></td></tr>
<tr class="separator:a90ecbad1ff3a8d2fe4b3ad1c474f7513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4368247d07e930bdd07ab8d2425c6de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8">async_wait_latency_then_handle_incoming</a> (const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;latency, <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *packet_data, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint)</td></tr>
<tr class="memdesc:a4368247d07e930bdd07ab8d2425c6de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up <code>handle_incoming(packet_data, low_lvl_remote_endpoint)</code> to be called asynchronously after a specified period of time.  <a href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8">More...</a><br /></td></tr>
<tr class="separator:a4368247d07e930bdd07ab8d2425c6de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db2bb587e0407077b11368df075f0ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff">async_sock_low_lvl_packet_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> &amp;&amp;packet, <a class="el" href="classbool.html">bool</a> delayed_by_pacing)</td></tr>
<tr class="memdesc:a0db2bb587e0407077b11368df075f0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a> wrapper to call when <code>packet</code> is to be sent to the remote side of the connection <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff">More...</a><br /></td></tr>
<tr class="separator:a0db2bb587e0407077b11368df075f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5752bf3848f31abbe753be47c1fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a08a5752bf3848f31abbe753be47c1fcf">async_no_sock_low_lvl_packet_send</a> (const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet)</td></tr>
<tr class="memdesc:a08a5752bf3848f31abbe753be47c1fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a> wrapper to call when <code>packet</code> is to be sent to the remote side of the connection <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a08a5752bf3848f31abbe753be47c1fcf">More...</a><br /></td></tr>
<tr class="separator:a08a5752bf3848f31abbe753be47c1fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f302fe63e36f72931e1a759b0aaaed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4">async_low_lvl_packet_send_impl</a> (const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet, <a class="el" href="classbool.html">bool</a> delayed_by_pacing, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a9f302fe63e36f72931e1a759b0aaaed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> specified by the given UDP endpoint.  <a href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4">More...</a><br /></td></tr>
<tr class="separator:a9f302fe63e36f72931e1a759b0aaaed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0055a25892990585561e69ceb02214d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5">low_lvl_packet_sent</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet, size_t bytes_expected_transferred, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;sys_err_code, size_t bytes_transferred)</td></tr>
<tr class="memdesc:a0055a25892990585561e69ceb02214d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion handler for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>; called when the packet is either successfully fed to the UDP net-stack for sending, or when there is an error in doing so.  <a href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5">More...</a><br /></td></tr>
<tr class="separator:a0055a25892990585561e69ceb02214d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2983d0d8a4d4eb5c3402f63f68ef44d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8">mark_data_packet_sent</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;seq_num)</td></tr>
<tr class="memdesc:a2983d0d8a4d4eb5c3402f63f68ef44d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs important book-keeping based on the event "DATA packet was sent to destination." The affected data structures are: Sent_packet::m_sent_when (for the Sent_packet in question), <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af392484f79ffcead4f74ca351672d8d4" title="Time at which the last Data_packet low-level packet for this connection was sent.">Peer_socket::m_snd_last_data_sent_when</a>, <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">Peer_socket::m_snd_drop_timer</a> (in <code>*sock</code>).  <a href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8">More...</a><br /></td></tr>
<tr class="separator:a2983d0d8a4d4eb5c3402f63f68ef44d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6a82a1390a76e985593969fb47184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a74a6a82a1390a76e985593969fb47184">async_no_sock_low_lvl_rst_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> causing_packet, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint)</td></tr>
<tr class="memdesc:a74a6a82a1390a76e985593969fb47184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an RST to the given UDP endpoint in response to the given incoming low-level packet that came from that endpoint, when there is no associated <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> for that remote endpoint/local port combo.  <a href="classflow_1_1net__flow_1_1Node.html#a74a6a82a1390a76e985593969fb47184">More...</a><br /></td></tr>
<tr class="separator:a74a6a82a1390a76e985593969fb47184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31edf238c1b21a409ea807c66c1b22f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0">async_sock_low_lvl_packet_send_paced</a> (const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;sock, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> &amp;&amp;packet, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a31edf238c1b21a409ea807c66c1b22f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the process of asynchronously sending the given low-level packet to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> specified by the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0">More...</a><br /></td></tr>
<tr class="separator:a31edf238c1b21a409ea807c66c1b22f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e1f8e6da36d7cd3ad905924aea376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a62e1f8e6da36d7cd3ad905924aea376c">sock_pacing_new_packet_ready</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> packet, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a62e1f8e6da36d7cd3ad905924aea376c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Handles a DATA or ACK packet that was just passed into <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>, i.e., is available for sending.  <a href="classflow_1_1net__flow_1_1Node.html#a62e1f8e6da36d7cd3ad905924aea376c">More...</a><br /></td></tr>
<tr class="separator:a62e1f8e6da36d7cd3ad905924aea376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb88dafa8ec5c1b412de86dfdccd9c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#afb88dafa8ec5c1b412de86dfdccd9c8f">sock_pacing_new_time_slice</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;now)</td></tr>
<tr class="memdesc:afb88dafa8ec5c1b412de86dfdccd9c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Resets the socket's <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> structure to reflect that a new pacing time slice should begin right now.  <a href="classflow_1_1net__flow_1_1Node.html#afb88dafa8ec5c1b412de86dfdccd9c8f">More...</a><br /></td></tr>
<tr class="separator:afb88dafa8ec5c1b412de86dfdccd9c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0acf9de5f151727a43acce180a5e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49">sock_pacing_process_q</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code, <a class="el" href="classbool.html">bool</a> executing_after_delay)</td></tr>
<tr class="memdesc:aaf0acf9de5f151727a43acce180a5e49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Given that we are currently in the pacing time slice in <code>sock-&gt;m_snd_pacing_data</code>, sends as many queued packets as possible given the time slice's budget, and if any remain queued after this, schedules for them to be sent in the next time slice.  <a href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49">More...</a><br /></td></tr>
<tr class="separator:aaf0acf9de5f151727a43acce180a5e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd57a0d025a78cbeccfd8a15a983575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3fd57a0d025a78cbeccfd8a15a983575">sock_pacing_time_slice_end</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;sys_err_code)</td></tr>
<tr class="memdesc:a3fd57a0d025a78cbeccfd8a15a983575"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: If <a class="el" href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49" title="async_sock_low_lvl_packet_send_paced() pacing helper: Given that we are currently in the pacing time ...">sock_pacing_process_q()</a> ran out of the last time slice's budget and still had packets to send, this is the handler that triggers when the out-of-budget time slice ends.  <a href="classflow_1_1net__flow_1_1Node.html#a3fd57a0d025a78cbeccfd8a15a983575">More...</a><br /></td></tr>
<tr class="separator:a3fd57a0d025a78cbeccfd8a15a983575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f7c019665d9dd91af0ad6431f8f97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d">async_sock_low_lvl_packet_send_or_close_immediately</a> (const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;sock, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> &amp;&amp;packet, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:aa5f7c019665d9dd91af0ad6431f8f97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> except it also calls <code>close_connection_immediately(sock)</code> if the former fails.  <a href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d">More...</a><br /></td></tr>
<tr class="separator:aa5f7c019665d9dd91af0ad6431f8f97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03aa88df3d1d3981454ee3356e868c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">async_sock_low_lvl_rst_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:ad03aa88df3d1d3981454ee3356e868c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an RST to the other side of the given socket asynchronously when possible.  <a href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">More...</a><br /></td></tr>
<tr class="separator:ad03aa88df3d1d3981454ee3356e868c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287eae1113865dba06c103cf023404ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a287eae1113865dba06c103cf023404ae">sync_sock_low_lvl_rst_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a287eae1113865dba06c103cf023404ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an RST to the other side of the given socket, synchronously.  <a href="classflow_1_1net__flow_1_1Node.html#a287eae1113865dba06c103cf023404ae">More...</a><br /></td></tr>
<tr class="separator:a287eae1113865dba06c103cf023404ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1699dfdaf3e5ebe1b1d715a9c306d116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116">handle_incoming</a> (<a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *packet_data, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint)</td></tr>
<tr class="memdesc:a1699dfdaf3e5ebe1b1d715a9c306d116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-received, not-yet-deserialized low-level packet.  <a href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116">More...</a><br /></td></tr>
<tr class="separator:a1699dfdaf3e5ebe1b1d715a9c306d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fba26db0055a969f3869014bc5c2bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc">perform_accumulated_on_recv_tasks</a> ()</td></tr>
<tr class="memdesc:a0fba26db0055a969f3869014bc5c2bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs all tasks to be performed at the end of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a>, as determined over the course of the execution of either of those methods.  <a href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc">More...</a><br /></td></tr>
<tr class="separator:a0fba26db0055a969f3869014bc5c2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f9ebea458490c37a38760c8335506c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">handle_syn_ack_to_syn_sent</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt; syn_ack)</td></tr>
<tr class="memdesc:aa0f9ebea458490c37a38760c8335506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed low-level SYN_ACK packet delivered to the given peer socket in <code>S_SYN_SENT</code> state.  <a href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">More...</a><br /></td></tr>
<tr class="separator:aa0f9ebea458490c37a38760c8335506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3d760b3c880b41e5a4ee7f2c13fd81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">handle_syn_ack_to_established</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt; syn_ack)</td></tr>
<tr class="memdesc:abb3d760b3c880b41e5a4ee7f2c13fd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed, duplicate (equal to already-received SYN_ACK) low-level SYN_ACK packet delivered to the given peer socket in <code>S_ESTABLISHED</code> state.  <a href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">More...</a><br /></td></tr>
<tr class="separator:abb3d760b3c880b41e5a4ee7f2c13fd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4cea2eefa1b06975864f09740c96b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">handle_data_to_established</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet, <a class="el" href="classbool.html">bool</a> syn_rcvd_qd_packet)</td></tr>
<tr class="memdesc:a06e4cea2eefa1b06975864f09740c96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer socket in <code>S_ESTABLISHED</code> state.  <a href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">More...</a><br /></td></tr>
<tr class="separator:a06e4cea2eefa1b06975864f09740c96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd969c7a16b2ea8bb7f0db6fa454df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">sock_categorize_data_to_established</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet, <a class="el" href="classbool.html">bool</a> *dupe, <a class="el" href="classbool.html">bool</a> *slide, size_t *slide_size)</td></tr>
<tr class="memdesc:acfbd969c7a16b2ea8bb7f0db6fa454df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that categorizes the DATA packet received as either illegal; legal but duplicate of a previously received DATA packet; legal but out-of-order; and finally legal and in-order.  <a href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">More...</a><br /></td></tr>
<tr class="separator:acfbd969c7a16b2ea8bb7f0db6fa454df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab414ebd0e2d27f02ed51270dab90c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">sock_data_to_rcv_buf_unless_overflow</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet)</td></tr>
<tr class="memdesc:aab414ebd0e2d27f02ed51270dab90c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to pass the payload of the given DATA packet to the given socket's Receive buffer for user consumption; but detects and reports overflow if appropriate, instead.  <a href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">More...</a><br /></td></tr>
<tr class="separator:aab414ebd0e2d27f02ed51270dab90c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40595ee69bfb87fd64005bc8443329dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">sock_rcv_buf_now_readable</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classbool.html">bool</a> syn_rcvd_qd_packet)</td></tr>
<tr class="memdesc:a40595ee69bfb87fd64005bc8443329dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that assumes the given's socket Receive buffer is currently readable and handles implications on the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> subsystem.  <a href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">More...</a><br /></td></tr>
<tr class="separator:a40595ee69bfb87fd64005bc8443329dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea53f6b451895e8efcdc68ba8770a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">sock_track_new_data_after_gap_rexmit_off</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet, size_t data_size, <a class="el" href="classbool.html">bool</a> *slide, size_t *slide_size)</td></tr>
<tr class="memdesc:a0ea53f6b451895e8efcdc68ba8770a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register the given DATA packet as an out-of-order packet in <code>sock-&gt;m_rcv_packets_with_gaps</code> &ndash; in retransmission-off mode.  <a href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">More...</a><br /></td></tr>
<tr class="separator:a0ea53f6b451895e8efcdc68ba8770a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9f88761fc18c4f9e0d5f4dd6b4bc95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">sock_data_to_reassembly_q_unless_overflow</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet)</td></tr>
<tr class="memdesc:a0f9f88761fc18c4f9e0d5f4dd6b4bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register the given DATA packet as an out-of-order packet in the reassembly queue <code>sock-&gt;m_rcv_packets_with_gaps</code> &ndash; in retransmission-on mode; but detects and reports overflow if appropriate, instead.  <a href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">More...</a><br /></td></tr>
<tr class="separator:a0f9f88761fc18c4f9e0d5f4dd6b4bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74adc7d61419f4beb7941d418a31a648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">sock_slide_rcv_next_seq_num</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, size_t slide_size, <a class="el" href="classbool.html">bool</a> reassembly_in_progress)</td></tr>
<tr class="memdesc:a74adc7d61419f4beb7941d418a31a648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register a set of received DATA packet data as in-order payload in the structures <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> in <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">More...</a><br /></td></tr>
<tr class="separator:a74adc7d61419f4beb7941d418a31a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d9838b735786bfed40fc1c437808d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">sock_max_packets_after_unrecvd_packet</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a31d9838b735786bfed40fc1c437808d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the max size for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> for <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">More...</a><br /></td></tr>
<tr class="separator:a31d9838b735786bfed40fc1c437808d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece1750c8f0bee297af113f8808b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">async_acknowledge_packet</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;seq_num, unsigned int rexmit_id, size_t data_size)</td></tr>
<tr class="memdesc:a8ece1750c8f0bee297af113f8808b7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes an acknowledgment of the given received packet to be included in a future <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a> sent to the other side.  <a href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">More...</a><br /></td></tr>
<tr class="separator:a8ece1750c8f0bee297af113f8808b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45583714bc147300158f074ecacce0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">handle_accumulated_pending_acks</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a45583714bc147300158f074ecacce0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that handles any additional individual outgoing acknowledgments accumulated during the currently running receive handler.  <a href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">More...</a><br /></td></tr>
<tr class="separator:a45583714bc147300158f074ecacce0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3574d50742fa0b1230c049f4b29fd3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">rcv_get_first_gap_info</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="el" href="classbool.html">bool</a> *first_gap_exists, <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *seq_num_after_first_gap)</td></tr>
<tr class="memdesc:a3574d50742fa0b1230c049f4b29fd3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that gets simple info about <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> in <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">More...</a><br /></td></tr>
<tr class="separator:a3574d50742fa0b1230c049f4b29fd3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fdb686165aae42f474cc655fca80c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">log_rcv_window</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="el" href="classbool.html">bool</a> force_verbose_info_logging=false) const</td></tr>
<tr class="memdesc:ac2fdb686165aae42f474cc655fca80c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs TRACE or DATA messages that show the detailed state of the receiving sequence number space.  <a href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">More...</a><br /></td></tr>
<tr class="separator:ac2fdb686165aae42f474cc655fca80c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515b28350c43635728d6de0e37ccb94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">handle_ack_to_established</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html">Ack_packet</a> &gt; ack)</td></tr>
<tr class="memdesc:ab515b28350c43635728d6de0e37ccb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a> state.  <a href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">More...</a><br /></td></tr>
<tr class="separator:ab515b28350c43635728d6de0e37ccb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136d9ccd25634cee2955ea79ae829006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">handle_accumulated_acks</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a136d9ccd25634cee2955ea79ae829006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that handles any incoming acknowledgments and rcv_wnd updates accumulated during the currently running receive handler.  <a href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">More...</a><br /></td></tr>
<tr class="separator:a136d9ccd25634cee2955ea79ae829006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055ee380cf87f83c06d7380821c4679e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">categorize_individual_ack</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack, <a class="el" href="classbool.html">bool</a> *dupe_or_late, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> *acked_pkt_it)</td></tr>
<tr class="memdesc:a055ee380cf87f83c06d7380821c4679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that categorizes the given accumulated individual acknowledgment w/r/t legality and validity; determines the DATA packet being acked if possible; logs and record stats accordingly; and closes underlying socket if ack is illegal.  <a href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">More...</a><br /></td></tr>
<tr class="separator:a055ee380cf87f83c06d7380821c4679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeccd8c86fcd54733e42593629fad96b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">compute_rtt_on_ack</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> flying_pkt, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;time_now, <a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a> **sent_when) const</td></tr>
<tr class="memdesc:adeccd8c86fcd54733e42593629fad96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that computes the RTT implied by a given individual acknowledgment.  <a href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">More...</a><br /></td></tr>
<tr class="separator:adeccd8c86fcd54733e42593629fad96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b88eadca41228fe6a671f2f14ead0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">new_round_trip_time_sample</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> round_trip_time)</td></tr>
<tr class="memdesc:ae9b88eadca41228fe6a671f2f14ead0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-computed new RTT (round trip time) measurement for an individual packet earlier sent: updates smoothed RTT, DTO, and anything else relevant.  <a href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">More...</a><br /></td></tr>
<tr class="separator:ae9b88eadca41228fe6a671f2f14ead0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3326b5bdc85b43232f55e2b2ec1dbe60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">categorize_pkts_as_dropped_on_acks</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const boost::unordered_set&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> &gt; &amp;flying_now_acked_pkts)</td></tr>
<tr class="memdesc:a3326b5bdc85b43232f55e2b2ec1dbe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that determines the range of In-flight packets that should be Dropped due to given individual acks that have just been processed; and updates the relevant <code>m_acks_after_me</code> members in the socket.  <a href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">More...</a><br /></td></tr>
<tr class="separator:a3326b5bdc85b43232f55e2b2ec1dbe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac910f24e5a176c4aa01992b08b62146a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">drop_pkts_on_acks</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> &amp;last_dropped_pkt_it, size_t *cong_ctl_dropped_pkts, size_t *cong_ctl_dropped_bytes, size_t *dropped_pkts, size_t *dropped_bytes, std::vector&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> &gt; *pkts_marked_to_drop)</td></tr>
<tr class="memdesc:ac910f24e5a176c4aa01992b08b62146a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that acts on the determination made by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60" title="Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...">categorize_pkts_as_dropped_on_acks()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">More...</a><br /></td></tr>
<tr class="separator:ac910f24e5a176c4aa01992b08b62146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfde94f7d529ea8e6c26b560abfa9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">log_accumulated_acks</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a1bfde94f7d529ea8e6c26b560abfa9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006" title="Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...">handle_accumulated_acks()</a> that logs the about-to-be-handled accumulated individual acknowledgments.  <a href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">More...</a><br /></td></tr>
<tr class="separator:a1bfde94f7d529ea8e6c26b560abfa9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbc6abb1e344c6e98d3ac8068a54670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">drop_timer_action</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classbool.html">bool</a> drop_all_packets)</td></tr>
<tr class="memdesc:affbc6abb1e344c6e98d3ac8068a54670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">Peer_socket::m_snd_drop_timer</a>) event in ESTABLISHED state by dropping the specified packets.  <a href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">More...</a><br /></td></tr>
<tr class="separator:affbc6abb1e344c6e98d3ac8068a54670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24785d3e04e0a9cd5daca43bc867e5aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">log_snd_window</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="el" href="classbool.html">bool</a> force_verbose_info_logging=false) const</td></tr>
<tr class="memdesc:a24785d3e04e0a9cd5daca43bc867e5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs TRACE or DATA messages thats show the detailed state of the sending sequence number space.  <a href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">More...</a><br /></td></tr>
<tr class="separator:a24785d3e04e0a9cd5daca43bc867e5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac619d1a96cc62d223f990ee6a3c909ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">connect_worker</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> *sock)</td></tr>
<tr class="memdesc:ac619d1a96cc62d223f990ee6a3c909ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">More...</a><br /></td></tr>
<tr class="separator:ac619d1a96cc62d223f990ee6a3c909ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e2786f5d1eeb068a828902a631a39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">sync_connect_impl</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts)</td></tr>
<tr class="memdesc:a49e2786f5d1eeb068a828902a631a39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation core of <code>sync_connect*()</code> that gets rid of templated or missing arguments thereof.  <a href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">More...</a><br /></td></tr>
<tr class="separator:a49e2786f5d1eeb068a828902a631a39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1485c07049d4bee70ad4ef2fc07bf12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">setup_connection_timers</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classbool.html">bool</a> initial)</td></tr>
<tr class="memdesc:ac1485c07049d4bee70ad4ef2fc07bf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming we've just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some amount of time, so that we may try the SYN[_ACK] again if we don't get the acknowledgement by then (or we may close socket after too many such retries).  <a href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">More...</a><br /></td></tr>
<tr class="separator:ac1485c07049d4bee70ad4ef2fc07bf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd654cb6b1ccff34ddccbe5226be8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">handle_connection_rexmit_timer_event</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:addd654cb6b1ccff34ddccbe5226be8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the triggering of the retransmit timer wait set up by <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12" title="Assuming we&#39;ve just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some a...">setup_connection_timers()</a>; it will re-send the SYN or SYN_ACK.  <a href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">More...</a><br /></td></tr>
<tr class="separator:addd654cb6b1ccff34ddccbe5226be8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9cf4d7160b3e27b3b0131fc4507ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">cancel_timers</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a3f9cf4d7160b3e27b3b0131fc4507ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any timers and scheduled tasks active in the given socket.  <a href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">More...</a><br /></td></tr>
<tr class="separator:a3f9cf4d7160b3e27b3b0131fc4507ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab427ebc124a6233ae48a7562662a6e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">setup_drop_timer</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:ab427ebc124a6233ae48a7562662a6e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Drop Timer and saves it to <code>sock-&gt;m_snd_drop_timer</code>.  <a href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">More...</a><br /></td></tr>
<tr class="separator:ab427ebc124a6233ae48a7562662a6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6461124e5bc3e59083e172e26029e632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">close_abruptly</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a6461124e5bc3e59083e172e26029e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of non-blocking <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632" title="Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...">close_abruptly()</a></code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">More...</a><br /></td></tr>
<tr class="separator:a6461124e5bc3e59083e172e26029e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade49e7bc7202a0adf33fec2d93d1b177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">close_connection_immediately</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;err_code, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:ade49e7bc7202a0adf33fec2d93d1b177"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED (including eliminating the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from our data structures).  <a href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">More...</a><br /></td></tr>
<tr class="separator:ade49e7bc7202a0adf33fec2d93d1b177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bca5c11ac5a4763fed6ce146fe733e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_packet::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">create_syn</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</td></tr>
<tr class="memdesc:a5bca5c11ac5a4763fed6ce146fe733e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">More...</a><br /></td></tr>
<tr class="separator:a5bca5c11ac5a4763fed6ce146fe733e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcd840049c57150cdaa5c59d22c488b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_ack_packet::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">create_syn_ack</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</td></tr>
<tr class="memdesc:a6bcd840049c57150cdaa5c59d22c488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7" title="Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...">create_syn()</a> but for SYN_ACK.  <a href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">More...</a><br /></td></tr>
<tr class="separator:a6bcd840049c57150cdaa5c59d22c488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf55766783893827061fd85cab2634f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acaf55766783893827061fd85cab2634f">async_low_lvl_syn_ack_ack_send_or_close_immediately</a> (const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt; &amp;syn_ack)</td></tr>
<tr class="memdesc:acaf55766783893827061fd85cab2634f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create, fully fill out, and asynchronously send via <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d" title="Similar to async_sock_low_lvl_packet_send_paced() except it also calls close_connection_immediately(s...">async_sock_low_lvl_packet_send_or_close_immediately()</a> a SYN_ACK_ACK packet.  <a href="classflow_1_1net__flow_1_1Node.html#acaf55766783893827061fd85cab2634f">More...</a><br /></td></tr>
<tr class="separator:acaf55766783893827061fd85cab2634f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70a0c32695e417e7a09e0ba773f151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">rst_and_close_connection_immediately</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;err_code, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:afe70a0c32695e417e7a09e0ba773f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously send RST to the other side of the given socket and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">More...</a><br /></td></tr>
<tr class="separator:afe70a0c32695e417e7a09e0ba773f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d1f49638ef8ce8883e7477a06d3fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aa19d1f49638ef8ce8883e7477a06d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of non-blocking <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>.  <a href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">More...</a><br /></td></tr>
<tr class="separator:aa19d1f49638ef8ce8883e7477a06d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0756fc7301d0cfa66f19e681a9c60c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">sock_is_writable</a> (const boost::any &amp;sock_as_any) const</td></tr>
<tr class="memdesc:a0756fc7301d0cfa66f19e681a9c60c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if calling <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> with at least some arguments would return either non-zero (i.e., successfully enqueued data to send) or zero and an error (but not zero and NO error).  <a href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">More...</a><br /></td></tr>
<tr class="separator:a0756fc7301d0cfa66f19e681a9c60c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2565b7c0bd82cad86eb168b62f8ffd9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">send_worker_check_state</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a2565b7c0bd82cad86eb168b62f8ffd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a> onto W to invoke <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> but ensures that the socket has not entered some state such that sending data is not possible and no longer going to be possible.  <a href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">More...</a><br /></td></tr>
<tr class="separator:a2565b7c0bd82cad86eb168b62f8ffd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a92f11a2c9f218cdd9a55f282e79b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">send_worker</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:a10a92f11a2c9f218cdd9a55f282e79b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread W implemention of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a>: synchronously or asynchronously send the contents of <code>sock-&gt;m_snd_buf</code> to the other side.  <a href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">More...</a><br /></td></tr>
<tr class="separator:a10a92f11a2c9f218cdd9a55f282e79b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395ac534047f06629962ad19b3fa657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">can_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a7395ac534047f06629962ad19b3fa657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers the perennial question of congestion and flow control: assuming there is a DATA packet to send to the other side on the given socket, should we do so at this moment? Over a perfect link and with a perfect receiver, this would always return true, and we would always send every packet as soon as we could make it.  <a href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">More...</a><br /></td></tr>
<tr class="separator:a7395ac534047f06629962ad19b3fa657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb96858fd7b3c9ddd7c6fe8078809c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">receive</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;rcv_buf_consume_func, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:addbb96858fd7b3c9ddd7c6fe8078809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of non-blocking sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>.  <a href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">More...</a><br /></td></tr>
<tr class="separator:addbb96858fd7b3c9ddd7c6fe8078809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44feae2c97b4bc1fe1f14f83e932d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">sock_is_readable</a> (const boost::any &amp;sock_as_any) const</td></tr>
<tr class="memdesc:aa44feae2c97b4bc1fe1f14f83e932d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if calling sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> with at least some arguments would return either non-zero (i.e., successfully dequeued received data) or zero and an error (but not zero and NO error).  <a href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">More...</a><br /></td></tr>
<tr class="separator:aa44feae2c97b4bc1fe1f14f83e932d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf95363b26c0c676979437e34db357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">receive_wnd_updated</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a08cf95363b26c0c676979437e34db357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> onto W if it has dequeued data from Receive buffer and given it to the user, which would free up space in the Receive buffer, which <em>possibly</em> should result in a window update sent to the server, so that it knows it can now send more data.  <a href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">More...</a><br /></td></tr>
<tr class="separator:a08cf95363b26c0c676979437e34db357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192d4b95b9f8a5c3d08b1e5486eb6f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">async_rcv_wnd_recovery</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, size_t rcv_wnd)</td></tr>
<tr class="memdesc:a192d4b95b9f8a5c3d08b1e5486eb6f78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357" title="Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...">receive_wnd_updated()</a> helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a rcv_wnd advertisement only and schedules the next iteration of a timer to have this occur again, unless that timer is canceled due to too long a recovery phase or DATA packets arriving from the other side.  <a href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">More...</a><br /></td></tr>
<tr class="separator:a192d4b95b9f8a5c3d08b1e5486eb6f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b05340098b0eb66f88a6a7e5f3d36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">receive_wnd_recovery_data_received</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a45b05340098b0eb66f88a6a7e5f3d36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pertaining to the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78" title="receive_wnd_updated() helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a r...">async_rcv_wnd_recovery()</a> mechanism, this handles the event that we have received an acceptable (either into Receive buffer or reassembly queue) DATA packet from the other side.  <a href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">More...</a><br /></td></tr>
<tr class="separator:a45b05340098b0eb66f88a6a7e5f3d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac397d3fd163f1456b7bb370a3cff951c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:ac397d3fd163f1456b7bb370a3cff951c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the currently correct rcv_wnd value; that is the amount of space free in Receive buffer for the given socket.  <a href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">More...</a><br /></td></tr>
<tr class="separator:ac397d3fd163f1456b7bb370a3cff951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad608f9bbe76426f4fbf4bf5af908e4e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">receive_emptied_rcv_buf_while_disconnecting</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:ad608f9bbe76426f4fbf4bf5af908e4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> onto W during a graceful close, after the Receive buffer had been emptied by the user; determines whether the socket can now proceed to <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code> and be removed from the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">More...</a><br /></td></tr>
<tr class="separator:ad608f9bbe76426f4fbf4bf5af908e4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e50276d0b162f6577adc690e0ef9e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a81e50276d0b162f6577adc690e0ef9e0">async_low_lvl_ack_send</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classbool.html">bool</a> defer_delta_check, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;sys_err_code=<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>())</td></tr>
<tr class="memdesc:a81e50276d0b162f6577adc690e0ef9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a low-level ACK packet, with all accumulated in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">Peer_socket::m_rcv_pending_acks</a> of <code>sock</code> individual packet acknowledgments, to the other side's UDP endpoint.  <a href="classflow_1_1net__flow_1_1Node.html#a81e50276d0b162f6577adc690e0ef9e0">More...</a><br /></td></tr>
<tr class="separator:a81e50276d0b162f6577adc690e0ef9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382b607fa2e482886f2fd75edc36b8b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a382b607fa2e482886f2fd75edc36b8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if and only if there are enough data either in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a845f21b754ef641b65b1fe44727fb429" title="If retransmission is on, this is the retransmission queue.">Peer_socket::m_snd_rexmit_q</a> of <code>sock</code> (if retransmission is on) or in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">Peer_socket::m_snd_buf</a> of <code>sock</code> to send a DATA packet to the other side.  <a href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">More...</a><br /></td></tr>
<tr class="separator:a382b607fa2e482886f2fd75edc36b8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d124ba678e2ab72f8c6d28140ca137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">snd_buf_enqable</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a70d124ba678e2ab72f8c6d28140ca137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if and only if there is enough free space in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">Peer_socket::m_snd_buf</a> of <code>sock</code> to enqueue any given atomic piece of user data.  <a href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">More...</a><br /></td></tr>
<tr class="separator:a70d124ba678e2ab72f8c6d28140ca137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cae2884eaf67d77c9f8cf56b31e4c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">rcv_buf_deqable</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a8cae2884eaf67d77c9f8cf56b31e4c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if and only if there are enough data in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">Peer_socket::m_rcv_buf</a> of <code>sock</code> to give the user some data in a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> call.  <a href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">More...</a><br /></td></tr>
<tr class="separator:a8cae2884eaf67d77c9f8cf56b31e4c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d9656e9e1480021c87530ec6dbebbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">sock_set_int_state</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a> new_state)</td></tr>
<tr class="memdesc:aa1d9656e9e1480021c87530ec6dbebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets internal state of given socket to the given state and logs a TRACE message about it.  <a href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">More...</a><br /></td></tr>
<tr class="separator:aa1d9656e9e1480021c87530ec6dbebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad502e0a992a79b71af42a9cdc20a4280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">sock_set_state</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> state, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Peer_socket::Open_sub_state</a> open_sub_state=<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>)</td></tr>
<tr class="memdesc:ad502e0a992a79b71af42a9cdc20a4280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">Peer_socket::m_open_sub_state</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">More...</a><br /></td></tr>
<tr class="separator:ad502e0a992a79b71af42a9cdc20a4280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9357f6ce9d5fc249b1cc176afdc471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">sock_disconnect_detected</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;disconnect_cause, <a class="el" href="classbool.html">bool</a> close)</td></tr>
<tr class="memdesc:ada9357f6ce9d5fc249b1cc176afdc471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records that thread W shows underlying connection is broken (graceful termination, or error) and sets <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">Peer_socket::m_disconnect_cause</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">Peer_socket::m_open_sub_state</a> accordingly.  <a href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">More...</a><br /></td></tr>
<tr class="separator:ada9357f6ce9d5fc249b1cc176afdc471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade529b5452c9fe363ae468346e662ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">sock_disconnect_completed</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:ade529b5452c9fe363ae468346e662ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">While in <code>S_OPEN</code>+<code>S_DISCONNECTING</code> state (i.e., after beginning a graceful close with <code>sock_disconnect_detected(..., false)</code>, moves the socket to <code>S_CLOSED</code> state and clears Receive/Send buffers and any other decently memory-consuming structures.  <a href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">More...</a><br /></td></tr>
<tr class="separator:ade529b5452c9fe363ae468346e662ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5f13062bec6730db533cc1e89bf515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">sock_free_memory</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a1d5f13062bec6730db533cc1e89bf515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that clears all non-O(1)-space data structures stored inside <code>sock</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">More...</a><br /></td></tr>
<tr class="separator:a1d5f13062bec6730db533cc1e89bf515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ee7115c70cbcd48e3897d32fc0276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">sock_validate_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *prev_opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a446ee7115c70cbcd48e3897d32fc0276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e" title="Given a new set of Node_options intended to replace (or initialize) a Node&#39;s m_opts,...">validate_options()</a> but checks per-socket options instead of per-Node options.  <a href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">More...</a><br /></td></tr>
<tr class="separator:a446ee7115c70cbcd48e3897d32fc0276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea4a9941c6138d9c025401b1f85ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">sock_set_options</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aadea4a9941c6138d9c025401b1f85ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread W implementation of sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">More...</a><br /></td></tr>
<tr class="separator:aadea4a9941c6138d9c025401b1f85ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ad769737db60dd637365010b80f4f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">sock_info</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</td></tr>
<tr class="memdesc:a07ad769737db60dd637365010b80f4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>sock-&gt;info()</code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">More...</a><br /></td></tr>
<tr class="separator:a07ad769737db60dd637365010b80f4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2336fae98b318ab73e7268e9a242bf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> *stats) const</td></tr>
<tr class="memdesc:a2336fae98b318ab73e7268e9a242bf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, copies all stats info (as available via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">Peer_socket::info()</a>) from various structures into the given stats <code>struct</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">More...</a><br /></td></tr>
<tr class="separator:a2336fae98b318ab73e7268e9a242bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af576c6156f5d69682e664d9ff3922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">snd_flying_pkts_erase_one</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> pkt_it)</td></tr>
<tr class="memdesc:a43af576c6156f5d69682e664d9ff3922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases (for example if considered Acknowledged or Dropped) a packet <code>struct</code> from the "scoreboard" (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>) and adjusts all related structures.  <a href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">More...</a><br /></td></tr>
<tr class="separator:a43af576c6156f5d69682e664d9ff3922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a3e10ef08b93daf87ea5f0f1e87062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">snd_flying_pkts_push_one</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;seq_num, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> sent_pkt)</td></tr>
<tr class="memdesc:a52a3e10ef08b93daf87ea5f0f1e87062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new packet <code>struct</code> (presumably representing packet to be sent shortly) to the "scoreboard" (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>) and adjusts all related structures as applicable.  <a href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">More...</a><br /></td></tr>
<tr class="separator:a52a3e10ef08b93daf87ea5f0f1e87062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00124a034c8fdac6f300900bdfcc8cfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">snd_flying_pkts_updated</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> pkt_begin, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> &amp;pkt_end, <a class="el" href="classbool.html">bool</a> added)</td></tr>
<tr class="memdesc:a00124a034c8fdac6f300900bdfcc8cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480" title="The number of bytes contained in all In-flight packets, used at least for comparison against the cong...">Peer_socket::m_snd_flying_bytes</a> according to an operation (add packets, remove packets) caller is about to undertake or has just undertaken on <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a> (= the scoreboard).  <a href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">More...</a><br /></td></tr>
<tr class="separator:a00124a034c8fdac6f300900bdfcc8cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39d69abde4efa88d5d40e1c529c1a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">ok_to_rexmit_or_close</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> &amp;pkt_it, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:af39d69abde4efa88d5d40e1c529c1a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given sent packet has been retransmitted the maximum number of allowed times; if so then performs <a class="el" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151" title="Asynchronously send RST to the other side of the given socket and close_connection_immediately().">rst_and_close_connection_immediately()</a> and returns <code>false</code>; otherwise returns <code>true</code>.  <a href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">More...</a><br /></td></tr>
<tr class="separator:af39d69abde4efa88d5d40e1c529c1a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755c329b9e0f2b8edb2e5b900bd2a337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">sock_log_detail</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) const</td></tr>
<tr class="memdesc:a755c329b9e0f2b8edb2e5b900bd2a337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs a verbose state report for the given socket.  <a href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">More...</a><br /></td></tr>
<tr class="separator:a755c329b9e0f2b8edb2e5b900bd2a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daaa6a5a7d0b7e5a2266dd9db400c01"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">sock_create</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a6daaa6a5a7d0b7e5a2266dd9db400c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal factory used for ALL <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects created by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (including subclasses).  <a href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">More...</a><br /></td></tr>
<tr class="separator:a6daaa6a5a7d0b7e5a2266dd9db400c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c67514c259404de3f27a8cae8b0567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567">accept</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:ac3c67514c259404de3f27a8cae8b0567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of non-blocking <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> for server socket <code>serv</code> in all cases except when <code>serv-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">Server_socket::State::S_CLOSED</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567">More...</a><br /></td></tr>
<tr class="separator:ac3c67514c259404de3f27a8cae8b0567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b26bff4cdf545f22d8edec7185c5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a51b26bff4cdf545f22d8edec7185c5c4">serv_is_acceptable</a> (const boost::any &amp;serv_as_any) const</td></tr>
<tr class="memdesc:a51b26bff4cdf545f22d8edec7185c5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if calling <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> with at least some arguments would return either non-null (i.e., successfully dequeued a connected socket) or null and an error (but not null and NO error).  <a href="classflow_1_1net__flow_1_1Node.html#a51b26bff4cdf545f22d8edec7185c5c4">More...</a><br /></td></tr>
<tr class="separator:a51b26bff4cdf545f22d8edec7185c5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba411df8746d5fd4db2d28df3a016f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aba411df8746d5fd4db2d28df3a016f5e">listen_worker</a> (<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> *serv)</td></tr>
<tr class="memdesc:aba411df8746d5fd4db2d28df3a016f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#aba411df8746d5fd4db2d28df3a016f5e">More...</a><br /></td></tr>
<tr class="separator:aba411df8746d5fd4db2d28df3a016f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf5c3b5e6b9f9f1658b60907b36a498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aaaf5c3b5e6b9f9f1658b60907b36a498">handle_syn_to_listening_server</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html">Syn_packet</a> &gt; syn, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_remote_endpoint)</td></tr>
<tr class="memdesc:aaaf5c3b5e6b9f9f1658b60907b36a498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed low-level SYN packet delivered to the given server socket.  <a href="classflow_1_1net__flow_1_1Node.html#aaaf5c3b5e6b9f9f1658b60907b36a498">More...</a><br /></td></tr>
<tr class="separator:aaaf5c3b5e6b9f9f1658b60907b36a498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d02f9e302c7b06288ff1c644fa8d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a29d02f9e302c7b06288ff1c644fa8d65">handle_syn_ack_ack_to_syn_rcvd</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html">Syn_ack_ack_packet</a> &gt; syn_ack_ack)</td></tr>
<tr class="memdesc:a29d02f9e302c7b06288ff1c644fa8d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed low-level SYN_ACK_ACK packet delivered to the given peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a> state.  <a href="classflow_1_1net__flow_1_1Node.html#a29d02f9e302c7b06288ff1c644fa8d65">More...</a><br /></td></tr>
<tr class="separator:a29d02f9e302c7b06288ff1c644fa8d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf80b7de1398e93d1d4289ef5bf2ae2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c">handle_data_to_syn_rcvd</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; packet)</td></tr>
<tr class="memdesc:abf80b7de1398e93d1d4289ef5bf2ae2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer socket in SYN_RCVD state.  <a href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c">More...</a><br /></td></tr>
<tr class="separator:abf80b7de1398e93d1d4289ef5bf2ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6d71af81def2d030f0fef159c1b06d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#adf6d71af81def2d030f0fef159c1b06d">close_empty_server_immediately</a> (const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;err_code, <a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:adf6d71af81def2d030f0fef159c1b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the transition of the given server socket from <code>S_LISTENING</code>/<code>S_CLOSING</code> to <code>S_CLOSED</code> (including eliminating the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from our data structures).  <a href="classflow_1_1net__flow_1_1Node.html#adf6d71af81def2d030f0fef159c1b06d">More...</a><br /></td></tr>
<tr class="separator:adf6d71af81def2d030f0fef159c1b06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bac29a091e1026e5b4f0b5d84a710c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0bac29a091e1026e5b4f0b5d84a710c7">serv_set_state</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a> state)</td></tr>
<tr class="memdesc:a0bac29a091e1026e5b4f0b5d84a710c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a783f81f10b50f62a638aa26b72d49e36" title="See state(). Should be set before user gets access to *this. Must not be modified by non-W threads.">Server_socket::m_state</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a0bac29a091e1026e5b4f0b5d84a710c7">More...</a><br /></td></tr>
<tr class="separator:a0bac29a091e1026e5b4f0b5d84a710c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af9ec4f1483cd9a2183286f7dfa9c87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2af9ec4f1483cd9a2183286f7dfa9c87">serv_close_detected</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;disconnect_cause, <a class="el" href="classbool.html">bool</a> close)</td></tr>
<tr class="memdesc:a2af9ec4f1483cd9a2183286f7dfa9c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records that thread W shows this socket is not to listen to incoming connections and is to abort any not-yet-established (i.e., not yet queued) and established-but-unclaimed (i.e., queued) connections; and sets <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ae87a97dcfaa0909789b76ef4462d6a0b" title="The Error_code causing this server&#39;s move from LISTENING state (if this has occurred); otherwise a cl...">Server_socket::m_disconnect_cause</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a783f81f10b50f62a638aa26b72d49e36" title="See state(). Should be set before user gets access to *this. Must not be modified by non-W threads.">Server_socket::m_state</a> in <code>serv</code> accordingly.  <a href="classflow_1_1net__flow_1_1Node.html#a2af9ec4f1483cd9a2183286f7dfa9c87">More...</a><br /></td></tr>
<tr class="separator:a2af9ec4f1483cd9a2183286f7dfa9c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0204e999b5dc28ee9b5db6eae9aa1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abf0204e999b5dc28ee9b5db6eae9aa1a">serv_peer_socket_acceptable</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:abf0204e999b5dc28ee9b5db6eae9aa1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records that an unestablished socket <code>sock</code> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a>) has just become established and can be <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>ed (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>).  <a href="classflow_1_1net__flow_1_1Node.html#abf0204e999b5dc28ee9b5db6eae9aa1a">More...</a><br /></td></tr>
<tr class="separator:abf0204e999b5dc28ee9b5db6eae9aa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0379c897bdb3e4eddeb759547be78261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0379c897bdb3e4eddeb759547be78261">serv_peer_socket_init</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a0379c897bdb3e4eddeb759547be78261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a new (just received SYN) peer socket from the given server socket.  <a href="classflow_1_1net__flow_1_1Node.html#a0379c897bdb3e4eddeb759547be78261">More...</a><br /></td></tr>
<tr class="separator:a0379c897bdb3e4eddeb759547be78261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6c02bf520a16df4028bd3c88732a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">serv_peer_socket_closed</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a8a6c02bf520a16df4028bd3c88732a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records that a <code><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a></code>-contained (i.e., currently un-established, or established but not yet accepted by user) <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is being closed and should be removed from the given <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">More...</a><br /></td></tr>
<tr class="separator:a8a6c02bf520a16df4028bd3c88732a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a91542fce634cf6a749c71f225b105a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a0a91542fce634cf6a749c71f225b105a">serv_create</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts)</td></tr>
<tr class="memdesc:a0a91542fce634cf6a749c71f225b105a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal factory used for ALL <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects created by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (including subclasses).  <a href="classflow_1_1net__flow_1_1Node.html#a0a91542fce634cf6a749c71f225b105a">More...</a><br /></td></tr>
<tr class="separator:a0a91542fce634cf6a749c71f225b105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4dc3d8e294bbc8423e111f52e414ae"><td class="memTemplParams" colspan="2">template&lt;typename Socket , typename Non_blocking_func_ret_type &gt; </td></tr>
<tr class="memitem:a2a4dc3d8e294bbc8423e111f52e414ae"><td class="memTemplItemLeft" align="right" valign="top">Non_blocking_func_ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">sync_op</a> (typename Socket::Ptr sock, const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; Non_blocking_func_ret_type()&gt; &amp;non_blocking_func, Non_blocking_func_ret_type would_block_ret_val, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a2a4dc3d8e294bbc8423e111f52e414ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of core <em>blocking</em> transfer methods, namely <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a> for all cases except when <code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">More...</a><br /></td></tr>
<tr class="separator:a2a4dc3d8e294bbc8423e111f52e414ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a14a4749f34d07c71bb2a1214d65f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f">event_set_async_wait</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set, const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_set::Event_handler</a> &amp;on_event, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aa18a14a4749f34d07c71bb2a1214d65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> when <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f">More...</a><br /></td></tr>
<tr class="separator:aa18a14a4749f34d07c71bb2a1214d65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a21e69d3ae442b2cc06220514de364a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4a21e69d3ae442b2cc06220514de364a">event_set_check_baseline_assuming_state</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set)</td></tr>
<tr class="memdesc:a4a21e69d3ae442b2cc06220514de364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f" title="Implementation of Event_set::async_wait() when Event_set::state() == Event_set::State::S_INACTIVE.">event_set_async_wait()</a> onto thread W to invoke <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8" title="Checks each desired (Event_set::m_want) event in event_set; any that holds true is saved into event_s...">event_set_check_baseline()</a> but first ensure that the <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> event_set</code> has not exited <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">Event_set::State::S_WAITING</a> (which would make any checking for active events nonsense).  <a href="classflow_1_1net__flow_1_1Node.html#a4a21e69d3ae442b2cc06220514de364a">More...</a><br /></td></tr>
<tr class="separator:a4a21e69d3ae442b2cc06220514de364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2195fb7d86acfaf340b3e7e59e7e10e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8">event_set_check_baseline</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set)</td></tr>
<tr class="memdesc:a2195fb7d86acfaf340b3e7e59e7e10e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks each desired (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">Event_set::m_want</a>) event in <code>event_set</code>; any that holds true is saved into <code>event_set</code> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a>).  <a href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8">More...</a><br /></td></tr>
<tr class="separator:a2195fb7d86acfaf340b3e7e59e7e10e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdefbbb3c3b9f2f2866f6b4c770fa62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#afdefbbb3c3b9f2f2866f6b4c770fa62d">event_set_fire_if_got_events</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set)</td></tr>
<tr class="memdesc:afdefbbb3c3b9f2f2866f6b4c770fa62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> contains any active sockets (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a>); if so, signals the user (who previously called <code>async_wait()</code> to set all this in motion): set state back to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> from <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">Event_set::State::S_WAITING</a>; calls the handler passed to <code>async_wait()</code>; forgets handler.  <a href="classflow_1_1net__flow_1_1Node.html#afdefbbb3c3b9f2f2866f6b4c770fa62d">More...</a><br /></td></tr>
<tr class="separator:afdefbbb3c3b9f2f2866f6b4c770fa62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4ddf81ddbeab1f740940c4cc0d3625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">event_set_all_check_delta</a> (<a class="el" href="classbool.html">bool</a> defer_delta_check)</td></tr>
<tr class="memdesc:a8a4ddf81ddbeab1f740940c4cc0d3625"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each WAITING <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> within the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>: checks for any events that hold, and if any do hold, signals the user (calls handler, goes to INACTIVE, etc.).  <a href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">More...</a><br /></td></tr>
<tr class="separator:a8a4ddf81ddbeab1f740940c4cc0d3625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ee0d42d38f3b98d032dee1549f8c4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a44ee0d42d38f3b98d032dee1549f8c4c">event_set_close</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a44ee0d42d38f3b98d032dee1549f8c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a> when <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> != <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a></code> for <code>event_set</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a44ee0d42d38f3b98d032dee1549f8c4c">More...</a><br /></td></tr>
<tr class="separator:a44ee0d42d38f3b98d032dee1549f8c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6727ca42e15c8627c1ed3d94e6dd7a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6727ca42e15c8627c1ed3d94e6dd7a53">event_set_close_worker</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set)</td></tr>
<tr class="memdesc:a6727ca42e15c8627c1ed3d94e6dd7a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The guts of event_set_close_worker_check_state(): same thing, but assumes <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a></code>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a0dda853ab017dd9bfcfb71b601d15698" title="Mutex protecting ALL data in this object.">Event_set::m_mutex</a> is locked (for <code>event_set</code>).  <a href="classflow_1_1net__flow_1_1Node.html#a6727ca42e15c8627c1ed3d94e6dd7a53">More...</a><br /></td></tr>
<tr class="separator:a6727ca42e15c8627c1ed3d94e6dd7a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2840a7a95f16b7e222e449e3d6b9aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca">interrupt_all_waits_worker</a> ()</td></tr>
<tr class="memdesc:ad2840a7a95f16b7e222e449e3d6b9aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">interrupt_all_waits()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca">More...</a><br /></td></tr>
<tr class="separator:ad2840a7a95f16b7e222e449e3d6b9aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996cab95eb139d00f0d430093e64a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae996cab95eb139d00f0d430093e64a5f">interrupt_all_waits_internal_sig_handler</a> (const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;sys_err_code, int sig_number)</td></tr>
<tr class="memdesc:ae996cab95eb139d00f0d430093e64a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>signal_set</code> handler, executed on SIGINT and SIGTERM, if user has enabled this feature: causes <a class="el" href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca" title="Thread W implementation of interrupt_all_waits().">interrupt_all_waits_worker()</a> to occur on thread W.  <a href="classflow_1_1net__flow_1_1Node.html#ae996cab95eb139d00f0d430093e64a5f">More...</a><br /></td></tr>
<tr class="separator:ae996cab95eb139d00f0d430093e64a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a99836ffb51eaefa4d2cc21770461cd97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</td></tr>
<tr class="memdesc:a99836ffb51eaefa4d2cc21770461cd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the socket pair (connection ID) for the given socket.  <a href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">More...</a><br /></td></tr>
<tr class="separator:a99836ffb51eaefa4d2cc21770461cd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837d37e6eb06fb6df4666bac327d20f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">snd_past_last_flying_datum_seq_num</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock)</td></tr>
<tr class="memdesc:a837d37e6eb06fb6df4666bac327d20f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the sequence number for the datum just past the last (latest) In-flight (i.e., sent but neither Acknowledged nor Dropped) packet, for the given socket.  <a href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">More...</a><br /></td></tr>
<tr class="separator:a837d37e6eb06fb6df4666bac327d20f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d58cfa8fad00a116a38f76ccb2b868"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a> (<a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *seq_num, boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; data)</td></tr>
<tr class="memdesc:a80d58cfa8fad00a116a38f76ccb2b868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <code>*seq_num</code> points to the start of data.m_data, increments <code>*seq_num</code> to point to the datum just past <code>data-&gt;m_data</code>.  <a href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">More...</a><br /></td></tr>
<tr class="separator:a80d58cfa8fad00a116a38f76ccb2b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95399fe09e4bd18ac2a43b2fbec8ab17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a95399fe09e4bd18ac2a43b2fbec8ab17">advance_seq_num</a> (<a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *seq_num, size_t data_size)</td></tr>
<tr class="memdesc:a95399fe09e4bd18ac2a43b2fbec8ab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <code>*seq_num</code> points to the start of some data of the given size, increments <code>*seq_num</code> to point to the datum just past that amount of data.  <a href="classflow_1_1net__flow_1_1Node.html#a95399fe09e4bd18ac2a43b2fbec8ab17">More...</a><br /></td></tr>
<tr class="separator:a95399fe09e4bd18ac2a43b2fbec8ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f1fd8b524ffe63dfa6b7ca76b1a43"><td class="memTemplParams" colspan="2">template&lt;typename Packet_map_iter &gt; </td></tr>
<tr class="memitem:a663f1fd8b524ffe63dfa6b7ca76b1a43"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">get_seq_num_range</a> (const Packet_map_iter &amp;packet_it, <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *seq_num_start, <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *seq_num_end)</td></tr>
<tr class="memdesc:a663f1fd8b524ffe63dfa6b7ca76b1a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an iterator into a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814" title="Short-hand for m_snd_flying_pkts_by_sent_when type; see that data member.">Peer_socket::Sent_pkt_by_sent_when_map</a> or Peer_socket::Recv_pkt_map, gets the range of sequence numbers in the packet represented thereby.  <a href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">More...</a><br /></td></tr>
<tr class="separator:a663f1fd8b524ffe63dfa6b7ca76b1a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479dfcb7944cb6571af51f1feed2656d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">sock_get_new_snd_order_num</a> (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock)</td></tr>
<tr class="memdesc:a479dfcb7944cb6571af51f1feed2656d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "order number" to use for <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html" title="Data store to keep timing related info when a packet is sent out.">Peer_socket::Sent_packet::Sent_when</a> structure corresponding to the next packet to be sent.  <a href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">More...</a><br /></td></tr>
<tr class="separator:a479dfcb7944cb6571af51f1feed2656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109a118ca312e94686595ea08dac7ad0"><td class="memTemplParams" colspan="2">template&lt;typename Socket_ptr &gt; </td></tr>
<tr class="memitem:a109a118ca312e94686595ea08dac7ad0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">ensure_sock_open</a> (Socket_ptr sock, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a109a118ca312e94686595ea08dac7ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that checks whether the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> is CLOSED; if so, it sets <code>*err_code</code> to the reason it was closed (which is in <code>sock-&gt;m_disconnect</code>) and returns <code>false</code>; otherwise it returns <code>true</code> and leaves <code>*err_code</code> untouched.  <a href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">More...</a><br /></td></tr>
<tr class="separator:a109a118ca312e94686595ea08dac7ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ade08f0457943f803c23b55649139c0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">m_opts</a></td></tr>
<tr class="memdesc:ade08f0457943f803c23b55649139c0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s global set of options.  <a href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">More...</a><br /></td></tr>
<tr class="separator:ade08f0457943f803c23b55649139c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449ef757abee4c5d12f8fc62a5ca66b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">Options_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4">m_opts_mutex</a></td></tr>
<tr class="memdesc:a449ef757abee4c5d12f8fc62a5ca66b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex protecting <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4">More...</a><br /></td></tr>
<tr class="separator:a449ef757abee4c5d12f8fc62a5ca66b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43472c3277cdf5e3f28d4f4f51e3bcc0"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a43472c3277cdf5e3f28d4f4f51e3bcc0">m_net_env_sim</a></td></tr>
<tr class="memdesc:a43472c3277cdf5e3f28d4f4f51e3bcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object used to simulate stuff like packet loss and latency via local means directly in the code.  <a href="classflow_1_1net__flow_1_1Node.html#a43472c3277cdf5e3f28d4f4f51e3bcc0">More...</a><br /></td></tr>
<tr class="separator:a43472c3277cdf5e3f28d4f4f51e3bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5597a417d03e2bed87cd772ef5cef29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a></td></tr>
<tr class="memdesc:af5597a417d03e2bed87cd772ef5cef29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main loop engine, functioning in the single-threaded-but-asynchronous callback-based "reactor" style (or is it "proactor"?).  <a href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">More...</a><br /></td></tr>
<tr class="separator:af5597a417d03e2bed87cd772ef5cef29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9e0224c17190e99debdfd81640bf89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">Udp_socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89">m_low_lvl_sock</a></td></tr>
<tr class="memdesc:a9b9e0224c17190e99debdfd81640bf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UDP socket used to receive low-level packets (to assemble into application layer data) and send them (vice versa).  <a href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89">More...</a><br /></td></tr>
<tr class="separator:a9b9e0224c17190e99debdfd81640bf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee89be07daf7d024921381a4bafe1289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aee89be07daf7d024921381a4bafe1289">m_low_lvl_endpoint</a></td></tr>
<tr class="memdesc:aee89be07daf7d024921381a4bafe1289"><td class="mdescLeft">&#160;</td><td class="mdescRight">After we bind <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> to a UDP endpoint, this is a copy of that endpoint.  <a href="classflow_1_1net__flow_1_1Node.html#aee89be07daf7d024921381a4bafe1289">More...</a><br /></td></tr>
<tr class="separator:aee89be07daf7d024921381a4bafe1289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266ec5d00a44bc48caf37444eb2b43a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">m_low_lvl_max_buf_size</a></td></tr>
<tr class="memdesc:a266ec5d00a44bc48caf37444eb2b43a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS-reported <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> UDP receive buffer maximum size, obtained right after we OS-set that setting and never changed subsequently.  <a href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">More...</a><br /></td></tr>
<tr class="separator:a266ec5d00a44bc48caf37444eb2b43a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4db94c4fb86ddaa2502c2d7e128ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acea4db94c4fb86ddaa2502c2d7e128ea">m_packet_data</a></td></tr>
<tr class="memdesc:acea4db94c4fb86ddaa2502c2d7e128ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores incoming raw packet data; re-used repeatedly for possible performance gains.  <a href="classflow_1_1net__flow_1_1Node.html#acea4db94c4fb86ddaa2502c2d7e128ea">More...</a><br /></td></tr>
<tr class="separator:acea4db94c4fb86ddaa2502c2d7e128ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6388a362531ada956a864fefff6011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Port__space.html">Port_space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">m_ports</a></td></tr>
<tr class="memdesc:afd6388a362531ada956a864fefff6011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow port space for both client and server sockets. All threads may access this.  <a href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">More...</a><br /></td></tr>
<tr class="separator:afd6388a362531ada956a864fefff6011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8938c4a091edf1c1c77e2cc8f505f0ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number_1_1Generator.html">Sequence_number::Generator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a8938c4a091edf1c1c77e2cc8f505f0ff">m_seq_num_generator</a></td></tr>
<tr class="memdesc:a8938c4a091edf1c1c77e2cc8f505f0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence number generator (at least to generate ISNs). Only thread W can access this.  <a href="classflow_1_1net__flow_1_1Node.html#a8938c4a091edf1c1c77e2cc8f505f0ff">More...</a><br /></td></tr>
<tr class="separator:a8938c4a091edf1c1c77e2cc8f505f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae536f016607677a945ad42034a21e82a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Rnd__gen__uniform__range.html">util::Rnd_gen_uniform_range</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">Peer_socket::security_token_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae536f016607677a945ad42034a21e82a">m_rnd_security_tokens</a></td></tr>
<tr class="memdesc:ae536f016607677a945ad42034a21e82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator for picking security tokens; seeded on time at <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> construction and generates integers from the entire range.  <a href="classflow_1_1net__flow_1_1Node.html#ae536f016607677a945ad42034a21e82a">More...</a><br /></td></tr>
<tr class="separator:ae536f016607677a945ad42034a21e82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90244d69d550370158bbe843ab595a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">Socket_id_to_socket_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">m_socks</a></td></tr>
<tr class="memdesc:a90244d69d550370158bbe843ab595a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The peer-to-peer connections this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently tracking.  <a href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">More...</a><br /></td></tr>
<tr class="separator:a90244d69d550370158bbe843ab595a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae28990628a86a07327f49973f2390df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">Port_to_server_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">m_servs</a></td></tr>
<tr class="memdesc:aae28990628a86a07327f49973f2390df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The server sockets this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently tracking.  <a href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">More...</a><br /></td></tr>
<tr class="separator:aae28990628a86a07327f49973f2390df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43345472c4f41933a9c16d114cc937b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">Event_sets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b">m_event_sets</a></td></tr>
<tr class="memdesc:ae43345472c4f41933a9c16d114cc937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> to have been returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f" title="Creates a new Event_set in Event_set::State::S_INACTIVE state with no sockets/events stored; returns ...">event_set_create()</a> and not subsequently reached <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b">More...</a><br /></td></tr>
<tr class="separator:ae43345472c4f41933a9c16d114cc937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0026feecdb74eda904d00d2c7016bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Event_set::Ev_type_to_socks_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">m_sock_events</a></td></tr>
<tr class="memdesc:ab0026feecdb74eda904d00d2c7016bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">All sockets that have been detected to be "ready" (by the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header definition) at any point since the last time <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a>'s contained sets were cleared (which happens initially and after each <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a> call).  <a href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">More...</a><br /></td></tr>
<tr class="separator:ab0026feecdb74eda904d00d2c7016bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bea132db0e45ea01b9a6bd22fd0fadb"><td class="memItemLeft" align="right" valign="top">boost::unordered_set&lt; <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb">m_socks_with_accumulated_pending_acks</a></td></tr>
<tr class="memdesc:a7bea132db0e45ea01b9a6bd22fd0fadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within a given <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a> (async part) call, by the time <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> is called, this stores exactly those sockets for which possible ACK sending tasks have been accumulated during the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>/etc.  <a href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb">More...</a><br /></td></tr>
<tr class="separator:a7bea132db0e45ea01b9a6bd22fd0fadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9f418a3c99197e58f71ce2fff2997f"><td class="memItemLeft" align="right" valign="top">boost::unordered_set&lt; <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f">m_socks_with_accumulated_acks</a></td></tr>
<tr class="memdesc:a7d9f418a3c99197e58f71ce2fff2997f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within a given <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a> call, by the time <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> is called, this stores exactly those sockets for which possible incoming-ACK handling tasks have been accumulated during the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>/etc.  <a href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f">More...</a><br /></td></tr>
<tr class="separator:a7d9f418a3c99197e58f71ce2fff2997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5004700cb085c6a2806f39426b0ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3b5004700cb085c6a2806f39426b0ea0">m_last_loss_sock_log_when</a></td></tr>
<tr class="memdesc:a3b5004700cb085c6a2806f39426b0ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging, when we detect loss of data we'd sent, we log the corresponding socket's state; this is the last time this was done for any socket (or epoch if never).  <a href="classflow_1_1net__flow_1_1Node.html#a3b5004700cb085c6a2806f39426b0ea0">More...</a><br /></td></tr>
<tr class="separator:a3b5004700cb085c6a2806f39426b0ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa440f6ff5442c58323bec7a2304b0d90"><td class="memItemLeft" align="right" valign="top">boost::promise&lt; <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90">m_event_loop_ready</a></td></tr>
<tr class="memdesc:aa440f6ff5442c58323bec7a2304b0d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promise that thread W sets to truthy <code>Error_code</code> if it fails to initialize or falsy once event loop is running.  <a href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90">More...</a><br /></td></tr>
<tr class="separator:aa440f6ff5442c58323bec7a2304b0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f87144f19e908ffb981f3bff91938e"><td class="memItemLeft" align="right" valign="top">boost::unique_future&lt; <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a61f87144f19e908ffb981f3bff91938e">m_event_loop_ready_result</a></td></tr>
<tr class="memdesc:a61f87144f19e908ffb981f3bff91938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The future object through which the non-W thread waits for <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90" title="Promise that thread W sets to truthy Error_code if it fails to initialize or falsy once event loop is...">m_event_loop_ready</a> to be set to success/failure.  <a href="classflow_1_1net__flow_1_1Node.html#a61f87144f19e908ffb981f3bff91938e">More...</a><br /></td></tr>
<tr class="separator:a61f87144f19e908ffb981f3bff91938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecf0f8111af82fa081c71fda490608a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">Signal_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abecf0f8111af82fa081c71fda490608a">m_signal_set</a></td></tr>
<tr class="memdesc:abecf0f8111af82fa081c71fda490608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal set which we may or may not be using to trap SIGINT and SIGTERM in order to auto-fire <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">interrupt_all_waits()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#abecf0f8111af82fa081c71fda490608a">More...</a><br /></td></tr>
<tr class="separator:abecf0f8111af82fa081c71fda490608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b7e03ae7b13dae0f59db1475e46fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">util::Thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3">m_worker</a></td></tr>
<tr class="memdesc:a84b7e03ae7b13dae0f59db1475e46fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread (= thread W). Other members should be initialized before this to avoid race condition.  <a href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3">More...</a><br /></td></tr>
<tr class="separator:a84b7e03ae7b13dae0f59db1475e46fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ac9f6edfb36abcd0402c4bd75b595f271"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">Peer_socket::Sent_packet::ack_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</a> = 2</td></tr>
<tr class="memdesc:ac9f6edfb36abcd0402c4bd75b595f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given unacknowledged sent packet P, the maximum number of times any individual packet with higher sequence numbers than P may be acknowledged before P is considered Dropped (i.e., we give up on it).  <a href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">More...</a><br /></td></tr>
<tr class="separator:ac9f6edfb36abcd0402c4bd75b595f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97b363281b79ef4f399789442c84de"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2f97b363281b79ef4f399789442c84de">S_REGULAR_INFREQUENT_TASKS_PERIOD</a> = boost::chrono::seconds(1)</td></tr>
<tr class="memdesc:a2f97b363281b79ef4f399789442c84de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time interval between performing "infrequent periodic tasks," such as stat logging.  <a href="classflow_1_1net__flow_1_1Node.html#a2f97b363281b79ef4f399789442c84de">More...</a><br /></td></tr>
<tr class="separator:a2f97b363281b79ef4f399789442c84de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a62cd43d29137c6c9abc7d9dd731555f9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a62cd43d29137c6c9abc7d9dd731555f9">Peer_socket</a></td></tr>
<tr class="memdesc:a62cd43d29137c6c9abc7d9dd731555f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> must be able to forward <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code>, <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code>, etc.  <a href="classflow_1_1net__flow_1_1Node.html#a62cd43d29137c6c9abc7d9dd731555f9">More...</a><br /></td></tr>
<tr class="separator:a62cd43d29137c6c9abc7d9dd731555f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165381af6166d76afba06862c762367"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2165381af6166d76afba06862c762367">Server_socket</a></td></tr>
<tr class="memdesc:a2165381af6166d76afba06862c762367"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> must be able to forward <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>, etc.  <a href="classflow_1_1net__flow_1_1Node.html#a2165381af6166d76afba06862c762367">More...</a><br /></td></tr>
<tr class="separator:a2165381af6166d76afba06862c762367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2bd684093a1769e08a56c9a088801a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aec2bd684093a1769e08a56c9a088801a">Event_set</a></td></tr>
<tr class="memdesc:aec2bd684093a1769e08a56c9a088801a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> must be able to forward <code>close()</code>, <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f" title="Implementation of Event_set::async_wait() when Event_set::state() == Event_set::State::S_INACTIVE.">event_set_async_wait()</a></code>, etc.  <a href="classflow_1_1net__flow_1_1Node.html#aec2bd684093a1769e08a56c9a088801a">More...</a><br /></td></tr>
<tr class="separator:aec2bd684093a1769e08a56c9a088801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9629b88c4cd0b337a51c2363893908"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7e9629b88c4cd0b337a51c2363893908">hash_value</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>)</td></tr>
<tr class="separator:a7e9629b88c4cd0b337a51c2363893908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99561404e8389fef08fa4ac5c16a7f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a99561404e8389fef08fa4ac5c16a7f36">operator==</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;lhs, const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;rhs)</td></tr>
<tr class="separator:a99561404e8389fef08fa4ac5c16a7f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer. </p>
<p >Here we summarize class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and its entire containing Flow module <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>.</p>
<p >See also flow::asio::Node, a subclass that allows for full use of our API (its superclass) and turns our sockets into boost.asio I/O objects, able to participate with ease in all boost.asio event loops. If you're already very familiar with <code>boost::asio::ip::tcp</code>, you can skip to the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> doc header. If not, recommend becoming comfortable with the asio-less API, then read the forementioned <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> doc header.</p>
<p >The flow::asio::Node class doc header (as of this writing) includes a compact summary of all network operations supported by the entire hierarchy and hence deserves a look for your convenience.</p>
<h2>Using <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>, starting with the present class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> </h2>
<p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is an important and central class of the <code>netflow</code> Flow module and thus deserves some semi-philosophical discussion, namely what makes a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> &ndash; why the name? Let's delve into the 2 aforementioned properties of a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.</p>
<h3>A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has a distinct IP address and UDP port: <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a></h3>
<p >A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> binds to an IP address and UDP port, both of which are given (with the usual ephemeral port and IP address&lt;-&gt;interface(s) nomenclature) as an argument at <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">Node::Node()</a> construction and can never change over the lifetime of the object. The IP and port together are a <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>, which is a <code>using</code>-alias of boost.asio's <code>boost::asio::ip::udp::endpoint</code> . In the same network (e.g., the Internet) no two <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects (even in separate processes; even on different machines) may be alive (as defined by <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">Node::running()</a> == true</code>) with constructor-provided <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> objects <code>R1</code> and <code>R2</code> such that <code>R1 == R2</code>. In particular, if <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> exists, with <code>n1.running()</code> and <code>n1.local_low_lvl_endpoint() == R1</code>, and on the same machine one attempts to construct <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n2(R2)</code>, such that <code>R1 == R2</code> (their IPs and ports are equal), then <code>n2</code> will fail to properly construct, hence <code>n2.running() == false</code> will be the case, probably due to port-already-bound OS error. (There are counter-examples with NAT'ed IP addresses and special values 0.0.0.0 and port 0, but please just ignore those and other pedantic objections and take the spirit of what I am saying. Ultimately, the point is:</p>
<p ><em>A successfully constructed (<code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> == true</code>) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> occupies the same IP-and-UDP "real estate" as would a a mere successfully bound UDP socket.</em></p>
<p >So all that was a long, overbearing way to emphasize that a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> binds to an IP address and UDP port, and a single such combo may have at most one <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> on it (unless it has <code>!running()</code>). <em>That's why it is called a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></em>: it's a node on the network, especially on Internet.</p>
<h3>A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> speaks the <em>Flow network protocol</em> to other, remote Nodes</h3>
<p >If <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> is successfully constructed, and <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n2</code> is as well, the two can communicate via a new protocol implemented by this Flow module. This protocol is capable of working with stream (TCP-like) sockets implemented on top of UDP in a manner analogous to how an OS's net-stack implements TCP over IP. So one could call this Flow/UDP. One can talk Flow/UDP to another Flow/UDP endpoint (a/k/a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>) only; no compatibility with any other protocol is supported. (This isn't, for example, an improvement to one side of TCP that is still compatible with legacy TCPs on the other end; though that is a fertile area for research in its own right.) The socket can also operate in unreliable, message boundary-preserving mode, controllable via a Flow-protocol-native socket option; in which case reliability is the responsibility of the <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> user. By default, though, it's like TCP: message bounds are not preserved; reliability is guaranteed inside the protocol. <code>n1</code> and <code>n2</code> can be local in the same process, or local in the same machine, or remote in the same overall network &ndash; as long as one is routable to the other, they can talk.</p>
<p >For practical purposes, it's important to have idea of a single <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s "weight." Is it light-weight like a UDP or TCP socket? Is it heavy-weight like an Apache server instance? The answer is that it's MUCH close to the former: it is fairly light-weight. As of this writing, internally, it stores a table of peer and server sockets (of which there could be a handful or tons, depending on the user's own API calls prior); and uses at least one dedicated worker thread (essentially not visible to the user but conceptually similar to a UDP or TCP stack user's view of the kernel: it does stuff for one in the background &ndash; for example it can wait for incoming connections, if asked). So, a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is an intricate but fairly light-weight object that stores socket tables (proportional in size to the sockets currently required by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s user) and roughly a single worker thread performing low-level I/O and other minimally CPU-intensive tasks. A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can get busy if a high-bandwidth network is sending or receiving intense traffic, as is the case for any TCP or UDP net-stack. In fact, a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can be seen as a little Flow-protocol stack implemented on top of UDP transport. (Historical note: <code>class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code> used to be <code>class Stack</code>, but this implied a heavy weight and misleadingly discouraged multiple constructions in the same program; all that ultimately caused the renaming to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.)</p>
<h3>Essential properties of Flow network protocol (Flow ports, mux/demuxing)</h3>
<p >A single <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> supports 0 or more (an arbitrary # of) peer-to-peer connections to other <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s. Moreover, given two <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s <code>n1</code> and <code>n2</code>, there can similarly be 0 or more peer-to-peer connections running between the two. In order to allow this, a port (and therefore multiplexing/demultiplexing) system is a feature of Flow protocol. (Whether this features is necessary or even desirable is slightly controversial and not a settled matter &ndash; a to-do on this topic can be found below.)</p>
<p >More specifically, think of a <em>given</em> <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> as analogous (in terms of is multiplexing capabilities) to one TCP stack running on a one-interface machine. To recap the TCP port-addressing scheme (assuming only 1 interface): The TCP stack has approximately 2^16 (~65k) ports available. One may create and "bind" a server "socket" to (more or less, for our discussion) any 1 of these ports. Let's say a server socket is bound to port P1. If a remote TCP stack successfully connects to such a server-bound port, this results in a passively-connected client "socket," which &ndash; also &ndash; is bound to P1 (bear with me as to how this is possible). Finally, the TCP stack's user may bind an <em>actively</em> connecting client "socket" to another port P2 (P2 =/= P1; as P1 is reserved to that server and passively connected clients from that server). Recall that we're contriving a situation where there is only one other remote stack, so suppose there is the remote, 1-interface TCP stack. Now, let's say a packet arrives along an established connection from this stack. How does our local TCP stack determine to which connection this belongs? This is "demultiplexing." If the packet contains the info "destination port: P2," then that clearly belongs to the actively-connected client we mentioned earlier... but what if it's "dest. port: P1"? This could belong to any number of connections originally passive-connected by incoming server connection requests to port P1. Answer: the packet also contains a "source TCP port" field. So the <em>connection ID</em> (a/k/a <em>socket ID</em>) consists of BOTH pieces of data: (1) destination (local) port; (2) source (remote) port. (Recall that, symmetrically, the remote TCP stack had to have a client bind to some port, and that means no more stuff can bind to that port; so it is unique and can't clash with anything else &ndash; inside that remote stack.) So this tuple uniquely identifies the connection in this scenario of a single-interface local TCP that can have both active client sockets and passive-client-socket-spawning server sockets; and talk to other stacks like it. Of course, there can be more than one remote TCP stack. So the 2-tuple (pair) becomes a 3-tuple (triplet) in our slightly simplified version of reality: (1) destination (local) TCP port; (2) source (remote) IP address; and (3) source (remote) TCP port. (In reality, the local TCP stack can bind to different interfaces, so it becomes a 4-tuple by adding in destination (local) IP address... but that's TCP and is of no interest to our analogy to Flow protocol.)</p>
<p >What about Flow protocol? GIVEN <code>n1</code> and <code>n2</code>, it works just the same. We have a special, TCP-like, Flow port space WITHIN <code>n1</code> and similarly within <code>n2</code>. So if only <code>n1</code> and <code>n2</code> are involved, an <code>n1</code> <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> (class) object can <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> (&lt;&ndash; actual method) on a <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d" title="Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).">net_flow::flow_port_t</a> (&lt;&ndash; alias to 2-byte unsigned as of this writing) port P1; <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> (another method) incoming connections, each still bound to port P1; and <code>n1</code> can also actively <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (another method) to <code>n2</code> at some port over there. Then an incoming UDP packet's intended established connection is demuxed to by a 2-tuple: (1) destination (local) <code>flow_port_t</code>; (2) source (remote) <code>flow_port_t</code>.</p>
<p >In reality, other remote <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s can of course be involved: <code>n3</code>, <code>n4</code>, whatever. As we've established, each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> lives at a UDP endpoint: <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> (again, IP address + UDP port). Therefore, from the stand-point of a given local <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code>, each established peer-to-peer connection is identified fully by the 5-tuple (marked here with roman numerals):</p><ol type="1">
<li>Local <code>flow_port_t</code> within <code>n1</code>'s port-space (not dissimilar to TCP's port space in size and behavior). (I)</li>
<li>Remote endpoint identifying the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>: <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html" title="Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...">Remote_endpoint</a>.<ol type="a">
<li><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>.<ol type="i">
<li>IP address. (II)</li>
<li>UDP port. (III)</li>
</ol>
</li>
<li>Remote <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d" title="Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).">net_flow::flow_port_t</a>. (IV)</li>
</ol>
</li>
</ol>
<p >So, that is how it works. Of course, if this complexity is not really necessary for some application, then only really (II) and (III) are truly necessary. (I) and (IV) can just be chosen to be some agreed-upon constant port number. Only one connection can ever exist in this situation, and one would need to create more <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s one side or the other or both to achieve more connections between the same pair of IP addresses, but that's totally reasonable: it's no different from simply binding to more UDP ports. My point here is that the Flow-protocol-invented construct of "Flow ports" (given as <code>flow_port_t</code> values) can be used to conserve UDP ports; but they can also be NOT used, and one can just use more UDP ports, as a "regular" UDP-using pair of applications would, if more than one flow of information is necessary between those two apps. It is up to you. (Again, some arguments can be made for getting rid of (I) and (IV), after all. This possibility is discussed in a below to-do.)</p>
<p >(Do note that, while we've emulated TCP's port scheme, there is no equivalent of IP's "interfaces." Each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> just has a bunch of ports; there is no port table belonging to each of N interfaces or any such thing.)</p>
<h3><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a> API overview</h3>
<p >This is a summary (and some of this is very briefly mentioned above); all the classes and APIs are much more deeply documented in their own right. Also, see above pointer to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> whose doc header may be immediately helpful to experienced users. Meanwhile, to summarize:</p>
<p >The <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> hands out sockets as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects; it acts as a factory for them (directly) via its <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> and (indirectly) <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> families of methods. It is not possible to construct a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> independently of a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, due to tight coordination between the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and each <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. Moreover each <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is handed out via <code>boost::shared_ptr</code> smart pointer. While not strictly necessary, this is a situation where both the user and a central registry (<a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>) can own the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> at a given time, which is an ideal application for <code>shared_ptr&lt;&gt;</code> that can greatly simplify questions of object ownership and providing auto-<code>delete</code> to boot.</p>
<p >Thus: <code>Node::listen(flow_port_t P)</code> yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a>, which will listen for incoming connections on <code>P</code>. <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> (and similar) yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>, one side of a peer-to-peer connection. On the other side, <code>Node::connect(Remote_endpoint R)</code> (where <code>R</code> contains <code>Udp_endpoint U</code>, where value equal to <code>U</code> had been earlier passed to constructor of the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a></code>ing <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>; and <code>R</code> also contains <code>flow_port_t P</code>, passed to <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a></code>). <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>, too, yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. And thus, if all went well, each side now has a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> <code>S1</code> and <code>S2</code>, which &ndash; while originating quite differently &ndash; are now completely equal in capabilities: they are indeed <em>peer</em> sockets. They have methods like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>.</p>
<p >Further nuances can be explored in the various other doc headers, but I'll mention that both non-blocking behavior (meaning the call always returns immediately, even if unable to immediately perform the desired task such as accept a connection or receive 1 or more bytes) and blocking behavior as supported, as in (for example) a BSD sockets API. However, there is no "blocking" or "non-blocking" mode as in BSD or WinSock (personally I, Yuri, see it as an annoying anachronism). Instead you simply call a method named according to whether it will never block or (possibly &ndash; if appropriate) block. The nomenclature convention is as follows: if the action is <code>X</code> (e.g., <code>X</code> is <code>receive</code> or <code>accept</code>), then <code>-&gt;X()</code> is the non-blocking version; and <code>-&gt;sync_X()</code> is the blocking one. A non-blocking version always exists for any possible action; and a blocking version exists if it makes sense for it to exist. (Exception: <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> explicitly includes <code>async_</code> prefix contrary to this convention. Partially it's because just calling it <code>wait()</code> &ndash; convention or not &ndash; makes it sound like it's going to block, whereas it emphatically will never do so. ALSO it's because it's a "special" method with unique properties including letting user execute their own code in a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s internal worker thread. So rules go out the window a little bit for that method; hence the slight naming exception.)</p>
<h3>Nomenclature: "low-level" instead of "UDP"</h3>
<p >Side note: You will sometimes see the phrase <code>low_lvl</code> in various identifiers among <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> APIs. <code>low_lvl</code> (low-level) really means "UDP" &ndash; but theoretically some other packet-based transport could be used instead in the future; or it could even be an option to chooose between possible underlying protocols. For example, if <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> moved to kernel-space, the transport could become IP, as it is for TCP. So this nomenclature is a hedge; and also it argubly is nicer/more generic: the fact it's UDP is immaterial; that it's the low-level (from our perspective) protocol is the salient fact. However, <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> is thus named because it is very specifically a gosh-darned UDP port (plus IP address), so hiding from that by naming it <code>Low_Lvl_endpoint</code> (or something) seemed absurd.</p>
<h3>Event, readability, writability, etc.</h3>
<p >Any experienced use of BSD sockets, WinSock, or similar is probably wondering by now, "That sounds reasonable, but
how does the API allow me to wait until I can connect/accept/read/write, letting me do other stuff in the meantime?" Again, one can use a blocking version of basically every operation; but then the wait for readability/writability/etc. may block the thread. One can work around this by creating multiple threads, but multi-threaded coding introduced various difficulties. So, the experienced socketeer will want to use non-blocking operations + an event loop + something that allow one to wait of various states (again, readability, writability, etc.) with various modes of operation (blocking, asynchronous, with or without a timeout, etc.). The most advanced and best way to get these capabilities is to use boost.asio integration (see <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a>). As explained elsewhere (see <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header) this is sometimes not usable in practice. In that case: These capabilities are supplied in the class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. See that class's doc header for further information. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is the <code>select()</code> of this socket API. However it is significantly more convenient AND indeed supports a model that will allow one to use Flow-protocol sockets in a <code>select()</code>- or equivalent-based event loop, making <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> module usable in a true server, such as a web server. That is, you don't just have to write a separate Flow event loop operating independently of your other sockets, file handles, etc. This is an important property in practice. (Again: Ideally you wouldn't need <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> for this; <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a>/etc. might be better to use.)</p>
<h3>Error reporting</h3>
<p >Like all Flow modules, <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> uses error reporting conventions/semantics introduced in <code>namespace</code> <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header Error Reporting section.</p>
<p >In particular, this module does add its own error code set. See <code>namespace</code> <a class="el" href="namespaceflow_1_1net__flow_1_1error.html" title="Namespace containing the net_flow module&#39;s extension of boost.system error conventions,...">net_flow::error</a> doc header which should point you to <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> <code>enum</code>. All error-emitting <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> APIs emit <code>Error_code</code>s assigned from <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> <code>enum</code> values.</p>
<h3>Configurability, statistics, logging</h3>
<p >Great care is taken to provide visibility into the "black box" that is Flow-protocol. That is, while the API follows good practices wherein implementation is shielded away from the user, at the same time the <em>human</em> user has powerful tools to both examine the insides of the library/protocol's performance AND to tweak the parameters of its behavior. Picture a modern automobile: while you're driving at least, it's not going to let you look at or mess with its engine or transmission &ndash; nor do you need to understand how they work; BUT, the onboard monitor will feature screens that tell you about its fuel economy performance, the engine's inner workings, and perhaps a few knobs to control the transmission's performance (for example). Same principles are followed here.</p>
<p >More specifically:</p><ul>
<li><em>Configuration</em> Socket options are supported via <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>. These control many aspects of the library's behavior, for example which congestion control algorithm to use. These options can be set programmatically, through a config file, or through command line options. Particular care was taken to make the latter two features seamlessly available by leveraging boost.program_options.</li>
<li><em>Statistics</em> Very detailed stats are kept in <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html" title="A data store that keeps stats about the incoming direction of a Peer_socket connection to another Flo...">Peer_socket_receive_stats</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html" title="A data store that keeps stats about the outgoing direction of a Peer_socket connection to another Flo...">Peer_socket_send_stats</a>, combined with more data in <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html" title="A data store that keeps stats about the a Peer_socket connection.">Peer_socket_info</a>. These can be accessed programmatically; their individual stats can also be accessed programmatically; or they can be logged to any <code>ostream</code>. Plus, the logging system periodically logs them (assuming this logging level is enabled).</li>
<li><em>Logging</em> Like all Flow modules, <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> uses logging conventions/semantics introduced in <code>namespace</code> <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header Logging section.</li>
</ul>
<h3>Multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects</h3>
<p >As mentioned already many times, multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects can exist and function simultaneously (as long as they are not bound to the same conceptual <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>, or to the same UDP port of at least one IP interface). However, it is worth emphasizing that &ndash; practically speaking &ndash; class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is implemented in such a way as to make a given <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> 100% independent of any other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in the same process. They don't share working thread(s), data (except <code>static</code> data, probably just constants), any namespaces, port spaces, address spaces, anything. Each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is independent both API-wise and in terms of internal implementation.</p>
<h3>Thread safety</h3>
<p >All operations safe for simultaneous execution on 2+ separate <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects <em>or on the same <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></em>, or on any objects (e.g., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>) returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (Please note the <em>emphasized</em> phrase.) "Operations" are any <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> or Node-returned-object method calls after construction and before destruction of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (In particular, for example, one thread can <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> while another <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>s.) The same guarantee may or may not apply to other classes; see their documentation headers for thread safety information.</p>
<h3>Thread safety of destructor</h3>
<p >Generally it is not safe to destruct a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (i.e., let <a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118" title="Destroys Node.">Node::~Node()</a> get called) while a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> operation is in progress on that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (obviously, in another thread). There is one exception to this: if a blocking operation (any operation with name starting with <code>sync_</code>) has entered its blocking (sleep) phase, it is safe to delete the underlying <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. In practice this means simply that, while you need not lock a given <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> with an external mutex while calling its various methods from different threads (if you really must use multiple threads this way), you should take care to probably join the various threads before letting a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> go away.</p>
<h2>Historical note re. FastTCP, Google BBR </h2>
<h3>Historical note re. FastTCP</h3>
<p >One notable change in this <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> vs. the original libgiga is this one lacks the FastTCP congestion control strategy. I omit the historical reasons for this for now (see to-do regarding re-introducing licensing/history/location/author info, in common.hpp).</p>
<p >Addendum to the topic of congestion control: I am not that interested in FastTCP, as I don't see it as cutting-edge any longer. I am interested in Google BBR. It is a goal to implement Google BBR in <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>, as that congestion control algorithm is seen by many as simply the best one available; a bold conclusion given how much research and given-and-take and pros-and-cons discussions have tramspired ever since the original Reno TCP became ubiquitous. Google BBR is (modulo whatever proprietary improvements Google chooses to implement in their closed-source software) publicly documented in research paper(s) and, I believe, available as Google open source.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000089">Todo:</a></b></dt><dd><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a> should use <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> for its socket-options mechanism. It is well suited for that purpose, and it uses some ideas from those socket-options in the first place but is generic and much more advanced. Currently <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> socket-options are custom-coded from long before <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> existed.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000090">Todo:</a></b></dt><dd><code>ostream</code> output operators for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> should exist. Also scour through all types; possibly some others could use the same. (I have been pretty good at already implementing these as-needed for logging; but I may have "missed a spot.")</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">Todo:</a></b></dt><dd>Some of the <code>ostream&lt;&lt;</code> operators we have take <code>X*</code> instead of <code>const X&amp;</code>; this should be changed to the latter for various minor reasons and for consistency.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000092">Todo:</a></b></dt><dd>Actively support IPv6 and IPv4, particularly in dual-stack mode (wherein <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a> would bind to an IPv6 endpoint but accept incoming V4 and V6 connections alike). It already supports it nominally, in that one can indeed listen on either type of address and connect to either as well, but how well it works is untested, and from some outside experience it might involve some subtle provisions internally.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000093">Todo:</a></b></dt><dd>Based on some outside experience, there maybe be problems &ndash; particularly considering the to-do regarding dual-stack IPv6/v4 support &ndash; in servers listening in multiple-IP situations; make sure we support these seamlessly. For example consider a machine with a WAN IP address and a LAN (10.x.x.x) IP address (and possibly IPv6 versions of each also) that (as is typical) binds on all of them at ANY:P (where P is some port; and ANY is the IPv6 version, with dual-stack mode ensuring V4 datagrams are also received). If a client connects to a LAN IP, while in our return datagrams we set the source IP to the default, does it work? Outside experience shows it might not, depending, plus even if in our protocol it does, it might be defeated by some firewall... the point is it requires investigation (e.g., mimic TCP itself; or look into what IETF or Google QUIC does; and so on).</dd></dl>
<h2>Implementation notes </h2>
<p >In this section, and within implementation, I may simply say "Flow" instead of "Flow [network] protocol," for brevity. This is not meant to represent all of the containing Flow project nor refer to any module other that <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>.</p>
<h3>Note on general design philosophy</h3>
<p >The protocol is TCP-like. However, it is not TCP. Moreover, it is not TCP even if you remove the fact that it sends UDP datagrams instead of IP packets. It follows the basic goals of TCP (stream of bytes, reliability, congestion control, etc.), and it borrows many of its internal techniques (congestion window, receive window ACKs, drop timeout, etc.), but it specifically will not inherit those limitations of TCP that are essentially historic and/or a result of having to be backwards- compatible with the other side which may be behind. For example, all ACKs in Flow are selective; whereas in TCP ACKs are generally cumulative, while selective ACKs (SACKs) are an advanced option that the other side may or may not support. Making certain modern decisions in Flow that TCP implementations simply cannot make means (1) a simpler protocol and implementation; and (2) potentially higher performance before we can try any advanced stuff like new congestion control strategies or FEC (forward error correction).</p>
<p >Moreover, I tried to take care in not copying various classic TCP RFCs mindlessly. Instead, the idea was to evaluate the spirit, or intent, of each technical detail of a given RFC &ndash; and then translate it into the (hopefully) more elegant and less historical baggage-encumbered world of Flow. This is particularly something I felt when translating the terse congestion control-related TCP RFCs into <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> C++ code. (For a more specific explanation of what I mean, check out the "general design note" in the class doc header of the class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a>.) Hopefully this means terse, concern-conflating TCP RFCs (and at times Linux kernel's somewhat less concern-conflating implementations of these RFCs) become clean, concern- separated Flow code. This means, also, a rather extremely high ratio of comments to code in many areas of this project. I wanted to clearly explain every non-trivial decision, even if it meant many long-winded English explanations.</p>
<h3>Basic implementation</h3>
<p >Constructor creates new thread, henceforth called thread W, which houses the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s main loop and performs all blocking work (and generally most work) for the class; this exists until the destructor executes. In general, for simplicity (in a way) and consistency, even when a given call (e.g., non-blocking <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>) could perform some preliminary work (e.g., argument checking and ephemeral port reservation) directly in the caller's thread and then place a callback (e.g., <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff" title="Thread W implementation of connect().">connect_worker()</a>) on W for the real work (e.g., filling out packet, sending SYN, etc.), we instead choose to put all the work (even the aforementioned preliminary kind) onto W and (non-blockingly!) wait for that callback to finish, via a boost.thread <code>future</code>. While a bit slower, I find this simplifies the code by breaking it up less and keeping it in one place in the code base for a given operation (in this example, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>). It can also reduce mutex usage in our code. Also it enables a slightly better user experience, as errors are reported earlier in the user code and state changes are not asynchronous, when they don't need to be.</p>
<p >The above can apply to such things as non-blocking <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>. It probably wouldn't apply to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> for performance reasons.</p>
<h3>Note on threads W and U</h3>
<p >In classic Berkeley sockets, one often thinks of "the kernel" performing certain work in "the background," the results of which the user level code might access. For example, the kernel might receive IP packets on some port and deserialize them into a socket's receive buffer &ndash; while the user's program is busy doing something completely unrelated like showing graphics in a video game &ndash; then the <code>recv()</code> call would later transfer the deserialized stream into the user's own user-level buffer (e.g., a <code>char[]</code> array). In our terminology, "thread W" is the equivalent of "the kernel" doing stuff "in the
background"; while "thread U" refers to the user's own thread where they do other stuff and at times access the results of the "kernel background" stuff. However, Flow is a user-level tool, so thread W is not actually running in the kernel... but conceptually it is like it.</p>
<h3>boost.asio</h3>
<p >The implementation heavily uses the boost.asio library, as recommended by <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header boost.asio section. This implements the main loop's flow (with a callback-based model), all UDP traffic, timers. Why use boost.asio and not home-made networking and event loop code? There are a few good reasons. For UDP networking, boost.asio provides a pain-free, portable, object-oriented wrapper around BSD sockets/WinSock (that nevertheless exposes the native resources like sockets/FDs <em>if</em> needed). For a high- performance event loop, boost.asio gives a flexible <em>proactor pattern</em> implementation, supporting arbitrary callbacks with lambdas or <code>bind()</code>, which is much easier and prettier than C-style function pointers with <code>void*</code> arguments a-la old-school HTTP servers written in C. For a complex event-driven loop like this, we'd have to implement some callback system anyway, and it would likely be far worse than boost.asio's, which is full-featured and proven through the years.</p>
<h2>To-dos and future features </h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000094">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): The OS UDP net-stack buffers arriving datagrams until they're <code>recv()</code>d by the application layer. This buffer is limited; on my Linux test machine the default appears to buffer ~80 1k datagrams. With a high sender CWND and high throughput (e.g., over loopback), thread W &ndash; which both reads off UDP datagrams and handles them, synchronously &ndash; cannot always keep up, and the buffer fills up. This introduces Flow loss despite the fact that the datagram actually safely got to the destination; and this is with just ONE sender; in a server situation there could be thousands. In Linux I was able to raise, via <code>setsockopt()</code>, the buffer size to somewhere between 1000 and 2000 1k datagrams. This helps quite a bit. However, we may still overflow the buffer in busy situations (I have seen it, still with only one connection). So, the to-do is to solve this problem. See below to-dos for ideas. WARNING: UDP buffer overflow can be hard to detect and may just look like loss; plus the user not reading off the Receive buffer quickly enough will also incur similar-looking loss. If there were a way to detect the total # of bytes or datagrams pending on a socket, that would be cool, but <code>sock.available()</code> (where <code>sock</code> is a UDP socket) just gives the size of the first queued datagram. Congestion control (if effective) should prevent this problem, if it is a steady-state situation (i.e., loss or queueing delay resulting from not keeping up with incoming datagrams should decrease CWND). However, if it happens in bursts due to high CPU use in the environment, then that may not help. NOTE 1: In practice a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> with many connections is running on a server and thus doesn't receive that much data but rather sends a lot. This mitigates the UDP-receive-buffer-overflow problem, as the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> receiving tons of data is more likely to be a client and thus have only one or two connections. Hence if we can handle a handful of really fast flows without such loss, we're good. (On other hand, ACKs are also traffic, and server may get a substantial amount of them. Much testing is needed.) Packet pacing on the sender side may also avoid this loss problem; on the other hand it may also decrease throughput. NOTE 2: Queue delay-based congestion control algorithms, such as FastTCP and Vegas, are highly sensitive to accurate RTT (round trip time) readings. Heavy CPU load can delay the recording of the "received" time stamp, because we call UDP <code>recv()</code> and handle the results all in one thread. Any solution, such as the dedicated thread proposed below, would <em>allow</em> one to record the time stamp immediately upon receipt of the packet by the dedicated thread; while W would independently handle everything else. Is that a good idea though? Maybe not. If the CPU load is such that ACK-receiver-side can't get to the time-stamp-saving, RTT-measuring step without tricks like doing it immediately upon some low-level datagram receipt hook, then that CPU-pegged jungle is, in a way, part of the network and should probably be fairly counted as part of the RTT. So perhaps we should continue to take the RTT time stamp while actually handling the individual acknowledgments. Instead we should strive to use multi-core resources efficiently, so that the gap between receipt (on whatever thread) and acknowledgment processing (on whatever thread) is as small as possible. Then RTT is RTT, but we make it smaller via improved performance. Meanwhile, we hopefully also solve the original problem (internal kernel buffer overflowing and dropping datagrams).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000095">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 1 (CO-WINNER!): One approach is to note that, as of this writing, we call <code>m_low_lvl_sock.async_receive(null_buffers)</code>; the <code>null_buffers</code> value for the buffers arg means that the handler is called without any actual UDP receive is performed by boost.asio; our handler is called once there is at least 1 message TO read; and then indeed our handler does read it (and any more messages that may also have arrived). Well, if we pass in an actual buffer instead, then boost.asio will read 1 (and no more, even if there are more) message into that buffer and have it ready in the handler. Assuming the mainstream case involves only 1 message being ready, and/or assuming that reading at least 1 message each time ASAP would help significantly, this may be a good step toward relieving the problem, when it exists. The code becomes a tiny bit less elegant, but that's negligible. This seems like a no-brainer that should be included in any solution, but it by itself may not be sufficient, since more than 1 datagram may be waiting, and datagrams 2, 3, ... would still have to be read off by our code in the handler. So other approaches should still be considered.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000096">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 2: To eliminate the problem to the maximum extent possible, we can dedicate its own thread &ndash; call it W2 &ndash; to reading <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a>. We could also write to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> on W2 (which would also allow us to use a different <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> from <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a> to exclusively deal with W2 and the UDP socket <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> &ndash; simpler in some ways that the strand-based solution described below). There are a couple of problems with this. One, it may delay receive ops due to send ops, which compromises the goals of this project in the first place. Two, send pacing code is in thread W (and moving it to W2 would be complex and unhelpful); and once the decision to REALLY send a given datagram has been made, this send should occur right then and there &ndash; queuing that task on W2 may delay it, compromising the quality of send pacing (whose entire nature is about being precise down to the microsecond or even better). Therefore, we'd like to keep <code>m_low_lvl_sock.async_send()</code> in thread W along with all other work (which allows vast majority of internal state to be accessed without locking, basically just the Send/Receive buffers excluded); except the chain of [<code>m_low_lvl_sock.async_receive()</code> -&gt; post handler of received datagram onto thread W; and immediately <code>m_low_lvl_sock.async_receive()</code> again] would be on W2. AS WRITTEN, this is actually hard or impossible to do with boost.asio because of its design: <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> must belong to exactly one <code>Task_engine</code> (here, <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a>), whereas to directly schedule a specific task onto a specific thread (as above design requires) would require separate <code>Task_engine</code> objects (1 per thread): boost.asio guarantees a task will run on <em>a</em> thread which is currently executing <code>run()</code> &ndash; if 2 threads are executing <code>run()</code> on the same service, it is unknown which thread a given task will land upon, which makes the above design (AS WRITTEN) impossible. (Side note: I'm not sure it's possible in plain C with BSD sockets either. A naive design, at least, might have W <code>select()</code> on <code>m_low_lvl_sock.native()</code> for writability as well other stuff like timers, while W2 <code>select()</code>s on same for readability; then the two threads perform UDP <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> and <code>recv()</code>, respectively, when so instructed by <code>select()</code>s. Is it allowed to use <code>select()</code> on the same socket concurrently like that? StackOverflow.com answers are not clear cut, and to me, at least, it seems somewhat dodgy.) However, an equivalent design IS possible (and supported cleanly by boost.asio): In addition to the 2 threads, set up 2 strands, S and S2. All work except the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> reads and posting of the handler onto S will be scheduled with a strand S. All work regarding <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> reads and posting of its handler onto S will be scheduled with a strand S2. Recall that executing tasks in 1 strand, with 2+ threads executing <code>run()</code>, guarantees that no 2+ of those tasks will execute simultaneously &ndash; always in series. This is actually &ndash; in terms of efficiency and thread safety &ndash; equivalent to the above W/W2 design. Since the S tasks will always execute serially, no locking is necessary to prevent concurrent execution; thus what we know today as thread W tasks (which need no locking against each other) will be equally thread safe; and same holds for the new S2 tasks (which are considerably simpler and fewer in number). So that's the thread safety aspect; but why is efficiency guaranteed? The answer becomes clear if one pictures the original thread W/W2 design; basically little task blocks serially pepper thread W timeline; and same for W2. By doing it with strands S and S2 (running on top of threads W and W2), the only thing that changes is that the little blocks might at random be swapped between threads. So the series of tasks T1 -&gt; T2 -&gt; T3 -&gt; T4 meant for for S might actually jump between W and W2 randomly; but whenever thread W2 is chosen instead of thread W, that leaves an empty "space" in thread W, which will be used by the S2 task queue if it needs to do work at the same time. So tasks may go on either thread, but the strands ensure that both are used with maximum efficiency while following the expected concurrency constraints (that each strand's tasks are to be executed in series). Note, however, that <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> (the socket object) is not itself safe for concurrent access, so we WILL need a lock to protect the tiny/short calls <code>m_low_lvl_sock.async_receive()</code> and <code>m_low_lvl_sock.async_send()</code>: we specifically allow that a read and write may be scheduled to happen simultaneously, since the two are independent of each other and supposed to occur as soon as humanly possible (once the desire to perform either one is expressed by the code &ndash; either in the pacing module in strand S or the read handler in S2). In terms of nomenclature, if we do this, it'd be more fair to call the threads W1 and W2 (as they become completely equal in this design). (In general, any further extensions of this nature (if we want still more mostly-independent task queues to use available processor cores efficiently), we would add 1 strand and 1 worker thread per each such new queue. So basically there's a thread pool of N threads for N mostly-independent queues, and N strands are used to use that pool efficiently without needing to lock any data that are accessed exclusively by at most 1 queue's tasks only. Resources accessed by 2 or more task queues concurrently would need explicit locking (e.g., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> in this design).) So then where we start thread W today, we'd start the thread pool of 2 threads W1, W2, with each executing <code>m_task_engine.run()</code>. Before the run()s execute, the initial tasks (each wrapped in strand S or S2, as appropriate) need to be posted onto <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a>; this can even occur in the user thread U in the constructor, before W1 and W2 are created. The destructor would <code>m_task_engine.stop()</code> (like today), ending each thread's <code>run()</code> and trigger the imminent end of that thread; at which point destructor can <code>W1.join()</code> and <code>W2.join()</code> (today it's just <code>W.join()</code>).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000097">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 3: Suppose we take APPROACH 1 (no-brainer) plus APPROACH 2. Certain decisions in the latter were made for certain stated reasons, but let's examine those more closely. First note that the APPROACH 1 part will ensure that, given a burst of incoming datagrams, the first UDP <code>recv()</code> will occur somewhere inside boost.asio, so that's definitely a success. Furthermore, strand S will invoke <code>m_low_lvl_sock.async_send()</code> as soon as the pacing module decides to do so; if I recall correctly, boost.asio will invoke the UDP <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> right then and there, synchronously (at least I wrote that unequivocally in a <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">Node::async_low_lvl_packet_send_impl()</a> comment). Again, that's as good as we can possibly want. Finally, for messages 2, 3, ... in that incoming datagram burst, our handler will (indirectly but synchronously) perform the UDP <code>recv()</code>s in strand S2. Here we're somewhat at boost.asio's mercy, but assuming its strand task scheduling is as efficient as possible, it should occur on the thread that's free, and either W1 or W2 should be free given the rest of the design. Still, boost.asio docs even say that different strands' tasks are NOT guaranteed to be invoked concurrently (though common sense implies they will be when possible... but WHAT IF WE'RE WRONG!!!?). Also, we don't know how much computational overhead is involved in making strands work so nicely (again, hopefully it's well written... but WHAT IF!!!?). A negative is the small mutex section around the two <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> calls; not complex and probably hardly a performance concern, but still, it's a small cost. Finally, using strands &ndash; while not ugly &ndash; does involve a bit more code, and one has to be careful not to forget to wrap each handler with the appropriate strand (there is no compile- or runtime error if we forget!) So what can we change about APPROACH 2 to avoid those negatives? As stated in that approach's description, we could have thread W not deal with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> at all; thread W2 would have a separate <code>Task_engine</code> handling only <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> (so no mutex needed). W2 would do both sends and receives on the socket; and absolutely nothing else (to ensure it's as efficient as possible at getting datagrams off the kernel buffer, solving the original problem). Yes, the receiving would have to share time with the sends, but assuming nothing else interferes, this feels like not much of a cost (at least compared with all the heavy lifting thread W does today anyway). Each receive would read off all available messages into raw buffers and pass those (sans any copying) on to thread W via <code>post(W)</code>. The other negative, also already mentioned, is that once pacing module (in thread W) decides that a datagram should be sent, the <code>post(W2)</code> for the task that would peform the send introduces a delay between the decision and the actual UDP <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> done by boost.asio. Thinking about it now, it is questionable to me how much of a cost that really is. Without CPU contention, we can measure it; I expect it to be quite cheap, but I coudl be wrong. With CPU contention &ndash; which would have to come from many datagrams arriving at the same time &ndash; I'm not sure. It wouldn't be overly hard to test; basically flood with UDP traffic over loopback and log the delay between W deciding to send datagram and W2 calling <code>m_low_lvl_sock.async_send_to()</code> (obviously use <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>!). All in all, if we name the dedicated thread approach described here as APPROACH 3, then APPROACH 3 is appealingly simpler than APPROACH 2; and in most ways appears like it'd be at least as efficient and good at solving the original problem as APPROACH 2. The only danger that worries me is this business with messing up pacing (and no, moving pacing into W2 just endangers the receiving efficiency and introduces thread safety problems and complexity) by having it compete with receiving during incoming-traffic-heavy times. Ultimately, I'd recommend timing this "danger zone" as described a bit earlier (also time delay introduced by <code>post(W2)</code> without any traffic coming in); and if it looks good, do APPROACH 3. Otherwise spring for APPROACH 2.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000098">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 4: It now occurs to me how to solve the main questionable part about APPROACH 3. If we fear that the reads and writes in thread W2 may compete for CPU, especially the reads delaying timing-sensitive paced writes, then we can eliminate the problem by taking W2's own <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> (which would be separate from <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a>) and have two equal threads W2' and W2'' start up and then each call <code>Task_engine::run()</code>. Without having to use any strand, this will essentially (as documented in boost.asio's doc overview) establish a thread pool of 2 threads and then perform the receive and send tasks at random on whichever thread(s) is/are available at a particular time. Since there's no strand(s) to worry about, the underlying overhead in boost.asio is probably small, so there's nothing to fear about efficiency. In fact, in this case we've now created 3 separate threads W, W2', W2'', all doing things independently of each other, which is an excellent feature in terms of using multiple cores. Do note we will now need a mutex and very short critical sections around the calls to <code>m_low_lvl_sock::async_receive()</code> and <code>m_low_lvl_sock::async_send()</code>, but as noted before this seems extremely unlikely to have any real cost due to the shortess of critical sections in both threads. If this is APPROACH 4, then I'd say just time how much absolute delay is introduced by a &lsquo;post(W2&rsquo;)<code>or</code>post(W2'')` of the async send call compared to directly making such a call on thread W, as is done today. I suspect it's small, in which case the action is go for APPROACH 4... finally.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000099">Todo:</a></b></dt><dd>Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 5 (CO-WINNER!): Actually, the thing I've been dismissing in approaches 2-4, which was to combine the pacing logic with the actual <code>m_low_lvl_sock.async_send()</code> (like today) but in their own dedicated thread, now seems like the best way to solve the one questionable aspect of APPROACH 4. So, APPROACH 4, but: Move the pacing stuff into the task queue associated with threads W2' and W2''. So then these 2 threads/cores will be available for 2 task queues: one for pacing timers + datagram sending over <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> (with mutex); the other for receiving over <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> (with same mutex). Now, the only "delay" is moved to before pacing occurs: whatever minimal time cost exists of adding a queue from thread W to thread W2' or W2'' occurs just before the pacing logic, after which chances are the datagram will be placed on a pacing queue anyway and sent off somewhat later; intuitively this is better than the delay occurring between pacing logic and the actual UDP send. Note, also, that the timing-sensitive pacing logic now gets its own thread/core and should thus work better vs. today in situations when thread W is doing a lot of work. This is even more logical than APPROACH 4 in that sense; the pacing and sending are concern 1 and get their own thread (essentially; really they get either W2' or W2'' for each given task); the receiving is concern 2 and gets its own thread (same deal); and all the rest is concern 3 and remains in its own thread W (until we can think of ways to split that into concerns; but that is another to-do). Only one mutex with 2 very small critical sections, as in APPROACH 4, is used. The only subtlety regarding concurrent data access is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8" title="Performs important book-keeping based on the event &quot;DATA packet was sent to destination....">Node::mark_data_packet_sent()</a>, which is called just before <code>m_low_lvl_sock.async_send()</code>, and which finalizes certain aspects of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html" title="Data store to keep timing related info when a packet is sent out.">Peer_socket::Sent_packet::Sent_when</a>; most notably <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#ad513e58f4eb611c3a91d96df26f53f2c" title="The timestamp when the packet is sent out.">Peer_socket::Sent_packet::Sent_when::m_sent_time</a> (used in RTT calculation upon ACK receipt later). This is stored in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>, which today is not protected by mutex due to only being accessed from thread W; and which is extremely frequently accessed. So either we protect the latter with a mutex (out of the question: it is too frequently accessed and would quite possibly reduce performance) or something else. Currently I think <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8" title="Performs important book-keeping based on the event &quot;DATA packet was sent to destination....">Node::mark_data_packet_sent()</a> should just be placed onto <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a> (thread W) via <code>post()</code> but perhaps take all or most of the items to update Sent_when with as arguments, so that they (especially <code>Sent_when::m_sent_time</code>) could be determined in thread W2' or W2'' but written thread-safely in W. (There is no way some other thread W task would mess with this area of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a> before the proposed <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8" title="Performs important book-keeping based on the event &quot;DATA packet was sent to destination....">mark_data_packet_sent()</a> was able to run; thread W had just decided to send that packet over wire in the first place; so there's no reason to access it until ACK &ndash; much later &ndash; or some kind of socket-wide catastrophe.) All that put together I dub APPROACH 5. Thus, APPROACH 1 + APPROACH 5 seems like the best idea of all, distilling all the trade-offs into the the fastest yet close to simplest approach.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000100">Todo:</a></b></dt><dd>More uniform diagnostic logging: There is much diagnostic logging in the implementation (FLOW_ERROR*(), etc.), but some of it lacks useful info like <code>sock</code> or <code>serv</code> (i.e., the <code>ostream</code> representations of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects, which include the UDP/Flow endpoints involved in each socket). The messages that do include these have to do so explicitly. Provide some macros to automatically insert this info, then convert the code to use the macros in most places. Note that existing logging is rather exhaustive, so this is not the biggest of deals but would be nice for ease of coding (and detailed logging).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000101">Todo:</a></b></dt><dd>It may be desirable to use not boost.asio's out-of-the-box UDP receive routines but rather extensions capable of some advanced features, such as <code>recvmsg()</code> &ndash; which can obtain kernel receipt time stamps and destination IP address via the <code>cmsg</code> feature. This would tie into various other to-dos listed around here. There is, as of this writing, also a to-do in the top-level <code>flow</code> namespace doc header about bringing some code into a new <code>io</code> namespace/Flow module; this includes the aforementioned <code>recvmsg()</code> wrapper.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000102">Todo:</a></b></dt><dd>It may be desirable to further use <code>recvmmsg()</code> for UDP input; this allows to read multiple UDP datagrams with one call for performance.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000103">Todo:</a></b></dt><dd>By the same token, wrapping <code>sendmsg()</code> and <code>sendmmsg()</code> may allow for futher perf and feature improvements &ndash; in some ways potentially symmetrically to <code>recvmsg()</code> and <code>recvmmsg()</code> respectively. However, as of this writing, I (ygoldfel) see this more of an opportunistic "look into it" thing and not something of active value; whereas <code>recv[m]msg()</code> bring actual features we actively desire for practical reasons.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000104">Todo:</a></b></dt><dd>Send and Receive buffer max sizes: These are set to some constants right now. That's not optimal. There are two competing factors: throughput and RAM. If buffer is too small, throughput can suffer in practice, if the Receiver can't read the data fast enough (there are web pages that show this). Possibly with today's CPUs it's no longer true, but I don't know. If buffer is too large and with a lot of users, a LOT of RAM can be eaten up (however note that a server will likely be mostly sending, not receiving, therefore it may need smaller Receive buffers). Therefore, as in Linux 2.6.17+, the buffer sizes should be adaptively sized. It may be non-trivial to come up with a good heuristic, but we may be able to copy Linux. The basic idea would probably be to use some total RAM budget and divide it up among the # of sockets (itself a constant estimate, or adaptive based on the number of sockets at a given time?). Also, buffer size should be determined on the Receive side; the Send side should make its buffer to be of equal size. Until we implement some sensible buffer sizing, it might be a good idea (for demo purposes with few users) to keep the buffers quite large. However, flow control (receive window) is now implemented and should cope well with momentary Receive buffer exhaustion. Related facts found on the web: In Linux, since a long time ago, Send buffer size is determined by other side's Receive buffer size (probably sent over in the SYN or SYN-ACK as the receive window). Also, in older Linuxes, Receive buffer defaults to 128k but can be manually set. Supposedly the default can lead to low throughput in high-speed (gigabit+) situations. Thus Linux 2.6.17+ apparently made the Receive buffer size adaptive.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000105">Todo:</a></b></dt><dd>Drop Acknowledgments: DCCP, a somewhat similar UDP-based protocol, uses the concept of Data-Dropped acknowledgments. If a packet gets to the receiver, but the receiver is forced to drop it (for example, no Receive buffer space; not sure if there are other reasons in Flow protocol), then the sender will only find out about this by inferring the drop via Drop Timeout or getting acknowledgments for later data. That may take a while, and since receiver-side drops can be quite large, it would be more constructive for the receive to send an un-ACK of sorts: a Data-Dropped packet informing the sender that specific data were dropped. The sender can then update his congestion state (and retransmit if we enable that). See RFC 4340 and 4341.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000106">Todo:</a></b></dt><dd>Add extra-thread-safe convention for setting options: We can provide a thread-safe (against other user threads doing the same thing) macro to set a given option. <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> has a documented, albeit in practice not usually truly problematic, thread safety flaw if one calls <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>, modifies the result, then calls <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. Since another thread may modify the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s options between the two calls, the latter call may unintentionally revert an option's value. Macro would take an option "name" (identifier for the <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> member), a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, and a target value for the option and would work together with a helper method template to obtain the necessary lock, make the assignment to the internal option, and give up the lock. The implementation would probably require <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to expose its internal stored <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> for the benefit of this macro only. Anyway, this feature is not super-important, as long as the user is aware that modifying options from multiple threads simultaneously may result in incorrect settings being applied.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000107">Todo:</a></b></dt><dd>The preceding to-do regarding <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> applies to <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> stored in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> in in an analogous way.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000108">Todo:</a></b></dt><dd>Consider removing Flow ports and even <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>: As explained above, we add the concept of a large set of available Flow ports within each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, and each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> itself has a UDP port all to itself. So, for example, I could bind a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to UDP port 1010, and within that <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> on Flow ports 1010 (unrelated to UDP port 1010!) and 1011. In retrospect, though, is that complexity necessary? We could save quite a few lines of code, particularly in the implementation (class <a class="el" href="classflow_1_1net__flow_1_1Port__space.html" title="Internal net_flow class that maintains the available Flow-protocol port space, somewhat similarly to ...">Port_space</a>, for example) and the protocol (extra bytes for Flow source and target ports, for example). (They're fun and pretty lines, but the absence of lines is arguably even prettier albeit less fun. On the other hand, bugs aren't fun, and more code implies a higher probability of bugs, maintenance errors, etc.) The interface would also be a bit simpler; and not just due to fewer items in <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html" title="Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...">Remote_endpoint</a> (which would in fact reduce to <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> and cease to exist). Consider <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>; currently <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> takes a <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d" title="Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).">flow_port_t</a> argument and returns a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which is listening; calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a> (etc.) on the latter yields <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, as the other side connects. Without Flow ports, there is no argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>; in fact, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> itself is not strictly necessary and could be folded into <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> becoming essentially something that turns on the "are we listening?" Boolean state, while stop_listening() would turn it off (instead of something like <code>Server_socket::close()</code>). (Important note: That was not an endorsement of removing <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. Arguably it is still a nice abstraction. Removing it would certainly remove some boiler-plate machinery to do with <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>'s life cycle, on the other hand. Perhaps it's best to take a two-step appraoch; remove Flow ports first; then after a long time, assuming it becomes clear that nothing like them is going to come back, remove <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> as well.) A key question is, of course what would we lose? At first glance, Flow port allows multiple connections on a single UDP-port-taking Flow server, including multiple connections from one client (e.g., with differing connection parameters such as reliability levels among the different connections, or "channels")... but actually that'd still work without Flow ports, assuming the "one client's" multiple connections can bind to different (presumably ephemeral) UDP ports; since the tuple (source host, source UDP port) is still enough to distinguish from the 2+ "channels" of the same "client" connecting to the one Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (vs. today's tuple: source host, source UDP port, source Flow port, destination Flow port; see <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html" title="The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to a port in th...">Socket_id</a>). However, without Flow ports, it is not possible for one <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to connect to another <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> twice, as each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> by definition is on one port. Is this important? Maybe, maybe not; for NAT purposes it can be important to use only 1 port; but that typically applies only to the server, while the client can send packets from anywhere. However, gaming applications can be very demanding and for the most restrictive NAT types might desire only a single port used on both sides. So whether to remove Flow ports is somewhat questionable, now that they exist; but arguably they didn't need to be added in the first place, until they were truly needed. I'd probably leave them alone, since they do exist.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000109">Todo:</a></b></dt><dd>Multi-core/multi-threading: The existing implementation already has a nice multi-threaded property, namely that each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (object that binds to a single UDP endpoint/port) is entirely independent of any other such object &ndash; they have entirely separate data, and each one does all its work on a separate thread. So to make use of multiple cores/processors, one can set up multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects. (Obviously this only makes sense for apps where using multiple ports is acceptable or even desired. E.g., a server could listen on N different UDP ports, where N=# of cores.) However, it would be nice for a single <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to be as multi-core/processor-friendly as possible. This is partially addressed by the "Dedicated thread to receive
UDP datagrams ASAP" to-do item elsewhere. We could go further. boost.asio lets one easily go from 1 thread to multiple threads by simply starting more worker threads like W (W1, W2, ...) and executing <code>m_task_engine::run()</code> in each one &ndash; note that <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a> is shared (sans lock). Then subsequent handlers (timer-fired handlers, ack-received handlers, data-received handlers, and many more) would be assigned evenly to available threads currently executing run(). However, then all data these handlers access would need to be protected by a mutex or mutexes, which would be a significant increase in complexity and maintenance headaches compared to existing code, which features mutexes for data accessed both by W and the user thread(s) U &ndash; which excludes most <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> state &ndash; essentially the user-visible "state" enums, and the Receive and Send buffers; but hugely complex things like the scoreboards, etc. etc., needed no mutex protection, but with this change they would need it. Actually, if the implementation essentially uses one mutex M, and every handler locks it for the entirety of its execution, then one isn't really making use of multi-cores/etc. anyway. One could make use of boost.asio "strands" to avoid the need for the mutex &ndash; just wrap every handler in a shared strand S, and no locking is needed; boost.asio will never execute two handlers simultaneously in different threads. While this would arguably make the code simpler, but in terms of performance it wouldn't make any difference anyway, as it is functionally equivalent to the lock-M-around-every-operation solution (in fact, internally, it might even amount to exactly that anyway). So that's probably not worth it. We need to have more mutexes or strands, based on some other criterion/criteria. After a datagram is demuxed, vast majority of work is done on a particular socket independently of all others. Therefore we could add a mutex (or use an equivalent) into the socket object and then lock on that mutex. Multiple threads could then concurrently handle multiple sockets. However, for this to be used, one would have to use a single <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (UDP endpoint) with multiple sockets at the same time. Without any changes at all, one can get the same concurrency by instead setting up multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects. Other than a bit of lost syntactic sugar (arguably) &ndash; multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects needed, each one having to initialize with its own set of options, for example &ndash; this is particularly cost-free on the client side, as each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can just use its own ephemeral UDP port. On the server side the network architecture has to allow for multiple non-ephemeral ports, and the client must know to (perhaps randomly) connect to one of N UDP ports/endpoints on the server, which is more restrictive than on the client. So perhaps there are some reasons to add the per-socket concurrency &ndash; but I would not put a high priority on it. IMPORTANT UPDATE: Long after the preceding text was written, <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> Flow module was created containing <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">flow::async::Concurrent_task_loop</a> interface. That looks at the general problem of multi-tasking thread pools and what's the user-friendliest-yet-most-powerful way of doing it. While the preceding discussion in this to-do has been left unchanged, one must first familiarize self with <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a>; and <em>then</em> read the above, both because some of those older ideas might need reevaluation; and because some of those ideas may have been implemented by <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> and are now available easily.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000110">Todo:</a></b></dt><dd>In <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5" title="Completion handler for async_low_lvl_packet_send_impl(); called when the packet is either successfull...">Node::low_lvl_packet_sent()</a>, the UDP <code>async_send()</code> handler, there is an inline to-do about specially treating the corner case of the <code>would_block</code> and <code>try_again</code> boost.asio errors being reported (a/k/a POSIX <code>EAGAIN</code>/<code>EWOULDBLOCK</code>). Please see that inline comment for details.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000111">Todo:</a></b></dt><dd>Class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> <code>private</code> section is very large. It's so large that the implementations of the methods therein are split up among different files such as <code>flow_peer_socket.cpp</code>, <code>flow_event_set.cpp</code>, <code>flow_low_lvl_io.cpp</code>, etc. Consider the following scheme to both better express this separation as well as enforce which of a given method group's method(s) are meant to be called by outside code vs. being helpers thereof: Introduce <code>static</code>-method-only inner classes (and, conceivably, even classes within those classes) to enforce this grouping (<code>public</code> methods and <code>private</code> methods enforcing what is a "public" helper vs. a helper's helper).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000112">Todo:</a></b></dt><dd>We are now on Boost 1.75; the use of asio's <code>null_buffers</code> semantics is deprecated and should be changed to the replacement mechanism suggested in Boost docs &ndash; the <code>async_wait()</code> method.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000113">Todo:</a></b></dt><dd>Make use of <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">flow::async::Concurrent_task_loop</a> or <a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html" title="A Concurrent_task_loop-related adapter-style class that represents a single-thread task loop; essenti...">flow::async::Single_thread_task_loop</a>, instead of manually setting up a thread and <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3" title="Worker thread (= thread W). Other members should be initialized before this to avoid race condition.">m_worker</a>. I, Yuri, wrote the constructor, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7" title="Worker thread W (main event loop) body.">worker_run()</a>, destructor, and related setup/teardown code as my very first boost.asio activity ever. It's solid, but <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> just makes it easier and more elegant to read/maintain; plus this would increase Flow-wide consistency. It would almost certainly reduce the number of methods and, even nicely, state (such as <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90" title="Promise that thread W sets to truthy Error_code if it fails to initialize or falsy once event loop is...">m_event_loop_ready</a>).</dd></dl>
<h2>Misc. topic: Doxygen markup within a Doxygen command </h2>
<p >This section may seem random: Indeed, it is the meat of a similarly named ("Doxygen markup," etc.) subsection of the doc header on the very-general namespace <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a>. As noted in that subsection, this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> class is a more convenient place to explain this, because it is a large class with many examples available. Without further ado:</p>
<p ><a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header discusses which items should be accompanied by Doxygen comment snippets. More specifically, each item is accompanied by a Doxygen "command". <code>"@param param_name Explain parameter here."</code>, for example, documents the parameter <code>param_name</code> with the text following that. (Some commands are implicit; namely without an explicit <code>"@brief"</code>, the first sentence is the brief description of the class/function/whatever.)</p>
<p >However, all that doesn't talk about formatting the <em>insides</em> of paragraphs in these commands. Essentially we are saying just use English. However, Doxygen uses certain markup language conventions when interpreting those paragraphs. For example <code>backticks</code> will turn the thing inside the ticks into an inline code snippet, in fixed-width font. There are a few things to watch out for with this:</p>
<ul>
<li>Don't accidentally enable markup when you don't mean to. E.g., an * asterisk as the first character in a paragraph will cause a bullet point to appear. Also, sometimes you do want to use some character for semantical reason X which Doxygen shares with you, but automatic markup handling might make it come out a little wrong. Just learn these through practice and check over the generated web page(s) before checking in the code.</li>
<li>DO use markup within reason for certain COMMON items. Do not overdo it: mostly it should be things you're keen to do even if there were NO Doxygen or Javadoc involved. Bullet point lists are an example. Basically: If you were going to do something anyway, why not have it come out nicely in the doc page(s)?</li>
<li>Make use of auto-linking (a/k/a automatic liwnk generation) liberally. This is when Doxygen sees a certain pattern within a Doxygen comment and understands it a reference to some other object, like a class or method; so in the output this will come out as a link to that thing. The nice thing is that, usually, within raw code it looks fine/normal; AND the generated page has the convenient linking functionality. However, if enabling linking in a certain case is too tedious, feel free to not.</li>
</ul>
<p >That said, I will now list all of the pieces of markup that are allowed within comments inside Flow code. Try not to add to this list without a very good reason. Simplicity is a virtue.</p>
<ul>
<li>Bullet points: Just a dash after one indent level: <code>"  - Item text."</code>. Nesting allowed.<ul>
<li>Numbered points: just type out the numbers explicitly instead of auto-numbering: <code>" 2. Item text."</code>; not <code>"  -# Item text."</code>. Yes, it leaves the numbering to you, but more importantly the raw comment remains readable, and you can refer to the numbers (e.g., "according to the condition in item 3" makes more sense when you can see a <code>3.</code> nearby).</li>
</ul>
</li>
<li>Emphasis: Just one asterisk before and after the emphasized stuff: <em>word</em>, <em>multiple words</em>. No "_underscores_" please. In general try to avoid too much emphasis, as asterisks are common characters and can confuse Doxygen. Plus, you shouldn't need to emphasize stuff THAT much. Plus, feel free to use CAPITALS to emphasize instead.</li>
<li><p class="startli">Inline code snippets: Backticks. <code>single_word</code>, <code>an_expression != other_expression * 2</code>. Definitely use this liberally: it helps readability of BOTH raw code and looks delightful in the generated web page(s). However, note explanation below regarding how this relates to auto-linking.</p><ul>
<li>Syntax-highlighted code spans: Use three tildes <code>"~~~"</code> to begin and end a code snippet. This MUST be used for multi-line code snippets; and CAN be used instead of <code>backticks</code> for single-line code snippets. The output will be a separate paragraph, just like the raw code should be. More precisely, the tildes and code should follow a single absolute indentation level:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (some_condition) <span class="comment">// Generated output will also be syntax-highlighted.</span></div>
<div class="line">{</div>
<div class="line">  obj.call_it(arg1, <span class="stringliteral">&quot;quote&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Large heading in a long doc header: Use the format seen in this comment itself: Words, underlined by a row of dashes ("----", etc.) on the next line. This results in a fairly large-fonted title.</li>
<li>Small heading is a long doc header: IF AND ONLY IF you need a sub-heading under a large heading (which would probably be in only quite long doc headers indeed), use the ### format. Again use the format seen in this very doc header. This results in a slightly large-fonted title (pretty close to normal).<ul>
<li>Avoid any other levels of heading. At that point things have become too complex.</li>
</ul>
</li>
<li>Escape from Doxygen formatting: To ensure Doxygen interprets a bunch of characters literally, when you know there is danger of it applying unwanted formatting, surround it in quotes. The quotes will be included in the output just like in the raw code; but anything inside quotes will be output verbatim even if full of Doxygen markup or commands. For example, if I don't want a to-do item to begin in the middle of this paragraph, but I do want to refer to how a to-do is declared is Doxygen comments, I will surround it in quotes: To declare a to-do, use the <code>"@todo"</code> command. Note that in that example I put <code>backticks</code> around the text to format the whole thing a certain way; any formatting already in effect will continue through the "quoted" text; but no formatting inside the "quotes" will go in effect. Plus, it looks appropriate in raw code. Best of all worlds.</li>
</ul>
<p >The most tricky yet powerful technique to learn here is the interplay between auto-linking and <code>inline code snippets</code>. Before discussing that in some detail, note the auto-linking which is allowed in this source code:</p>
<ul>
<li>Class/<code>struct</code>/union names are auto-linked: for example, just <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. That's because every class/<code>struct</code>/union for us starts with a Capital letter. Easy!</li>
<li>A method local to the class/<code>struct</code> being documented, like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> in this class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> which we are documenting right now, is auto-linked as written.</li>
<li>ANY member explicitly specified as belonging to a class/<code>struct</code>/union or namespace is auto-linked as written. It can be a member function, variable, alias, nested class, or <em>anything</em> else. The presence of <code>"::"</code> will auto-link whatever it is. Note this is a very powerful auto-linking technique; the vast majority of things are members of something, even if's merely a namespace, so if you absolutely must auto-link something, there is always at least one straightforward way: a <em>fully or partially qualified name</em>. It will be simple/readable as raw source and equally simple/readable AND linked in the doc output. The only <em>possible</em> (not really probable, but it certainly happens) down-side is it can be too verbose.<ul>
<li>Example: alias-type: <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html#ad9db6f435dfc65b7bd4b539467f1c3ec" title="The counter type used to distinguish a given start_timer() call from any other such call (for this ob...">Drop_timer::timer_wait_id_t</a>; method: <a class="el" href="classflow_1_1net__flow_1_1Port__space.html#a9fe1be917ff7584ff587b5da5967127a" title="Return a previously reserved port (of any type).">Port_space::return_port()</a>.</li>
<li>Macros are not members of anything and thus cannot be auto-linked by qualifying them. However, read below on how to auto-link them too.</li>
</ul>
</li>
<li>A free (non-member) function or functional macro will generally auto-link, even if it's in some other namespace.<ul>
<li>This can result in name collisions, if some function <code>f()</code> is in two namespaces meaning two entirely different things. And not just functions but anything else, like classes, can thus collide. That is, after all, why namespaces exist! Just be careful and qualify things with namespace paths when needed (or even just for clarity).</li>
</ul>
</li>
<li>For non-functions/methods: Things like variables/constants, type aliases, <code>enum</code> values will not auto-link if seen "naked." For example S_PORT_ANY is, to Doxygen, just a word. We use either <code>"#"</code> or <code>"::"</code> to force auto-linking. Here is how to decide which one to use:<ul>
<li><code>"#id"</code>: To refer to a <em>member</em> of anything (compound type, namespace) member named <code>id</code>, such that the <em>currently documented item</em> is also a member of that [anything] &ndash; either at the same depth (e.g., in the same class) or deeper (e.g., <code>id</code> is in namespace <code>flow</code>, while we are in namespace <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a></code>, or in class <code>flow::Some_class</code>, or both &ndash; <code>flow::net_flow::Some_class</code>). Example: <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a" title="Short-hand for UDP socket.">Udp_socket</a> (member alias), <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463" title="Total number of Flow ports in the port space, including S_PORT_ANY.">S_NUM_PORTS</a> (member constant), <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> (member variable).</li>
<li><code>"::id"</code>: To refer to an item in the global namespace. Almost always, this will be an (outer) namespace. Global-namespace members that are not themselves namespaces are strongly discouraged elsewhere. Example: <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> (namespace).</li>
</ul>
</li>
<li>A functional macro is formatted the same as a free function in global namespace: e.g., <a class="el" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc" title="Logs a WARNING message into flow::log::Logger *get_logger() with flow::log::Component get_log_compone...">FLOW_LOG_WARNING()</a>.</li>
<li>If a non-functional macro needs to be documented (VERY rare or non-existent given our coding style), use this special format: <code>"#MACRO_NAME"</code>. <code>"::"</code> is inappropriate, since a macro does not belong to a namespace (global or otherwise), and that would look confusing in raw code.</li>
</ul>
<p >Now finally here are the guidelines about what to use: <code>backticks</code>, an auto-linked symbol, or both. Suppose there is some comment <em>snippet</em> X that you are considering how to format.</p>
<ul>
<li>If X is just a piece of English language and not referring to or quoting code per se, then do not format it. Type it verbatim: "The socket's state is ESTABLISHED here." Even though ESTABLISHED may be thought of as code, here it's referring more to a concept (the state "ESTABLISHED") rather than code snippet. <code>S_ESTABLISHED</code> is a different story, on the other hand, and that one you must either backtick (as I just did there) or auto-link; read on for guidelines on that.</li>
<li>If the <em>entirety</em> of X is an identifier:<ul>
<li>Auto-link it, WITHOUT backticks, if to auto-link it you would just write X verbatim anyway. For example, mentioning <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> just like that will auto-link it. So, that's great. Do NOT add backticks, as that increases code verbosity and adds very little (making the auto-linked <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a></code> also use a fixed-width font; meh).</li>
<li>Auto-link it, WITHOUT backticks, if you would like the convenience of it being auto-linked in the output.<ul>
<li>Do NOT auto-link it, but DO add <code>backticks</code>, if you do not need the convenience of the auto-linked output. Backticks are easy: auto-linking can be a little tricky/verbose. So in that case just <code>backtick</code> it for readable raw source AND pretty output; without worrying about subtleties of proper auto-linking.</li>
</ul>
</li>
</ul>
</li>
<li>If X consists of some identifiers but also contains non-identifiers:<ul>
<li>The non-code parts should be verbatim.</li>
<li>ALL code parts should be in <code>backticks</code>.</li>
<li>IF you want the convenience of some parts of the output being auto-linked, auto-link those parts.<ul>
<li>IF you'd prefer shorter and clearer raw code, then don't auto-link where doing so would require extra raw code characters.</li>
</ul>
</li>
<li>Example: Suppose X is: "The allowed range is [S_FIRST_SERVICE_PORT + 1, S_FIRST_EPHEMERAL_PORT + 2)." Variant 1 will auto-link but a bit longer and less readable as raw code. Variant 2 will forego auto-linking but is short and readable as raw code.<ul>
<li><em>Variant 1</em>: The allowed range is [<code>#S_FIRST_SERVICE_PORT + 1</code>, <code>#S_FIRST_EPHEMERAL_PORT + 2</code>).</li>
<li><em>Variant 2</em>: The allowed range is [<code>S_FIRST_SERVICE_PORT + 1</code>, <code>S_FIRST_EPHEMERAL_PORT + 2</code>).</li>
</ul>
</li>
<li>Example: Suppose X is: "The condition holds if sock-&gt;m_local_port != 2223." Variant 1 is brief and readable. Variant 2 is readable enough but much longer. However, it will very conveniently auto-link to that obscure data member for the web page reader's pleasure, the convenience of which shouldn't be dismissed.<ul>
<li><em>Variant 1</em>: The condition holds if <code>sock-&gt;m_local_port != 2223</code>.</li>
<li><em>Variant 2</em>: The condition holds if <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd" title="See local_port(). Should be set before user gets access to *this and not changed afterwards.">Peer_socket::m_local_port</a> != 2223</code> (for <code>sock</code>). </li>
</ul>
</li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00933">933</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff19033bff73d4f51766a9575c01f883" name="aff19033bff73d4f51766a9575c01f883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff19033bff73d4f51766a9575c01f883">&#9670;&nbsp;</a></span>Event_sets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">flow::net_flow::Node::Event_sets</a> =  boost::unordered_set&lt;<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A set of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01456">1456</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a97c8679c70ac9c7dda394fdf335aaed7" name="a97c8679c70ac9c7dda394fdf335aaed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c8679c70ac9c7dda394fdf335aaed7">&#9670;&nbsp;</a></span>Options_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">flow::net_flow::Node::Options_lock</a> =  <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Peer_socket::Options_lock</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for lock that acquires exclusive access to an <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138" title="Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.">Options_mutex</a>. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01439">1439</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a4903f254cff9d2605ace404174203138" name="a4903f254cff9d2605ace404174203138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4903f254cff9d2605ace404174203138">&#9670;&nbsp;</a></span>Options_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">flow::net_flow::Node::Options_mutex</a> =  <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Peer_socket::Options_mutex</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for high-performance, non-reentrant, exclusive mutex used to lock <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01436">1436</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c" name="a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">&#9670;&nbsp;</a></span>Port_to_server_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">flow::net_flow::Node::Port_to_server_map</a> =  boost::unordered_map&lt;<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from the local Flow port to the local <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> listening on that port. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01453">1453</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a1c2fe94f0b1064d35ce99c58bc95dc0f" name="a1c2fe94f0b1064d35ce99c58bc95dc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2fe94f0b1064d35ce99c58bc95dc0f">&#9670;&nbsp;</a></span>Signal_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">flow::net_flow::Node::Signal_set</a> =  boost::asio::signal_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for a signal set. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01433">1433</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="abfc902bc41381d21f4ca2d4073bb617c" name="abfc902bc41381d21f4ca2d4073bb617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc902bc41381d21f4ca2d4073bb617c">&#9670;&nbsp;</a></span>Socket_id_to_socket_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">flow::net_flow::Node::Socket_id_to_socket_map</a> =  boost::unordered_map&lt;<a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>, <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A map from the connection ID (= remote-local socket pair) to the local <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> that is the local portion of the connection. </p>
<p >Applies to peer-to-peer (not server) sockets. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01450">1450</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a44af106f110963a465065a7ea19185a3" name="a44af106f110963a465065a7ea19185a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44af106f110963a465065a7ea19185a3">&#9670;&nbsp;</a></span>Timer_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3">flow::net_flow::Node::Timer_ptr</a> =  boost::shared_ptr&lt;<a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">util::Timer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>boost.asio timer wrapped in a ref-counted pointer. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01430">1430</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a4f175a1923aeef5eee39bd726e88c93a" name="a4f175a1923aeef5eee39bd726e88c93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f175a1923aeef5eee39bd726e88c93a">&#9670;&nbsp;</a></span>Udp_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">flow::net_flow::Node::Udp_socket</a> =  boost::asio::ip::udp::socket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for UDP socket. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01427">1427</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd93ba39d6a9cdee60c2ad7da1085902" name="acd93ba39d6a9cdee60c2ad7da1085902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd93ba39d6a9cdee60c2ad7da1085902">&#9670;&nbsp;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *&#160;</td>
          <td class="paramname"><em>net_env_sim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Post-condition: <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> ready for arbitrary use. (Internally this includes asynchronously waiting for any incoming UDP packets on the given endpoint.)</p>
<p >Does not block. After exiting this constructor, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> can be used to determine whether <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> initialized or failed to do so; or one can get this from <code>*err_code</code>.</p>
<h3>Potential shared use of <code>Logger *logger</code></h3>
<p >All logging, both in this thread (from which the constructor executes) and any potential internally spawned threads, by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and all objects created through it (directly or otherwise) will be through this Logger. <code>*logger</code> may have been used or not used for any purpose whatsoever prior to this constructor call. However, from now on, <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will assume that <code>*logger</code> will be in exclusive use by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and no other code until destruction. It is strongly recommended that all code refrains from further use of <code>*logger</code> until the destructor <a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118" title="Destroys Node.">~Node()</a> exits. Otherwise, quality of this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s logging (until destruction) may be lowered in undefined fashion except for the following formal guarantees: the output will not be corrupted from unsafe concurrent logging; and the current thread's nickname (for logging purposes only) will not be changed at any point. Less formally, interleaved or concurrent use of the same Logger might result in such things as formatters from <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> log calls affecting output of your log calls or vice versa. Just don't, and it'll look good.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_lvl_endpoint</td><td>The UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. E.g.: <code>Udp_endpoint(Ip_address_v4::any(), 1234)</code> // UDP port 1234 on all IPv4 interfaces. </td></tr>
    <tr><td class="paramname">logger</td><td>The Logger implementation through which all logging from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will run. See notes on logger ownership above. </td></tr>
    <tr><td class="paramname">net_env_sim</td><td>Network environment simulator to use to simulate (fake) external network conditions inside the code, e.g., for testing. If 0, no such simulation will occur. Otherwise the code will add conditions such as loss and latency (in addition to any present naturally) and will take ownership of the the passed in pointer (meaning, we will <code>delete</code> as we see fit; and you must never do so from now on). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> failed to initialize), <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>The low-level per-Node options to use. The default uses reasonable values that normally need not be changed. No reference to opts is saved; it is only copied. See also <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">Node::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">Node::options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">Peer_socket::options()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00040">40</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="util__fwd_8hpp_source.html#l00971">FLOW_UTIL_WHERE_AM_I_STR</a>, <a class="el" href="node_8hpp_source.html#l03883">m_event_loop_ready_result</a>, <a class="el" href="node_8hpp_source.html#l03893">m_worker</a>, and <a class="el" href="node_8cpp_source.html#l01107">options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_acd93ba39d6a9cdee60c2ad7da1085902_cgraph.svg" width="536" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a16c53c4848ea976b075a0b56f33eb118" name="a16c53c4848ea976b075a0b56f33eb118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c53c4848ea976b075a0b56f33eb118">&#9670;&nbsp;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Closes all <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects as if by <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632" title="Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...">close_abruptly()</a></code>. Then closes all <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects Then closes all <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects as if by <code>event_set-&gt;close()</code>. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000114">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects closed as if by what?</dd></dl>
<p >Frees all resources except the objects still shared by <code>shared_ptr&lt;&gt;</code>s returned to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> user. All <code>shared_ptr&lt;&gt;</code> instances inside <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> sharing the latter objects are, however, eliminated. Therefore any such object will be deleted the moment the user also eliminates all her <code>shared_ptr&lt;&gt;</code> instances sharing that same object; any object for which that is already the case is deleted immediately.</p>
<p >Does not block.</p>
<p >Note: as a corollary of the fact this acts as if <code>{Peer|Server_}socket::close_abruptly()</code> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>, in that order, were called, all event waits on the closed sockets (<code>sync_send()</code>, <code>sync_receive()</code>, <code>sync_accept()</code>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>) will execute their on-event behavior (<code>sync_send()</code> return, <code>sync_receive()</code> return, <code>sync_accept()</code> return, <code>sync_wait()</code> return and invoke handler, respectively). Since <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a> is executed soon after the sockets close, those <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects are cleared. Therefore, the user on-event behavior handling may find that, despite a given event firing, the containing <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is empty; or they may win the race and see an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> with a bunch of <code>S_CLOSED</code> sockets. Either way, no work is possible on these sockets.</p>
<p >Rationale for previous paragraph: We want to wake up any threads or event loops waiting on these sockets, so they don't sit around while the underlying <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is long since destroyed. On the other hand, we want to free any resources we own (including socket handles inside <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>). This solution satisfies both desires. It does add a bit of non-determinism (easily handled by the user: any socket in the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>, even if user wins the race, will be <code>S_CLOSED</code> anyway). However it introduces no actual thread safety problems (corruption, etc.).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000115">Todo:</a></b></dt><dd>Provide another method to shut down everything gracefully? </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00139">139</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, and <a class="el" href="node_8hpp_source.html#l03893">m_worker</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3c67514c259404de3f27a8cae8b0567" name="ac3c67514c259404de3f27a8cae8b0567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c67514c259404de3f27a8cae8b0567">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of non-blocking <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> for server socket <code>serv</code> in all cases except when <code>serv-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">Server_socket::State::S_CLOSED</a></code>. </p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>serv-&gt;m_mutex</code> is locked and just after entering <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>;</li>
<li>no changes to <code>*serv</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>serv-&gt;state() != <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">Server_socket::State::S_CLOSED</a></code> (so <code>serv</code> is in <code>m_servs</code>).</li>
</ul>
<p >This method completes the functionality of <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket, which must be in <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df" title="The server sockets this Node is currently tracking.">m_servs</a>, on which <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> was called. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00300">300</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00218">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42">flow::net_flow::Server_socket::S_CLOSING</a>, and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a">flow::net_flow::Server_socket::S_LISTENING</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00075">flow::net_flow::Server_socket::accept()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00100">flow::net_flow::Server_socket::sync_accept_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac3c67514c259404de3f27a8cae8b0567_icgraph.svg" width="548" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a80d58cfa8fad00a116a38f76ccb2b868" name="a80d58cfa8fad00a116a38f76ccb2b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d58cfa8fad00a116a38f76ccb2b868">&#9670;&nbsp;</a></span>advance_seq_num() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::advance_seq_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *&#160;</td>
          <td class="paramname"><em>seq_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming <code>*seq_num</code> points to the start of data.m_data, increments <code>*seq_num</code> to point to the datum just past <code>data-&gt;m_data</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_num</td><td>Pointer to sequence number to increment. </td></tr>
    <tr><td class="paramname">data</td><td>DATA packet whose <code>m_data</code> to examine. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06456">6456</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l06456">advance_seq_num()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06456">advance_seq_num()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06479">get_seq_num_range()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a80d58cfa8fad00a116a38f76ccb2b868_cgraph.svg" width="146" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a80d58cfa8fad00a116a38f76ccb2b868_icgraph.svg" width="942" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a95399fe09e4bd18ac2a43b2fbec8ab17" name="a95399fe09e4bd18ac2a43b2fbec8ab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95399fe09e4bd18ac2a43b2fbec8ab17">&#9670;&nbsp;</a></span>advance_seq_num() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::advance_seq_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *&#160;</td>
          <td class="paramname"><em>seq_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming <code>*seq_num</code> points to the start of some data of the given size, increments <code>*seq_num</code> to point to the datum just past that amount of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_num</td><td>Pointer to sequence number to increment. </td></tr>
    <tr><td class="paramname">data_size</td><td>Data size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06468">6468</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a8ece1750c8f0bee297af113f8808b7a6" name="a8ece1750c8f0bee297af113f8808b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ece1750c8f0bee297af113f8808b7a6">&#9670;&nbsp;</a></span>async_acknowledge_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_acknowledge_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;&#160;</td>
          <td class="paramname"><em>seq_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rexmit_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes an acknowledgment of the given received packet to be included in a future <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a> sent to the other side. </p>
<p >That ACK low-level UDP packet is not sent in this handler, even if the low-level UDP socket is currently writable. The sending of this packet is performed asynchronously in the manner of <code>boost::asio::io_service::post()</code>.</p>
<p >Note that the <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a> may include other packets being acknowledged; and that ACK may be artificially delayed for reasons like the desire to accumulate more acknowledgments before sending ACK (to cut down on overhead).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. </td></tr>
    <tr><td class="paramname">seq_num</td><td>Sequence number of first datum in the packet to be acknowledged. </td></tr>
    <tr><td class="paramname">rexmit_id</td><td>Which attempt are we acknowledging (0 = initial send, 1 = first retransmission, 2 = second retransmission, ...). Always 0 if retransmission is off. </td></tr>
    <tr><td class="paramname">data_size</td><td>Number of bytes in the user data in the packet to be acknowledged. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01581">1581</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

</div>
</div>
<a id="a81e50276d0b162f6577adc690e0ef9e0" name="a81e50276d0b162f6577adc690e0ef9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e50276d0b162f6577adc690e0ef9e0">&#9670;&nbsp;</a></span>async_low_lvl_ack_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_low_lvl_ack_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>sys_err_code</em> = <code><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a low-level ACK packet, with all accumulated in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">Peer_socket::m_rcv_pending_acks</a> of <code>sock</code> individual packet acknowledgments, to the other side's UDP endpoint. </p>
<p >If the pending acknowledgments don't fit into one ACK, more ACKs are generated and sent as necessary. If there is an error sending or preparing to send, <code>sock</code> is closed abruptly (<a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>).</p>
<p >This may be called either directly or by boost.asio due to delayed ACK timer being triggered. If <code>sock</code> is not in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>, this does nothing except possibly logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket the remote side of which will get the RST. Method is basically a NOOP unless state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
    <tr><td class="paramname">sys_err_code</td><td>If invoked via timer trigger, this is boost.asio's error code. If invoked directly, this should be set to the default (success). Value is handled as follows: assuming ESTABLISHED state: <code>operation_aborted</code> =&gt; NOOP; success or any other error =&gt; attempt to send ACK(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05857">5857</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8cpp_source.html#l01112">max_block_size()</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a81e50276d0b162f6577adc690e0ef9e0_cgraph.svg" width="1723" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9f302fe63e36f72931e1a759b0aaaed4" name="a9f302fe63e36f72931e1a759b0aaaed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f302fe63e36f72931e1a759b0aaaed4">&#9670;&nbsp;</a></span>async_low_lvl_packet_send_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_low_lvl_packet_send_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>delayed_by_pacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> specified by the given UDP endpoint. </p>
<p >The local and target ports are assumed to be already filled out in <code>*packet</code>. Once the send is possible (i.e., UDP net-stack is able to buffer it for sending; or there is an error), <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5" title="Completion handler for async_low_lvl_packet_send_impl(); called when the packet is either successfull...">low_lvl_packet_sent()</a> is called (asynchronously).</p>
<p >Takes ownership of <code>packet</code>; do not reference it in any way after this method returns.</p>
<dl class="section note"><dt>Note</dt><dd>This method exiting in no way indicates the send succeeded (indeed, the send cannot possibly initiate until this method exits).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>UDP endpoint for the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to which to send the packet. </td></tr>
    <tr><td class="paramname">packet</td><td>Pointer to packet structure with everything filled out as desired. </td></tr>
    <tr><td class="paramname">delayed_by_pacing</td><td><code>true</code> if there was a (pacing-related) delay between when higher-level code decided to send this packet and the execution of this method; <code>false</code> if there was not, meaning said higher-level code executed us immediately (synchronously), though not necessarily via a direct call (in fact that's unlikely; hence <code>_impl</code> in the name). </td></tr>
    <tr><td class="paramname">sock</td><td><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> associated with this connection; null pointer if none is so associated. If not null, behavior undefined unless <code>low_lvl_remote_endpoint == sock-&gt;remote_endpoint().m_udp_endpoint</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00321">321</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00242">FLOW_LOG_DATA</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00497">low_lvl_packet_sent()</a>, <a class="el" href="options_8hpp_source.html#l00553">flow::net_flow::Node_options::m_dyn_low_lvl_max_packet_size</a>, <a class="el" href="node_8hpp_source.html#l03753">m_low_lvl_sock</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00422">mark_data_packet_sent()</a>, and <a class="el" href="node_8hpp_source.html#l04180">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00313">async_no_sock_low_lvl_packet_send()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00307">async_sock_low_lvl_packet_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a9f302fe63e36f72931e1a759b0aaaed4_cgraph.svg" width="555" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a9f302fe63e36f72931e1a759b0aaaed4_icgraph.svg" width="1866" height="510"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ade12d2ebbd88b62432089a3a071b9514" name="ade12d2ebbd88b62432089a3a071b9514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade12d2ebbd88b62432089a3a071b9514">&#9670;&nbsp;</a></span>async_low_lvl_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_low_lvl_recv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers so that during the current or next <code>m_task_engine.run()</code>, the latter will wait for a receivable UDP packet and, when one is available, will call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>. </p>
<p >Pre-condition: we are in thread W. </p>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00031">31</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>, and <a class="el" href="node_8hpp_source.html#l03753">m_low_lvl_sock</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade12d2ebbd88b62432089a3a071b9514_cgraph.svg" width="1159" height="262"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade12d2ebbd88b62432089a3a071b9514_icgraph.svg" width="356" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acaf55766783893827061fd85cab2634f" name="acaf55766783893827061fd85cab2634f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf55766783893827061fd85cab2634f">&#9670;&nbsp;</a></span>async_low_lvl_syn_ack_ack_send_or_close_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::async_low_lvl_syn_ack_ack_send_or_close_immediately </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>syn_ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to create, fully fill out, and asynchronously send via <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d" title="Similar to async_sock_low_lvl_packet_send_paced() except it also calls close_connection_immediately(s...">async_sock_low_lvl_packet_send_or_close_immediately()</a> a SYN_ACK_ACK packet. </p>
<p >Since rcv_wnd is advertised, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7fa76b609ef0aa5962d8de77338cf9ee" title="The last rcv_wnd value sent to the other side (in an ACK).">Peer_socket::m_rcv_last_sent_rcv_wnd</a> is updated for <code>sock</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff" title="async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...">async_sock_low_lvl_packet_send()</a>. </td></tr>
    <tr><td class="paramname">syn_ack</td><td>SYN_ACK to which the resulting SYN_ACK_ACK is the reply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff" title="async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...">async_sock_low_lvl_packet_send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05839">5839</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_acaf55766783893827061fd85cab2634f_cgraph.svg" width="1544" height="336"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a08a5752bf3848f31abbe753be47c1fcf" name="a08a5752bf3848f31abbe753be47c1fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5752bf3848f31abbe753be47c1fcf">&#9670;&nbsp;</a></span>async_no_sock_low_lvl_packet_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_no_sock_low_lvl_packet_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a> wrapper to call when <code>packet</code> is to be sent to the remote side of the connection <code>sock</code>. </p>
<p >In particular, this records certain per-socket stats accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>UDP endpoint for the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> to which to send the packet. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00313">313</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00586">async_no_sock_low_lvl_rst_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a08a5752bf3848f31abbe753be47c1fcf_cgraph.svg" width="755" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a08a5752bf3848f31abbe753be47c1fcf_icgraph.svg" width="1151" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a74a6a82a1390a76e985593969fb47184" name="a74a6a82a1390a76e985593969fb47184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a6a82a1390a76e985593969fb47184">&#9670;&nbsp;</a></span>async_no_sock_low_lvl_rst_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_no_sock_low_lvl_rst_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>causing_packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends an RST to the given UDP endpoint in response to the given incoming low-level packet that came from that endpoint, when there is no associated <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> for that remote endpoint/local port combo. </p>
<p >An error is unlikely, but if it happens there is no reporting other than logging.</p>
<p >You should use this to reply with an RST in situations where no <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is applicable; for example if anything but a SYN or RST is sent to a server port. In situations where a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is applicable (which is most of the time an RST is needed), use <a class="el" href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1" title="Sends an RST to the other side of the given socket asynchronously when possible.">async_sock_low_lvl_rst_send()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causing_packet</td><td>Packet we're responding to (used at least to set the source and destination Flow ports of the sent packet). </td></tr>
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>Where <code>causing_packet</code> came from (the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> low-level endpoint). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00586">586</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00313">async_no_sock_low_lvl_packet_send()</a>, and <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a74a6a82a1390a76e985593969fb47184_cgraph.svg" width="955" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a74a6a82a1390a76e985593969fb47184_icgraph.svg" width="1162" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a192d4b95b9f8a5c3d08b1e5486eb6f78" name="a192d4b95b9f8a5c3d08b1e5486eb6f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192d4b95b9f8a5c3d08b1e5486eb6f78">&#9670;&nbsp;</a></span>async_rcv_wnd_recovery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_rcv_wnd_recovery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rcv_wnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357" title="Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...">receive_wnd_updated()</a> helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a rcv_wnd advertisement only and schedules the next iteration of a timer to have this occur again, unless that timer is canceled due to too long a recovery phase or DATA packets arriving from the other side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357" title="Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...">receive_wnd_updated()</a>. </td></tr>
    <tr><td class="paramname">rcv_wnd</td><td>The rcv_wnd (free Receive buffer space) to advertise to the other side. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05397">5397</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="sched__task_8hpp_source.html#l00034">flow::util::schedule_task_from_now()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05263">receive_wnd_updated()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a192d4b95b9f8a5c3d08b1e5486eb6f78_cgraph.svg" width="1507" height="396"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a192d4b95b9f8a5c3d08b1e5486eb6f78_icgraph.svg" width="994" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0db2bb587e0407077b11368df075f0ff" name="a0db2bb587e0407077b11368df075f0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db2bb587e0407077b11368df075f0ff">&#9670;&nbsp;</a></span>async_sock_low_lvl_packet_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_sock_low_lvl_packet_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>delayed_by_pacing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a> wrapper to call when <code>packet</code> is to be sent to the remote side of the connection <code>sock</code>. </p>
<p >In particular, this records certain per-socket stats accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose remote side to target when sending. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>. </td></tr>
    <tr><td class="paramname">delayed_by_pacing</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00307">307</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00605">async_sock_low_lvl_packet_send_paced()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00649">sock_pacing_new_packet_ready()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00849">sock_pacing_process_q()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0db2bb587e0407077b11368df075f0ff_cgraph.svg" width="738" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0db2bb587e0407077b11368df075f0ff_icgraph.svg" width="1858" height="791"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa5f7c019665d9dd91af0ad6431f8f97d" name="aa5f7c019665d9dd91af0ad6431f8f97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f7c019665d9dd91af0ad6431f8f97d">&#9670;&nbsp;</a></span>async_sock_low_lvl_packet_send_or_close_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::async_sock_low_lvl_packet_send_or_close_immediately </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> except it also calls <code>close_connection_immediately(sock)</code> if the former fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. Additionally, <code>sock</code> must be suitable for <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>; see that method's doc comment. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> analogous parameter. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See async_low_lvl_packet_send_paced(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l01019">1019</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00605">async_sock_low_lvl_packet_send_paced()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05857">async_low_lvl_ack_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05839">async_low_lvl_syn_ack_ack_send_or_close_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa5f7c019665d9dd91af0ad6431f8f97d_cgraph.svg" width="1467" height="310"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa5f7c019665d9dd91af0ad6431f8f97d_icgraph.svg" width="1028" height="367"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a31edf238c1b21a409ea807c66c1b22f0" name="a31edf238c1b21a409ea807c66c1b22f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31edf238c1b21a409ea807c66c1b22f0">&#9670;&nbsp;</a></span>async_sock_low_lvl_packet_send_paced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::async_sock_low_lvl_packet_send_paced </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins the process of asynchronously sending the given low-level packet to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> specified by the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<p >The method, if this feature is applicable and enabled, applies packet pacing (which attempts to avoid burstiness by spreading out packets without changing overall sending rate). Therefore the given packet may be sent as soon as a UDP send is possible according to OS (which is typically immediate), or later, if pacing delays it. Once it is time to send it, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff" title="async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...">async_sock_low_lvl_packet_send()</a> is used.</p>
<p >Takes ownership of packet; do not reference it in any way after this method returns.</p>
<p >Note that an error may occur in asynchronous operations triggered by this method; if this happens the socket will be closed via <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. However if the error happens IN this method (<code>false</code> is returned), it is up to the caller to handle the error as desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose <code>remote_endpoint()</code> specifies to what <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and what Flow port within that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> this socket will go. </td></tr>
    <tr><td class="paramname">packet</td><td>Pointer to packet structure with everything except the source, destination, and retransmission mode fields (essentially, the public members of <a class="el" href="structflow_1_1net__flow_1_1Low__lvl__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level packet structure and serves as...">Low_lvl_packet</a> proper but not its derived types) filled out as desired. </td></tr>
    <tr><td class="paramname">err_code</td><td>After return, <code>*err_code</code> is success or: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae020e63f3ada47025681c8d7f2a00f28" title="Internal error: System error: Something went wrong with boost.asio timer subsystem.">error::Code::S_INTERNAL_ERROR_SYSTEM_ERROR_ASIO_TIMER</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success so far; <code>false</code> on failure (and thus no send initiation). Note that <code>true</code> in no way indicates the send succeeded (indeed, the send cannot possibly <em>initiate</em> until this method exits). </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00605">605</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00307">async_sock_low_lvl_packet_send()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00649">sock_pacing_new_packet_ready()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01033">async_sock_low_lvl_rst_send()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a31edf238c1b21a409ea807c66c1b22f0_cgraph.svg" width="1463" height="267"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a31edf238c1b21a409ea807c66c1b22f0_icgraph.svg" width="1618" height="683"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad03aa88df3d1d3981454ee3356e868c1" name="ad03aa88df3d1d3981454ee3356e868c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03aa88df3d1d3981454ee3356e868c1">&#9670;&nbsp;</a></span>async_sock_low_lvl_rst_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_sock_low_lvl_rst_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends an RST to the other side of the given socket asynchronously when possible. </p>
<p >An error is unlikely, but if it happens there is no reporting other than logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket the remote side of which will get the RST. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l01033">1033</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00605">async_sock_low_lvl_packet_send_paced()</a>, and <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad03aa88df3d1d3981454ee3356e868c1_cgraph.svg" width="1646" height="230"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad03aa88df3d1d3981454ee3356e868c1_icgraph.svg" width="1659" height="259"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4368247d07e930bdd07ab8d2425c6de8" name="a4368247d07e930bdd07ab8d2425c6de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4368247d07e930bdd07ab8d2425c6de8">&#9670;&nbsp;</a></span>async_wait_latency_then_handle_incoming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::async_wait_latency_then_handle_incoming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;&#160;</td>
          <td class="paramname"><em>latency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *&#160;</td>
          <td class="paramname"><em>packet_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up <code>handle_incoming(packet_data, low_lvl_remote_endpoint)</code> to be called asynchronously after a specified period of time. </p>
<p >Used to simulate latency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latency</td><td>After how long to call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a>. </td></tr>
    <tr><td class="paramname">packet_data</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513" title="Helper for low_lvl_recv_and_handle() that calls handle_incoming() on the not-yet-deserialized low-lev...">handle_incoming_with_simulation()</a>. </td></tr>
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513" title="Helper for low_lvl_recv_and_handle() that calls handle_incoming() on the not-yet-deserialized low-lev...">handle_incoming_with_simulation()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00255">255</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>, and <a class="el" href="sched__task_8hpp_source.html#l00034">flow::util::schedule_task_from_now()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a4368247d07e930bdd07ab8d2425c6de8_cgraph.svg" width="2391" height="2087"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a4368247d07e930bdd07ab8d2425c6de8_icgraph.svg" width="936" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7395ac534047f06629962ad19b3fa657" name="a7395ac534047f06629962ad19b3fa657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7395ac534047f06629962ad19b3fa657">&#9670;&nbsp;</a></span>can_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::can_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Answers the perennial question of congestion and flow control: assuming there is a DATA packet to send to the other side on the given socket, should we do so at this moment? Over a perfect link and with a perfect receiver, this would always return true, and we would always send every packet as soon as we could make it. </p>
<p >As it is, some congestion control algorithm is used here to determine if the link should be able to handle a packet, and rcv_wnd is used to determine if the receive would be able to buffer a packet if it did arrive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket for which we answer the question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if should send; <code>false</code> if should wait until it becomes <code>true</code> and THEN send. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05039">5039</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a7395ac534047f06629962ad19b3fa657_icgraph.svg" width="938" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3f9cf4d7160b3e27b3b0131fc4507ce7" name="a3f9cf4d7160b3e27b3b0131fc4507ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9cf4d7160b3e27b3b0131fc4507ce7">&#9670;&nbsp;</a></span>cancel_timers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::cancel_timers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel any timers and scheduled tasks active in the given socket. </p>
<p >More precisely, causes for each handler scheduled to happen in the future to be called as soon as possible with error code <code>operation_aborted</code>. If, by the time the current handler has begun, the handler was about to be called due the timer triggering, this method will not be able to induce <code>operation_aborted</code>. Therefore the handler should be careful to check state and not rely on <code>operation_aborted</code>, despite this method.</p>
<p >Update: The caveats in previous paragraph do not apply to scheduled tasks (<code>util::schedule_task_*()</code>). Canceling such tasks (which this method also does) prevents their handlers from running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose timers/scheduled tasks to abort. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04447">4447</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="sched__task_8cpp_source.html#l00026">flow::util::scheduled_task_cancel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3f9cf4d7160b3e27b3b0131fc4507ce7_cgraph.svg" width="336" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3f9cf4d7160b3e27b3b0131fc4507ce7_icgraph.svg" width="1655" height="762"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a055ee380cf87f83c06d7380821c4679e" name="a055ee380cf87f83c06d7380821c4679e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055ee380cf87f83c06d7380821c4679e">&#9670;&nbsp;</a></span>categorize_individual_ack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::categorize_individual_ack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>dupe_or_late</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> *&#160;</td>
          <td class="paramname"><em>acked_pkt_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that categorizes the given accumulated individual acknowledgment w/r/t legality and validity; determines the DATA packet being acked if possible; logs and record stats accordingly; and closes underlying socket if ack is illegal. </p>
<p >In all cases, all relevant (to the categorization of the given ack) information is logged and stats are recorded.</p>
<p >Furthermore, if the ack is illegal, the socket is closed (while <code>false</code> is returned). Otherwise, <code>true</code> is returned, and <code>*dupe_or_late</code> is set to indicate whether the ack is valid or not. If valid, <code>*acked_pkt_it</code> is definitely set to indicate which DATA packet is being acked. If invalid, <code>*acked_pkt_it</code> may or may not be set, as that information may or may not be available any longer (example of it being available: the ack is for an earlier transmission attempt of packet P, but packet P is currently In-flight due to a subsequent retransmission attempt).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
    <tr><td class="paramname">ack</td><td>Individual acknowledgment being categorized. </td></tr>
    <tr><td class="paramname">dupe_or_late</td><td>Set to false if ack refers to currently In-flight instance of a packet; true if no longer In-flight (late = considered Dropped laready; duplicate = was acked before); untouched if <code>false</code> returned. </td></tr>
    <tr><td class="paramname">acked_pkt_it</td><td>Set to point into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a> that is being acked if <code>!*dupe_or_late</code>, or if <code>*dupe_or_late</code> but the acked packet is still known; set to <code>end()</code> a/k/a <code>past_oldest()</code> otherwise; untouched if <code>false</code> returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if and only if the ack is sufficiently invalid to have made this method close the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l02545">2545</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="util_2util_8hpp_source.html#l00270">flow::util::in_open_open_range()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02254">flow::net_flow::Peer_socket::Sent_packet::m_packet</a>, <a class="el" href="peer__socket_8hpp_source.html#l02220">flow::net_flow::Peer_socket::Sent_packet::m_sent_when</a>, <a class="el" href="peer__socket_8hpp_source.html#l02198">flow::net_flow::Peer_socket::Sent_packet::m_size</a>, <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">flow::net_flow::error::S_SEQ_NUM_ARITHMETIC_FAILURE</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765">flow::net_flow::error::S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a055ee380cf87f83c06d7380821c4679e_cgraph.svg" width="536" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3326b5bdc85b43232f55e2b2ec1dbe60" name="a3326b5bdc85b43232f55e2b2ec1dbe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3326b5bdc85b43232f55e2b2ec1dbe60">&#9670;&nbsp;</a></span>categorize_pkts_as_dropped_on_acks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> flow::net_flow::Node::categorize_pkts_as_dropped_on_acks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>flying_now_acked_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that determines the range of In-flight packets that should be Dropped due to given individual acks that have just been processed; and updates the relevant <code>m_acks_after_me</code> members in the socket. </p>
<p >Logging is minimal, and no stats are recorded. However, see associated <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a" title="Helper of perform_accumulated_on_recv_tasks() that acts on the determination made by categorize_pkts_...">drop_pkts_on_acks()</a> method.</p>
<p ><a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa" title="The number of times any packet with m_sent_when.back().m_order_num &gt; this-&gt;m_sent_when....">Peer_socket::Sent_packet::m_acks_after_me</a> data members, as documented, are incremented where relevant based on the just-processed acks in <code>flying_now_acked_pkts</code>.</p>
<p >Finally, the following In-flight packets must be considered Dropped due to acks:</p><ul>
<li>The packet referred to by the returned iterator into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>.</li>
<li>All packets contained in the same structure appearing later in it (i.e., sent out earlier), up to <code>past_oldest()</code> (a/k/a <code>end()</code>).</li>
</ul>
<p >Note that this method does not actually perform the various tasks: it only updates <code>m_acks_after_me</code> and computes/returns the start of the to-be-Dropped range. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a" title="Helper of perform_accumulated_on_recv_tasks() that acts on the determination made by categorize_pkts_...">drop_pkts_on_acks()</a> for the actual dropping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
    <tr><td class="paramname">flying_now_acked_pkts</td><td>The individual DATA packet send attempts acks of which have just been processed. The <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Peer_socket::Sent_packet</a> (and within it, the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html" title="Data store to keep timing related info when a packet is sent out.">Peer_socket::Sent_packet::Sent_when</a>) with the order ID P, where P is in <code>flying_now_acked_pkts</code>, must be in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator into <code>sock-&gt;m_snd_flying_pkts_by_sent_when</code> indicating the latest-sent packet that should be Dropped due to acks; <code>past_oldest()</code> a/k/a <code>end()</code> if none should be so Dropped. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l02936">2936</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02239">flow::net_flow::Peer_socket::Sent_packet::m_acks_after_me</a>, <a class="el" href="peer__socket_8hpp_source.html#l02297">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_order_num</a>, <a class="el" href="peer__socket_8hpp_source.html#l02220">flow::net_flow::Peer_socket::Sent_packet::m_sent_when</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3326b5bdc85b43232f55e2b2ec1dbe60_cgraph.svg" width="336" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6461124e5bc3e59083e172e26029e632" name="a6461124e5bc3e59083e172e26029e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6461124e5bc3e59083e172e26029e632">&#9670;&nbsp;</a></span>close_abruptly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::close_abruptly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of non-blocking <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632" title="Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...">close_abruptly()</a></code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>. </p>
<p >See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">Peer_socket::close_abruptly()</a> doc header; this method is the entirety of that method's implementation after CLOSED is eliminated as a possibility.</p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>sock-&gt;m_mutex</code> is locked and just after entering <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632" title="Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...">close_abruptly()</a></code>;</li>
<li>no changes to <code>*sock</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>sock-&gt;state() == Stated::S_OPEN</code> (so <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>);</li>
<li><code>sock</code> has been given to user via <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> or friends.</li>
</ul>
<p >Post-condition (not exhaustive): <code>sock-&gt;m_mutex</code> is unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket in OPEN state. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">Peer_socket::close_abruptly()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05615">5615</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8">flow::net_flow::error::S_USER_CLOSED_ABRUPTLY</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00269">flow::net_flow::Peer_socket::close_abruptly()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6461124e5bc3e59083e172e26029e632_cgraph.svg" width="1299" height="1238"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6461124e5bc3e59083e172e26029e632_icgraph.svg" width="344" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ade49e7bc7202a0adf33fec2d93d1b177" name="ade49e7bc7202a0adf33fec2d93d1b177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade49e7bc7202a0adf33fec2d93d1b177">&#9670;&nbsp;</a></span>close_connection_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::close_connection_immediately </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED (including eliminating the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from our data structures). </p>
<p >For example, if an invalid packet comes in on the socket, and we send back an RST, then we're free to then close our side immediately, as no further communication (with the other side or the local user) is needed. As another example, if we there is a graceful close while Receive buffer has data, user must Receive all of it, and the final handshake must finish, and then this is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000117">Todo:</a></b></dt><dd>Graceful close not yet implemented w/r/t <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>.</dd></dl>
<p >Pre-condition: if <code>err_code</code> is failure: <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>; <code>sock-&gt;state() == S_OPEN</code> (and any <code>sock-&gt;m_int_state</code> that corresponds to it); <code>err_code</code> contains the reason for the close.</p>
<p >Pre-condition: if <code>err_code</code> is success: <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>; <code>sock</code> state is OPEN+DISCONNECTING; <code>m_int_state</code> is CLOSED; Send and Receive buffers are empty; <code>m_disconnect_cause</code> is not success.</p>
<p >Post-condition: <code>sock</code> Receive and Send buffers are empty; <code>sock-&gt;state() == S_CLOSED</code> (and <code>sock</code> is no longer in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a> or any other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> structures, directly or indirectly) with <code>sock-&gt;m_disconnect_cause</code> set to reason for closing. Other decently memory-consuming structures are also cleared to conserve memory.</p>
<p >Any socket that is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a> MUST be eventually closed using this method. No socket that is not in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a> must be passed to this method. In particular, do not call this method during <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#aaaf5c3b5e6b9f9f1658b60907b36a498" title="Handles a just-deserialized, just-demultiplexed low-level SYN packet delivered to the given server so...">handle_syn_to_listening_server()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket to close. </td></tr>
    <tr><td class="paramname">err_code</td><td>If this is not success, then it is an abrupt close, and this is why <code>sock</code> is being abruptly closed. <code>m_disconnect_cause</code> is set accordingly and logged. If <code>err_code</code> is failure, then: <code>sock</code> is OPEN+DISCONNECTING (graceful close), and all criteria required for it to move so CLOSED are satisfied: internal state is CLOSED (goodbye handshake finished), and Receive and Send buffers are empty; <code>m_disconnect_cause</code> is already set. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05683">5683</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l04447">cancel_timers()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">event_set_all_check_delta()</a>, <a class="el" href="error_2error_8hpp_source.html#l00233">FLOW_ERROR_LOG_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00761">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::insert()</a>, <a class="el" href="node_8hpp_source.html#l03777">m_ports</a>, <a class="el" href="node_8hpp_source.html#l03798">m_servs</a>, <a class="el" href="node_8hpp_source.html#l03830">m_sock_events</a>, <a class="el" href="node_8hpp_source.html#l03792">m_socks</a>, <a class="el" href="port__space_8cpp_source.html#l00175">flow::net_flow::Port_space::return_port()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">flow::net_flow::Event_set::S_PEER_SOCKET_READABLE</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::S_PEER_SOCKET_WRITABLE</a>, <a class="el" href="server__socket_8cpp_source.html#l00786">serv_peer_socket_closed()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06155">sock_disconnect_completed()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06134">sock_disconnect_detected()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06435">sock_log_detail()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06103">sock_set_int_state()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05551">receive_emptied_rcv_buf_while_disconnecting()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade49e7bc7202a0adf33fec2d93d1b177_cgraph.svg" width="1028" height="1139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade49e7bc7202a0adf33fec2d93d1b177_icgraph.svg" width="1751" height="700"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adf6d71af81def2d030f0fef159c1b06d" name="adf6d71af81def2d030f0fef159c1b06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6d71af81def2d030f0fef159c1b06d">&#9670;&nbsp;</a></span>close_empty_server_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::close_empty_server_immediately </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the transition of the given server socket from <code>S_LISTENING</code>/<code>S_CLOSING</code> to <code>S_CLOSED</code> (including eliminating the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from our data structures). </p>
<p >Pre-condition: there is no socket <code>sock</code> such that <code>sock-&gt;m_originating_serv == serv</code>; i.e., there are no sockets having to do with this server that have not yet been <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>ed.</p>
<p >Pre-condition: <code>serv</code> is in <code>m_servs</code>; <code>serv-&gt;state() != S_OPEN</code>.</p>
<p >Post-condition: <code>serv-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">Server_socket::State::S_CLOSED</a></code> (and <code>serv</code> is no longer in <code>m_servs</code> or any other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> structures, directly or indirectly) with <code>serv-&gt;m_disconnect_cause</code> set to <code>err_code</code> (or see below).</p>
<p >Any server socket that is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df" title="The server sockets this Node is currently tracking.">m_servs</a> MUST be eventually closed using this method. No socket that is not in <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df" title="The server sockets this Node is currently tracking.">m_servs</a> must be passed to this method. In particular, do not call this method during <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_port</td><td>Flow port of the server to delete. </td></tr>
    <tr><td class="paramname">serv</td><td>Socket to close. </td></tr>
    <tr><td class="paramname">err_code</td><td>Why is it being closed? <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ae87a97dcfaa0909789b76ef4462d6a0b" title="The Error_code causing this server&#39;s move from LISTENING state (if this has occurred); otherwise a cl...">Server_socket::m_disconnect_cause</a> is set accordingly and logged. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00364">364</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l01129">event_set_all_check_delta()</a>, <a class="el" href="error_2error_8hpp_source.html#l00233">FLOW_ERROR_LOG_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="node_8hpp_source.html#l03777">m_ports</a>, <a class="el" href="node_8hpp_source.html#l03798">m_servs</a>, <a class="el" href="node_8hpp_source.html#l03830">m_sock_events</a>, <a class="el" href="port__space_8cpp_source.html#l00175">flow::net_flow::Port_space::return_port()</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Server_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2">flow::net_flow::Event_set::S_SERVER_SOCKET_ACCEPTABLE</a>, and <a class="el" href="server__socket_8cpp_source.html#l00766">serv_close_detected()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_adf6d71af81def2d030f0fef159c1b06d_cgraph.svg" width="924" height="667"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_adf6d71af81def2d030f0fef159c1b06d_icgraph.svg" width="331" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adeccd8c86fcd54733e42593629fad96b" name="adeccd8c86fcd54733e42593629fad96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeccd8c86fcd54733e42593629fad96b">&#9670;&nbsp;</a></span>compute_rtt_on_ack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> flow::net_flow::Node::compute_rtt_on_ack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>flying_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>time_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a> **&#160;</td>
          <td class="paramname"><em>sent_when</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that computes the RTT implied by a given individual acknowledgment. </p>
<p >In addition to returning the RTT, note the convenience out-param.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flying_pkt</td><td>The In-flight DATA packet to which the ack pertains. </td></tr>
    <tr><td class="paramname">time_now</td><td>The current time to use for the RTT computation (not using value within to allow for caller to simulate simultaneity between nearby RTT computations). </td></tr>
    <tr><td class="paramname">ack</td><td>Individual acknowledgment being categorized. </td></tr>
    <tr><td class="paramname">sent_when</td><td>This out-param is set to point within <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>'s <code>Sent_when</code> structure pertaining to the DATA packet send attempt to which <code>ack</code> refers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RTT. May be zero. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l02870">2870</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02297">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_order_num</a>.</p>

</div>
</div>
<a id="a893c8393930110e2aa0823583e37cabd" name="a893c8393930110e2aa0823583e37cabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893c8393930110e2aa0823583e37cabd">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an active connect to the specified remote Flow server. </p>
<p >Returns a safe pointer to a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. The socket's state will be some substate of <code>S_OPEN</code> at least initially. The connection operation, involving network traffic, will be performed asynchronously.</p>
<p >One can treat the resulting socket as already connected; its Writable and Readable status can be determined; once Readable or Writable one can receive or send, respectively.</p>
<p >Port selection: An available local Flow port will be chosen and will be available for information purposes via sock-&gt;local_port(), where <code>sock</code> is the returned socket. The port will be in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">Node::S_NUM_EPHEMERAL_PORTS</a> - 1]. Note that there is no overlap between that range and the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">Node::S_NUM_SERVICE_PORTS</a> - 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The remote Flow port to which to connect. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>The low-level per-Peer_socket options to use in the new socket. If null (typical), the per-socket options template in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">Node::options()</a> is used. If not null, the given per-socket options are first validated and, if valid, used. If invalid, it is an error. See also <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">Peer_socket::options()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, which is in the <code>S_OPEN</code> main state; or null pointer, indicating an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03944">3944</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="ae9a0e5492b9ea005cc12c20c8e7cec9a" name="ae9a0e5492b9ea005cc12c20c8e7cec9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a0e5492b9ea005cc12c20c8e7cec9a">&#9670;&nbsp;</a></span>connect_with_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but sends, as part of the connection handshake, the user-supplied metadata, which the other side can access via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> after accepting the connection. </p>
<dl class="section note"><dt>Note</dt><dd>It is up to the user to serialize the metadata portably. One recommended convention is to use <code>boost::endian::native_to_little()</code> (and similar) before connecting; and on the other side use the reverse (<code>boost::endian::little_to_native()</code>) before using the value. Packet dumps will show a flipped (little-endian) representation, while with most platforms the conversion will be a no-op at compile time. Alternatively use <code>native_to_big()</code> and vice-versa. </dd>
<dd>
Why provide this metadata facility? After all, they could just send the data upon connection via <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a>/receive()/etc. Answers: Firstly, this is guaranteed to be delivered (assuming successful connection), even if reliability (such as via retransmission) is disabled in socket options (opts argument). For example, if a reliability mechanism (such as FEC) is built on top of the Flow layer, parameters having to do with configuring that reliability mechanism can be bootstrapped reliably using this mechanism. Secondly, it can be quite convenient (albeit not irreplaceably so) for connection-authenticating techniques like security tokens known by both sides. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>Data copied and sent to the other side during the connection establishment. The other side can get equal data using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a>. The returned socket <code>sock</code> also stores it; it's similarly accessible via sock-&gt;get_connect_metadata() on this side. The metadata must fit into a single low-level packet; otherwise <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a> error is returned. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03951">3951</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03951">connect_with_metadata()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00352">flow::net_flow::Peer_socket::max_block_size()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd">flow::net_flow::error::S_CONN_METADATA_TOO_LARGE</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">flow::net_flow::asio::Node::async_connect_impl()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l03951">connect_with_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ae9a0e5492b9ea005cc12c20c8e7cec9a_cgraph.svg" width="555" height="188"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ae9a0e5492b9ea005cc12c20c8e7cec9a_icgraph.svg" width="591" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac619d1a96cc62d223f990ee6a3c909ff" name="ac619d1a96cc62d223f990ee6a3c909ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac619d1a96cc62d223f990ee6a3c909ff">&#9670;&nbsp;</a></span>connect_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::connect_worker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </p>
<p >Performs all the needed work up to waiting for network traffic, gives the resulting <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> to the user thread, and signals that user thread.</p>
<p >Pre-condition: We're in thread W; thread U != W is waiting for us to return having set <code>*sock</code>. Post-condition: <code>*sock</code> contains a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> in an OPEN+CONNECTING state if <code>!(<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">Peer_socket::m_disconnect_cause</a>)</code> for <code>*sock</code>; otherwise an error occurred, and that error is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">Peer_socket::m_disconnect_cause</a> (in <code>*sock</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>Serialized metadata to provide to the peer when the connection is being established. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">sock</td><td><code>*sock</code> shall be set to the resulting new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. Check <code>(*sock)-&gt;m_disconnect_cause</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04005">4005</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="cong__ctl_8cpp_source.html#l00101">flow::net_flow::Congestion_control_selector::create_strategy()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01178">flow::net_flow::Peer_socket::m_opts</a>, <a class="el" href="peer__socket_8hpp_source.html#l01181">flow::net_flow::Peer_socket::m_opts_mutex</a>, <a class="el" href="endpoint_8hpp_source.html#l00097">flow::net_flow::Remote_endpoint::m_udp_endpoint</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99">flow::net_flow::error::S_CANNOT_CONNECT_TO_IP_ANY</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">flow::net_flow::Peer_socket::S_CONNECTING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2">flow::net_flow::error::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="port__space_8cpp_source.html#l00033">flow::net_flow::S_PORT_ANY</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::S_SYN_SENT</a>, <a class="el" href="peer__socket_8hpp_source.html#l00836">flow::net_flow::Peer_socket::Send_bandwidth_estimator</a>, <a class="el" href="seq__num_8cpp_source.html#l00268">flow::net_flow::Sequence_number::set_metadata()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac619d1a96cc62d223f990ee6a3c909ff_cgraph.svg" width="375" height="374"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5bca5c11ac5a4763fed6ce146fe733e7" name="a5bca5c11ac5a4763fed6ce146fe733e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bca5c11ac5a4763fed6ce146fe733e7">&#9670;&nbsp;</a></span>create_syn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_packet::Ptr</a> flow::net_flow::Node::create_syn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. </p>
<p ><code>sock</code> members that reflect any data in <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN packet.">Syn_packet</a> must already be saved and are not used as the source for such data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff" title="async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...">async_sock_low_lvl_packet_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new packet object suitable for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> without having to fill any further data members in the object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05811">5811</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a5bca5c11ac5a4763fed6ce146fe733e7_cgraph.svg" width="336" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a5bca5c11ac5a4763fed6ce146fe733e7_icgraph.svg" width="366" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6bcd840049c57150cdaa5c59d22c488b" name="a6bcd840049c57150cdaa5c59d22c488b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcd840049c57150cdaa5c59d22c488b">&#9670;&nbsp;</a></span>create_syn_ack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_ack_packet::Ptr</a> flow::net_flow::Node::create_syn_ack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7" title="Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...">create_syn()</a> but for SYN_ACK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7" title="Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...">create_syn()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7" title="Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...">create_syn()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05826">5826</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6bcd840049c57150cdaa5c59d22c488b_cgraph.svg" width="336" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6bcd840049c57150cdaa5c59d22c488b_icgraph.svg" width="946" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac910f24e5a176c4aa01992b08b62146a" name="ac910f24e5a176c4aa01992b08b62146a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac910f24e5a176c4aa01992b08b62146a">&#9670;&nbsp;</a></span>drop_pkts_on_acks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::drop_pkts_on_acks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> &amp;&#160;</td>
          <td class="paramname"><em>last_dropped_pkt_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cong_ctl_dropped_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cong_ctl_dropped_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dropped_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dropped_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> &gt; *&#160;</td>
          <td class="paramname"><em>pkts_marked_to_drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that acts on the determination made by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60" title="Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...">categorize_pkts_as_dropped_on_acks()</a>. </p>
<p >In all cases, all relevant (to the categorization of the In-flight packets as Dropped) information is logged and stats are recorded.</p>
<p >This acts, or gathers information necessary to act, on the determination by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60" title="Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...">categorize_pkts_as_dropped_on_acks()</a> that a certain range of In-flight packets should be Dropped due to excess acks of packets sent before them. Namely:</p><ul>
<li><code>*cong_ctl_dropped_...</code> are set to the values to report congestion control as part of a new loss event.</li>
<li><code>*dropped_...</code> are set to values that indicate totals w/r/t the packets Dropped (regardless of whether it's a new or existing loss event).</li>
<li><code>*pkts_marked_to_drop</code> are loaded with the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html#a5265c3824ad25d1de4f888fa811dd4e6" title="Order number of the packet.">Peer_socket::Sent_packet::Sent_when::m_order_num</a> order IDs specifying the Dropped packets.</li>
<li><code>sock</code> members <code>m_snd_flying_pkts*</code> and related are updated, meaning the newly Dropped packets are removed.</li>
<li>On the other hand, if retransmission is on, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a845f21b754ef641b65b1fe44727fb429" title="If retransmission is on, this is the retransmission queue.">Peer_socket::m_snd_rexmit_q</a> is pushed onto, gaining the just-Dropped packets to retransmit.</li>
<li><code>true</code> is returned.</li>
</ul>
<p >However, if it is determined that a retransmission placed onto <code>sock-&gt;m_snd_rexmit_q</code> would indicate one retransmission too many, the socket is closed, and <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
    <tr><td class="paramname">last_dropped_pkt_it</td><td>Return value of of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60" title="Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...">categorize_pkts_as_dropped_on_acks()</a>. </td></tr>
    <tr><td class="paramname">cong_ctl_dropped_pkts</td><td>Will be set to total # of packets marked as Dropped to report to congestion control as part of a loss event (<code>&lt;= *dropped_pkts</code>). </td></tr>
    <tr><td class="paramname">cong_ctl_dropped_bytes</td><td>Total data size corresponding to <code>cong_ctl_dropped_pkts</code> (<code>&lt;= *dropped_bytes)</code>). </td></tr>
    <tr><td class="paramname">dropped_pkts</td><td>Will be set to total # of packets marked as Dropped by this method. </td></tr>
    <tr><td class="paramname">dropped_bytes</td><td>Total data size corresponding to <code>dropped_pkts</code>. </td></tr>
    <tr><td class="paramname">pkts_marked_to_drop</td><td>Will be filled with packet IDs (<code>sock-&gt;m_snd_flying_pkts_by_sent_when[...]-&gt;m_sent_when-&gt;m_order_num</code>) of the packets marked dropped by this method. Results undefined unless empty at method start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> normally; <code>false</code> if too many retransmissions detected, and thus <code>sock</code> was closed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03102">3102</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l02297">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_order_num</a>, <a class="el" href="peer__socket_8hpp_source.html#l02309">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_sent_time</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac910f24e5a176c4aa01992b08b62146a_cgraph.svg" width="500" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="affbc6abb1e344c6e98d3ac8068a54670" name="affbc6abb1e344c6e98d3ac8068a54670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbc6abb1e344c6e98d3ac8068a54670">&#9670;&nbsp;</a></span>drop_timer_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::drop_timer_action </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>drop_all_packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">Peer_socket::m_snd_drop_timer</a>) event in ESTABLISHED state by dropping the specified packets. </p>
<p >To be executed as a <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a> with at least one In-flight sent packet. </td></tr>
    <tr><td class="paramname">drop_all_packets</td><td>If <code>true</code>, will consider all packets Dropped. If <code>false</code>, will consider only the earliest In-flight packet dropped. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03317">3317</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04498">setup_drop_timer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_affbc6abb1e344c6e98d3ac8068a54670_cgraph.svg" width="500" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_affbc6abb1e344c6e98d3ac8068a54670_icgraph.svg" width="1096" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a109a118ca312e94686595ea08dac7ad0" name="a109a118ca312e94686595ea08dac7ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109a118ca312e94686595ea08dac7ad0">&#9670;&nbsp;</a></span>ensure_sock_open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket_ptr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::ensure_sock_open </td>
          <td>(</td>
          <td class="paramtype">Socket_ptr&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method that checks whether the given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> is CLOSED; if so, it sets <code>*err_code</code> to the reason it was closed (which is in <code>sock-&gt;m_disconnect</code>) and returns <code>false</code>; otherwise it returns <code>true</code> and leaves <code>*err_code</code> untouched. </p>
<p >This exists to improve code reuse, as this is a frequent operation for both socket types.</p>
<p >Pre- and post-conditions: <code>sock-&gt;m_mutex</code> is locked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Socket_ptr</td><td><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> or <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket in question. </td></tr>
    <tr><td class="paramname">err_code</td><td><code>*err_code</code> is set to <code>sock-&gt;m_disconnect_cause</code> if socket is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if state is not CLOSED; otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l04141">4141</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00218">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00075">flow::net_flow::Server_socket::accept()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00269">flow::net_flow::Peer_socket::close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00419">flow::net_flow::Peer_socket::ensure_open()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00323">flow::net_flow::Peer_socket::info()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00219">flow::net_flow::Peer_socket::node_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00134">flow::net_flow::Peer_socket::node_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00234">flow::net_flow::Peer_socket::node_sync_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00149">flow::net_flow::Peer_socket::node_sync_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00297">flow::net_flow::Peer_socket::set_options()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00100">flow::net_flow::Server_socket::sync_accept_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a109a118ca312e94686595ea08dac7ad0_icgraph.svg" width="778" height="711"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8a4ddf81ddbeab1f740940c4cc0d3625" name="a8a4ddf81ddbeab1f740940c4cc0d3625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4ddf81ddbeab1f740940c4cc0d3625">&#9670;&nbsp;</a></span>event_set_all_check_delta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::event_set_all_check_delta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each WAITING <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> within the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>: checks for any events that hold, and if any do hold, signals the user (calls handler, goes to INACTIVE, etc.). </p>
<p >The logic for how it does so is complex. For background, please see <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> giant internal comment first. Then read on here.</p>
<p >For each WAITING <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>: If baseline check (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8" title="Checks each desired (Event_set::m_want) event in event_set; any that holds true is saved into event_s...">event_set_check_baseline()</a>) is still required and hasn't been performed, perform it. Otherwise, for efficiency perform a "delta" check, wherein EVERY active (for all definitions of active: Readable, Writable, Acceptable) socket detected since the last baseline check is checked against the desired event/socket pairs in the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. Any socket in both sets (active + desired) is saved in <code>event_set-&gt;m_can</code>. If either the baseline or delta check yields at least one active event, signal user (call handler, go INACTIVE, etc.).</p>
<p >For the delta check just described, how does it know which sockets have been active since the last check? Answer: <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">Node::m_sock_events</a></code> members (NOTE: not the same as <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a></code>, though they are related). See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a> doc header for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defer_delta_check</td><td>Set to <code>true</code> if and only if you know, for a FACT, that within a non-blocking amount of time <code>event_set_all_check_delta(false)</code> will be called. For example, you may know <code>event_set_all_check_delta(false)</code> will be called within the present boost.asio handler. Then this method will only log and not perform the actual check, deferring to the promised <code>event_set_all_check_delta(false)</code> call, by which point more events may have been detected in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01129">1129</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00747">flow::net_flow::Event_set::clear_ev_type_to_socks_map()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00858">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::empty()</a>, <a class="el" href="event__set_8cpp_source.html#l00756">flow::net_flow::Event_set::ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="event__set_8cpp_source.html#l00761">flow::net_flow::Event_set::ev_type_to_socks_map_sizes_to_str()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00591">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::insert()</a>, <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00852">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::size()</a>, and <a class="el" href="event__set_8cpp_source.html#l00777">flow::net_flow::Event_set::sock_as_any_to_str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a8a4ddf81ddbeab1f740940c4cc0d3625_cgraph.svg" width="734" height="495"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a8a4ddf81ddbeab1f740940c4cc0d3625_icgraph.svg" width="1916" height="784"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa18a14a4749f34d07c71bb2a1214d65f" name="aa18a14a4749f34d07c71bb2a1214d65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a14a4749f34d07c71bb2a1214d65f">&#9670;&nbsp;</a></span>event_set_async_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::event_set_async_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_set::Event_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>on_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> when <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a></code>. </p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>event_set-&gt;m_mutex</code> is locked and just after entering async_wait();</li>
<li>no changes to <code>*event_set</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>event_set-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a></code> (so <code>event_set</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b" title="Every Event_set to have been returned by event_set_create() and not subsequently reached Event_set::S...">m_event_sets</a>);</li>
<li>on_event is as originally passed into async_wait().</li>
</ul>
<p >This method completes the functionality of <code>event_set-&gt;async_wait()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
    <tr><td class="paramname">on_event</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00917">917</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00747">flow::net_flow::Event_set::clear_ev_type_to_socks_map()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">flow::net_flow::Event_set::S_INACTIVE</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00072">flow::net_flow::Event_set::async_wait()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa18a14a4749f34d07c71bb2a1214d65f_cgraph.svg" width="350" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa18a14a4749f34d07c71bb2a1214d65f_icgraph.svg" width="711" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2195fb7d86acfaf340b3e7e59e7e10e8" name="a2195fb7d86acfaf340b3e7e59e7e10e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2195fb7d86acfaf340b3e7e59e7e10e8">&#9670;&nbsp;</a></span>event_set_check_baseline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::event_set_check_baseline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks each desired (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">Event_set::m_want</a>) event in <code>event_set</code>; any that holds true is saved into <code>event_set</code> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a>). </p>
<p >This is the exhaustive, or "baseline," check. This should only be performed when necessary, as it is typically slower than checking individual active sockets against the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> ("delta" check).</p>
<p >This check is skipped if <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ada8d103341b6450f3390dc6ce24ccdef" title="While in State::S_WAITING, if this is true, an exhaustive check of all desired events is yet to be pe...">Event_set::m_baseline_check_pending</a> == false</code> (for <code>event_set</code>).</p>
<p >See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> giant internal comment for context on all of the above.</p>
<p >Pre-conditions: <code>event_set</code> state is <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">Event_set::State::S_WAITING</a>; <code>event_set-&gt;m_mutex</code> is locked.</p>
<p >This method, unlike most, is intended to be called from either W or U != W. All actions it takes are on non-W-exclusive data (namely, actions on: <code>event_set</code>; and non-W-exclusive data in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, namely their state() and Receive/Send/Accept structures).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the check was performed; <code>false</code> returned if <code>!event_set-&gt;m_baseline_check_pending</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01017">1017</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00858">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::empty()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00591">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::insert()</a>, <a class="el" href="event__set_8hpp_source.html#l00897">flow::net_flow::Event_set::S_EV_TYPE_TO_IS_ACTIVE_NODE_MTD</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>, and <a class="el" href="event__set_8cpp_source.html#l00777">flow::net_flow::Event_set::sock_as_any_to_str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00266">flow::net_flow::Event_set::poll()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2195fb7d86acfaf340b3e7e59e7e10e8_cgraph.svg" width="735" height="196"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2195fb7d86acfaf340b3e7e59e7e10e8_icgraph.svg" width="735" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4a21e69d3ae442b2cc06220514de364a" name="a4a21e69d3ae442b2cc06220514de364a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a21e69d3ae442b2cc06220514de364a">&#9670;&nbsp;</a></span>event_set_check_baseline_assuming_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::event_set_check_baseline_assuming_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f" title="Implementation of Event_set::async_wait() when Event_set::state() == Event_set::State::S_INACTIVE.">event_set_async_wait()</a> onto thread W to invoke <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8" title="Checks each desired (Event_set::m_want) event in event_set; any that holds true is saved into event_s...">event_set_check_baseline()</a> but first ensure that the <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> event_set</code> has not exited <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">Event_set::State::S_WAITING</a> (which would make any checking for active events nonsense). </p>
<p >If it has exited that state, does nothing. (That situation is possible due to concurrently deleting the overarching <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (IIRC) and maybe other similar races.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00989">989</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>.</p>

</div>
</div>
<a id="a44ee0d42d38f3b98d032dee1549f8c4c" name="a44ee0d42d38f3b98d032dee1549f8c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ee0d42d38f3b98d032dee1549f8c4c">&#9670;&nbsp;</a></span>event_set_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::event_set_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a> when <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> != <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a></code> for <code>event_set</code>. </p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>event_set-&gt;m_mutex</code> is locked and just after entering async_wait();</li>
<li>no changes to <code>*event_set</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>event_set-&gt;state() != <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a></code> (so <code>event_set</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b" title="Every Event_set to have been returned by event_set_create() and not subsequently reached Event_set::S...">m_event_sets</a>).</li>
</ul>
<p >This method completes the functionality of <code>event_set-&gt;close()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01273">1273</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Event_set::S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00464">flow::net_flow::Event_set::close()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a44ee0d42d38f3b98d032dee1549f8c4c_cgraph.svg" width="520" height="128"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a44ee0d42d38f3b98d032dee1549f8c4c_icgraph.svg" width="330" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6727ca42e15c8627c1ed3d94e6dd7a53" name="a6727ca42e15c8627c1ed3d94e6dd7a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6727ca42e15c8627c1ed3d94e6dd7a53">&#9670;&nbsp;</a></span>event_set_close_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::event_set_close_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The guts of event_set_close_worker_check_state(): same thing, but assumes <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">Event_set::state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a></code>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a0dda853ab017dd9bfcfb71b601d15698" title="Mutex protecting ALL data in this object.">Event_set::m_mutex</a> is locked (for <code>event_set</code>). </p>
<p >May be called directly from thread W assuming those pre-conditions holds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01332">1332</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00747">flow::net_flow::Event_set::clear_ev_type_to_socks_map()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Event_set::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">flow::net_flow::Event_set::S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6727ca42e15c8627c1ed3d94e6dd7a53_cgraph.svg" width="360" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6727ca42e15c8627c1ed3d94e6dd7a53_icgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad100464cf0126dbbad39bde1c90a774f" name="ad100464cf0126dbbad39bde1c90a774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad100464cf0126dbbad39bde1c90a774f">&#9670;&nbsp;</a></span>event_set_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> flow::net_flow::Node::event_set_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> state with no sockets/events stored; returns this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>; or null pointer, indicating an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00881">881</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="event__set_8cpp_source.html#l00042">flow::net_flow::Event_set::Event_set()</a>, <a class="el" href="event__set_8cpp_source.html#l00881">event_set_create()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">flow::net_flow::Event_set::S_INACTIVE</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8hpp_source.html#l00581">flow::net_flow::asio::Node::async_op()</a>, <a class="el" href="event__set_8cpp_source.html#l00881">event_set_create()</a>, and <a class="el" href="node_8hpp_source.html#l03977">sync_op()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad100464cf0126dbbad39bde1c90a774f_cgraph.svg" width="520" height="188"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad100464cf0126dbbad39bde1c90a774f_icgraph.svg" width="960" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afdefbbb3c3b9f2f2866f6b4c770fa62d" name="afdefbbb3c3b9f2f2866f6b4c770fa62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdefbbb3c3b9f2f2866f6b4c770fa62d">&#9670;&nbsp;</a></span>event_set_fire_if_got_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::event_set_fire_if_got_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td>
          <td class="paramname"><em>event_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> contains any active sockets (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a>); if so, signals the user (who previously called <code>async_wait()</code> to set all this in motion): set state back to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> from <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">Event_set::State::S_WAITING</a>; calls the handler passed to <code>async_wait()</code>; forgets handler. </p>
<p >If no active sockets, does nothing.</p>
<p >Pre-conditions: same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8" title="Checks each desired (Event_set::m_want) event in event_set; any that holds true is saved into event_s...">event_set_check_baseline()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_set</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in question. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01084">1084</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00756">flow::net_flow::Event_set::ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">flow::net_flow::Event_set::S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_afdefbbb3c3b9f2f2866f6b4c770fa62d_cgraph.svg" width="347" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a663f1fd8b524ffe63dfa6b7ca76b1a43" name="a663f1fd8b524ffe63dfa6b7ca76b1a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663f1fd8b524ffe63dfa6b7ca76b1a43">&#9670;&nbsp;</a></span>get_seq_num_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Packet_map_iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::get_seq_num_range </td>
          <td>(</td>
          <td class="paramtype">const Packet_map_iter &amp;&#160;</td>
          <td class="paramname"><em>packet_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *&#160;</td>
          <td class="paramname"><em>seq_num_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *&#160;</td>
          <td class="paramname"><em>seq_num_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an iterator into a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814" title="Short-hand for m_snd_flying_pkts_by_sent_when type; see that data member.">Peer_socket::Sent_pkt_by_sent_when_map</a> or Peer_socket::Recv_pkt_map, gets the range of sequence numbers in the packet represented thereby. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Packet_map_iter</td><td>Iterator type (<code>const</code> or otherwise) into one of the above-mentioned maps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_it</td><td>A valid, non-<code>end()</code> iterator into such a map. </td></tr>
    <tr><td class="paramname">seq_num_start</td><td>If 0, ignored; otherwise the sequence number of the first datum in that packet is placed there. </td></tr>
    <tr><td class="paramname">seq_num_end</td><td>If 0, ignored; otherwise the sequence number just past the last datum in that packet is placed there. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06479">6479</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l06456">advance_seq_num()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a663f1fd8b524ffe63dfa6b7ca76b1a43_cgraph.svg" width="332" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a136d9ccd25634cee2955ea79ae829006" name="a136d9ccd25634cee2955ea79ae829006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136d9ccd25634cee2955ea79ae829006">&#9670;&nbsp;</a></span>handle_accumulated_acks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_accumulated_acks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that handles any incoming acknowledgments and rcv_wnd updates accumulated during the currently running receive handler. </p>
<p >Pre-conditions: executed from <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a>; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8229396adfd306d15e8a05dac3fe8c29" title="While Node::low_lvl_recv_and_handle() or async part of Node::async_wait_latency_then_handle_incoming(...">Peer_socket::m_rcv_acked_packets</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a07d885e5c8ec85e7ef8718dc0468ffe9" title="While Node::low_lvl_recv_and_handle() or async part of Node::async_wait_latency_then_handle_incoming(...">Peer_socket::m_snd_pending_rcv_wnd</a> (in <code>sock</code>) have been set; <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f" title="Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() c...">m_socks_with_accumulated_acks</a>.</p>
<p >If <code>sock</code> is not in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>, method does nothing except possibly log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l02061">2061</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="peer__socket_8hpp_source.html#l02297">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_order_num</a>, <a class="el" href="peer__socket_8hpp_source.html#l02327">flow::net_flow::Peer_socket::Sent_packet::Sent_when::m_sent_cwnd_bytes</a>, <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, and <a class="el" href="util_2util_8hpp_source.html#l00282">flow::util::setup_auto_cleanup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a136d9ccd25634cee2955ea79ae829006_cgraph.svg" width="550" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a136d9ccd25634cee2955ea79ae829006_icgraph.svg" width="991" height="114"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a45583714bc147300158f074ecacce0fd" name="a45583714bc147300158f074ecacce0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45583714bc147300158f074ecacce0fd">&#9670;&nbsp;</a></span>handle_accumulated_pending_acks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_accumulated_pending_acks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> that handles any additional individual outgoing acknowledgments accumulated during the currently running receive handler. </p>
<p >Pre-conditions: executed from <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a>; <code>!(<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">Peer_socket::m_rcv_pending_acks</a>).empty()</code> for <code>sock</code>; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a780f86759f861a3a84de8c5c768736b7" title="Helper state, to be used while inside either Node::low_lvl_recv_and_handle() or async part of Node::a...">Peer_socket::m_rcv_pending_acks_size_at_recv_handler_start</a> (for <code>sock</code>) has been set; <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb" title="Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() (...">m_socks_with_accumulated_pending_acks</a>.</p>
<p >If state is not <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>, method does nothing except possibly log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01638">1638</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae020e63f3ada47025681c8d7f2a00f28">flow::net_flow::error::S_INTERNAL_ERROR_SYSTEM_ERROR_ASIO_TIMER</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a45583714bc147300158f074ecacce0fd_icgraph.svg" width="960" height="114"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab515b28350c43635728d6de0e37ccb94" name="ab515b28350c43635728d6de0e37ccb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515b28350c43635728d6de0e37ccb94">&#9670;&nbsp;</a></span>handle_ack_to_established()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_ack_to_established </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html">Ack_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a> state. </p>
<p >This will hopefully update internal data structures and inform congestion control (or queue that to be done by the end of the current receive handler, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. </td></tr>
    <tr><td class="paramname">ack</td><td>Deserialized immutable ACK. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01990">1990</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab515b28350c43635728d6de0e37ccb94_icgraph.svg" width="979" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="addd654cb6b1ccff34ddccbe5226be8f0" name="addd654cb6b1ccff34ddccbe5226be8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd654cb6b1ccff34ddccbe5226be8f0">&#9670;&nbsp;</a></span>handle_connection_rexmit_timer_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_connection_rexmit_timer_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the triggering of the retransmit timer wait set up by <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12" title="Assuming we&#39;ve just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some a...">setup_connection_timers()</a>; it will re-send the SYN or SYN_ACK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04402">4402</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05811">create_syn()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05826">create_syn_ack()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::S_SYN_SENT</a>, <a class="el" href="peer__socket_8cpp_source.html#l04323">setup_connection_timers()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_addd654cb6b1ccff34ddccbe5226be8f0_cgraph.svg" width="1516" height="559"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a06e4cea2eefa1b06975864f09740c96b" name="a06e4cea2eefa1b06975864f09740c96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e4cea2eefa1b06975864f09740c96b">&#9670;&nbsp;</a></span>handle_data_to_established()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_data_to_established </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>syn_rcvd_qd_packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer socket in <code>S_ESTABLISHED</code> state. </p>
<p >This will hopefully reply with ACK and deliver the data to the Receive buffer, where the user can <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> them.</p>
<p >Also similarly handles packets received and queued earlier while in <code>S_SYN_RCVD</code> state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a> internal state. </td></tr>
    <tr><td class="paramname">packet</td><td>Deserialized DATA packet. (For performance when moving data to Receive buffer, this is modifiable.) </td></tr>
    <tr><td class="paramname">syn_rcvd_qd_packet</td><td>If <code>true</code>, this packet was saved during <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a> by <a class="el" href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_syn_rcvd()</a> and is being handled now that socket is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. If <code>false</code>, this packet was received normally during <code>S_ESTABLISHED</code> state. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00560">560</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00481">flow::util::buffers_dump_string()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00069">flow::net_flow::Peer_socket_receive_stats_accumulator::error_data_packet()</a>, <a class="el" href="log_8hpp_source.html#l00242">FLOW_LOG_DATA</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="socket__stats_8cpp_source.html#l00033">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00092">flow::net_flow::Peer_socket_receive_stats_accumulator::good_to_send_ack_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00075">flow::net_flow::Peer_socket_receive_stats_accumulator::late_or_dupe_data_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00098">flow::net_flow::Peer_socket_receive_stats_accumulator::late_or_dupe_to_send_ack_packet()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>, and <a class="el" href="socket__stats_8cpp_source.html#l00027">flow::net_flow::Peer_socket_receive_stats_accumulator::total_data_packet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a06e4cea2eefa1b06975864f09740c96b_cgraph.svg" width="588" height="640"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a06e4cea2eefa1b06975864f09740c96b_icgraph.svg" width="1172" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abf80b7de1398e93d1d4289ef5bf2ae2c" name="abf80b7de1398e93d1d4289ef5bf2ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf80b7de1398e93d1d4289ef5bf2ae2c">&#9670;&nbsp;</a></span>handle_data_to_syn_rcvd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_data_to_syn_rcvd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer socket in SYN_RCVD state. </p>
<p >This is legitimate under loss and re-ordering conditions. This will hopefully save the packet for later handling once we have entered ESTABLISHED state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>Deserialized packet of type DATA. (For performance when moving data to Receive buffer, this is modifiable.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00701">701</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00489">FLOW_LOG_WITH_CHECKING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">flow::log::S_INFO</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_abf80b7de1398e93d1d4289ef5bf2ae2c_icgraph.svg" width="968" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1699dfdaf3e5ebe1b1d715a9c306d116" name="a1699dfdaf3e5ebe1b1d715a9c306d116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1699dfdaf3e5ebe1b1d715a9c306d116">&#9670;&nbsp;</a></span>handle_incoming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *&#160;</td>
          <td class="paramname"><em>packet_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-received, not-yet-deserialized low-level packet. </p>
<p >A rather important method....</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_data</td><td>Packet to deserialize and handle. Upon return, the state of <code>*packet_data</code> is not known; and caller retains ownership of it (e.g., can read another datagram into it if desired). </td></tr>
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>From where the packet came. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00426">426</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00586">async_no_sock_low_lvl_rst_send()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01033">async_sock_low_lvl_rst_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="low__lvl__packet_8cpp_source.html#l00381">flow::net_flow::Low_lvl_packet::create_from_raw_data_packet()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8cpp_source.html#l01990">handle_ack_to_established()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00560">handle_data_to_established()</a>, <a class="el" href="server__socket_8cpp_source.html#l00701">handle_data_to_syn_rcvd()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00539">handle_syn_ack_to_established()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00474">handle_syn_ack_to_syn_sent()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="options_8hpp_source.html#l00568">flow::net_flow::Node_options::m_dyn_guarantee_one_low_lvl_in_buf_per_socket</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="node_8hpp_source.html#l03798">m_servs</a>, <a class="el" href="node_8hpp_source.html#l03792">m_socks</a>, <a class="el" href="node_8cpp_source.html#l01112">max_block_size()</a>, <a class="el" href="node_8hpp_source.html#l04180">opt()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aa220d89e1d0e34bab02ed2fc7512be9b">flow::net_flow::error::S_CONN_REFUSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab2c97d0fbc585d3726ec79c7802da891">flow::net_flow::error::S_CONN_RESET_BAD_PEER_BEHAVIOR</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4">flow::net_flow::error::S_CONN_RESET_BY_OTHER_SIDE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a">flow::net_flow::Server_socket::S_LISTENING</a>, <a class="el" href="port__space_8cpp_source.html#l00033">flow::net_flow::S_PORT_ANY</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::S_SYN_SENT</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00255">async_wait_latency_then_handle_incoming()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a1699dfdaf3e5ebe1b1d715a9c306d116_cgraph.svg" width="2644" height="2639"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a1699dfdaf3e5ebe1b1d715a9c306d116_icgraph.svg" width="936" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a90ecbad1ff3a8d2fe4b3ad1c474f7513" name="a90ecbad1ff3a8d2fe4b3ad1c474f7513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ecbad1ff3a8d2fe4b3ad1c474f7513">&#9670;&nbsp;</a></span>handle_incoming_with_simulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Node::handle_incoming_with_simulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> *&#160;</td>
          <td class="paramname"><em>packet_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_sim_duplicate_packet</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> that calls <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a> on the not-yet-deserialized low-level packet just read off the UDP socket, but first handles simulation of various network conditions like latency, loss, and duplication. </p>
<p >Pre-condition is that a UDP receive just successfully got the data, or that a simulation thereof occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_data</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a>. Note that, despite this method possibly acting asynchronously (e.g., if simulating latency), <code>*packet_data</code> ownership is retained by the immediate caller. Caller must not assume anything about its contents upon return and is free to do anything else to it (e.g., read another datagram into it). </td></tr>
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a>. </td></tr>
    <tr><td class="paramname">is_sim_duplicate_packet</td><td><code>false</code> if <code>packet_data</code> contains data actually just read from UDP socket. <code>true</code> if <code>packet_data</code> contains data placed there as a simulated duplicate packet. The latter is used to prevent that simulated duplicated packet from itself getting duplicated or dropped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a> was called <em>within</em> this call (before this call returned); i.e., the number of packets (e.g., packet and/or its duplicate) handled immediately as opposed to dropped or scheduled to be handled later. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00187">187</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00255">async_wait_latency_then_handle_incoming()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>, and <a class="el" href="node_8hpp_source.html#l03713">m_net_env_sim</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a90ecbad1ff3a8d2fe4b3ad1c474f7513_cgraph.svg" width="1934" height="2510"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a90ecbad1ff3a8d2fe4b3ad1c474f7513_icgraph.svg" width="738" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a29d02f9e302c7b06288ff1c644fa8d65" name="a29d02f9e302c7b06288ff1c644fa8d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d02f9e302c7b06288ff1c644fa8d65">&#9670;&nbsp;</a></span>handle_syn_ack_ack_to_syn_rcvd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_syn_ack_ack_to_syn_rcvd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html">Syn_ack_ack_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>syn_ack_ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed low-level SYN_ACK_ACK packet delivered to the given peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a> state. </p>
<p >So it will hopefully finish up establishing connection on our side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a>. </td></tr>
    <tr><td class="paramname">syn_ack_ack</td><td>Deserialized immutable SYN_ACK_ACK. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00583">583</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l04447">cancel_timers()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">event_set_all_check_delta()</a>, <a class="el" href="log_8hpp_source.html#l00372">FLOW_LOG_DATA_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00560">handle_data_to_established()</a>, <a class="el" href="node_8hpp_source.html#l03830">m_sock_events</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab2c97d0fbc585d3726ec79c7802da891">flow::net_flow::error::S_CONN_RESET_BAD_PEER_BEHAVIOR</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::S_CONNECTED</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2">flow::net_flow::Event_set::S_SERVER_SOCKET_ACCEPTABLE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>, <a class="el" href="server__socket_8cpp_source.html#l00838">serv_peer_socket_acceptable()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04498">setup_drop_timer()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06103">sock_set_int_state()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06112">sock_set_state()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a29d02f9e302c7b06288ff1c644fa8d65_cgraph.svg" width="1731" height="1827"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a29d02f9e302c7b06288ff1c644fa8d65_icgraph.svg" width="942" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abb3d760b3c880b41e5a4ee7f2c13fd81" name="abb3d760b3c880b41e5a4ee7f2c13fd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3d760b3c880b41e5a4ee7f2c13fd81">&#9670;&nbsp;</a></span>handle_syn_ack_to_established()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_syn_ack_to_established </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>syn_ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed, duplicate (equal to already-received SYN_ACK) low-level SYN_ACK packet delivered to the given peer socket in <code>S_ESTABLISHED</code> state. </p>
<p >This will hopefully reply with SYN_ACK_ACK again. Reasoning for this behavior is given in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116" title="Handles a just-received, not-yet-deserialized low-level packet.">handle_incoming()</a> at the call to this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a> internal state with sock-&gt;m_active_connect. </td></tr>
    <tr><td class="paramname">syn_ack</td><td>Deserialized immutable SYN_ACK. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00539">539</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_abb3d760b3c880b41e5a4ee7f2c13fd81_icgraph.svg" width="1003" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa0f9ebea458490c37a38760c8335506c" name="aa0f9ebea458490c37a38760c8335506c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f9ebea458490c37a38760c8335506c">&#9670;&nbsp;</a></span>handle_syn_ack_to_syn_sent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::handle_syn_ack_to_syn_sent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html">Syn_ack_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>syn_ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed low-level SYN_ACK packet delivered to the given peer socket in <code>S_SYN_SENT</code> state. </p>
<p >So it will hopefully send back a SYN_ACK_ACK, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87" title="Public state is OPEN+CONNECTING; user requested active connect; we sent SYN and are awaiting response...">Peer_socket::Int_state::S_SYN_SENT</a> internal state. </td></tr>
    <tr><td class="paramname">syn_ack</td><td>Deserialized immutable SYN_ACK. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00474">474</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::S_CONNECTED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::S_PEER_SOCKET_WRITABLE</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa0f9ebea458490c37a38760c8335506c_icgraph.svg" width="987" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaaf5c3b5e6b9f9f1658b60907b36a498" name="aaaf5c3b5e6b9f9f1658b60907b36a498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf5c3b5e6b9f9f1658b60907b36a498">&#9670;&nbsp;</a></span>handle_syn_to_listening_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::handle_syn_to_listening_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html">Syn_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>syn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_remote_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-deserialized, just-demultiplexed low-level SYN packet delivered to the given server socket. </p>
<p >So it will hopefully create a <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a> entry, send back a SYN_ACK, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket in LISTENING state to which this SYN was demuxed. </td></tr>
    <tr><td class="paramname">syn</td><td>Deserialized immutable SYN. </td></tr>
    <tr><td class="paramname">low_lvl_remote_endpoint</td><td>The remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New socket placed into <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> socket table; or <code>Ptr()</code> on error, wherein no socket was saved. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00433">433</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00586">async_no_sock_low_lvl_rst_send()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00605">async_sock_low_lvl_packet_send_paced()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04447">cancel_timers()</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00190">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::const_ptr_cast()</a>, <a class="el" href="cong__ctl_8cpp_source.html#l00101">flow::net_flow::Congestion_control_selector::create_strategy()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05826">create_syn_ack()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="seq__num_8cpp_source.html#l00048">flow::net_flow::Sequence_number::Generator::generate_init_seq_num()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="options_8hpp_source.html#l00580">flow::net_flow::Node_options::m_dyn_sock_opts</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="node_8hpp_source.html#l03707">m_opts_mutex</a>, <a class="el" href="node_8hpp_source.html#l03786">m_rnd_security_tokens</a>, <a class="el" href="node_8hpp_source.html#l03780">m_seq_num_generator</a>, <a class="el" href="node_8hpp_source.html#l03792">m_socks</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">flow::net_flow::Peer_socket::S_CONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="server__socket_8cpp_source.html#l00850">serv_peer_socket_init()</a>, <a class="el" href="seq__num_8cpp_source.html#l00268">flow::net_flow::Sequence_number::set_metadata()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04323">setup_connection_timers()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06500">sock_create()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06103">sock_set_int_state()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06112">sock_set_state()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aaaf5c3b5e6b9f9f1658b60907b36a498_cgraph.svg" width="1748" height="1374"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aaaf5c3b5e6b9f9f1658b60907b36a498_icgraph.svg" width="962" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1124027c715d674f113f2d961e4c6861" name="a1124027c715d674f113f2d961e4c6861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1124027c715d674f113f2d961e4c6861">&#9670;&nbsp;</a></span>interrupt_all_waits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::interrupt_all_waits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blocking operation's outcome was being interrupted. </p>
<p >Conceptually, this causes a similar fate as a POSIX blocking function exiting with -1/<code>EINTR</code>, for all such functions currently executing. This may be called from any thread whatsoever and, particularly, from signal handlers as well.</p>
<p >Before deciding to call this explicitly from signal handler(s), consider using the simpler <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#aea7861f3c7739f8e588293d16a2de447" title="If and only if this is true, the Node will detect SIGINT and SIGTERM (or your OS&#39;s version thereof); ...">Node_options::m_st_capture_interrupt_signals_internally</a> instead.</p>
<p >The above is vague about how an interrupted "wait" exhibits itself. More specifically, then: Any operation with name <code>sync_...()</code> will return with an error, that error being <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>-initiated wait will end, with the handler function being called, passing the Boolean value <code>true</code> to that function. <code>true</code> indicates the wait was interrupted rather than successfully finishing with 1 or more active events (<code>false</code> would've indicated th latter, more typical situation).</p>
<p >Note that various calsses have <code>sync_...()</code> operations, including <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a>), <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>), and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01392">1392</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00168">flow::error::exec_void_and_throw_on_error()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="util__fwd_8hpp_source.html#l00971">FLOW_UTIL_WHERE_AM_I_STR</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a1124027c715d674f113f2d961e4c6861_cgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae996cab95eb139d00f0d430093e64a5f" name="ae996cab95eb139d00f0d430093e64a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae996cab95eb139d00f0d430093e64a5f">&#9670;&nbsp;</a></span>interrupt_all_waits_internal_sig_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::interrupt_all_waits_internal_sig_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>sys_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>signal_set</code> handler, executed on SIGINT and SIGTERM, if user has enabled this feature: causes <a class="el" href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca" title="Thread W implementation of interrupt_all_waits().">interrupt_all_waits_worker()</a> to occur on thread W. </p>
<p >Pre-condition: We're in thread W [sic].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sys_err_code</td><td>boost.asio error code indicating the circumstances of the callback executing. It is unusual for this to be truthy. </td></tr>
    <tr><td class="paramname">sig_number</td><td>Signal number of the signal that was detected. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01456">1456</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ae996cab95eb139d00f0d430093e64a5f_icgraph.svg" width="331" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad2840a7a95f16b7e222e449e3d6b9aca" name="ad2840a7a95f16b7e222e449e3d6b9aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2840a7a95f16b7e222e449e3d6b9aca">&#9670;&nbsp;</a></span>interrupt_all_waits_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::interrupt_all_waits_worker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">interrupt_all_waits()</a>. </p>
<p >Performs all the needed work, which is to trigger any WAITING <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects to fire their on-event callbacks, with the Boolean argument set to <code>true</code>, indicating interrupted wait.</p>
<p >Pre-condition: We're in thread W. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01421">1421</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00747">flow::net_flow::Event_set::clear_ev_type_to_socks_map()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">flow::net_flow::Event_set::S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">flow::net_flow::Event_set::S_WAITING</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad2840a7a95f16b7e222e449e3d6b9aca_cgraph.svg" width="336" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3c2cd6a6c328a2d5381308258d35d95d" name="a3c2cd6a6c328a2d5381308258d35d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2cd6a6c328a2d5381308258d35d95d">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> flow::net_flow::Node::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a server on the given local Flow port and returns <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which can be used to accept subsequent incoming connections to this server. </p>
<p >Any subsequent incoming connections will be established asynchronously and, once established, can be claimed (as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects) via Server_server::accept() and friends.</p>
<p >Port specification: You must select a port in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">Node::S_NUM_SERVICE_PORTS</a> - 1] or the special value <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>. In the latter case an available port in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">Node::S_NUM_EPHEMERAL_PORTS</a> - 1] will be chosen for you. Otherwise we will use the port you explicitly specified.</p>
<p >Note that using <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a> in this context typically makes sense only if you somehow communicate <code>serv-&gt;local_port()</code> (where <code>serv</code> is the returned socket) to the other side through some other means (for example if both client and server are running in the same program, you could just pass it via variable or function call). Note that there is no overlap between the two aforementioned port ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_port</td><td>The local Flow port to which to bind. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a2c42b01b60ebe4834e9be3933ce94cb6" title="Flow port already reserved.">error::Code::S_PORT_TAKEN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482abb79e941df00b67a8631a9361ee5a4d1" title="Flow port number is not in the valid service port number range.">error::Code::S_INVALID_SERVICE_PORT_NUMBER</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>. </td></tr>
    <tr><td class="paramname">child_sock_opts</td><td>If null, any Peer_sockets that <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> may return (where <code>serv</code> is the returned <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>) will be initialized with the options set equal to <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>.m_dyn_sock_opts</code>. If not null, they will be initialized with a copy of <code>*child_sock_opts</code>. No reference to <code>*child_sock_opts</code> is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, which is in the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a" title="Future or current accept()s may be possible. A socket in this state may be Acceptable.">Server_socket::State::S_LISTENING</a> state at least initially; or null pointer, indicating an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00144">144</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="server__socket_8cpp_source.html#l00144">listen()</a>, <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00144">listen()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3c2cd6a6c328a2d5381308258d35d95d_cgraph.svg" width="978" height="446"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3c2cd6a6c328a2d5381308258d35d95d_icgraph.svg" width="146" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aba411df8746d5fd4db2d28df3a016f5e" name="aba411df8746d5fd4db2d28df3a016f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba411df8746d5fd4db2d28df3a016f5e">&#9670;&nbsp;</a></span>listen_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::listen_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> *&#160;</td>
          <td class="paramname"><em>serv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread W implementation of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>. </p>
<p >Performs all the needed work, gives the resulting <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> to the user thread, and signals that user thread.</p>
<p >Pre-condition: We're in thread W; thread U != W is waiting for us to return having set <code>*serv</code>. Post-condition: <code>*serv</code> contains a <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a></code> in a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a" title="Future or current accept()s may be possible. A socket in this state may be Acceptable.">Server_socket::State::S_LISTENING</a> state if <code>!(*serv)-&gt;m_disconnect_cause</code>; otherwise an error occurred, and that error is <code>(*serv)-&gt;m_disconnect_cause</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_port</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>. </td></tr>
    <tr><td class="paramname">child_sock_opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>. </td></tr>
    <tr><td class="paramname">serv</td><td><code>*serv</code> shall be set to the resulting <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. Check <code>(*serv)-&gt;m_disconnect_cause</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00218">218</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="node_8hpp_source.html#l03777">m_ports</a>, <a class="el" href="node_8hpp_source.html#l03798">m_servs</a>, <a class="el" href="port__space_8cpp_source.html#l00075">flow::net_flow::Port_space::reserve_port()</a>, <a class="el" href="port__space_8cpp_source.html#l00175">flow::net_flow::Port_space::return_port()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2">flow::net_flow::error::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a">flow::net_flow::Server_socket::S_LISTENING</a>, <a class="el" href="port__space_8cpp_source.html#l00033">flow::net_flow::S_PORT_ANY</a>, <a class="el" href="server__socket_8cpp_source.html#l00873">serv_create()</a>, <a class="el" href="server__socket_8cpp_source.html#l00414">serv_set_state()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06239">sock_validate_options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00144">listen()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aba411df8746d5fd4db2d28df3a016f5e_cgraph.svg" width="784" height="366"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aba411df8746d5fd4db2d28df3a016f5e_icgraph.svg" width="328" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4cb3dcb90f1dfc44a4343c0e89ce6b83" name="a4cb3dcb90f1dfc44a4343c0e89ce6b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb3dcb90f1dfc44a4343c0e89ce6b83">&#9670;&nbsp;</a></span>local_low_lvl_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp; flow::net_flow::Node::local_low_lvl_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >This is similar to to the value passed to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> constructor, except that it represents the actual bound address and port (e.g., if you chose 0 as the port, the value returned here will contain the actual emphemeral port randomly chosen by the OS).</p>
<p >If <code>!running()</code>, this equals <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">Udp_endpoint()</a>. The logical value of the returned <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> never changes over the lifetime of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. Note that it is a reference. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00369">369</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l03764">m_low_lvl_endpoint</a>.</p>

</div>
</div>
<a id="a1bfde94f7d529ea8e6c26b560abfa9c7" name="a1bfde94f7d529ea8e6c26b560abfa9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfde94f7d529ea8e6c26b560abfa9c7">&#9670;&nbsp;</a></span>log_accumulated_acks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::log_accumulated_acks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006" title="Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...">handle_accumulated_acks()</a> that logs the about-to-be-handled accumulated individual acknowledgments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket with 0 or more accumulated acks recorded. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03266">3266</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00372">FLOW_LOG_DATA_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a1bfde94f7d529ea8e6c26b560abfa9c7_cgraph.svg" width="355" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac2fdb686165aae42f474cc655fca80c0" name="ac2fdb686165aae42f474cc655fca80c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fdb686165aae42f474cc655fca80c0">&#9670;&nbsp;</a></span>log_rcv_window()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::log_rcv_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>force_verbose_info_logging</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs TRACE or DATA messages that show the detailed state of the receiving sequence number space. </p>
<p >Quite slow if DATA log level is enabled or <code>force_verbose_info_logging</code> is <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose data to log. </td></tr>
    <tr><td class="paramname">force_verbose_info_logging</td><td>If <code>true</code>, then the method acts as if DATA logging is enabled, i.e., the maximum amount of information is logged (but with INFO verbosity). You should only do this if you know for a fact that this is being called infrequently (such as from <a class="el" href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb" title="Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat logging ...">perform_regular_infrequent_tasks()</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01904">1904</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00532">FLOW_LOG_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="util_2util_8hpp_source.html#l00342">flow::util::ostream_op_to_string()</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">flow::log::S_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06435">sock_log_detail()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac2fdb686165aae42f474cc655fca80c0_cgraph.svg" width="515" height="196"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac2fdb686165aae42f474cc655fca80c0_icgraph.svg" width="1824" height="682"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a24785d3e04e0a9cd5daca43bc867e5aa" name="a24785d3e04e0a9cd5daca43bc867e5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24785d3e04e0a9cd5daca43bc867e5aa">&#9670;&nbsp;</a></span>log_snd_window()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::log_snd_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>force_verbose_info_logging</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs TRACE or DATA messages thats show the detailed state of the sending sequence number space. </p>
<p >Quite slow if DATA log level is enabled or <code>force_verbose_info_logging</code> is <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose data to log. </td></tr>
    <tr><td class="paramname">force_verbose_info_logging</td><td>Similar to same argument in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0" title="Logs TRACE or DATA messages that show the detailed state of the receiving sequence number space.">log_rcv_window()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03635">3635</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00489">FLOW_LOG_WITH_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00532">FLOW_LOG_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="util_2util_8hpp_source.html#l00342">flow::util::ostream_op_to_string()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00373">flow::net_flow::Peer_socket::rexmit_on()</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">flow::log::S_INFO</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06435">sock_log_detail()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a24785d3e04e0a9cd5daca43bc867e5aa_cgraph.svg" width="515" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a24785d3e04e0a9cd5daca43bc867e5aa_icgraph.svg" width="1824" height="682"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0055a25892990585561e69ceb02214d5" name="a0055a25892990585561e69ceb02214d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0055a25892990585561e69ceb02214d5">&#9670;&nbsp;</a></span>low_lvl_packet_sent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::low_lvl_packet_sent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_expected_transferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>sys_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_transferred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completion handler for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>; called when the packet is either successfully fed to the UDP net-stack for sending, or when there is an error in doing so. </p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to pass <code>packet</code> to this, because the serialization operation produces a bunch of pointers into <code>*packet</code>; if one does not pass it here through the boost.asio send call, <code>*packet</code> might get deleted, and then send op will try to access pointer(s) to invalid memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>Ref-counted pointer to the packet that was hopefully sent. Will be destroyed at the end of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5" title="Completion handler for async_low_lvl_packet_send_impl(); called when the packet is either successfull...">low_lvl_packet_sent()</a> unless a copy of this pointer is saved elsewhere before that point. (Usually you should indeed let it be destroyed.) </td></tr>
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4" title="Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...">async_low_lvl_packet_send_impl()</a>. Note the null pointer is allowed. </td></tr>
    <tr><td class="paramname">bytes_expected_transferred</td><td>Size of the serialization of <code>*packet</code>, that being the total # of bytes we want sent over UDP. </td></tr>
    <tr><td class="paramname">sys_err_code</td><td>Result of UDP send operation. </td></tr>
    <tr><td class="paramname">bytes_transferred</td><td>Number of bytes transferred assuming <code>!err_code</code>. Presumably that would equal <code>bytes_expected_transferred</code>, but we will see. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00497">497</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00372">FLOW_LOG_DATA_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a138fe9b2eb78ab00c84b21c4a6b48fed">flow::log::S_DATA</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0055a25892990585561e69ceb02214d5_cgraph.svg" width="339" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0055a25892990585561e69ceb02214d5_icgraph.svg" width="1588" height="235"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9909cd2b2a77c57da9e35fcef0f8a4e5" name="a9909cd2b2a77c57da9e35fcef0f8a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9909cd2b2a77c57da9e35fcef0f8a4e5">&#9670;&nbsp;</a></span>low_lvl_recv_and_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::low_lvl_recv_and_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td>
          <td class="paramname"><em>sys_err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the pre-condition that <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> has a UDP packet available for reading, or that there was an error in waiting for this pre-condition. </p>
<p >If no error (<code>!sys_err_code</code>) then the packet is read (thus erased) from the OS UDP net-stack's packet queue. The packet is then properly handled (for example it may result in more data decoded into an appropriate <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>'s stream buffer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sys_err_code</td><td>Error code of the operation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00046">46</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00031">async_low_lvl_recv()</a>, <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>, <a class="el" href="options_8hpp_source.html#l00553">flow::net_flow::Node_options::m_dyn_low_lvl_max_packet_size</a>, <a class="el" href="options_8hpp_source.html#l00545">flow::net_flow::Node_options::m_dyn_max_packets_per_main_loop_iteration</a>, <a class="el" href="node_8hpp_source.html#l03753">m_low_lvl_sock</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="node_8hpp_source.html#l03774">m_packet_data</a>, <a class="el" href="node_8hpp_source.html#l04180">opt()</a>, and <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00031">async_low_lvl_recv()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a9909cd2b2a77c57da9e35fcef0f8a4e5_cgraph.svg" width="1439" height="1244"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a9909cd2b2a77c57da9e35fcef0f8a4e5_icgraph.svg" width="539" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2983d0d8a4d4eb5c3402f63f68ef44d8" name="a2983d0d8a4d4eb5c3402f63f68ef44d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2983d0d8a4d4eb5c3402f63f68ef44d8">&#9670;&nbsp;</a></span>mark_data_packet_sent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::mark_data_packet_sent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;&#160;</td>
          <td class="paramname"><em>seq_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs important book-keeping based on the event "DATA packet was sent to destination." The affected data structures are: Sent_packet::m_sent_when (for the Sent_packet in question), <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af392484f79ffcead4f74ca351672d8d4" title="Time at which the last Data_packet low-level packet for this connection was sent.">Peer_socket::m_snd_last_data_sent_when</a>, <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">Peer_socket::m_snd_drop_timer</a> (in <code>*sock</code>). </p>
<p >sock-&gt;m_snd_drop_timer. More information is in the doc headers for those data members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket for which the given DATA packet is sent. </td></tr>
    <tr><td class="paramname">seq_num</td><td>The first sequence number for the sent DATA packet. Sent_packet::m_sent_when for its Sent_packet should contain the time at which <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> removed the data from Send buffer and packetized it; it's used to log the difference between that time and now. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00422">422</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02220">flow::net_flow::Peer_socket::Sent_packet::m_sent_when</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2983d0d8a4d4eb5c3402f63f68ef44d8_cgraph.svg" width="360" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2983d0d8a4d4eb5c3402f63f68ef44d8_icgraph.svg" width="1610" height="235"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4bd7b471dd6cd3e3570930b48d30e577" name="a4bd7b471dd6cd3e3570930b48d30e577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7b471dd6cd3e3570930b48d30e577">&#9670;&nbsp;</a></span>max_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::max_block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes of user data per received or sent block on connections generated from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, unless this value is overridden in the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (or friend). </p>
<p >See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7" title="The size of block that we will strive to (and will, assuming at least that many bytes are available i...">Peer_socket_options::m_st_max_block_size</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01112">1112</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="options_8hpp_source.html#l00580">flow::net_flow::Node_options::m_dyn_sock_opts</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="options_8hpp_source.html#l00114">flow::net_flow::Peer_socket_options::m_st_max_block_size</a>, and <a class="el" href="node_8hpp_source.html#l04180">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05857">async_low_lvl_ack_send()</a>, and <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a4bd7b471dd6cd3e3570930b48d30e577_cgraph.svg" width="354" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a4bd7b471dd6cd3e3570930b48d30e577_icgraph.svg" width="960" height="114"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae9b88eadca41228fe6a671f2f14ead0b" name="ae9b88eadca41228fe6a671f2f14ead0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b88eadca41228fe6a671f2f14ead0b">&#9670;&nbsp;</a></span>new_round_trip_time_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::new_round_trip_time_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td>
          <td class="paramname"><em>round_trip_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a just-computed new RTT (round trip time) measurement for an individual packet earlier sent: updates smoothed RTT, DTO, and anything else relevant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Peer socket in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. </td></tr>
    <tr><td class="paramname">round_trip_time</td><td>The RTT just computed, with as much resolution as is available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03497">3497</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

</div>
</div>
<a id="af39d69abde4efa88d5d40e1c529c1a25" name="af39d69abde4efa88d5d40e1c529c1a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39d69abde4efa88d5d40e1c529c1a25">&#9670;&nbsp;</a></span>ok_to_rexmit_or_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::ok_to_rexmit_or_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> &amp;&#160;</td>
          <td class="paramname"><em>pkt_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the given sent packet has been retransmitted the maximum number of allowed times; if so then performs <a class="el" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151" title="Asynchronously send RST to the other side of the given socket and close_connection_immediately().">rst_and_close_connection_immediately()</a> and returns <code>false</code>; otherwise returns <code>true</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to check and possibly close. </td></tr>
    <tr><td class="paramname">pkt_it</td><td>Iterator info <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a> of <code>sock</code> for packet in question. Its <code>m_rexmit_id</code> should not yet be incremented for the potential new retransmission. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03921">3921</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="peer__socket_8hpp_source.html#l02254">flow::net_flow::Peer_socket::Sent_packet::m_packet</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3c1dc923491f5e20763fc27d025665d4">flow::net_flow::error::S_CONN_RESET_TOO_MANY_REXMITS</a>.</p>

</div>
</div>
<a id="a43c42121d48a55a43a48e3a84bd10595" name="a43c42121d48a55a43a48e3a84bd10595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c42121d48a55a43a48e3a84bd10595">&#9670;&nbsp;</a></span>opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Opt_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Opt_type flow::net_flow::Node::opt </td>
          <td>(</td>
          <td class="paramtype">const Opt_type &amp;&#160;</td>
          <td class="paramname"><em>opt_val_ref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a copy of the value of a given option in a thread-safe manner. </p>
<p >Because <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a> may be modified at any time &ndash; even if the desired option is static and not being modified, this is still unsafe &ndash; <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a> must be locked, the desired value must be copied, and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a> must be unlocked. This method does so.</p>
<p >Do NOT read option values without <a class="el" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595" title="Obtain a copy of the value of a given option in a thread-safe manner.">opt()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Opt_type</td><td>The type of the option data member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_val_ref</td><td>A reference (important!) to the value you want; this may be either a data member of <code>this-&gt;m_opts</code> or the entire <code>this-&gt;m_opts</code> itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the value at the given reference. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l04180">4180</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l03707">m_opts_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>, <a class="el" href="node_8cpp_source.html#l01112">max_block_size()</a>, <a class="el" href="node_8cpp_source.html#l01107">options()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00765">sock_pacing_new_time_slice()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01045">sync_sock_low_lvl_rst_send()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a43c42121d48a55a43a48e3a84bd10595_icgraph.svg" width="1986" height="815"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a159b9c2b9a8a969f5e3715341c433aec" name="a159b9c2b9a8a969f5e3715341c433aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159b9c2b9a8a969f5e3715341c433aec">&#9670;&nbsp;</a></span>options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> flow::net_flow::Node::options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s option set and returns that copy. </p>
<p >If you intend to use <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> to modify a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s options, we recommend you make the modifications on the copy returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01107">1107</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, and <a class="el" href="node_8hpp_source.html#l04180">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00040">Node()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a159b9c2b9a8a969f5e3715341c433aec_cgraph.svg" width="354" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a159b9c2b9a8a969f5e3715341c433aec_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0fba26db0055a969f3869014bc5c2bfc" name="a0fba26db0055a969f3869014bc5c2bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fba26db0055a969f3869014bc5c2bfc">&#9670;&nbsp;</a></span>perform_accumulated_on_recv_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::perform_accumulated_on_recv_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs all tasks to be performed at the end of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a>, as determined over the course of the execution of either of those methods. </p>
<p >This includes at least performing <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a> for anything in <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a>, etc., and any accumulated ACK-related tasks stored in the Peer_sockets in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb" title="Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() (...">m_socks_with_accumulated_pending_acks</a> and similar. This is done for efficiency and to reduce network overhead (for example, to combine several individual acknowledgments into one ACK packet). </p>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00375">375</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l01129">event_set_all_check_delta()</a>, <a class="el" href="peer__socket_8cpp_source.html#l02061">handle_accumulated_acks()</a>, <a class="el" href="peer__socket_8cpp_source.html#l01638">handle_accumulated_pending_acks()</a>, <a class="el" href="node_8hpp_source.html#l03867">m_socks_with_accumulated_acks</a>, <a class="el" href="node_8hpp_source.html#l03849">m_socks_with_accumulated_pending_acks</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00255">async_wait_latency_then_handle_incoming()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0fba26db0055a969f3869014bc5c2bfc_cgraph.svg" width="942" height="688"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0fba26db0055a969f3869014bc5c2bfc_icgraph.svg" width="951" height="114"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aee8466d9c810da5edea443d665b24dcb" name="aee8466d9c810da5edea443d665b24dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8466d9c810da5edea443d665b24dcb">&#9670;&nbsp;</a></span>perform_regular_infrequent_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::perform_regular_infrequent_tasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reschedule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat logging and schedules the next time this should happen. </p>
<p >This is the timer handler for that timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reschedule</td><td>If <code>true</code>, after completing the tasks, the timer is scheduled to run again later; otherwise it is not. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01117">1117</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03792">m_socks</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, <a class="el" href="node_8hpp_source.html#l03693">S_REGULAR_INFREQUENT_TASKS_PERIOD</a>, <a class="el" href="sched__task_8hpp_source.html#l00034">flow::util::schedule_task_from_now()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06435">sock_log_detail()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aee8466d9c810da5edea443d665b24dcb_cgraph.svg" width="1020" height="410"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aee8466d9c810da5edea443d665b24dcb_icgraph.svg" width="407" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8cae2884eaf67d77c9f8cf56b31e4c4b" name="a8cae2884eaf67d77c9f8cf56b31e4c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cae2884eaf67d77c9f8cf56b31e4c4b">&#9670;&nbsp;</a></span>rcv_buf_deqable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::rcv_buf_deqable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if and only if there are enough data in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">Peer_socket::m_rcv_buf</a> of <code>sock</code> to give the user some data in a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> call. </p>
<p >Pre-condition: <code>sock-&gt;m_mutex</code> is locked.</p>
<p >Currently this simply means that there is at least 1 block of data in <code>m_rcv_buf</code>.</p>
<p >Design rationale: see snd_buf_deqable().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose Receive buffer to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06097">6097</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05233">sock_is_readable()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a8cae2884eaf67d77c9f8cf56b31e4c4b_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3574d50742fa0b1230c049f4b29fd3dc" name="a3574d50742fa0b1230c049f4b29fd3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3574d50742fa0b1230c049f4b29fd3dc">&#9670;&nbsp;</a></span>rcv_get_first_gap_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::rcv_get_first_gap_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>first_gap_exists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> *&#160;</td>
          <td class="paramname"><em>seq_num_after_first_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that gets simple info about <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> in <code>sock</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to examine. </td></tr>
    <tr><td class="paramname">first_gap_exists</td><td>Pointer to value to set to true if and only if !(<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a>).empty() in <code>sock</code>. If the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> invariant fully holds, this means that there is at least one gap of unreceived packets between some received packets and other received packets, by sequence number order. </td></tr>
    <tr><td class="paramname">seq_num_after_first_gap</td><td>Pointer to value that will be set to the first sequence number of the first element of <code>sock-&gt;m_rcv_packets_with_gaps</code>; untouched if <code>!*first_gap_exists</code> at return. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01569">1569</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="addbb96858fd7b3c9ddd7c6fe8078809c" name="addbb96858fd7b3c9ddd7c6fe8078809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbb96858fd7b3c9ddd7c6fe8078809c">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;&#160;</td>
          <td class="paramname"><em>rcv_buf_consume_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of non-blocking sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>. </p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>sock-&gt;m_mutex</code> is locked and just after entering <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code>;</li>
<li>no changes to <code>*sock</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>sock-&gt;state() == Stated::S_OPEN</code> (so <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>);</li>
<li><code>rcv_buf_feed_func</code> is as described below.</li>
</ul>
<p >This method completes the functionality of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket, which must be in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>, on which <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code> was called. </td></tr>
    <tr><td class="paramname">rcv_buf_consume_func</td><td>Pointer to function with signature <code>size_t fn()</code> that will perform <code>sock-&gt;m_rcv_buf.consume_bufs_copy(...)</code> call, which will consume data from <code>m_rcv_buf</code>, and return the return value of that call (which indicates how many bytes <a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html#af60133c1d6825246b54f10f26810cd88" title="Consumes (removes from the front of the internal byte buffer and returns them to the caller) a byte s...">Socket_buffer::consume_bufs_copy()</a> was able to fit into the user's data structure). Doing it this way prevents this <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a> from being a template, which prevents circular dependency unpleasantness. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> for details. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05083">5083</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="peer__socket_8cpp_source.html#l05551">receive_emptied_rcv_buf_while_disconnecting()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05263">receive_wnd_updated()</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::S_CONNECTED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">flow::net_flow::Peer_socket::S_CONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00219">flow::net_flow::Peer_socket::node_receive()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00234">flow::net_flow::Peer_socket::node_sync_receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_addbb96858fd7b3c9ddd7c6fe8078809c_cgraph.svg" width="1670" height="1296"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_addbb96858fd7b3c9ddd7c6fe8078809c_icgraph.svg" width="775" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad608f9bbe76426f4fbf4bf5af908e4e0" name="ad608f9bbe76426f4fbf4bf5af908e4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad608f9bbe76426f4fbf4bf5af908e4e0">&#9670;&nbsp;</a></span>receive_emptied_rcv_buf_while_disconnecting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::receive_emptied_rcv_buf_while_disconnecting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> onto W during a graceful close, after the Receive buffer had been emptied by the user; determines whether the socket can now proceed to <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code> and be removed from the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket which may possibly now move to <code>m_state == S_CLOSED</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05551">5551</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05083">receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad608f9bbe76426f4fbf4bf5af908e4e0_cgraph.svg" width="1059" height="1023"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad608f9bbe76426f4fbf4bf5af908e4e0_icgraph.svg" width="984" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a45b05340098b0eb66f88a6a7e5f3d36f" name="a45b05340098b0eb66f88a6a7e5f3d36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b05340098b0eb66f88a6a7e5f3d36f">&#9670;&nbsp;</a></span>receive_wnd_recovery_data_received()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::receive_wnd_recovery_data_received </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pertaining to the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78" title="receive_wnd_updated() helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a r...">async_rcv_wnd_recovery()</a> mechanism, this handles the event that we have received an acceptable (either into Receive buffer or reassembly queue) DATA packet from the other side. </p>
<p >If we are currently in rcv_wnd recovery, this signifies the recovery "worked" &ndash; the sender is sending data again &ndash; so we can now end this phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357" title="Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...">receive_wnd_updated()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05485">5485</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="sched__task_8cpp_source.html#l00026">flow::util::scheduled_task_cancel()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a45b05340098b0eb66f88a6a7e5f3d36f_cgraph.svg" width="352" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a08cf95363b26c0c676979437e34db357" name="a08cf95363b26c0c676979437e34db357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cf95363b26c0c676979437e34db357">&#9670;&nbsp;</a></span>receive_wnd_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::receive_wnd_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> onto W if it has dequeued data from Receive buffer and given it to the user, which would free up space in the Receive buffer, which <em>possibly</em> should result in a window update sent to the server, so that it knows it can now send more data. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket (whose state is ESTABLISHED or later). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05263">5263</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05083">receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a08cf95363b26c0c676979437e34db357_cgraph.svg" width="1279" height="396"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a08cf95363b26c0c676979437e34db357_icgraph.svg" width="972" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afe70a0c32695e417e7a09e0ba773f151" name="afe70a0c32695e417e7a09e0ba773f151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe70a0c32695e417e7a09e0ba773f151">&#9670;&nbsp;</a></span>rst_and_close_connection_immediately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::rst_and_close_connection_immediately </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously send RST to the other side of the given socket and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05803">5803</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l01033">async_sock_low_lvl_rst_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05615">close_abruptly()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04498">setup_drop_timer()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00969">sock_pacing_time_slice_end()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_afe70a0c32695e417e7a09e0ba773f151_cgraph.svg" width="1747" height="1283"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_afe70a0c32695e417e7a09e0ba773f151_icgraph.svg" width="1266" height="250"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aae148cec361b59237996a4b30c6624b5" name="aae148cec361b59237996a4b30c6624b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae148cec361b59237996a4b30c6624b5">&#9670;&nbsp;</a></span>running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is operating. </p>
<p >If not, all attempts to use this object or any objects generated by this object (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>, etc.) will result in error. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00420">420</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05615">close_abruptly()</a>, <a class="el" href="server__socket_8cpp_source.html#l00144">listen()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05083">receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04520">send()</a>, <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06338">sock_info()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06191">sock_set_options()</a>, and <a class="el" href="node_8hpp_source.html#l03977">sync_op()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aae148cec361b59237996a4b30c6624b5_icgraph.svg" width="960" height="556"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa19d1f49638ef8ce8883e7477a06d3fc" name="aa19d1f49638ef8ce8883e7477a06d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19d1f49638ef8ce8883e7477a06d3fc">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;&#160;</td>
          <td class="paramname"><em>snd_buf_feed_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of non-blocking <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == State::S_CLOSED</code>. </p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>sock-&gt;m_mutex</code> is locked and after entering <code>sock-&gt;[sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code>;</li>
<li>no changes to <code>*sock</code> have been made since <code>m_mutex</code> was locked;</li>
<li><code>sock-&gt;state() == State::S_OPEN</code> (so <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>);</li>
<li>`snd_buf_feed_func is as described below.</li>
</ul>
<p >This method completes the functionality of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd>Important: see giant comment inside <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a> for overall design and how <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> fits into it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket, which must be in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>, on which <code>[sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> was called. </td></tr>
    <tr><td class="paramname">snd_buf_feed_func</td><td>Pointer to function with signature <code>size_t fn(size_t x)</code> that will perform <code>sock-&gt;m_snd_buf.feed_bufs_copy(...)</code> call with <code>max_data_size == X</code>, which will feed the data the user wants to <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> into <code>sock-&gt;m_snd_buf</code>, and return the return value of that call (which indicates how many bytes the call was able to fit into <code>m_snd_buf</code>). Doing it this way prevents this <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a> from being a template, which prevents circular dependency unpleasantness. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> for details. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04520">4520</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00218">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::S_CONNECTED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">flow::net_flow::Peer_socket::S_CONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="peer__socket_8cpp_source.html#l04747">send_worker_check_state()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06074">snd_deqable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00134">flow::net_flow::Peer_socket::node_send()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00149">flow::net_flow::Peer_socket::node_sync_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa19d1f49638ef8ce8883e7477a06d3fc_cgraph.svg" width="1252" height="852"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa19d1f49638ef8ce8883e7477a06d3fc_icgraph.svg" width="752" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a10a92f11a2c9f218cdd9a55f282e79b1" name="a10a92f11a2c9f218cdd9a55f282e79b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a92f11a2c9f218cdd9a55f282e79b1">&#9670;&nbsp;</a></span>send_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::send_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>defer_delta_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread W implemention of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a>: synchronously or asynchronously send the contents of <code>sock-&gt;m_snd_buf</code> to the other side. </p>
<p >This locks the socket and examines <code>m_snd_buf</code>. If a low-level UDP packet cannot be produced from the front of <code>m_snd_buf</code> (i.e., not enough data in <code>m_snd_buf</code>), then there is nothing to do. Otherwise, determines whether network conditions (e.g., congestion control) allow for 1 or more such packets to be sent. If not, then there is nothing to do. Otherwise (if 1 or more packets can be sent), 1 or more packets are sent and removed from <code>sock-&gt;m_snd_buf</code>. Finally, <code>m_snd_buf</code> is unlocked.</p>
<p >Pre-condition: <code>sock-&gt;m_int_state == S_ESTABLISHED</code>. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000118">Todo:</a></b></dt><dd>Are there other states where sending DATA packets is OK? If so it would be during graceful termination, if we implement it. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> for contedt for this to-do.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Important: see giant comment inside <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a> for overall design and how <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> fits into it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket on which to possibly send low-level packets. </td></tr>
    <tr><td class="paramname">defer_delta_check</td><td>Same meaning as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04792">4792</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l06456">advance_seq_num()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05039">can_send()</a>, <a class="el" href="socket__buffer_8cpp_source.html#l00103">flow::net_flow::Socket_buffer::consume_buf_move()</a>, <a class="el" href="socket__buffer_8cpp_source.html#l00034">flow::net_flow::Socket_buffer::data_size()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">event_set_all_check_delta()</a>, <a class="el" href="log_8hpp_source.html#l00242">FLOW_LOG_DATA</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03830">m_sock_events</a>, <a class="el" href="shared__ptr__alias__holder_8hpp_source.html#l00180">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::ptr_cast()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::S_PEER_SOCKET_WRITABLE</a>, <a class="el" href="peer__socket_8cpp_source.html#l06080">snd_buf_enqable()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06074">snd_deqable()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03818">snd_flying_pkts_push_one()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03760">snd_past_last_flying_datum_seq_num()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06494">sock_get_new_snd_order_num()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04747">send_worker_check_state()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a10a92f11a2c9f218cdd9a55f282e79b1_cgraph.svg" width="1492" height="875"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a10a92f11a2c9f218cdd9a55f282e79b1_icgraph.svg" width="975" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2565b7c0bd82cad86eb168b62f8ffd9d" name="a2565b7c0bd82cad86eb168b62f8ffd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2565b7c0bd82cad86eb168b62f8ffd9d">&#9670;&nbsp;</a></span>send_worker_check_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::send_worker_check_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper placed by <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a> onto W to invoke <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> but ensures that the socket has not entered some state such that sending data is not possible and no longer going to be possible. </p>
<p >Example: <code>send(sock)</code> runs while <code>sock</code> is in ESTABLISHED state; queues up <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d" title="Helper placed by send() onto W to invoke send_worker() but ensures that the socket has not entered so...">send_worker_check_state()</a> on thread W; thread W detects a connection reset and moves <code>sock</code> to CLOSED; <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d" title="Helper placed by send() onto W to invoke send_worker() but ensures that the socket has not entered so...">send_worker_check_state()</a> gets its turn on thread W; detects state is now CLOSED and returns without doing anything.</p>
<dl class="section see"><dt>See also</dt><dd>Important: see giant comment inside <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a> for overall design and how <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">send_worker()</a> fits into it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket on which to possibly send low-level packets. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04747">4747</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">flow::net_flow::Peer_socket::S_ESTABLISHED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::S_SYN_SENT</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04520">send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2565b7c0bd82cad86eb168b62f8ffd9d_cgraph.svg" width="1284" height="872"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2565b7c0bd82cad86eb168b62f8ffd9d_icgraph.svg" width="970" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2af9ec4f1483cd9a2183286f7dfa9c87" name="a2af9ec4f1483cd9a2183286f7dfa9c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af9ec4f1483cd9a2183286f7dfa9c87">&#9670;&nbsp;</a></span>serv_close_detected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::serv_close_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>disconnect_cause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records that thread W shows this socket is not to listen to incoming connections and is to abort any not-yet-established (i.e., not yet queued) and established-but-unclaimed (i.e., queued) connections; and sets <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ae87a97dcfaa0909789b76ef4462d6a0b" title="The Error_code causing this server&#39;s move from LISTENING state (if this has occurred); otherwise a cl...">Server_socket::m_disconnect_cause</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a783f81f10b50f62a638aa26b72d49e36" title="See state(). Should be set before user gets access to *this. Must not be modified by non-W threads.">Server_socket::m_state</a> in <code>serv</code> accordingly. </p>
<p >Thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket under consideration. </td></tr>
    <tr><td class="paramname">disconnect_cause</td><td>The cause of the disconnect. </td></tr>
    <tr><td class="paramname">close</td><td>If <code>true</code>, the target public state should be the super-final <code>S_CLOSED</code>; if false, the target public state should be the ominous <code>S_CLOSING</code>. The caller's responsibility is to decide which one it is. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00766">766</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Server_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42">flow::net_flow::Server_socket::S_CLOSING</a>, and <a class="el" href="server__socket_8cpp_source.html#l00414">serv_set_state()</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2af9ec4f1483cd9a2183286f7dfa9c87_cgraph.svg" width="335" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2af9ec4f1483cd9a2183286f7dfa9c87_icgraph.svg" width="520" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0a91542fce634cf6a749c71f225b105a" name="a0a91542fce634cf6a749c71f225b105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a91542fce634cf6a749c71f225b105a">&#9670;&nbsp;</a></span>serv_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> * flow::net_flow::Node::serv_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal factory used for ALL <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects created by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (including subclasses). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_sock_opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a1f48a72439665d8754549f11a4f4c7bb" title="Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meani...">Server_socket::Server_socket()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly constructed socket. </dd></dl>

<p>Reimplemented in <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a63171653725513e198b8baf60c3c1427">flow::net_flow::asio::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00873">873</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0a91542fce634cf6a749c71f225b105a_icgraph.svg" width="511" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab330b19f4039bab074251111789b568a" name="ab330b19f4039bab074251111789b568a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab330b19f4039bab074251111789b568a">&#9670;&nbsp;</a></span>serv_create_forward_plus_ctor_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_socket_impl_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> * flow::net_flow::Node::serv_create_forward_plus_ctor_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c" title="Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...">sock_create_forward_plus_ctor_args()</a> but for Server_sockets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Server_socket_impl_type</td><td>Either <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">net_flow::asio::Server_socket</a>, as of this writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_sock_opts</td><td>See, for example, <code>Peer_socket::accept(..., const Peer_socket_options* child_sock_opts)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new object of type <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> or of a subclass. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l04199">4199</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab330b19f4039bab074251111789b568a_cgraph.svg" width="342" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a51b26bff4cdf545f22d8edec7185c5c4" name="a51b26bff4cdf545f22d8edec7185c5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b26bff4cdf545f22d8edec7185c5c4">&#9670;&nbsp;</a></span>serv_is_acceptable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::serv_is_acceptable </td>
          <td>(</td>
          <td class="paramtype">const boost::any &amp;&#160;</td>
          <td class="paramname"><em>serv_as_any</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if calling <code>serv-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> with at least some arguments would return either non-null (i.e., successfully dequeued a connected socket) or null and an error (but not null and NO error). </p>
<p ><code>serv</code> will be locked and unlocked; safe to call from any thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv_as_any</td><td>Socket to examine, as an <code>any</code> wrapping a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00342">342</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a">flow::net_flow::Server_socket::S_LISTENING</a>.</p>

</div>
</div>
<a id="abf0204e999b5dc28ee9b5db6eae9aa1a" name="abf0204e999b5dc28ee9b5db6eae9aa1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0204e999b5dc28ee9b5db6eae9aa1a">&#9670;&nbsp;</a></span>serv_peer_socket_acceptable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::serv_peer_socket_acceptable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records that an unestablished socket <code>sock</code> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a>) has just become established and can be <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>ed (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>). </p>
<p >Moves <code>sock</code> from <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a16bcbf9951c24d13d5b84d9aa163288e" title="Set of passively opening sockets in pre-ESTABLISHED (so SYN_RCVD?) internal state (and thus are not y...">Server_socket::m_connecting_socks</a> to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a7ba32040008ffe0637d3a1847deb76c5" title="Queue of passively opened sockets in Peer_socket::Int_state::S_ESTABLISHED internal state that have n...">Server_socket::m_unaccepted_socks</a> (in <code>serv</code>). To be called from thread W only. Thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket under consideration. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket that was just moved to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Peer_socket::Int_state::S_ESTABLISHED</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00838">838</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_abf0204e999b5dc28ee9b5db6eae9aa1a_icgraph.svg" width="970" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8a6c02bf520a16df4028bd3c88732a8d" name="a8a6c02bf520a16df4028bd3c88732a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6c02bf520a16df4028bd3c88732a8d">&#9670;&nbsp;</a></span>serv_peer_socket_closed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::serv_peer_socket_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records that a <code><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a></code>-contained (i.e., currently un-established, or established but not yet accepted by user) <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is being closed and should be removed from the given <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </p>
<p >To be called from thread W only. Thread-safe.</p>
<p >If <code>sock</code> is not contained in <code>*serv</code>, method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket under consideration. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket to remove (moving from <code>S_SYN_RCVD</code> or <code>S_ESTABLISHED</code> to <code>S_CLOSED</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00786">786</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a8a6c02bf520a16df4028bd3c88732a8d_icgraph.svg" width="1686" height="699"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0379c897bdb3e4eddeb759547be78261" name="a0379c897bdb3e4eddeb759547be78261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0379c897bdb3e4eddeb759547be78261">&#9670;&nbsp;</a></span>serv_peer_socket_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::serv_peer_socket_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records a new (just received SYN) peer socket from the given server socket. </p>
<p >Adds <code>sock</code> to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a16bcbf9951c24d13d5b84d9aa163288e" title="Set of passively opening sockets in pre-ESTABLISHED (so SYN_RCVD?) internal state (and thus are not y...">Server_socket::m_connecting_socks</a> (in <code>serv</code>) and maintains the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5629d810d2c7252eaa2243e076dde83f" title="For sockets that come a Server_socket, this is the inverse of Server_socket::m_connecting_socks: it i...">Peer_socket::m_originating_serv</a> (in <code>sock</code>) invariant. To be called from thread W only. Thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server that originated <code>sock</code>. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket that was just moved to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Peer_socket::Int_state::S_SYN_RCVD</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00850">850</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0379c897bdb3e4eddeb759547be78261_icgraph.svg" width="946" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0bac29a091e1026e5b4f0b5d84a710c7" name="a0bac29a091e1026e5b4f0b5d84a710c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bac29a091e1026e5b4f0b5d84a710c7">&#9670;&nbsp;</a></span>serv_set_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::serv_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a783f81f10b50f62a638aa26b72d49e36" title="See state(). Should be set before user gets access to *this. Must not be modified by non-W threads.">Server_socket::m_state</a>. </p>
<p >If moving to <code>S_CLOSED</code>, resets the required data to their "undefined" values (e.g., <code><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ac36eb28d50496b3f8f1b9790194e825e" title="See local_port().">Server_socket::m_local_port</a> = #S_PORT_ANY</code>). Thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serv</td><td>Server socket under consideration. </td></tr>
    <tr><td class="paramname">state</td><td>New <code>m_state</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="server__socket_8cpp_source.html#l00414">414</a> of file <a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Server_socket::S_CLOSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00766">serv_close_detected()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0bac29a091e1026e5b4f0b5d84a710c7_icgraph.svg" width="703" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2779cc2429651696df1bca8de73534f3" name="a2779cc2429651696df1bca8de73534f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2779cc2429651696df1bca8de73534f3">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>) with the given options set. </p>
<p >Only those members of <code>opts</code> designated as dynamic (as opposed to static) may be different between <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a> and <code>opts</code>. If this is violated, it is an error, and no options are changed.</p>
<p >Typically one would acquire a copy of the existing options set via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>, modify the desired dynamic data members of that copy, and then apply that copy back by calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. Warning: this technique is only safe if other (user) threads do not call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> simultaneously. There is a to-do to provide a thread-safe maneuver for when this is a problem (see class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> doc header).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The new options to apply to this socket. It is copied; no reference is saved. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01054">1054</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="node_8hpp_source.html#l03707">m_opts_mutex</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>, and <a class="el" href="node_8cpp_source.html#l00980">validate_options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2779cc2429651696df1bca8de73534f3_cgraph.svg" width="703" height="160"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2779cc2429651696df1bca8de73534f3_icgraph.svg" width="146" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac1485c07049d4bee70ad4ef2fc07bf12" name="ac1485c07049d4bee70ad4ef2fc07bf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1485c07049d4bee70ad4ef2fc07bf12">&#9670;&nbsp;</a></span>setup_connection_timers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::setup_connection_timers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>initial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming we've just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some amount of time, so that we may try the SYN[_ACK] again if we don't get the acknowledgement by then (or we may close socket after too many such retries). </p>
<p >If <code>initial</code> is <code>true</code>, an overall connection timeout scheduled task is also set up, to trigger the aforementioned close on timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Peer socket in SYN_SENT or SYN_RCVD internal state. </td></tr>
    <tr><td class="paramname">initial</td><td><code>true</code> if and only if the first SYN or SYN_ACK; otherwise it is a retry. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04323">4323</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090">flow::net_flow::error::S_CONN_TIMEOUT</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">flow::net_flow::Peer_socket::S_SYN_RCVD</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">flow::net_flow::Peer_socket::S_SYN_SENT</a>, <a class="el" href="sched__task_8hpp_source.html#l00034">flow::util::schedule_task_from_now()</a>, <a class="el" href="sched__task_8cpp_source.html#l00238">flow::util::scheduled_task_fired()</a>, and <a class="el" href="sched__task_8cpp_source.html#l00200">flow::util::scheduled_task_fires_from_now_or_canceled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac1485c07049d4bee70ad4ef2fc07bf12_cgraph.svg" width="782" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac1485c07049d4bee70ad4ef2fc07bf12_icgraph.svg" width="978" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab427ebc124a6233ae48a7562662a6e81" name="ab427ebc124a6233ae48a7562662a6e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab427ebc124a6233ae48a7562662a6e81">&#9670;&nbsp;</a></span>setup_drop_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::setup_drop_timer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Drop Timer and saves it to <code>sock-&gt;m_snd_drop_timer</code>. </p>
<p >Pre-condition: <code>m_int_state == S_ESTABLISHED</code>, and <code>sock-&gt;m_snd_drop_timer</code> is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Connection ID (socket pair) identifying the socket in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a>. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket that just entered ESTABLISHED state. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04498">4498</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="drop__timer_8cpp_source.html#l00028">flow::net_flow::Drop_timer::create_drop_timer()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03317">drop_timer_action()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab427ebc124a6233ae48a7562662a6e81_cgraph.svg" width="1476" height="1388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab427ebc124a6233ae48a7562662a6e81_icgraph.svg" width="914" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a70d124ba678e2ab72f8c6d28140ca137" name="a70d124ba678e2ab72f8c6d28140ca137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d124ba678e2ab72f8c6d28140ca137">&#9670;&nbsp;</a></span>snd_buf_enqable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::snd_buf_enqable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if and only if there is enough free space in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">Peer_socket::m_snd_buf</a> of <code>sock</code> to enqueue any given atomic piece of user data. </p>
<p >Pre-condition: <code>sock-&gt;m_mutex</code> is locked.</p>
<p >Currently this simply means that there is space for at least max-block-size bytes (i.e., one maximally large block) in <code>sock-&gt;m_snd_buf</code>.</p>
<p >Design rationale for the latter: See code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose Send buffer to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06080">6080</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04713">sock_is_writable()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a70d124ba678e2ab72f8c6d28140ca137_icgraph.svg" width="938" height="138"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a382b607fa2e482886f2fd75edc36b8b7" name="a382b607fa2e482886f2fd75edc36b8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382b607fa2e482886f2fd75edc36b8b7">&#9670;&nbsp;</a></span>snd_deqable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::snd_deqable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if and only if there are enough data either in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a845f21b754ef641b65b1fe44727fb429" title="If retransmission is on, this is the retransmission queue.">Peer_socket::m_snd_rexmit_q</a> of <code>sock</code> (if retransmission is on) or in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">Peer_socket::m_snd_buf</a> of <code>sock</code> to send a DATA packet to the other side. </p>
<p >Pre-condition: <code>sock-&gt;m_mutex</code> is locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose retransmission queue and Send buffer to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06074">6074</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04520">send()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a382b607fa2e482886f2fd75edc36b8b7_icgraph.svg" width="1335" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a43af576c6156f5d69682e664d9ff3922" name="a43af576c6156f5d69682e664d9ff3922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43af576c6156f5d69682e664d9ff3922">&#9670;&nbsp;</a></span>snd_flying_pkts_erase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::snd_flying_pkts_erase_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&#160;</td>
          <td class="paramname"><em>pkt_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases (for example if considered Acknowledged or Dropped) a packet <code>struct</code> from the "scoreboard" (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>) and adjusts all related structures. </p>
<p >Note: It does NOT inform <code>sock-&gt;m_snd_drop_timer</code> (namely calling <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html#a5d1fff72b5c044cba0651de0508553e0" title="Indicates that a packet for which on_packet_in_flight() was called is now no longer considered In-fli...">Drop_timer::on_packet_no_longer_in_flight()</a>). This is left to the caller; in particular because the timing may not be appropriate for what such a call might trigger (e.g., on-Drop-Timeout actions such as massive retransmission).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">pkt_it</td><td>Iterator into <code>m_snd_flying_pkts_by_sent_when</code> which will be deleted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03781">3781</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02254">flow::net_flow::Peer_socket::Sent_packet::m_packet</a>, <a class="el" href="peer__socket_8hpp_source.html#l02220">flow::net_flow::Peer_socket::Sent_packet::m_sent_when</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a43af576c6156f5d69682e664d9ff3922_cgraph.svg" width="376" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a52a3e10ef08b93daf87ea5f0f1e87062" name="a52a3e10ef08b93daf87ea5f0f1e87062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a3e10ef08b93daf87ea5f0f1e87062">&#9670;&nbsp;</a></span>snd_flying_pkts_push_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::snd_flying_pkts_push_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> &amp;&#160;</td>
          <td class="paramname"><em>seq_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a>&#160;</td>
          <td class="paramname"><em>sent_pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new packet <code>struct</code> (presumably representing packet to be sent shortly) to the "scoreboard" (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a>) and adjusts all related structures as applicable. </p>
<p >Note, however, that <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8" title="Performs important book-keeping based on the event &quot;DATA packet was sent to destination....">mark_data_packet_sent()</a> is NOT called, because we should do that when the DATA packet is actually sent (after pacing, if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">seq_num</td><td>The first sequence number of the DATA packet. </td></tr>
    <tr><td class="paramname">sent_pkt</td><td>Ref-counted pointer to new packet <code>struct</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03818">3818</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00354">FLOW_LOG_TRACE_WITHOUT_CHECKING</a>, <a class="el" href="log_8cpp_source.html#l00229">flow::log::Log_context::get_log_component()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::S_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a52a3e10ef08b93daf87ea5f0f1e87062_cgraph.svg" width="372" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a52a3e10ef08b93daf87ea5f0f1e87062_icgraph.svg" width="974" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a00124a034c8fdac6f300900bdfcc8cfe" name="a00124a034c8fdac6f300900bdfcc8cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00124a034c8fdac6f300900bdfcc8cfe">&#9670;&nbsp;</a></span>snd_flying_pkts_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::snd_flying_pkts_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a>&#160;</td>
          <td class="paramname"><em>pkt_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> &amp;&#160;</td>
          <td class="paramname"><em>pkt_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>added</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480" title="The number of bytes contained in all In-flight packets, used at least for comparison against the cong...">Peer_socket::m_snd_flying_bytes</a> according to an operation (add packets, remove packets) caller is about to undertake or has just undertaken on <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">Peer_socket::m_snd_flying_pkts_by_sent_when</a> (= the scoreboard). </p>
<p >Call this WHENEVER <code>m_snd_flying_pkts_by_sent_when</code> is about to be modified (if erasing) or has just been modified (if adding) to ensure <code>m_snd_flying_bytes</code> is updated accordingly.</p>
<dl class="section warning"><dt>Warning</dt><dd>This has strong implications for congestion control! Do not forget. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">pkt_begin</td><td>Iterator to first packet that was added or will be removed. </td></tr>
    <tr><td class="paramname">pkt_end</td><td>Iterator one past the last packet that was added or will be removed. </td></tr>
    <tr><td class="paramname">added</td><td>If <code>true</code>, the given range of packets was just added (e.g., Sent); if <code>false</code>, the given range of packets is about to be removed (e.g., Dropped or Acknowledged). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03884">3884</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

</div>
</div>
<a id="a837d37e6eb06fb6df4666bac327d20f8" name="a837d37e6eb06fb6df4666bac327d20f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837d37e6eb06fb6df4666bac327d20f8">&#9670;&nbsp;</a></span>snd_past_last_flying_datum_seq_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> flow::net_flow::Node::snd_past_last_flying_datum_seq_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the sequence number for the datum just past the last (latest) In-flight (i.e., sent but neither Acknowledged nor Dropped) packet, for the given socket. </p>
<p >If there are no In-flight packets, returns the default <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html" title="An internal net_flow sequence number identifying a piece of data.">Sequence_number</a> &ndash; which is &lt; all other Sequence_numbers.</p>
<p >Note that "last" in this case refers to position in the sequence number space, not time at which packets are sent. (A packet with a given <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html" title="An internal net_flow sequence number identifying a piece of data.">Sequence_number</a> may be sent several times due to retransmission.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose In-flight packets to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l03760">3760</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a837d37e6eb06fb6df4666bac327d20f8_icgraph.svg" width="942" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acfbd969c7a16b2ea8bb7f0db6fa454df" name="acfbd969c7a16b2ea8bb7f0db6fa454df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd969c7a16b2ea8bb7f0db6fa454df">&#9670;&nbsp;</a></span>sock_categorize_data_to_established()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> flow::net_flow::Node::sock_categorize_data_to_established </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>dupe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>slide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>slide_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that categorizes the DATA packet received as either illegal; legal but duplicate of a previously received DATA packet; legal but out-of-order; and finally legal and in-order. </p>
<p >Illegal means sender can never validly send such sequence numbers in a DATA packet. Legal means it can, although network problems may still lead to the received DATA being not-useful in some way. Out-of-order means that <code>packet</code> occupies seq. numbers past the start of the first unreceived data, or "first gap," which starts at <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a>. In-order, therefore, means <code>packet</code> indeed begins exactly at <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> (which means typically one should increment the latter by <code>packet-&gt;m_data.size()</code>).</p>
<p >No statistics are marked down on <code>sock</code>; the caller should proceed depending on the output as described just below.</p>
<p >If a truthy value is returned, packet is illegal; other outputs are meaningless. Otherwise, falsy is returned; and: If <code>*dupe</code>, then packet is a legal dupe; and other outputs are meaningless. Otherwise, <code>!*dupe</code>. and: <code>*slide</code> if and only if the packet is in-order (hence receive window left edge should "slide" right). <code>*slide_size</code> is the number of bytes by which <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> should increment ("slide"); it is meaningful if and only if <code>*slide</code>.</p>
<p >(Aside: Every attempt to detect illegality is made, within reason, but NOT every illegal behavior can be detected as such; but defensive coding strives that a failure to detect such leads to nothing worse than meaningless data received by user.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. Note it is read-only, however. .</td></tr>
    <tr><td class="paramname">dupe</td><td>Output for whether the packet is a dupe (true if so). Meaningless if truthy is returned. </td></tr>
    <tr><td class="paramname">slide</td><td>Output for whether the packet consists of the next data to be passed to Receive buffer. Meaningless if truthy is returned, or else if <code>*dupe</code> is set to <code>true</code>. </td></tr>
    <tr><td class="paramname">slide_size</td><td>By how much to increment <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> due to this in-order packet. Meaningless unless <code>*slide</code> is set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success if <code>packet</code> is legal; the recommended error to accompany the connection-breaking RST due to the illegal <code>packet</code>, otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00825">825</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="socket__stats_8cpp_source.html#l00069">flow::net_flow::Peer_socket_receive_stats_accumulator::error_data_packet()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="peer__socket_8hpp_source.html#l01386">flow::net_flow::Peer_socket::m_rcv_init_seq_num</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8ad7147a3e4e63313c7a5954790cd458">flow::net_flow::error::S_SEQ_NUM_ARITHMETIC_FAILURE</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a891201a96c5838bbb24cc9ed08b47765">flow::net_flow::error::S_SEQ_NUM_IMPLIES_CONNECTION_COLLISION</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_acfbd969c7a16b2ea8bb7f0db6fa454df_cgraph.svg" width="366" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6daaa6a5a7d0b7e5a2266dd9db400c01" name="a6daaa6a5a7d0b7e5a2266dd9db400c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6daaa6a5a7d0b7e5a2266dd9db400c01">&#9670;&nbsp;</a></span>sock_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> * flow::net_flow::Node::sock_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal factory used for ALL <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects created by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (including subclasses). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42" title="Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meani...">Peer_socket::Peer_socket()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly constructed socket. </dd></dl>

<p>Reimplemented in <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a13e8070f5a4e4300e0138b63694884fc">flow::net_flow::asio::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06500">6500</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6daaa6a5a7d0b7e5a2266dd9db400c01_icgraph.svg" width="934" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa42efbce8c5ea908a253fca2e9b2a02c" name="aa42efbce8c5ea908a253fca2e9b2a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42efbce8c5ea908a253fca2e9b2a02c">&#9670;&nbsp;</a></span>sock_create_forward_plus_ctor_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Peer_socket_impl_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> * flow::net_flow::Node::sock_create_forward_plus_ctor_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to newly created <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or sub-instance like <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>, depending on the template parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Peer_socket_impl_type</td><td>Either <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">net_flow::asio::Peer_socket</a>, as of this writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>See, for example, <code>Peer_socket::connect(..., const Peer_socket_options&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new object of type <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or of a subclass. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l04193">4193</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa42efbce8c5ea908a253fca2e9b2a02c_cgraph.svg" width="344" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aab414ebd0e2d27f02ed51270dab90c45" name="aab414ebd0e2d27f02ed51270dab90c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab414ebd0e2d27f02ed51270dab90c45">&#9670;&nbsp;</a></span>sock_data_to_rcv_buf_unless_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_data_to_rcv_buf_unless_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to pass the payload of the given DATA packet to the given socket's Receive buffer for user consumption; but detects and reports overflow if appropriate, instead. </p>
<p >Certain relevant stats are logged in all cases. <code>packet.m_data</code> is emptied due to moving it elsewhere &ndash; for performance (recommend saving its <code>.size()</code> before-hand, if needed for later) &ndash; and the implications on rcv_wnd recovery (if any) are handled. <code>true</code> is returned assuming no overflow.</p>
<p >If overflow detected, only statistical observations and logs are made, and <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> on overflow; <code>true</code> on success. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01133">1133</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="socket__stats_8cpp_source.html#l00148">flow::net_flow::Peer_socket_receive_stats_accumulator::buffer_fed()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="socket__stats_8cpp_source.html#l00051">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_accepted_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00057">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_delivered_packet()</a>, and <a class="el" href="socket__stats_8cpp_source.html#l00039">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_dropped_buf_overflow_packet()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aab414ebd0e2d27f02ed51270dab90c45_cgraph.svg" width="395" height="312"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0f9f88761fc18c4f9e0d5f4dd6b4bc95" name="a0f9f88761fc18c4f9e0d5f4dd6b4bc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">&#9670;&nbsp;</a></span>sock_data_to_reassembly_q_unless_overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_data_to_reassembly_q_unless_overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register the given DATA packet as an out-of-order packet in the reassembly queue <code>sock-&gt;m_rcv_packets_with_gaps</code> &ndash; in retransmission-on mode; but detects and reports overflow if appropriate, instead. </p>
<p >Certain relevant stats are logged in all cases. <code>packet.m_data</code> is emptied due to moving it elsewhere &ndash; for performance (recommend saving its <code>.size()</code> before-hand, if needed for later) &ndash; and the implications on rcv_wnd recovery (if any) are handled. <code>true</code> is returned assuming no overflow. The retransmission-off counterpart is, roughly speaking, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43" title="Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...">sock_track_new_data_after_gap_rexmit_off()</a>.</p>
<p >If overflow detected, only statistical observations and logs are made, and <code>false</code> is returned.</p>
<p >This assumes that <a class="el" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df" title="Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...">sock_categorize_data_to_established()</a> returned <code>*slide == false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> on overflow; <code>true</code> on success. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01320">1320</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00051">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_accepted_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00045">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_dropped_reassembly_q_overflow_packet()</a>, <a class="el" href="socket__stats_8cpp_source.html#l00063">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_first_qd_packet()</a>, and <a class="el" href="util_2util_8hpp_source.html#l00299">flow::util::subtract_with_floor()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0f9f88761fc18c4f9e0d5f4dd6b4bc95_cgraph.svg" width="475" height="359"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ade529b5452c9fe363ae468346e662ceb" name="ade529b5452c9fe363ae468346e662ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade529b5452c9fe363ae468346e662ceb">&#9670;&nbsp;</a></span>sock_disconnect_completed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_disconnect_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While in <code>S_OPEN</code>+<code>S_DISCONNECTING</code> state (i.e., after beginning a graceful close with <code>sock_disconnect_detected(..., false)</code>, moves the socket to <code>S_CLOSED</code> state and clears Receive/Send buffers and any other decently memory-consuming structures. </p>
<p >Pre-conditions: state is <code>S_OPEN</code>+<code>S_DISCONNECTING</code>; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">Peer_socket::m_disconnect_cause</a> is set to non-success value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06155">6155</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="peer__socket_8cpp_source.html#l06168">sock_free_memory()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06112">sock_set_state()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade529b5452c9fe363ae468346e662ceb_cgraph.svg" width="376" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ade529b5452c9fe363ae468346e662ceb_icgraph.svg" width="1703" height="699"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ada9357f6ce9d5fc249b1cc176afdc471" name="ada9357f6ce9d5fc249b1cc176afdc471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9357f6ce9d5fc249b1cc176afdc471">&#9670;&nbsp;</a></span>sock_disconnect_detected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_disconnect_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>disconnect_cause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>close</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records that thread W shows underlying connection is broken (graceful termination, or error) and sets <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">Peer_socket::m_disconnect_cause</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">Peer_socket::m_open_sub_state</a> accordingly. </p>
<p >Optionally also empties the Send and Receive buffers and any other decently memory-consuming structures. Thread-safe.</p>
<p >So the mutually exclusive closure scenarios are:</p><ul>
<li><code>sock_disconnect_detected(sock, err_code, false); ...; sock_disconnect_completed(sock);</code> Graceful close initiated; ...buffers emptied...; graceful close completed.</li>
<li><code>sock_disconnect_detected(sock, err_code, true);</code> Abrupt close, or graceful close when the buffers already happen to be empty.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">disconnect_cause</td><td>The cause of the disconnect. </td></tr>
    <tr><td class="paramname">close</td><td>If <code>true</code>, the target public state should be the super-final <code>S_CLOSED</code>, and the Send and Receive buffers are cleared; if <code>false</code>, the target public state should be the ominous <code>S_OPEN</code>+<code>S_DISCONNECTING</code>, and the buffers are left alone. The caller's responsibility is to decide which one it is, but <code>true</code> is typically either for an abrupt close (e.g., RST) or for a graceful close when buffers are empty; while <code>false</code> is typically for a graceful close before buffers are empty, so that the user can get Receive buffer, and the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can send out Send buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06134">6134</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>, <a class="el" href="peer__socket_8cpp_source.html#l06168">sock_free_memory()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06112">sock_set_state()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ada9357f6ce9d5fc249b1cc176afdc471_cgraph.svg" width="368" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ada9357f6ce9d5fc249b1cc176afdc471_icgraph.svg" width="1695" height="699"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1d5f13062bec6730db533cc1e89bf515" name="a1d5f13062bec6730db533cc1e89bf515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5f13062bec6730db533cc1e89bf515">&#9670;&nbsp;</a></span>sock_free_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_free_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that clears all non-O(1)-space data structures stored inside <code>sock</code>. </p>
<p >Intended to be called from <code>sock_disconnect_*()</code>, not anywhere else. Pre-condition: <code>sock-&gt;m_mutex</code> is locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06168">6168</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06155">sock_disconnect_completed()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06134">sock_disconnect_detected()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a1d5f13062bec6730db533cc1e89bf515_icgraph.svg" width="1856" height="682"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a479dfcb7944cb6571af51f1feed2656d" name="a479dfcb7944cb6571af51f1feed2656d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479dfcb7944cb6571af51f1feed2656d">&#9670;&nbsp;</a></span>sock_get_new_snd_order_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> flow::net_flow::Node::sock_get_new_snd_order_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "order number" to use for <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html" title="Data store to keep timing related info when a packet is sent out.">Peer_socket::Sent_packet::Sent_when</a> structure corresponding to the next packet to be sent. </p>
<p >This will be higher than the last sent packet's number. Make sure you send packets in exactly increasing numeric order of this order number.</p>
<p >0 is reserved and never returned by this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06494">6494</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a479dfcb7944cb6571af51f1feed2656d_icgraph.svg" width="998" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a07ad769737db60dd637365010b80f4f3" name="a07ad769737db60dd637365010b80f4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ad769737db60dd637365010b80f4f3">&#9670;&nbsp;</a></span>sock_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> flow::net_flow::Node::sock_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <code>sock-&gt;info()</code> for socket <code>sock</code> in all cases except when <code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code>. </p>
<p >See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">Peer_socket::info()</a> doc header; this method is the entirety of that method's implementation after <code>S_CLOSED</code> is eliminated as a possibility.</p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>sock-&gt;m_mutex</code> is locked and just after entering <code>sock-&gt;info()</code>;</li>
<li>no changes to *sock have been made since <code>m_mutex</code> was locked;</li>
<li><code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">Peer_socket::State::S_OPEN</a></code>.</li>
</ul>
<p >Post-condition (not exhaustive): <code>sock-&gt;m_mutex</code> is unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket in consideration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">Peer_socket::info()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06338">6338</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="async_2util_8hpp_source.html#l00031">flow::async::asio_exec_ctx_post()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00323">flow::net_flow::Peer_socket::info()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a07ad769737db60dd637365010b80f4f3_cgraph.svg" width="548" height="275"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a07ad769737db60dd637365010b80f4f3_icgraph.svg" width="323" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa44feae2c97b4bc1fe1f14f83e932d84" name="aa44feae2c97b4bc1fe1f14f83e932d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44feae2c97b4bc1fe1f14f83e932d84">&#9670;&nbsp;</a></span>sock_is_readable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_is_readable </td>
          <td>(</td>
          <td class="paramtype">const boost::any &amp;&#160;</td>
          <td class="paramname"><em>sock_as_any</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if calling sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a> with at least some arguments would return either non-zero (i.e., successfully dequeued received data) or zero and an error (but not zero and NO error). </p>
<p ><code>sock</code> will be locked and unlocked; safe to call from any thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock_as_any</td><td>Socket to examine, as an <code>any</code> wrapping a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05233">5233</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l06097">rcv_buf_deqable()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa44feae2c97b4bc1fe1f14f83e932d84_cgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0756fc7301d0cfa66f19e681a9c60c06" name="a0756fc7301d0cfa66f19e681a9c60c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0756fc7301d0cfa66f19e681a9c60c06">&#9670;&nbsp;</a></span>sock_is_writable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_is_writable </td>
          <td>(</td>
          <td class="paramtype">const boost::any &amp;&#160;</td>
          <td class="paramname"><em>sock_as_any</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if calling <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> with at least some arguments would return either non-zero (i.e., successfully enqueued data to send) or zero and an error (but not zero and NO error). </p>
<p ><code>sock</code> will be locked and unlocked; safe to call from any thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock_as_any</td><td>Socket to examine, as an <code>any</code> wrapping a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04713">4713</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::S_CONNECTED</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">flow::net_flow::Peer_socket::S_DISCONNECTING</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06080">snd_buf_enqable()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0756fc7301d0cfa66f19e681a9c60c06_cgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2336fae98b318ab73e7268e9a242bf09" name="a2336fae98b318ab73e7268e9a242bf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2336fae98b318ab73e7268e9a242bf09">&#9670;&nbsp;</a></span>sock_load_info_struct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_load_info_struct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, copies all stats info (as available via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">Peer_socket::info()</a>) from various structures into the given stats <code>struct</code>. </p>
<p >This can then be logged, given to the user, etc.</p>
<p >This should be run from thread W only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket in consideration. It can be in any state, but see above. </td></tr>
    <tr><td class="paramname">stats</td><td>All members (direct or indirect) of this <code>struct</code> will be filled. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06382">6382</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="info_8hpp_source.html#l00539">flow::net_flow::Peer_socket_info::m_disconnect_cause</a>, <a class="el" href="info_8hpp_source.html#l00533">flow::net_flow::Peer_socket_info::m_int_state_str</a>, <a class="el" href="info_8hpp_source.html#l00536">flow::net_flow::Peer_socket_info::m_is_active_connect</a>, <a class="el" href="info_8hpp_source.html#l00526">flow::net_flow::Peer_socket_info::m_low_lvl_max_buf_size</a>, <a class="el" href="node_8hpp_source.html#l03771">m_low_lvl_max_buf_size</a>, <a class="el" href="info_8hpp_source.html#l00651">flow::net_flow::Peer_socket_info::m_node_opts</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="info_8hpp_source.html#l00508">flow::net_flow::Peer_socket_info::m_rcv</a>, <a class="el" href="info_8hpp_source.html#l00549">flow::net_flow::Peer_socket_info::m_rcv_buf_size</a>, <a class="el" href="info_8hpp_source.html#l00570">flow::net_flow::Peer_socket_info::m_rcv_packets_with_gaps</a>, <a class="el" href="info_8hpp_source.html#l00558">flow::net_flow::Peer_socket_info::m_rcv_reassembly_q_data_size</a>, <a class="el" href="info_8hpp_source.html#l00573">flow::net_flow::Peer_socket_info::m_rcv_syn_rcvd_data_cumulative_size</a>, <a class="el" href="info_8hpp_source.html#l00576">flow::net_flow::Peer_socket_info::m_rcv_syn_rcvd_data_q_size</a>, <a class="el" href="info_8hpp_source.html#l00552">flow::net_flow::Peer_socket_info::m_rcv_wnd</a>, <a class="el" href="info_8hpp_source.html#l00555">flow::net_flow::Peer_socket_info::m_rcv_wnd_last_advertised</a>, <a class="el" href="info_8hpp_source.html#l00511">flow::net_flow::Peer_socket_info::m_snd</a>, <a class="el" href="info_8hpp_source.html#l00590">flow::net_flow::Peer_socket_info::m_snd_buf_size</a>, <a class="el" href="info_8hpp_source.html#l00608">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_in_flight_bytes</a>, <a class="el" href="info_8hpp_source.html#l00611">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_in_flight_count</a>, <a class="el" href="info_8hpp_source.html#l00599">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_wnd_bytes</a>, <a class="el" href="info_8hpp_source.html#l00602">flow::net_flow::Peer_socket_info::m_snd_cong_ctl_wnd_count_approx</a>, <a class="el" href="info_8hpp_source.html#l00620">flow::net_flow::Peer_socket_info::m_snd_drop_timeout</a>, <a class="el" href="info_8hpp_source.html#l00641">flow::net_flow::Peer_socket_info::m_snd_est_bandwidth_mbit_per_sec</a>, <a class="el" href="info_8hpp_source.html#l00635">flow::net_flow::Peer_socket_info::m_snd_pacing_bytes_allowed_this_slice</a>, <a class="el" href="info_8hpp_source.html#l00623">flow::net_flow::Peer_socket_info::m_snd_pacing_packet_q_size</a>, <a class="el" href="info_8hpp_source.html#l00629">flow::net_flow::Peer_socket_info::m_snd_pacing_slice_period</a>, <a class="el" href="info_8hpp_source.html#l00626">flow::net_flow::Peer_socket_info::m_snd_pacing_slice_start</a>, <a class="el" href="info_8hpp_source.html#l00596">flow::net_flow::Peer_socket_info::m_snd_rcv_wnd</a>, <a class="el" href="info_8hpp_source.html#l00617">flow::net_flow::Peer_socket_info::m_snd_round_trip_time_variance</a>, <a class="el" href="info_8hpp_source.html#l00614">flow::net_flow::Peer_socket_info::m_snd_smoothed_round_trip_time</a>, <a class="el" href="info_8hpp_source.html#l00644">flow::net_flow::Peer_socket_info::m_sock_opts</a>, <a class="el" href="node_8hpp_source.html#l04180">opt()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05518">sock_rcv_wnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06338">sock_info()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06435">sock_log_detail()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2336fae98b318ab73e7268e9a242bf09_cgraph.svg" width="366" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2336fae98b318ab73e7268e9a242bf09_icgraph.svg" width="1866" height="690"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a755c329b9e0f2b8edb2e5b900bd2a337" name="a755c329b9e0f2b8edb2e5b900bd2a337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755c329b9e0f2b8edb2e5b900bd2a337">&#9670;&nbsp;</a></span>sock_log_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_log_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs a verbose state report for the given socket. </p>
<p >This is suitable for calling from <a class="el" href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb" title="Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat logging ...">perform_regular_infrequent_tasks()</a> and other infrequently executed spots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket whose state to log. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06435">6435</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="peer__socket_8cpp_source.html#l01904">log_rcv_window()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03635">log_snd_window()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, and <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a755c329b9e0f2b8edb2e5b900bd2a337_cgraph.svg" width="727" height="336"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a755c329b9e0f2b8edb2e5b900bd2a337_icgraph.svg" width="1671" height="690"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a31d9838b735786bfed40fc1c437808d7" name="a31d9838b735786bfed40fc1c437808d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d9838b735786bfed40fc1c437808d7">&#9670;&nbsp;</a></span>sock_max_packets_after_unrecvd_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::sock_max_packets_after_unrecvd_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the max size for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> for <code>sock</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>An open socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01556">1556</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a62e1f8e6da36d7cd3ad905924aea376c" name="a62e1f8e6da36d7cd3ad905924aea376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e1f8e6da36d7cd3ad905924aea376c">&#9670;&nbsp;</a></span>sock_pacing_new_packet_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_pacing_new_packet_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a>&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Handles a DATA or ACK packet that was just passed into <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>, i.e., is available for sending. </p>
<p >That is, either sends the packet via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff" title="async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...">async_sock_low_lvl_packet_send()</a> immediately or queues it for sending later.</p>
<p >Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed (is not undefined); packet is DATA or ACK; packet is fully filled out; <code>sock</code> is in OPEN state; invariants described for <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> hold.</p>
<p >Note that an error may occur in asynchronous operations triggered by this method; if this happens the socket will be closed via <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. However if the error happens IN this method (<code>false</code> is returned), it is up to the caller to handle the error as desired.</p>
<p >Takes ownership of packet; do not reference it in any way after this method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">packet</td><td>Packet to send. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00649">649</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00307">async_sock_low_lvl_packet_send()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00212">flow::net_flow::Send_pacing_data::m_bytes_allowed_this_slice</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00221">flow::net_flow::Send_pacing_data::m_packet_q</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00199">flow::net_flow::Send_pacing_data::m_slice_period</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00192">flow::net_flow::Send_pacing_data::m_slice_start</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00765">sock_pacing_new_time_slice()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00849">sock_pacing_process_q()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00605">async_sock_low_lvl_packet_send_paced()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a62e1f8e6da36d7cd3ad905924aea376c_cgraph.svg" width="1318" height="344"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a62e1f8e6da36d7cd3ad905924aea376c_icgraph.svg" width="1858" height="643"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afb88dafa8ec5c1b412de86dfdccd9c8f" name="afb88dafa8ec5c1b412de86dfdccd9c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb88dafa8ec5c1b412de86dfdccd9c8f">&#9670;&nbsp;</a></span>sock_pacing_new_time_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_pacing_new_time_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Resets the socket's <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> structure to reflect that a new pacing time slice should begin right now. </p>
<p >The slice start is set to now, its period is set based on the current SRTT and congestion window (so that packets are evenly spread out over the next SRTT); and the number of full packets allowed over this time slice are computed.</p>
<p >Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed (is not undefined); <code>sock</code> is in OPEN state; invariants described for <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> hold.</p>
<dl class="section see"><dt>See also</dt><dd><code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> doc header. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. Should be in OPEN state. </td></tr>
    <tr><td class="paramname">now</td><td>For performance (so that we don't need to acquire the current time again), this is the very recent time point at which it was determined it is time for a new pacing time slice. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00765">765</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00212">flow::net_flow::Send_pacing_data::m_bytes_allowed_this_slice</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00199">flow::net_flow::Send_pacing_data::m_slice_period</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00192">flow::net_flow::Send_pacing_data::m_slice_start</a>, <a class="el" href="options_8hpp_source.html#l00534">flow::net_flow::Node_options::m_st_timer_min_period</a>, and <a class="el" href="node_8hpp_source.html#l04180">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00649">sock_pacing_new_packet_ready()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00969">sock_pacing_time_slice_end()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_afb88dafa8ec5c1b412de86dfdccd9c8f_cgraph.svg" width="403" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_afb88dafa8ec5c1b412de86dfdccd9c8f_icgraph.svg" width="1315" height="508"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaf0acf9de5f151727a43acce180a5e49" name="aaf0acf9de5f151727a43acce180a5e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0acf9de5f151727a43acce180a5e49">&#9670;&nbsp;</a></span>sock_pacing_process_q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_pacing_process_q </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>executing_after_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: Given that we are currently in the pacing time slice in <code>sock-&gt;m_snd_pacing_data</code>, sends as many queued packets as possible given the time slice's budget, and if any remain queued after this, schedules for them to be sent in the next time slice. </p>
<p >Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed (is not undefined); <code>sock</code> is in OPEN state; invariants described for <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> hold; the current time is roughly within the current pacing time slice.</p>
<p >Note that an error may occur in asynchronous operations triggered by this method; if this happens to socket will be closed via <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. However if the error happens IN this method (<code>false</code> is returned), it is up to the caller to handle the error as desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. </td></tr>
    <tr><td class="paramname">executing_after_delay</td><td><code>true</code> if executing from a pacing-related timer handler; <code>false</code> otherwise (i.e., if <a class="el" href="classflow_1_1net__flow_1_1Node.html#a62e1f8e6da36d7cd3ad905924aea376c" title="async_sock_low_lvl_packet_send_paced() pacing helper: Handles a DATA or ACK packet that was just pass...">sock_pacing_new_packet_ready()</a> is in the call stack). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00849">849</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00307">async_sock_low_lvl_packet_send()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00212">flow::net_flow::Send_pacing_data::m_bytes_allowed_this_slice</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00221">flow::net_flow::Send_pacing_data::m_packet_q</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00199">flow::net_flow::Send_pacing_data::m_slice_period</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00192">flow::net_flow::Send_pacing_data::m_slice_start</a>, <a class="el" href="low__lvl__io_8hpp_source.html#l00232">flow::net_flow::Send_pacing_data::m_slice_timer</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae020e63f3ada47025681c8d7f2a00f28">flow::net_flow::error::S_INTERNAL_ERROR_SYSTEM_ERROR_ASIO_TIMER</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00969">sock_pacing_time_slice_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00649">sock_pacing_new_packet_ready()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00969">sock_pacing_time_slice_end()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aaf0acf9de5f151727a43acce180a5e49_cgraph.svg" width="1919" height="840"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aaf0acf9de5f151727a43acce180a5e49_icgraph.svg" width="1288" height="538"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3fd57a0d025a78cbeccfd8a15a983575" name="a3fd57a0d025a78cbeccfd8a15a983575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd57a0d025a78cbeccfd8a15a983575">&#9670;&nbsp;</a></span>sock_pacing_time_slice_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_pacing_time_slice_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>sys_err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0" title="Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...">async_sock_low_lvl_packet_send_paced()</a> pacing helper: If <a class="el" href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49" title="async_sock_low_lvl_packet_send_paced() pacing helper: Given that we are currently in the pacing time ...">sock_pacing_process_q()</a> ran out of the last time slice's budget and still had packets to send, this is the handler that triggers when the out-of-budget time slice ends. </p>
<p >Sets up a new time slice starting now and tries to send as many queud packets as possible with the new budget; if still more packets remain after this, schedules yet another timer.</p>
<p >This may also be called via <code>cancel()</code> of the timer. In this case, the pre-condition is that <code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code>; the method will do nothing.</p>
<p >Otherwise, pre-conditions: <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html#aed68c9912e8c2ada5a9fcef0f9df2331" title="Queue of low-level packets to be sent to the remote endpoint, in order in which they are to be sent,...">Send_pacing_data::m_packet_q</a> for <code>sock</code> is NOT empty; the byte budget for the current time slice is less than the packet at the head <code>m_packet_q</code>; <code>sock</code> is in OPEN state; invariants described for <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a> hold; the current time is roughly just past the current pacing time slice.</p>
<p >Note that an error may occur in asynchronous operations triggered by this method; if this happens to socket will be closed via <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177" title="A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...">close_connection_immediately()</a>. However if the error happens IN this method (<code>false</code> is returned), it is up to the caller to handle the error as desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">sys_err_code</td><td>boost.asio error code. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l00969">969</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00765">sock_pacing_new_time_slice()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00849">sock_pacing_process_q()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06068">socket_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00849">sock_pacing_process_q()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3fd57a0d025a78cbeccfd8a15a983575_cgraph.svg" width="1579" height="1295"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a3fd57a0d025a78cbeccfd8a15a983575_icgraph.svg" width="1040" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a40595ee69bfb87fd64005bc8443329dc" name="a40595ee69bfb87fd64005bc8443329dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40595ee69bfb87fd64005bc8443329dc">&#9670;&nbsp;</a></span>sock_rcv_buf_now_readable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_rcv_buf_now_readable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>syn_rcvd_qd_packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that assumes the given's socket Receive buffer is currently readable and handles implications on the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">syn_rcvd_qd_packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01210">1210</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">flow::net_flow::Event_set::S_PEER_SOCKET_READABLE</a>.</p>

</div>
</div>
<a id="ac397d3fd163f1456b7bb370a3cff951c" name="ac397d3fd163f1456b7bb370a3cff951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac397d3fd163f1456b7bb370a3cff951c">&#9670;&nbsp;</a></span>sock_rcv_wnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::sock_rcv_wnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the currently correct rcv_wnd value; that is the amount of space free in Receive buffer for the given socket. </p>
<p >This may only be called from thread W.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>A socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l05518">5518</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05857">async_low_lvl_ack_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05839">async_low_lvl_syn_ack_ack_send_or_close_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05263">receive_wnd_updated()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ac397d3fd163f1456b7bb370a3cff951c_icgraph.svg" width="2078" height="763"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa1d9656e9e1480021c87530ec6dbebbe" name="aa1d9656e9e1480021c87530ec6dbebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d9656e9e1480021c87530ec6dbebbe">&#9670;&nbsp;</a></span>sock_set_int_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_set_int_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a>&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets internal state of given socket to the given state and logs a TRACE message about it. </p>
<p >Should only be run from thread W; performs no locking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">new_state</td><td>New state. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06103">6103</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa1d9656e9e1480021c87530ec6dbebbe_icgraph.svg" width="1655" height="762"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aadea4a9941c6138d9c025401b1f85ceb" name="aadea4a9941c6138d9c025401b1f85ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadea4a9941c6138d9c025401b1f85ceb">&#9670;&nbsp;</a></span>sock_set_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_set_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread W implementation of sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. </p>
<p >Performs all the needed work to complete <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a></code> call.</p>
<p >Pre-condition: <code>sock-&gt;state()</code> is not <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06191">6191</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06239">sock_validate_options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00297">flow::net_flow::Peer_socket::set_options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aadea4a9941c6138d9c025401b1f85ceb_cgraph.svg" width="520" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aadea4a9941c6138d9c025401b1f85ceb_icgraph.svg" width="328" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad502e0a992a79b71af42a9cdc20a4280" name="ad502e0a992a79b71af42a9cdc20a4280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad502e0a992a79b71af42a9cdc20a4280">&#9670;&nbsp;</a></span>sock_set_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Peer_socket::Open_sub_state</a>&#160;</td>
          <td class="paramname"><em>open_sub_state</em> = <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">Peer_socket::m_open_sub_state</a>. </p>
<p >If moving to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a>, resets the required data to their "undefined" values (e.g., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd" title="See local_port(). Should be set before user gets access to *this and not changed afterwards.">Peer_socket::m_local_port</a> = <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>). Thread-safe.</p>
<dl class="section warning"><dt>Warning</dt><dd>Only set <code>state</code> = <code>S_CLOSED</code> if no more data are in Receive buffer, so that the user can get those data before <code>S_CLOSED</code> state. See Peer_socket::State::S_DISCONNECTING.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket under consideration. </td></tr>
    <tr><td class="paramname">state</td><td>New <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">Peer_socket::m_state</a>. </td></tr>
    <tr><td class="paramname">open_sub_state</td><td>Ignored if <code>state != S_OPEN</code>; otherwise the new value for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">Peer_socket::m_open_sub_state</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06112">6112</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">flow::net_flow::Peer_socket::S_OPEN</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06155">sock_disconnect_completed()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06134">sock_disconnect_detected()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ad502e0a992a79b71af42a9cdc20a4280_icgraph.svg" width="1856" height="803"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a74adc7d61419f4beb7941d418a31a648" name="a74adc7d61419f4beb7941d418a31a648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74adc7d61419f4beb7941d418a31a648">&#9670;&nbsp;</a></span>sock_slide_rcv_next_seq_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_slide_rcv_next_seq_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slide_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reassembly_in_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register a set of received DATA packet data as in-order payload in the structures <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> in <code>sock</code>. </p>
<p >Both structures are updated given the precondition that a set of data had arrived with data starting at <code>sock-&gt;m_rcv_next_seq_num</code>. If <code>reassembly_in_progress</code> (which should be <code>true</code> if and only if retransmission is on), then the reassembly queue is popped into <code>sock-&gt;m_rcv_buf</code> to the appropriate extent (as the just-arrived packet may have bridged the entire gap to the first packet in that queue).</p>
<p >Certain relevant stats are logged in all cases. Note that it's possible to simulate DATA packets' receipt without actually having received such a packet. This method will slide the window as directed regardless.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">slide_size</td><td>By how much to increment (slide right) <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a>. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">reassembly_in_progress</td><td>Basically, <code>sock-&gt;rexmit_on()</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01471">1471</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="socket__stats_8cpp_source.html#l00148">flow::net_flow::Peer_socket_receive_stats_accumulator::buffer_fed()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="socket__stats_8cpp_source.html#l00057">flow::net_flow::Peer_socket_receive_stats_accumulator::good_data_delivered_packet()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02353">flow::net_flow::Peer_socket::Received_packet::m_data</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02345">flow::net_flow::Peer_socket::Received_packet::m_size</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a74adc7d61419f4beb7941d418a31a648_cgraph.svg" width="355" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0ea53f6b451895e8efcdc68ba8770a43" name="a0ea53f6b451895e8efcdc68ba8770a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea53f6b451895e8efcdc68ba8770a43">&#9670;&nbsp;</a></span>sock_track_new_data_after_gap_rexmit_off()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sock_track_new_data_after_gap_rexmit_off </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; const <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>slide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>slide_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a> that aims to register the given DATA packet as an out-of-order packet in <code>sock-&gt;m_rcv_packets_with_gaps</code> &ndash; in retransmission-off mode. </p>
<p >The retransmission-on counterpart is, roughly speaking, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95" title="Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...">sock_data_to_reassembly_q_unless_overflow()</a>.</p>
<p >This assumes that <a class="el" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df" title="Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...">sock_categorize_data_to_established()</a> returned <code>*slide == false</code>. However, due to overflow considerations this helper itself set its own <code>*slide</code> (and <code>*slide_size</code>) value. The <code>*slide</code> argument should be interpereted the same way as from <a class="el" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df" title="Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...">sock_categorize_data_to_established()</a>; <code>*slide_size</code> (meaningful if and only if <code>*slide = true</code> is set) specifies by how much <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> must now increment. (Note, then, that in the caller this can only set <code>*slide</code> from <code>false</code> to <code>true</code>; or not touch it.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">handle_data_to_established()</a>. Note it is read-only, however. </td></tr>
    <tr><td class="paramname">data_size</td><td>Original <code>packet-&gt;m_data.size()</code> value; by now presumbly that value is 0, but we want the original. </td></tr>
    <tr><td class="paramname">slide</td><td>Same semantics as in <a class="el" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df" title="Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...">sock_categorize_data_to_established()</a> (except it is always set; no "illegal" case). </td></tr>
    <tr><td class="paramname">slide_size</td><td>By how much to increment <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">Peer_socket::m_rcv_next_seq_num</a> due certain overflow considerations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l01244">1244</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="socket__stats_8cpp_source.html#l00081">flow::net_flow::Peer_socket_receive_stats_accumulator::presumed_dropped_data()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a0ea53f6b451895e8efcdc68ba8770a43_cgraph.svg" width="363" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a446ee7115c70cbcd48e3897d32fc0276" name="a446ee7115c70cbcd48e3897d32fc0276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ee7115c70cbcd48e3897d32fc0276">&#9670;&nbsp;</a></span>sock_validate_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::sock_validate_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>prev_opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e" title="Given a new set of Node_options intended to replace (or initialize) a Node&#39;s m_opts,...">validate_options()</a> but checks per-socket options instead of per-Node options. </p>
<p ><code>*prev_opts</code> is replaced with <code>opts</code>. Leave <code>prev_opts</code> as null unless an existing <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>'s options are being changed via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. Otherwise a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a71b56a75a4b6dba57daeef79b0b880f7" title="The set of per-Peer_socket options in this per-Node set of options.">Node_options::m_dyn_sock_opts</a> <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> is being changed, and that is always allowed (since if a per-socket option were not dynamic in that way, it would simply be a per-Node option instead).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>New option values to validate. </td></tr>
    <tr><td class="paramname">prev_opts</td><td>null if called from constructor; <code>&amp;sock-&gt;m_opts</code> if called from sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. Used to ensure no static per-socket option is being changed. </td></tr>
    <tr><td class="paramname">err_code</td><td>After return, <code>*err_code</code> is success or: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58" title="When setting options, tried to set an unchangeable (static) option.">error::Code::S_STATIC_OPTION_CHANGED</a>. If <code>!err_code</code>, error::Runtime_error() with that <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> is thrown instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on validation error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06239">6239</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00246">flow::util::in_closed_range()</a>, <a class="el" href="util_2util_8hpp_source.html#l00254">flow::util::in_open_closed_range()</a>, <a class="el" href="options_8hpp_source.html#l00325">flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_backoff_factor</a>, <a class="el" href="options_8hpp_source.html#l00317">flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_ceiling</a>, <a class="el" href="options_8hpp_source.html#l00333">flow::net_flow::Peer_socket_options::m_dyn_rcv_wnd_recovery_timer_period</a>, <a class="el" href="options_8hpp_source.html#l00314">flow::net_flow::Peer_socket_options::m_st_cong_ctl_classic_wnd_decay_percent</a>, <a class="el" href="options_8hpp_source.html#l00306">flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_avoidance_increment_blocks</a>, <a class="el" href="options_8hpp_source.html#l00299">flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</a>, <a class="el" href="options_8hpp_source.html#l00277">flow::net_flow::Peer_socket_options::m_st_cong_ctl_init_cong_wnd_blocks</a>, <a class="el" href="options_8hpp_source.html#l00296">flow::net_flow::Peer_socket_options::m_st_cong_ctl_max_cong_wnd_blocks</a>, <a class="el" href="options_8hpp_source.html#l00121">flow::net_flow::Peer_socket_options::m_st_connect_retransmit_period</a>, <a class="el" href="options_8hpp_source.html#l00124">flow::net_flow::Peer_socket_options::m_st_connect_retransmit_timeout</a>, <a class="el" href="options_8hpp_source.html#l00191">flow::net_flow::Peer_socket_options::m_st_delayed_ack_timer_period</a>, <a class="el" href="options_8hpp_source.html#l00226">flow::net_flow::Peer_socket_options::m_st_init_drop_timeout</a>, <a class="el" href="options_8hpp_source.html#l00114">flow::net_flow::Peer_socket_options::m_st_max_block_size</a>, <a class="el" href="options_8hpp_source.html#l00198">flow::net_flow::Peer_socket_options::m_st_max_full_blocks_before_ack_send</a>, <a class="el" href="options_8hpp_source.html#l00220">flow::net_flow::Peer_socket_options::m_st_max_rexmissions_per_packet</a>, <a class="el" href="options_8hpp_source.html#l00141">flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size</a>, <a class="el" href="options_8hpp_source.html#l00171">flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size_to_advertise_percent</a>, <a class="el" href="options_8hpp_source.html#l00183">flow::net_flow::Peer_socket_options::m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</a>, <a class="el" href="options_8hpp_source.html#l00267">flow::net_flow::Peer_socket_options::m_st_snd_bandwidth_est_sample_period_floor</a>, and <a class="el" href="options_8hpp_source.html#l00134">flow::net_flow::Peer_socket_options::m_st_snd_buf_max_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06191">sock_set_options()</a>, and <a class="el" href="node_8cpp_source.html#l00980">validate_options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a446ee7115c70cbcd48e3897d32fc0276_cgraph.svg" width="338" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a446ee7115c70cbcd48e3897d32fc0276_icgraph.svg" width="527" height="239"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a99836ffb51eaefa4d2cc21770461cd97" name="a99836ffb51eaefa4d2cc21770461cd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99836ffb51eaefa4d2cc21770461cd97">&#9670;&nbsp;</a></span>socket_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a> flow::net_flow::Node::socket_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the socket pair (connection ID) for the given socket. </p>
<p >For performance, try not to use this, as this is usually already available in most points in <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> code and can be passed around to places where it's not. However there are situations when one must reconstruct it from a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> alone.</p>
<p >Call from thread W only.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd>Could make it a <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html" title="The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to a port in th...">Socket_id</a> constructor instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Source socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06068">6068</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l01019">async_sock_low_lvl_packet_send_or_close_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05615">close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04005">connect_worker()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04402">handle_connection_rexmit_timer_event()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05551">receive_emptied_rcv_buf_while_disconnecting()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05803">rst_and_close_connection_immediately()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04498">setup_drop_timer()</a>, and <a class="el" href="low__lvl__io_8cpp_source.html#l00969">sock_pacing_time_slice_end()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a99836ffb51eaefa4d2cc21770461cd97_icgraph.svg" width="1880" height="962"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aba2e6fc905dbeef3ea9e31bf844f8da5" name="aba2e6fc905dbeef3ea9e31bf844f8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2e6fc905dbeef3ea9e31bf844f8da5">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but instead of returning a connecting socket immediately, waits until the initial handshake either succeeds or fails, and then returns the socket or null, respectively. Additionally, you can specify a timeout; if the connection is not successful by this time, the connection attempt is aborted and null is returned.</p>
<p >Note that there is always a built-in Flow protocol connect timeout that is mandatory and will report an error if it expires; but it may be too long for your purposes, so you can specify your own that may expire before it. The two timeouts should be thought of as fundamentally independent (built-in one is in the lower level of Flow protocol; the one you provide is at the application layer), so don't make assumptions about Flow's behavior and set a timeout if you know you need one &ndash; even if in practice it is longer than the Flow one (which as of this writing can be controlled via socket option).</p>
<p >The following are the possible outcomes:</p><ol type="1">
<li>Connection succeeds before the given timeout expires (or succeeds, if no timeout given). Socket is at least Writable at time of return. The new socket is returned, no error is returned via <code>*err_code</code>.</li>
<li>Connection fails before the given timeout expires (or fails, if no timeout given). null is returned, <code>*err_code</code> is set to reason for connection failure. (Note that a built-in handshake timeout &ndash; NOT the given user timeout, if any &ndash; falls under this category.) <code>*err_code == <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a></code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>A user timeout is given, and the connection does not succeed before it expires. null is returned, and <code>*err_code</code> is set to <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. (Rationale: consistent with <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a> behavior.)</li>
</ol>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait &ndash; however, not really, as there is a built-in connection timeout that will expire. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99" title="Cannot ask to connect to &quot;any&quot; IP address. Use specific IP address.">error::Code::S_CANNOT_CONNECT_TO_IP_ANY</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090" title="Other side did not complete connection handshake within the allowed time; perhaps no one is listening...">error::Code::S_CONN_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aa220d89e1d0e34bab02ed2fc7512be9b" title="Other side refused connection.">error::Code::S_CONN_REFUSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4" title="Other side reset an established connection.">error::Code::S_CONN_RESET_BY_OTHER_SIDE</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5d57c6a6029d7c6a9e5442ac72ac7a6b" title="Node shutting down.">error::Code::S_NODE_SHUTTING_DOWN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03967">3967</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l01403">S_DEFAULT_CONN_METADATA</a>, and <a class="el" href="node_8hpp_source.html#l03956">sync_connect_with_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aba2e6fc905dbeef3ea9e31bf844f8da5_cgraph.svg" width="786" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac094b83973fd9af8b45d8f4cb3c14e35" name="ac094b83973fd9af8b45d8f4cb3c14e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac094b83973fd9af8b45d8f4cb3c14e35">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_connect(to, duration::max(), err_code, opt)s</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> with no user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04191">4191</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a49e2786f5d1eeb068a828902a631a39a" name="a49e2786f5d1eeb068a828902a631a39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e2786f5d1eeb068a828902a631a39a">&#9670;&nbsp;</a></span>sync_connect_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation core of <code>sync_connect*()</code> that gets rid of templated or missing arguments thereof. </p>
<p >E.g., the API would wrap this and supply a Fine_duration instead of generic <code>duration</code>; and supply <code>Fine_duration::max()</code> if user omitted the timeout argument. Code bloat and possible circular definition issues are among the reasons for this "de-templating" pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>See the public <code>sync_connect(timeout)</code>. <code>"duration&lt;Rep, Period&gt;::max()"</code> maps to the value <code>Fine_duration::max()</code> for this argument. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04206">4206</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::S_PEER_SOCKET_WRITABLE</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5">flow::net_flow::error::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c">flow::net_flow::error::S_WAIT_USER_TIMEOUT</a>, <a class="el" href="util_2util_8hpp_source.html#l00282">flow::util::setup_auto_cleanup()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04206">sync_connect_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04206">sync_connect_impl()</a>, and <a class="el" href="node_8hpp_source.html#l03956">sync_connect_with_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a49e2786f5d1eeb068a828902a631a39a_cgraph.svg" width="332" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a49e2786f5d1eeb068a828902a631a39a_icgraph.svg" width="567" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6db1043586a0e6413b1118d6c090bf89" name="a6db1043586a0e6413b1118d6c090bf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db1043586a0e6413b1118d6c090bf89">&#9670;&nbsp;</a></span>sync_connect_with_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2" title="A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...">sync_connect_with_metadata()</a> with no user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l04199">4199</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a6725d69ea1a6457d88abb63cef6e6bb2" name="a6725d69ea1a6457d88abb63cef6e6bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6725d69ea1a6457d88abb63cef6e6bb2">&#9670;&nbsp;</a></span>sync_connect_with_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (blocking connect, with supplied metadata). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03956">3956</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00031">flow::util::chrono_duration_to_fine_duration()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04206">sync_connect_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8hpp_source.html#l03967">sync_connect()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6725d69ea1a6457d88abb63cef6e6bb2_cgraph.svg" width="603" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a6725d69ea1a6457d88abb63cef6e6bb2_icgraph.svg" width="384" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2a4dc3d8e294bbc8423e111f52e414ae" name="a2a4dc3d8e294bbc8423e111f52e414ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4dc3d8e294bbc8423e111f52e414ae">&#9670;&nbsp;</a></span>sync_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket , typename Non_blocking_func_ret_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Non_blocking_func_ret_type flow::net_flow::Node::sync_op </td>
          <td>(</td>
          <td class="paramtype">typename Socket::Ptr&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; Non_blocking_func_ret_type()&gt; &amp;&#160;</td>
          <td class="paramname"><em>non_blocking_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Non_blocking_func_ret_type&#160;</td>
          <td class="paramname"><em>would_block_ret_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of core <em>blocking</em> transfer methods, namely <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a> for all cases except when <code>sock-&gt;state() == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a></code>. </p>
<p >It is heavily templated and shared among those three implementations to avoid massive copy/pasting, since the basic pattern of the blocking wrapper around <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a> and a non-blocking operation (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>, respectively) is the same in all cases.</p>
<p >Pre-conditions:</p><ul>
<li>current thread is not W;</li>
<li><code>sock-&gt;m_mutex</code> is locked;</li>
<li>no changes to <code>*sock</code> have been made since <code>sock-&gt;m_mutex</code> was locked;</li>
<li><code>sock-&gt;state()</code> is OPEN (so <code>sock</code> is in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a" title="The peer-to-peer connections this Node is currently tracking.">m_socks</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df" title="The server sockets this Node is currently tracking.">m_servs</a>, depending on socket type at compile time);</li>
<li>other arguments are as described below.</li>
</ul>
<p >This method completes the functionality of <code>sock-&gt;sync_send()</code>, <code>sock-&gt;sync_receive()</code>, and <code>sock-&gt;sync_accept()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Socket</td><td>Underlying object of the transfer operation (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>). </td></tr>
    <tr><td class="paramname">Non_blocking_func_ret_type</td><td>The return type of the calling transfer operation (<code>size_t</code> or <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket on which user called <code>sync_*()</code>. </td></tr>
    <tr><td class="paramname">non_blocking_func</td><td>When this method believes it should attempt a non-blocking transfer op, it will execute <code>non_blocking_func()</code>. If <code>non_blocking_func.empty()</code>, do not call <code>non_blocking_func()</code> &ndash; return indicating no error so far, and let them do actual operation, if they want; we just tell them it should be ready for them. This is known as <code>null_buffers</code> mode or reactor pattern mode. Otherwise, do the successful operation and then return. This is arguably more typical. </td></tr>
    <tr><td class="paramname">would_block_ret_val</td><td>The value that <code>non_blocking_func()</code> returns to indicate it was unable to perform the non-blocking operation (i.e., no data/sockets available). </td></tr>
    <tr><td class="paramname">ev_type</td><td>Event type applicable to the type of operation this is. See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a> doc header. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <code>max_wait</code> argument on the originating <code>sync_*()</code> method. This is absolute timeout time point derived from it; zero-valued if no timeout. </td></tr>
    <tr><td class="paramname">err_code</td><td>See this argument on the originating <code>sync_*()</code> method. However, unlike that calling method's user-facing API, the present <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae" title="Implementation of core blocking transfer methods, namely Peer_socket::sync_send(),...">sync_op()</a> method does NOT allow null <code>err_code</code> (behavior undefined if <code>err_code</code> is null). Corollary: we will NOT throw Runtime_error(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value that the calling <code>sync_*()</code> method should return to its caller. Corner/special case: If <code>non_blocking_func.empty()</code> (a/k/a "reactor pattern" mode), then this will always return <code>would_block_ret_val</code>; the caller shall interpret <code>bool(*err_code) == false</code> as meaning the socket has reached the desired state in time and without error. In that special case, as of this writing, you can't just return this return value, since it's always a zero/null/whatever. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03977">3977</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00881">event_set_create()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::S_NODE_NOT_RUNNING</a>, and <a class="el" href="util_2util_8hpp_source.html#l00282">flow::util::setup_auto_cleanup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00234">flow::net_flow::Peer_socket::node_sync_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00149">flow::net_flow::Peer_socket::node_sync_send()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00100">flow::net_flow::Server_socket::sync_accept_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2a4dc3d8e294bbc8423e111f52e414ae_cgraph.svg" width="707" height="248"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a2a4dc3d8e294bbc8423e111f52e414ae_icgraph.svg" width="778" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a287eae1113865dba06c103cf023404ae" name="a287eae1113865dba06c103cf023404ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287eae1113865dba06c103cf023404ae">&#9670;&nbsp;</a></span>sync_sock_low_lvl_rst_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::sync_sock_low_lvl_rst_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends an RST to the other side of the given socket, synchronously. </p>
<p >An error is unlikely, but if it happens there is no reporting other than logging. Will block (though probably not for long, this being UDP) if <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> is in blocking mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket the remote side of which will get the RST. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="low__lvl__io_8cpp_source.html#l01045">1045</a> of file <a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="options_8hpp_source.html#l00553">flow::net_flow::Node_options::m_dyn_low_lvl_max_packet_size</a>, <a class="el" href="node_8hpp_source.html#l03753">m_low_lvl_sock</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, and <a class="el" href="node_8hpp_source.html#l04180">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a287eae1113865dba06c103cf023404ae_cgraph.svg" width="396" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a287eae1113865dba06c103cf023404ae_icgraph.svg" width="371" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa894fd58b246c2a8d6c7c7d25a8748cb" name="aa894fd58b246c2a8d6c7c7d25a8748cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa894fd58b246c2a8d6c7c7d25a8748cb">&#9670;&nbsp;</a></span>this_thread_init_logger_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> * flow::net_flow::Node::this_thread_init_logger_setup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to invoke for each thread in which this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> executes, whether or not it starts that thread, that applies certain common settings to all subsequent logging from that thread. </p>
<p >E.g., it might nickname the thread (w/r/t logging) and set a certain style of printing duration units (short like "ms" or long like "milliseconds"): these probably won't change for the rest of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_type</td><td>Roughly 3-letter character sequence identifying the thread's purpose, to be included in the thread's logged nickname in subsequent log message prefixes; or empty string to let the thread's nickname stay as-is. </td></tr>
    <tr><td class="paramname">logger</td><td>The Logger whose logging to configure(); or null to assume <code>this-&gt;<a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d" title="Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.">get_logger()</a></code> (which is typical but may not yet be available, say, during object construction). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the Logger that was configured (either <code>logger</code> or <code>this-&gt;<a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d" title="Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.">get_logger()</a></code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00113">113</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8cpp_source.html#l00278">flow::log::beautify_chrono_logger_this_thread()</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, and <a class="el" href="util_2util_8hpp_source.html#l00342">flow::util::ostream_op_to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa894fd58b246c2a8d6c7c7d25a8748cb_cgraph.svg" width="990" height="339"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_aa894fd58b246c2a8d6c7c7d25a8748cb_icgraph.svg" width="383" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9511f3ba50d19f2c32a8de94f0a306e8" name="a9511f3ba50d19f2c32a8de94f0a306e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9511f3ba50d19f2c32a8de94f0a306e8">&#9670;&nbsp;</a></span>validate_option_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::validate_option_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>check_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that, if the given condition is false, logs and returns an error; used to check for option value validity when setting options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check</td><td><code>false</code> if and only if some validity check failed. </td></tr>
    <tr><td class="paramname">check_str</td><td>String describing which condition was checked; this is presumably obtained using the macro # technique. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on validation error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01093">1093</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450">flow::net_flow::error::S_OPTION_CHECK_FAILED</a>.</p>

</div>
</div>
<a id="ab2595f47710ddb06cfb22b6710b7286e" name="ab2595f47710ddb06cfb22b6710b7286e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2595f47710ddb06cfb22b6710b7286e">&#9670;&nbsp;</a></span>validate_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp; flow::net_flow::Node::validate_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a new set of <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> intended to replace (or initialize) a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>, ensures that these new option values are legal. </p>
<p >In all cases, values are checked for individual and mutual validity. Additionally, unless init is true, which means we're being called from constructor, ensures that no <code>static</code> data member is different between <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a> and opts. If any validation fails, it is an error.</p>
<p >Pre-condition: If <code>!init</code>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4" title="The mutex protecting m_opts.">m_opts_mutex</a> is locked.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000116">Todo:</a></b></dt><dd>Is it necessary to return <code>opts</code> now that we've switched to C++11 or better?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>New option values to validate. </td></tr>
    <tr><td class="paramname">init</td><td>True if called from constructor; false if called from <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58" title="When setting options, tried to set an unchangeable (static) option.">error::Code::S_STATIC_OPTION_CHANGED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>opts</code>. The only reason we return this is so that it can be called during the construction's initializer section (go, C++03!). </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00980">980</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="util__fwd_8hpp_source.html#l00971">FLOW_UTIL_WHERE_AM_I_STR</a>, <a class="el" href="options_8hpp_source.html#l00553">flow::net_flow::Node_options::m_dyn_low_lvl_max_packet_size</a>, <a class="el" href="options_8hpp_source.html#l00580">flow::net_flow::Node_options::m_dyn_sock_opts</a>, <a class="el" href="options_8hpp_source.html#l00525">flow::net_flow::Node_options::m_st_low_lvl_max_buf_size</a>, <a class="el" href="options_8hpp_source.html#l00534">flow::net_flow::Node_options::m_st_timer_min_period</a>, <a class="el" href="peer__socket_8cpp_source.html#l06239">sock_validate_options()</a>, and <a class="el" href="node_8cpp_source.html#l00980">validate_options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>, and <a class="el" href="node_8cpp_source.html#l00980">validate_options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab2595f47710ddb06cfb22b6710b7286e_cgraph.svg" width="520" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_ab2595f47710ddb06cfb22b6710b7286e_icgraph.svg" width="328" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8aa99dc4800a49b7b958b585717eb50b" name="a8aa99dc4800a49b7b958b585717eb50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa99dc4800a49b7b958b585717eb50b">&#9670;&nbsp;</a></span>validate_static_option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Opt_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Node::validate_static_option </td>
          <td>(</td>
          <td class="paramtype">const Opt_type &amp;&#160;</td>
          <td class="paramname"><em>new_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Opt_type &amp;&#160;</td>
          <td class="paramname"><em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that compares <code>new_val</code> to <code>old_val</code> and, if they are not equal, logs and returns an error; used to ensure static options are not changed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Opt_type</td><td>Type of a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>, etc., data member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_val</td><td>Proposed new value for the option. </td></tr>
    <tr><td class="paramname">old_val</td><td>Current value of the option. </td></tr>
    <tr><td class="paramname">opt_id</td><td>The name of the option, suitable for logging; this is presumably obtained using the macro <code>#</code> technique. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on validation error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l04161">4161</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="options_8cpp_source.html#l00160">flow::net_flow::Node_options::opt_id_to_str()</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58">flow::net_flow::error::S_STATIC_OPTION_CHANGED</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a8aa99dc4800a49b7b958b585717eb50b_cgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5b056ed753b832458f44f537acfe86d7" name="a5b056ed753b832458f44f537acfe86d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b056ed753b832458f44f537acfe86d7">&#9670;&nbsp;</a></span>worker_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::worker_run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&#160;</td>
          <td class="paramname"><em>low_lvl_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread W (main event loop) body. </p>
<p >Does not exit unless told to do so by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s destruction (presumably from a non-W thread, as W is not exposed to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> user).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_lvl_endpoint</td><td>See that parameter on <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> constructor. Intentionally passed by value, to avoid race with user's Udp_endpoint object disappearing before <a class="el" href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7" title="Worker thread W (main event loop) body.">worker_run()</a> can use it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l00151">151</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="low__lvl__io_8cpp_source.html#l00031">async_low_lvl_recv()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>, <a class="el" href="event__set_8cpp_source.html#l01332">event_set_close_worker()</a>, <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8hpp_source.html#l00152">FLOW_LOG_WARNING</a>, <a class="el" href="log_8cpp_source.html#l00224">flow::log::Log_context::get_logger()</a>, <a class="el" href="event__set_8cpp_source.html#l01456">interrupt_all_waits_internal_sig_handler()</a>, <a class="el" href="node_8hpp_source.html#l03880">m_event_loop_ready</a>, <a class="el" href="node_8hpp_source.html#l03804">m_event_sets</a>, <a class="el" href="node_8hpp_source.html#l03764">m_low_lvl_endpoint</a>, <a class="el" href="node_8hpp_source.html#l03771">m_low_lvl_max_buf_size</a>, <a class="el" href="node_8hpp_source.html#l03753">m_low_lvl_sock</a>, <a class="el" href="node_8hpp_source.html#l03704">m_opts</a>, <a class="el" href="node_8hpp_source.html#l03798">m_servs</a>, <a class="el" href="node_8hpp_source.html#l03890">m_signal_set</a>, <a class="el" href="node_8hpp_source.html#l03792">m_socks</a>, <a class="el" href="options_8hpp_source.html#l00517">flow::net_flow::Node_options::m_st_capture_interrupt_signals_internally</a>, <a class="el" href="options_8hpp_source.html#l00525">flow::net_flow::Node_options::m_st_low_lvl_max_buf_size</a>, <a class="el" href="node_8hpp_source.html#l03739">m_task_engine</a>, <a class="el" href="node_8hpp_source.html#l04180">opt()</a>, <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5d57c6a6029d7c6a9e5442ac72ac7a6b">flow::net_flow::error::S_NODE_SHUTTING_DOWN</a>, <a class="el" href="node_8hpp_source.html#l03693">S_REGULAR_INFREQUENT_TASKS_PERIOD</a>, <a class="el" href="sched__task_8hpp_source.html#l00034">flow::util::schedule_task_from_now()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01045">sync_sock_low_lvl_rst_send()</a>, and <a class="el" href="node_8cpp_source.html#l00113">this_thread_init_logger_setup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node_a5b056ed753b832458f44f537acfe86d7_cgraph.svg" width="1934" height="1014"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aec2bd684093a1769e08a56c9a088801a" name="aec2bd684093a1769e08a56c9a088801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2bd684093a1769e08a56c9a088801a">&#9670;&nbsp;</a></span>Event_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html">Event_set</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> must be able to forward <code>close()</code>, <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f" title="Implementation of Event_set::async_wait() when Event_set::state() == Event_set::State::S_INACTIVE.">event_set_async_wait()</a></code>, etc. </p>
<p >to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01422">1422</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a7e9629b88c4cd0b337a51c2363893908" name="a7e9629b88c4cd0b337a51c2363893908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9629b88c4cd0b337a51c2363893908">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>socket_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Free function that returns socket_id.hash(); has to be a free function named <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7e9629b88c4cd0b337a51c2363893908">hash_value()</a></code> for boost.hash to pick it up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Socket ID to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket_id.hash(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01162">1162</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

</div>
</div>
<a id="a99561404e8389fef08fa4ac5c16a7f36" name="a99561404e8389fef08fa4ac5c16a7f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99561404e8389fef08fa4ac5c16a7f36">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether <code>lhs</code> is equal to <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8cpp_source.html#l01157">1157</a> of file <a class="el" href="node_8cpp_source.html">node.cpp</a>.</p>

</div>
</div>
<a id="a62cd43d29137c6c9abc7d9dd731555f9" name="a62cd43d29137c6c9abc7d9dd731555f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd43d29137c6c9abc7d9dd731555f9">&#9670;&nbsp;</a></span>Peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> must be able to forward <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code>, <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code>, etc. </p>
<p >to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01412">1412</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a2165381af6166d76afba06862c762367" name="a2165381af6166d76afba06862c762367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2165381af6166d76afba06862c762367">&#9670;&nbsp;</a></span>Server_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> must be able to forward <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code>, etc. </p>
<p >to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01417">1417</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa440f6ff5442c58323bec7a2304b0d90" name="aa440f6ff5442c58323bec7a2304b0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa440f6ff5442c58323bec7a2304b0d90">&#9670;&nbsp;</a></span>m_event_loop_ready</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::promise&lt;<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&gt; flow::net_flow::Node::m_event_loop_ready</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promise that thread W sets to truthy <code>Error_code</code> if it fails to initialize or falsy once event loop is running. </p>
<p >The truthy payload can be returned or thrown inside an error::Runtime_exception if desired. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03880">3880</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a61f87144f19e908ffb981f3bff91938e" name="a61f87144f19e908ffb981f3bff91938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f87144f19e908ffb981f3bff91938e">&#9670;&nbsp;</a></span>m_event_loop_ready_result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::unique_future&lt;<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&gt; flow::net_flow::Node::m_event_loop_ready_result</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The future object through which the non-W thread waits for <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90" title="Promise that thread W sets to truthy Error_code if it fails to initialize or falsy once event loop is...">m_event_loop_ready</a> to be set to success/failure. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03883">3883</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00040">Node()</a>.</p>

</div>
</div>
<a id="ae43345472c4f41933a9c16d114cc937b" name="ae43345472c4f41933a9c16d114cc937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43345472c4f41933a9c16d114cc937b">&#9670;&nbsp;</a></span>m_event_sets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">Event_sets</a> flow::net_flow::Node::m_event_sets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Every <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> to have been returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f" title="Creates a new Event_set in Event_set::State::S_INACTIVE state with no sockets/events stored; returns ...">event_set_create()</a> and not subsequently reached <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">Event_set::State::S_CLOSED</a>. </p>
<p >Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03804">3804</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a3b5004700cb085c6a2806f39426b0ea0" name="a3b5004700cb085c6a2806f39426b0ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5004700cb085c6a2806f39426b0ea0">&#9670;&nbsp;</a></span>m_last_loss_sock_log_when</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> flow::net_flow::Node::m_last_loss_sock_log_when</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For debugging, when we detect loss of data we'd sent, we log the corresponding socket's state; this is the last time this was done for any socket (or epoch if never). </p>
<p >It's used to throttle such messages, since they are CPU-intensive and disk-intensive (when logging to disk). </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03874">3874</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="aee89be07daf7d024921381a4bafe1289" name="aee89be07daf7d024921381a4bafe1289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee89be07daf7d024921381a4bafe1289">&#9670;&nbsp;</a></span>m_low_lvl_endpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> flow::net_flow::Node::m_low_lvl_endpoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After we bind <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> to a UDP endpoint, this is a copy of that endpoint. </p>
<p >Thus it should contain the actual local address and port (even if user specified 0 for the latter, say).</p>
<p >This is equal to <code><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">Udp_endpoint()</a></code> until the constructor exits. After the constructor exits, its value never changes, therefore all threads can access it without mutex. If the constructor fails to bind, this remains equal to <code><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">Udp_endpoint()</a></code> forever. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03764">3764</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00369">local_low_lvl_endpoint()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a266ec5d00a44bc48caf37444eb2b43a1" name="a266ec5d00a44bc48caf37444eb2b43a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266ec5d00a44bc48caf37444eb2b43a1">&#9670;&nbsp;</a></span>m_low_lvl_max_buf_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::m_low_lvl_max_buf_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OS-reported <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89" title="The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...">m_low_lvl_sock</a> UDP receive buffer maximum size, obtained right after we OS-set that setting and never changed subsequently. </p>
<p >Note the OS may not respect whatever value we passed into the OS socket option setting call, or it may respect it but only approximately. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03771">3771</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a9b9e0224c17190e99debdfd81640bf89" name="a9b9e0224c17190e99debdfd81640bf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9e0224c17190e99debdfd81640bf89">&#9670;&nbsp;</a></span>m_low_lvl_sock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">Udp_socket</a> flow::net_flow::Node::m_low_lvl_sock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The UDP socket used to receive low-level packets (to assemble into application layer data) and send them (vice versa). </p>
<p >Only thread W can access this.</p>
<p >Access to this may be highly contentious in high-traffic situations. Since only thread W accesses this, and that thread does the vast bulk of the work of the entire <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, at least one known problem is that the internal OS UDP receive buffer may be exceeded, as we may not read datagrams off this socket quickly enough.</p>
<dl class="section see"><dt>See also</dt><dd>Class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> doc header for to-do items regarding the aforementioned UDP <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive</a> buffer overflow problem. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03753">3753</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00031">async_low_lvl_recv()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01045">sync_sock_low_lvl_rst_send()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a43472c3277cdf5e3f28d4f4f51e3bcc0" name="a43472c3277cdf5e3f28d4f4f51e3bcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43472c3277cdf5e3f28d4f4f51e3bcc0">&#9670;&nbsp;</a></span>m_net_env_sim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a>&gt; flow::net_flow::Node::m_net_env_sim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The object used to simulate stuff like packet loss and latency via local means directly in the code. </p>
<p >If 0, no such simulation is performed. <code>shared_ptr&lt;&gt;</code> used for basic auto-<code>delete</code> convenience. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03713">3713</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00187">handle_incoming_with_simulation()</a>.</p>

</div>
</div>
<a id="ade08f0457943f803c23b55649139c0d3" name="ade08f0457943f803c23b55649139c0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade08f0457943f803c23b55649139c0d3">&#9670;&nbsp;</a></span>m_opts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> flow::net_flow::Node::m_opts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s global set of options. </p>
<p >Initialized at construction; can be subsequently modified by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>, although only the dynamic members of this may be modified.</p>
<p >Accessed from thread W and user thread U != W. Protected by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4" title="The mutex protecting m_opts.">m_opts_mutex</a>. When reading, do NOT access without locking (which is encapsulated in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595" title="Obtain a copy of the value of a given option in a thread-safe manner.">opt()</a>). </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03704">3704</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00321">async_low_lvl_packet_send_impl()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>, <a class="el" href="node_8cpp_source.html#l01112">max_block_size()</a>, <a class="el" href="node_8cpp_source.html#l01107">options()</a>, <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06382">sock_load_info_struct()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00765">sock_pacing_new_time_slice()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l01045">sync_sock_low_lvl_rst_send()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a449ef757abee4c5d12f8fc62a5ca66b4" name="a449ef757abee4c5d12f8fc62a5ca66b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449ef757abee4c5d12f8fc62a5ca66b4">&#9670;&nbsp;</a></span>m_opts_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">Options_mutex</a> flow::net_flow::Node::m_opts_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex protecting <a class="el" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3" title="This Node&#39;s global set of options.">m_opts</a>. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03707">3707</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="node_8hpp_source.html#l04180">opt()</a>, and <a class="el" href="node_8cpp_source.html#l01054">set_options()</a>.</p>

</div>
</div>
<a id="acea4db94c4fb86ddaa2502c2d7e128ea" name="acea4db94c4fb86ddaa2502c2d7e128ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4db94c4fb86ddaa2502c2d7e128ea">&#9670;&nbsp;</a></span>m_packet_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> flow::net_flow::Node::m_packet_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores incoming raw packet data; re-used repeatedly for possible performance gains. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03774">3774</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="low__lvl__io_8cpp_source.html#l00046">low_lvl_recv_and_handle()</a>.</p>

</div>
</div>
<a id="afd6388a362531ada956a864fefff6011" name="afd6388a362531ada956a864fefff6011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6388a362531ada956a864fefff6011">&#9670;&nbsp;</a></span>m_ports</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Port__space.html">Port_space</a> flow::net_flow::Node::m_ports</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flow port space for both client and server sockets. All threads may access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03777">3777</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>, and <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>.</p>

</div>
</div>
<a id="ae536f016607677a945ad42034a21e82a" name="ae536f016607677a945ad42034a21e82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae536f016607677a945ad42034a21e82a">&#9670;&nbsp;</a></span>m_rnd_security_tokens</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Rnd__gen__uniform__range.html">util::Rnd_gen_uniform_range</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">Peer_socket::security_token_t</a>&gt; flow::net_flow::Node::m_rnd_security_tokens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random number generator for picking security tokens; seeded on time at <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> construction and generates integers from the entire range. </p>
<p >(Not thread-safe. Use only in thread W.) </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03786">3786</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>

</div>
</div>
<a id="a8938c4a091edf1c1c77e2cc8f505f0ff" name="a8938c4a091edf1c1c77e2cc8f505f0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8938c4a091edf1c1c77e2cc8f505f0ff">&#9670;&nbsp;</a></span>m_seq_num_generator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number_1_1Generator.html">Sequence_number::Generator</a> flow::net_flow::Node::m_seq_num_generator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequence number generator (at least to generate ISNs). Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03780">3780</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>.</p>

</div>
</div>
<a id="aae28990628a86a07327f49973f2390df" name="aae28990628a86a07327f49973f2390df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae28990628a86a07327f49973f2390df">&#9670;&nbsp;</a></span>m_servs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">Port_to_server_map</a> flow::net_flow::Node::m_servs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The server sockets this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently tracking. </p>
<p >Their states are not <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">Server_socket::State::S_CLOSED</a>. Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03798">3798</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="server__socket_8cpp_source.html#l00218">listen_worker()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="abecf0f8111af82fa081c71fda490608a" name="abecf0f8111af82fa081c71fda490608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecf0f8111af82fa081c71fda490608a">&#9670;&nbsp;</a></span>m_signal_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">Signal_set</a> flow::net_flow::Node::m_signal_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal set which we may or may not be using to trap SIGINT and SIGTERM in order to auto-fire <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">interrupt_all_waits()</a>. </p>
<p ><code>add()</code> is called on it at initialization if and only if that feature is enabled by the user via <code><a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a></code>. Otherwise this object just does nothing for the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s lifetime. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03890">3890</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="ab0026feecdb74eda904d00d2c7016bab" name="ab0026feecdb74eda904d00d2c7016bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0026feecdb74eda904d00d2c7016bab">&#9670;&nbsp;</a></span>m_sock_events</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Event_set::Ev_type_to_socks_map</a> flow::net_flow::Node::m_sock_events</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All sockets that have been detected to be "ready" (by the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header definition) at any point since the last time <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a>'s contained sets were cleared (which happens initially and after each <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a> call). </p>
<p >EVERY piece of code in thread W to potentially set a socket's status to "ready" (e.g.: DATA received, error detected) MUST add that socket's handle to this data structure. This enables the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> machinery to efficiently but thoroughly detect every event in which the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> user is interested. The theory behind this is described in the giant comment inside <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>.</p>
<p >This maps <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a> <code>enum</code> members to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Event_set::Sockets</a> socket sets, exactly the same way <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">Event_set::m_want</a> are set up.</p>
<p >A question arises: why use this set to store such active sockets? Why not just call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625" title="For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...">event_set_all_check_delta()</a> EVERY time we see a socket is now Readable, etc., thus handling it right away and not needing to store it? Answer: we could. However, we want to collect as many possibly active events as possible, without blocking, before performing the check. That way the user is informed of as many events as possible, instead of the very first one (when there could be hundreds more; for example if hundreds of DATA packets have arrived simultaneously). The theory behind this is also discussed in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> giant comment. So we insert into <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">m_sock_events</a> and defer <code>event_set_all_check_delta(false)</code> to the end of the current boost.asio handler, since we know we won't block (sleep) until the handler exits.</p>
<p >Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03830">3830</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00364">close_empty_server_immediately()</a>, <a class="el" href="server__socket_8cpp_source.html#l00583">handle_syn_ack_ack_to_syn_rcvd()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04792">send_worker()</a>.</p>

</div>
</div>
<a id="a90244d69d550370158bbe843ab595a7a" name="a90244d69d550370158bbe843ab595a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90244d69d550370158bbe843ab595a7a">&#9670;&nbsp;</a></span>m_socks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">Socket_id_to_socket_map</a> flow::net_flow::Node::m_socks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The peer-to-peer connections this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently tracking. </p>
<p >Their states are not <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">Peer_socket::State::S_CLOSED</a>. Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03792">3792</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05683">close_connection_immediately()</a>, <a class="el" href="node_8cpp_source.html#l00426">handle_incoming()</a>, <a class="el" href="server__socket_8cpp_source.html#l00433">handle_syn_to_listening_server()</a>, <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<a id="a7d9f418a3c99197e58f71ce2fff2997f" name="a7d9f418a3c99197e58f71ce2fff2997f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9f418a3c99197e58f71ce2fff2997f">&#9670;&nbsp;</a></span>m_socks_with_accumulated_acks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::unordered_set&lt;<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&gt; flow::net_flow::Node::m_socks_with_accumulated_acks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Within a given <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a> call, by the time <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> is called, this stores exactly those sockets for which possible incoming-ACK handling tasks have been accumulated during the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>/etc. </p>
<p >call. The idea is that, for congestion control robustness, all simultaneously available acknowledgments and rcv_wnd updates are collected first, and then they're all handled together at the end.</p>
<p >Details on the acks to potentially send are stored within that <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> itself (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8229396adfd306d15e8a05dac3fe8c29" title="While Node::low_lvl_recv_and_handle() or async part of Node::async_wait_latency_then_handle_incoming(...">Peer_socket::m_rcv_acked_packets</a> scan all).</p>
<p >This should be added to throughout the method, used in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a>, and then cleared for the next run.</p>
<p >Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03867">3867</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>.</p>

</div>
</div>
<a id="a7bea132db0e45ea01b9a6bd22fd0fadb" name="a7bea132db0e45ea01b9a6bd22fd0fadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bea132db0e45ea01b9a6bd22fd0fadb">&#9670;&nbsp;</a></span>m_socks_with_accumulated_pending_acks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::unordered_set&lt;<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&gt; flow::net_flow::Node::m_socks_with_accumulated_pending_acks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Within a given <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">async_wait_latency_then_handle_incoming()</a> (async part) call, by the time <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a> is called, this stores exactly those sockets for which possible ACK sending tasks have been accumulated during the <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">low_lvl_recv_and_handle()</a>/etc. </p>
<p >call. The idea is that, for efficiency and reduced overhead, all simultaneously available incoming data are examined first, and some tasks are accumulated to perform at the end. For example, all DATA packets to be acknowledged at the same time are collected and then sent in as few ACKs as possible.</p>
<p >Details on the acks to potentially send are stored within that <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> itself (e.g., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">Peer_socket::m_rcv_pending_acks</a>).</p>
<p >This should be added to throughout the method, used in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc" title="Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...">perform_accumulated_on_recv_tasks()</a>, and then cleared for the next run.</p>
<p >Only thread W can access this. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03849">3849</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00375">perform_accumulated_on_recv_tasks()</a>.</p>

</div>
</div>
<a id="af5597a417d03e2bed87cd772ef5cef29" name="af5597a417d03e2bed87cd772ef5cef29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5597a417d03e2bed87cd772ef5cef29">&#9670;&nbsp;</a></span>m_task_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> flow::net_flow::Node::m_task_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main loop engine, functioning in the single-threaded-but-asynchronous callback-based "reactor" style (or is it "proactor"?). </p>
<p >The <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> constructor creates a single new thread W, which then places some callbacks onto this guy and invoke <code>m_task_engine.run()</code>, at which point the main loop begins in thread W.</p>
<p >Thus, per boost.asio's model, any work items (functions) placed onto <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a> (e.g.: <code>post(m_task_engine, do_something_fn);</code>) will execute in thread W, as it's the one invoking <code>run()</code> at the time &ndash; even if the placing itself is done on some other thread, such as a user thread U. An example of the latter is a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> implementation might write to the socket's internal Send buffer in thread U, check whether it's currently possible to send over the wire, and if and only if the answer is yes, <code>post(m_task_engine, S)</code>, where S is a function/functor (created via lambdas usually) that will perform the hairy needed Node/socket work on thread W.</p>
<p >All threads may access this (no mutex required, as explicitly announced in boost.asio docs).</p>
<p >Adding more threads that would call <code>m_task_engine.run()</code> would create a thread pool. With "strands" one can avoid concurrency in this situation. An intelligent combination of those two concepts can lead to efficient multi-core use without complex and/or inefficient locking. This is non-trivial.</p>
<dl class="section see"><dt>See also</dt><dd>Class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> doc header for to-do items regarding efficient multi-core use and how that relates to using an <a class="el" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29" title="The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...">m_task_engine</a> thread pool and/or strands. </dd></dl>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03739">3739</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05397">async_rcv_wnd_recovery()</a>, <a class="el" href="low__lvl__io_8cpp_source.html#l00255">async_wait_latency_then_handle_incoming()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05615">close_abruptly()</a>, <a class="el" href="server__socket_8cpp_source.html#l00144">listen()</a>, <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05083">receive()</a>, <a class="el" href="node_8cpp_source.html#l00420">running()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04520">send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l04498">setup_drop_timer()</a>, <a class="el" href="node_8hpp_source.html#l04193">sock_create_forward_plus_ctor_args()</a>, <a class="el" href="peer__socket_8cpp_source.html#l06338">sock_info()</a>, <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>, and <a class="el" href="node_8cpp_source.html#l00139">~Node()</a>.</p>

</div>
</div>
<a id="a84b7e03ae7b13dae0f59db1475e46fd3" name="a84b7e03ae7b13dae0f59db1475e46fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b7e03ae7b13dae0f59db1475e46fd3">&#9670;&nbsp;</a></span>m_worker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">util::Thread</a> flow::net_flow::Node::m_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread (= thread W). Other members should be initialized before this to avoid race condition. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03893">3893</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l00040">Node()</a>, and <a class="el" href="node_8cpp_source.html#l00139">~Node()</a>.</p>

</div>
</div>
<a id="ab13749ccdf4ab44445f21c77296ffa13" name="ab13749ccdf4ab44445f21c77296ffa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13749ccdf4ab44445f21c77296ffa13">&#9670;&nbsp;</a></span>S_DEFAULT_CONN_METADATA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> flow::net_flow::Node::S_DEFAULT_CONN_METADATA = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type and value to supply as user-supplied metadata in SYN, if user chooses to use <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a></code> instead of <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a></code>. </p>
<p >If you change this value, please update <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> doc header. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l01403">1403</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8hpp_source.html#l00916">flow::net_flow::asio::Node::async_connect()</a>, and <a class="el" href="node_8hpp_source.html#l03967">sync_connect()</a>.</p>

</div>
</div>
<a id="aa1d1021e099c70c1a6e192e65f86debf" name="aa1d1021e099c70c1a6e192e65f86debf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d1021e099c70c1a6e192e65f86debf">&#9670;&nbsp;</a></span>S_FIRST_EPHEMERAL_PORT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp; flow::net_flow::Node::S_FIRST_EPHEMERAL_PORT = Port_space::S_FIRST_EPHEMERAL_PORT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">S_NUM_EPHEMERAL_PORTS</a> - 1]. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00963">963</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a96b593d90c246cb2e35fc6a0834e6876" name="a96b593d90c246cb2e35fc6a0834e6876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b593d90c246cb2e35fc6a0834e6876">&#9670;&nbsp;</a></span>S_FIRST_SERVICE_PORT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp; flow::net_flow::Node::S_FIRST_SERVICE_PORT = Port_space::S_FIRST_SERVICE_PORT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port number of the lowest service port, making the range of service ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">S_NUM_SERVICE_PORTS</a> - 1]. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00957">957</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="ac9f6edfb36abcd0402c4bd75b595f271" name="ac9f6edfb36abcd0402c4bd75b595f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f6edfb36abcd0402c4bd75b595f271">&#9670;&nbsp;</a></span>S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">Peer_socket::Sent_packet::ack_count_t</a> flow::net_flow::Node::S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given unacknowledged sent packet P, the maximum number of times any individual packet with higher sequence numbers than P may be acknowledged before P is considered Dropped (i.e., we give up on it). </p>
<p >If we enable retransmission, that would trigger Fast Retransmit, using TCP's terminology. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03686">3686</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a7aadcad6c19587cd0d788570194b2afd" name="a7aadcad6c19587cd0d788570194b2afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aadcad6c19587cd0d788570194b2afd">&#9670;&nbsp;</a></span>S_NUM_EPHEMERAL_PORTS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; flow::net_flow::Node::S_NUM_EPHEMERAL_PORTS = Port_space::S_NUM_EPHEMERAL_PORTS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of Flow "ephemeral" ports (ones reserved locally at random with <code>Node::listen(S_PORT_ANY)</code> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>). </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00951">951</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a1ecd7c03349fcb26b9692d300a759463" name="a1ecd7c03349fcb26b9692d300a759463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecd7c03349fcb26b9692d300a759463">&#9670;&nbsp;</a></span>S_NUM_PORTS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; flow::net_flow::Node::S_NUM_PORTS = Port_space::S_NUM_PORTS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of Flow ports in the port space, including <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00942">942</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="aa1b913c5c759a465a9fcaa637ddaea99" name="aa1b913c5c759a465a9fcaa637ddaea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b913c5c759a465a9fcaa637ddaea99">&#9670;&nbsp;</a></span>S_NUM_SERVICE_PORTS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; flow::net_flow::Node::S_NUM_SERVICE_PORTS = Port_space::S_NUM_SERVICE_PORTS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of Flow "service" ports (ones that can be reserved by number with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>). </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l00945">945</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a2f97b363281b79ef4f399789442c84de" name="a2f97b363281b79ef4f399789442c84de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f97b363281b79ef4f399789442c84de">&#9670;&nbsp;</a></span>S_REGULAR_INFREQUENT_TASKS_PERIOD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> flow::net_flow::Node::S_REGULAR_INFREQUENT_TASKS_PERIOD = boost::chrono::seconds(1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time interval between performing "infrequent periodic tasks," such as stat logging. </p>
<p >This should be large enough to ensure that the tasks being performed incur no significant processor use. </p>

<p class="definition">Definition at line <a class="el" href="node_8hpp_source.html#l03693">3693</a> of file <a class="el" href="node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l01117">perform_regular_infrequent_tasks()</a>, and <a class="el" href="node_8cpp_source.html#l00151">worker_run()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="node_8hpp_source.html">node.hpp</a></li>
<li>net_flow/detail/<a class="el" href="low__lvl__io_8cpp_source.html">low_lvl_io.cpp</a></li>
<li>net_flow/<a class="el" href="event__set_8cpp_source.html">event_set.cpp</a></li>
<li>net_flow/<a class="el" href="node_8cpp_source.html">node.cpp</a></li>
<li>net_flow/<a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a></li>
<li>net_flow/<a class="el" href="server__socket_8cpp_source.html">server_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 10 2024 15:49:02 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
