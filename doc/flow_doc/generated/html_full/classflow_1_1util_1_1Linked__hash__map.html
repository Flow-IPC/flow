<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Linked__hash__map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a map that combines the lookup speed of an <code>unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>.  
 <a href="classflow_1_1util_1_1Linked__hash__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map__coll__graph.svg" width="288" height="251"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c528ba7ead507ad4ecf2760937173db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> = Key_t</td></tr>
<tr class="memdesc:a1c528ba7ead507ad4ecf2760937173db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">More...</a><br /></td></tr>
<tr class="separator:a1c528ba7ead507ad4ecf2760937173db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> = Mapped_t</td></tr>
<tr class="memdesc:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">More...</a><br /></td></tr>
<tr class="separator:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232ad8dd1cfa23d0377c8b3db872219a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> = Hash_t</td></tr>
<tr class="memdesc:a232ad8dd1cfa23d0377c8b3db872219a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">More...</a><br /></td></tr>
<tr class="separator:a232ad8dd1cfa23d0377c8b3db872219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea14e7770b9b7e7529753502f818505b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> = Pred_t</td></tr>
<tr class="memdesc:aea14e7770b9b7e7529753502f818505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">More...</a><br /></td></tr>
<tr class="separator:aea14e7770b9b7e7529753502f818505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> = std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> const, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &gt;</td></tr>
<tr class="memdesc:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for key/mapped-value pairs stored in the structure.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">More...</a><br /></td></tr>
<tr class="separator:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7bf4c62aad92c36900c7974354dfcb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> = std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &gt;</td></tr>
<tr class="memdesc:a1a7bf4c62aad92c36900c7974354dfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for key/mapped-value pair best-suited (perf-wise) as arg type for the moving <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a></code> overload.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">More...</a><br /></td></tr>
<tr class="separator:a1a7bf4c62aad92c36900c7974354dfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ce79aa68113033d3d5295bf6e3fdf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a135ce79aa68113033d3d5295bf6e3fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses sizes/lengths of relevant things.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">More...</a><br /></td></tr>
<tr class="separator:a135ce79aa68113033d3d5295bf6e3fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8574ed84883500dbb67270facdb328"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8f8574ed84883500dbb67270facdb328">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8f8574ed84883500dbb67270facdb328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8f8574ed84883500dbb67270facdb328">More...</a><br /></td></tr>
<tr class="separator:a8f8574ed84883500dbb67270facdb328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcf7b6069c82bb96bd31e9351f21704"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a> = typename Value_list::iterator</td></tr>
<tr class="memdesc:a0fcf7b6069c82bb96bd31e9351f21704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">More...</a><br /></td></tr>
<tr class="separator:a0fcf7b6069c82bb96bd31e9351f21704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b082d4967a366aeb30fa644bb4605"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> = typename Value_list::const_iterator</td></tr>
<tr class="memdesc:aa81b082d4967a366aeb30fa644bb4605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">More...</a><br /></td></tr>
<tr class="separator:aa81b082d4967a366aeb30fa644bb4605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6caa6709547211a33b894f0c267218"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a> = typename Value_list::reverse_iterator</td></tr>
<tr class="memdesc:acf6caa6709547211a33b894f0c267218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into a mutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">More...</a><br /></td></tr>
<tr class="separator:acf6caa6709547211a33b894f0c267218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca606e926a239c4e94d428aadf1f74d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a> = typename Value_list::const_reverse_iterator</td></tr>
<tr class="memdesc:a4ca606e926a239c4e94d428aadf1f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">More...</a><br /></td></tr>
<tr class="separator:a4ca606e926a239c4e94d428aadf1f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b472c1256b3661c73018fd07ca446"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abe6b472c1256b3661c73018fd07ca446">key_type</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a></td></tr>
<tr class="memdesc:abe6b472c1256b3661c73018fd07ca446"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#abe6b472c1256b3661c73018fd07ca446">More...</a><br /></td></tr>
<tr class="separator:abe6b472c1256b3661c73018fd07ca446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9995f0c063e81317c64e3f1a9924f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1e9995f0c063e81317c64e3f1a9924f7">mapped_type</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a></td></tr>
<tr class="memdesc:a1e9995f0c063e81317c64e3f1a9924f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1e9995f0c063e81317c64e3f1a9924f7">More...</a><br /></td></tr>
<tr class="separator:a1e9995f0c063e81317c64e3f1a9924f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400decc79397fec52be13e1098e04661"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a400decc79397fec52be13e1098e04661">value_type</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a></td></tr>
<tr class="memdesc:a400decc79397fec52be13e1098e04661"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a400decc79397fec52be13e1098e04661">More...</a><br /></td></tr>
<tr class="separator:a400decc79397fec52be13e1098e04661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816dda3b07a92e4446347b71f420f82f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a816dda3b07a92e4446347b71f420f82f">hasher</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a></td></tr>
<tr class="memdesc:a816dda3b07a92e4446347b71f420f82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classHash.html">Hash</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a816dda3b07a92e4446347b71f420f82f">More...</a><br /></td></tr>
<tr class="separator:a816dda3b07a92e4446347b71f420f82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f8b89d9bc13270c601b89c62b74191"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a39f8b89d9bc13270c601b89c62b74191">key_equal</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a></td></tr>
<tr class="memdesc:a39f8b89d9bc13270c601b89c62b74191"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classPred.html">Pred</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a39f8b89d9bc13270c601b89c62b74191">More...</a><br /></td></tr>
<tr class="separator:a39f8b89d9bc13270c601b89c62b74191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18a7ba77b88c3dfa8547a54747a72bf6">pointer</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> *</td></tr>
<tr class="memdesc:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a18a7ba77b88c3dfa8547a54747a72bf6">More...</a><br /></td></tr>
<tr class="separator:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5425ac3f7f0b5760b92312b60753adb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac5425ac3f7f0b5760b92312b60753adb">const_pointer</a> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> *</td></tr>
<tr class="memdesc:ac5425ac3f7f0b5760b92312b60753adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac5425ac3f7f0b5760b92312b60753adb">More...</a><br /></td></tr>
<tr class="separator:ac5425ac3f7f0b5760b92312b60753adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6d63f26c3fb953b0ab2856a3c76a22d6">reference</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;</td></tr>
<tr class="memdesc:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6d63f26c3fb953b0ab2856a3c76a22d6">More...</a><br /></td></tr>
<tr class="separator:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a762084112e0def72d1e94493bba1f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6a762084112e0def72d1e94493bba1f4">const_reference</a> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;</td></tr>
<tr class="memdesc:a6a762084112e0def72d1e94493bba1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6a762084112e0def72d1e94493bba1f4">More...</a><br /></td></tr>
<tr class="separator:a6a762084112e0def72d1e94493bba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d16a268b95319c8611d57951c3317b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18d16a268b95319c8611d57951c3317b">iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a></td></tr>
<tr class="memdesc:a18d16a268b95319c8611d57951c3317b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a18d16a268b95319c8611d57951c3317b">More...</a><br /></td></tr>
<tr class="separator:a18d16a268b95319c8611d57951c3317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616e1be6dd8a0e20a2a7dce501864039"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a616e1be6dd8a0e20a2a7dce501864039">const_iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a></td></tr>
<tr class="memdesc:a616e1be6dd8a0e20a2a7dce501864039"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a616e1be6dd8a0e20a2a7dce501864039">More...</a><br /></td></tr>
<tr class="separator:a616e1be6dd8a0e20a2a7dce501864039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0033ec6c091d68ac9804cae1675b93f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af0033ec6c091d68ac9804cae1675b93f">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{})</td></tr>
<tr class="memdesc:af0033ec6c091d68ac9804cae1675b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty structure with some basic parameters.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af0033ec6c091d68ac9804cae1675b93f">More...</a><br /></td></tr>
<tr class="separator:af0033ec6c091d68ac9804cae1675b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa5c23bc3d7a79eb3e334b80bf37b5529">Linked_hash_map</a> (std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &gt; values, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{})</td></tr>
<tr class="memdesc:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs structure with some basic parameters, and values initialized from initializer list.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aa5c23bc3d7a79eb3e334b80bf37b5529">More...</a><br /></td></tr>
<tr class="separator:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae42dd8b8ecfd51d6414e4c8c8ac79924">Linked_hash_map</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;src)</td></tr>
<tr class="memdesc:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object that is a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae42dd8b8ecfd51d6414e4c8c8ac79924">More...</a><br /></td></tr>
<tr class="separator:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad440ab087f3335e9ba2664826d99f9e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad440ab087f3335e9ba2664826d99f9e5">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad440ab087f3335e9ba2664826d99f9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad440ab087f3335e9ba2664826d99f9e5">More...</a><br /></td></tr>
<tr class="separator:ad440ab087f3335e9ba2664826d99f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621b7defed9015b5d0eeca0301450ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad621b7defed9015b5d0eeca0301450ba">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;src)</td></tr>
<tr class="memdesc:ad621b7defed9015b5d0eeca0301450ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object with a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad621b7defed9015b5d0eeca0301450ba">More...</a><br /></td></tr>
<tr class="separator:ad621b7defed9015b5d0eeca0301450ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08522b4af94f87b543649e367afd643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad08522b4af94f87b543649e367afd643">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad08522b4af94f87b543649e367afd643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad08522b4af94f87b543649e367afd643">More...</a><br /></td></tr>
<tr class="separator:ad08522b4af94f87b543649e367afd643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8393b9576ef14102a467e317f443471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;other)</td></tr>
<tr class="memdesc:ac8393b9576ef14102a467e317f443471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471">More...</a><br /></td></tr>
<tr class="separator:ac8393b9576ef14102a467e317f443471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">insert</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;key_and_mapped)</td></tr>
<tr class="memdesc:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; if key already in <code>*this</code> makes no change.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">More...</a><br /></td></tr>
<tr class="separator:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6444fd8206c662fe4ebe61a91acb3eb9">insert</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;key_and_mapped)</td></tr>
<tr class="memdesc:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload, except that (if key not already present in <code>*this</code>) the key and mapped-value are moved, not copied, into <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6444fd8206c662fe4ebe61a91acb3eb9">More...</a><br /></td></tr>
<tr class="separator:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e4a04383d686564b3c0cc3383b3880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18e4a04383d686564b3c0cc3383b3880">operator[]</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a18e4a04383d686564b3c0cc3383b3880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either finds the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value at the given key, or if not found inserts one with a default-constructed <code>Mapped{}</code>; then returns reference to the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a18e4a04383d686564b3c0cc3383b3880">More...</a><br /></td></tr>
<tr class="separator:a18e4a04383d686564b3c0cc3383b3880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8766bd2c286c40e1036cf3836558d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae8766bd2c286c40e1036cf3836558d55">operator[]</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&amp;key)</td></tr>
<tr class="memdesc:ae8766bd2c286c40e1036cf3836558d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae8766bd2c286c40e1036cf3836558d55">More...</a><br /></td></tr>
<tr class="separator:ae8766bd2c286c40e1036cf3836558d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a18e44447eb0b848f1ed4c6d947427d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d">find</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a9a18e44447eb0b848f1ed4c6d947427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find value at the given key in the map.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d">More...</a><br /></td></tr>
<tr class="separator:a9a18e44447eb0b848f1ed4c6d947427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b55a895a78341363146459f45f345c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a50b55a895a78341363146459f45f345c">find</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a50b55a895a78341363146459f45f345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload but in a <code>const</code> context: the returned iterator is to immutable memory.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a50b55a895a78341363146459f45f345c">More...</a><br /></td></tr>
<tr class="separator:a50b55a895a78341363146459f45f345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f75f926f679c06727298db80b18ea67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8f75f926f679c06727298db80b18ea67">count</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a8f75f926f679c06727298db80b18ea67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8f75f926f679c06727298db80b18ea67">More...</a><br /></td></tr>
<tr class="separator:a8f75f926f679c06727298db80b18ea67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283501e0657922191813c9a465ea0748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a283501e0657922191813c9a465ea0748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748">More...</a><br /></td></tr>
<tr class="separator:a283501e0657922191813c9a465ea0748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad5252a028dae9a6cee1e7fccabc37d8f">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad5252a028dae9a6cee1e7fccabc37d8f">More...</a><br /></td></tr>
<tr class="separator:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1ef46da85774193ad4153e56460ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a58c1ef46da85774193ad4153e56460ad">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a58c1ef46da85774193ad4153e56460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element pointed to by the given valid iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a58c1ef46da85774193ad4153e56460ad">More...</a><br /></td></tr>
<tr class="separator:a58c1ef46da85774193ad4153e56460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ca10ae279f49663ba17df190f36fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a50ca10ae279f49663ba17df190f36fab">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it_newest, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it_past_oldest)</td></tr>
<tr class="memdesc:a50ca10ae279f49663ba17df190f36fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a50ca10ae279f49663ba17df190f36fab">More...</a><br /></td></tr>
<tr class="separator:a50ca10ae279f49663ba17df190f36fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad3e9ea0a2c3675577b4582b6a7f59312">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element with the given key, if it exists.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad3e9ea0a2c3675577b4582b6a7f59312">More...</a><br /></td></tr>
<tr class="separator:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81c78165446043355a1e3f0cc42c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65">clear</a> ()</td></tr>
<tr class="memdesc:acb81c78165446043355a1e3f0cc42c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510" title="Returns number of elements stored.">size()</a> == 0</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65">More...</a><br /></td></tr>
<tr class="separator:acb81c78165446043355a1e3f0cc42c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b7d184077a8644d764d104feed76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a">begin</a> ()</td></tr>
<tr class="memdesc:a585b7d184077a8644d764d104feed76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a">More...</a><br /></td></tr>
<tr class="separator:a585b7d184077a8644d764d104feed76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b0e5555bd112c464d4ab053fb3d06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c">newest</a> ()</td></tr>
<tr class="memdesc:a43b0e5555bd112c464d4ab053fb3d06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator; or <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c">More...</a><br /></td></tr>
<tr class="separator:a43b0e5555bd112c464d4ab053fb3d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc31f275883d1076755d2b179bc66d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6">end</a> ()</td></tr>
<tr class="memdesc:abbc31f275883d1076755d2b179bc66d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6">More...</a><br /></td></tr>
<tr class="separator:abbc31f275883d1076755d2b179bc66d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9135b5521dd34bea817b2326b04737f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3">past_oldest</a> ()</td></tr>
<tr class="memdesc:a9135b5521dd34bea817b2326b04737f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns special iterator indicating the position just past the iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "oldest," element in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3">More...</a><br /></td></tr>
<tr class="separator:a9135b5521dd34bea817b2326b04737f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed">cbegin</a> () const</td></tr>
<tr class="memdesc:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed">More...</a><br /></td></tr>
<tr class="separator:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2385c71b4970ba71af8479900117ab79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2385c71b4970ba71af8479900117ab79">begin</a> () const</td></tr>
<tr class="memdesc:a2385c71b4970ba71af8479900117ab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2385c71b4970ba71af8479900117ab79">More...</a><br /></td></tr>
<tr class="separator:a2385c71b4970ba71af8479900117ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1640cce76b51f0fa0d8c1e95b682808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808">const_newest</a> () const</td></tr>
<tr class="memdesc:ad1640cce76b51f0fa0d8c1e95b682808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> but operating on immutable <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808">More...</a><br /></td></tr>
<tr class="separator:ad1640cce76b51f0fa0d8c1e95b682808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deb6b537745b164988fed8755722999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999">cend</a> () const</td></tr>
<tr class="memdesc:a4deb6b537745b164988fed8755722999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999">More...</a><br /></td></tr>
<tr class="separator:a4deb6b537745b164988fed8755722999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f223c371de3409879887bbb3a558b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1f223c371de3409879887bbb3a558b65">end</a> () const</td></tr>
<tr class="memdesc:a1f223c371de3409879887bbb3a558b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1f223c371de3409879887bbb3a558b65">More...</a><br /></td></tr>
<tr class="separator:a1f223c371de3409879887bbb3a558b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29dc85660cc2ed821cd887bff0ed953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953">const_past_oldest</a> () const</td></tr>
<tr class="memdesc:ad29dc85660cc2ed821cd887bff0ed953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> but operating on immutable <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953">More...</a><br /></td></tr>
<tr class="separator:ad29dc85660cc2ed821cd887bff0ed953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2bba3816cc1c1d0f43b0d8205f04ec66">rbegin</a> ()</td></tr>
<tr class="memdesc:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2bba3816cc1c1d0f43b0d8205f04ec66">More...</a><br /></td></tr>
<tr class="separator:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155305b98475f232236ec395ec925e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4">oldest</a> ()</td></tr>
<tr class="memdesc:a3155305b98475f232236ec395ec925e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4">More...</a><br /></td></tr>
<tr class="separator:a3155305b98475f232236ec395ec925e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a797e0ff66fe4044f5a551bee4540e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a84a797e0ff66fe4044f5a551bee4540e">rend</a> ()</td></tr>
<tr class="memdesc:a84a797e0ff66fe4044f5a551bee4540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a84a797e0ff66fe4044f5a551bee4540e">More...</a><br /></td></tr>
<tr class="separator:a84a797e0ff66fe4044f5a551bee4540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e24934208292fb4096b7e036d5227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227">past_newest</a> ()</td></tr>
<tr class="memdesc:a0a4e24934208292fb4096b7e036d5227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227">More...</a><br /></td></tr>
<tr class="separator:a0a4e24934208292fb4096b7e036d5227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d426d7711d31be672f504593783887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a85d426d7711d31be672f504593783887">crbegin</a> () const</td></tr>
<tr class="memdesc:a85d426d7711d31be672f504593783887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a85d426d7711d31be672f504593783887">More...</a><br /></td></tr>
<tr class="separator:a85d426d7711d31be672f504593783887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af841fbe9ea76f962a56828098934199d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d">const_oldest</a> () const</td></tr>
<tr class="memdesc:af841fbe9ea76f962a56828098934199d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d">More...</a><br /></td></tr>
<tr class="separator:af841fbe9ea76f962a56828098934199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146bacf7c55bc513217fc0c8a951cfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a146bacf7c55bc513217fc0c8a951cfd8">crend</a> () const</td></tr>
<tr class="memdesc:a146bacf7c55bc513217fc0c8a951cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a146bacf7c55bc513217fc0c8a951cfd8">More...</a><br /></td></tr>
<tr class="separator:a146bacf7c55bc513217fc0c8a951cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47">const_past_newest</a> () const</td></tr>
<tr class="memdesc:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns special reverse iterator indicating the position just past the reverse-iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "newest," element in the reverse-iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47">More...</a><br /></td></tr>
<tr class="separator:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff10ef8e0f54d49462c1a651efca6424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424">empty</a> () const</td></tr>
<tr class="memdesc:aff10ef8e0f54d49462c1a651efca6424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if container is empty.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424">More...</a><br /></td></tr>
<tr class="separator:aff10ef8e0f54d49462c1a651efca6424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ea7121aa85856c9d977777f6c7c510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510">size</a> () const</td></tr>
<tr class="memdesc:a97ea7121aa85856c9d977777f6c7c510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510">More...</a><br /></td></tr>
<tr class="separator:a97ea7121aa85856c9d977777f6c7c510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059c278705edc45e9b2660f17a295837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a059c278705edc45e9b2660f17a295837">max_size</a> () const</td></tr>
<tr class="memdesc:a059c278705edc45e9b2660f17a295837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max number of elements that can be stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a059c278705edc45e9b2660f17a295837">More...</a><br /></td></tr>
<tr class="separator:a059c278705edc45e9b2660f17a295837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a29f69fa281255611a919ae0a042d81ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a29f69fa281255611a919ae0a042d81ef">Value_list</a> = std::list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &gt;</td></tr>
<tr class="memdesc:a29f69fa281255611a919ae0a042d81ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for doubly linked list of (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>) pairs.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a29f69fa281255611a919ae0a042d81ef">More...</a><br /></td></tr>
<tr class="separator:a29f69fa281255611a919ae0a042d81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afd8f1651012750223c078e645de0ead0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afd8f1651012750223c078e645de0ead0">insert_impl</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;key_and_mapped)</td></tr>
<tr class="memdesc:afd8f1651012750223c078e645de0ead0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a> so that <code>key_and_mapped</code>'s copy is inserted into the structure.  <a href="classflow_1_1util_1_1Linked__hash__map.html#afd8f1651012750223c078e645de0ead0">More...</a><br /></td></tr>
<tr class="separator:afd8f1651012750223c078e645de0ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f16297dae7c3f384e833e5ce22fd86e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f16297dae7c3f384e833e5ce22fd86e">insert_impl_mv</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;key_and_mapped)</td></tr>
<tr class="memdesc:a2f16297dae7c3f384e833e5ce22fd86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afd8f1651012750223c078e645de0ead0" title="Helper that modifies m_value_list and m_value_iter_set so that key_and_mapped&#39;s copy is inserted into...">insert_impl()</a>, except <code>key_and_mapped</code> components are <code>move()</code>d into <code>*this</code> instead of being copied.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2f16297dae7c3f384e833e5ce22fd86e">More...</a><br /></td></tr>
<tr class="separator:a2f16297dae7c3f384e833e5ce22fd86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac636005479265a02045cac776f71c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a29f69fa281255611a919ae0a042d81ef">Value_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213">m_value_list</a></td></tr>
<tr class="memdesc:ac636005479265a02045cac776f71c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual values &ndash; which, as in <code>unordered_map&lt;K, M&gt;</code>, are instances of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a> = <code>pair&lt;const Key, Mapped&gt;</code> &ndash; are stored in here, in the order in which user would iterate over them.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213">More...</a><br /></td></tr>
<tr class="separator:ac636005479265a02045cac776f71c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ceba9fd4f7a5b63be0b5e11e02056d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#acb68e7985082dd9cbe7b1c67dd3b54a1">Linked_hash_key_set</a>&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d">m_value_iter_set</a></td></tr>
<tr class="memdesc:a49ceba9fd4f7a5b63be0b5e11e02056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that allows the amortized-constant-time (as in <code>unordered_set</code>) implementation of <code>this-&gt;find(key)</code>, where <code>key</code> is <code>const Key&amp;</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d">More...</a><br /></td></tr>
<tr class="separator:a49ceba9fd4f7a5b63be0b5e11e02056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memTemplParams" colspan="2">template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </td></tr>
<tr class="memitem:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaac7b774853aa9a83e2935634fd5e7a6">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;val1, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;val2)</td></tr>
<tr class="memdesc:aaac7b774853aa9a83e2935634fd5e7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>val1.swap(val2)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aaac7b774853aa9a83e2935634fd5e7a6">More...</a><br /></td></tr>
<tr class="separator:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key_t, typename Mapped_t, typename Hash_t, typename Pred_t&gt;<br />
class flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;</div><p >An object of this class is a map that combines the lookup speed of an <code>unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>. </p>
<p >The API is generally that of an <code>unordered_map&lt;&gt;</code>. The differences essentially all have to do with iterators. This map introduces a concept of "newness," which determines the iteration order. Moreover, <em>every</em> iterator remains valid except (of course) under erasure of the underlying element. Newness is defined as follows inductively: whenever an element is inserted, it is "newest," thus it is placed at the front of the iterator order. Furthermore, the methods <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> can be used to make any element "newest" (moved to the front of the iterator order). Iterator thus formed orders elements from newest to oldest (hence <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a" title="Synonym of newest().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a>).</p>
<p >Performance expectations: The best way to determine a method's time needs is to imagine what it must do. If it must perform a lookup by key, that is an <code>unordered_set&lt;&gt;</code> lookup resulting in an (at least internal) iterator. If it must insert an element, it is always inserted at the start of a <code>list</code>; and also into an <code>unordered_set&lt;&gt;</code>. If it must erase an element based on an iterator, that element is erased from a list based on that iterator; and also by key from said <code>unordered_set&lt;&gt;</code>. Iteration itself is iteration along a <code>list</code>. But essentially, every operation is either near constant time or constant time. In terms of space needs, this essentially stores the values themselves in a <code>list</code>; and also a pointer to each list-held key/element in an <code>unordered_set&lt;&gt;</code>, which also stores a pointer or list iterator per element.</p>
<p >Move semantics for both keys and mapped-values are supported (let <code>T</code> be a concrete type for a <code>*this</code> and <code>x</code> a <code>*this</code>):</p><ul>
<li><code>x.insert(std::make_pair&lt;Key, Mapped&gt;(..., ...))</code>;<ul>
<li>or <code>x.insert(T::Value_movable{..., ...})</code>;</li>
</ul>
</li>
<li><code>x[std::move(...)] = std::move(...)</code>.</li>
</ul>
<p >There is the standard complement of container-wide move operations: move-construction, move-assignment, and <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471" title="Swaps the contents of this structure and other.">swap()</a></code> (all constant-time, excluding any implied <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65" title="Makes it so that size() == 0.">clear()</a></code> in the move-assignment).</p>
<p >The iterators are, really, <code>list&lt;pair&lt;const Key, Mapped&gt;&gt;</code> iterators; and as such are not invalidated except due to direct erasure of a given pointee.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000149">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html" title="An object of this class is a map that combines the lookup speed of an unordered_set&lt;&gt; and ordering an...">Linked_hash_set</a> have a reasonable complement of C++1x-ish APIs including move-semantics; but the API does not quite mirror the full complement of what is in existence for <code>unordered_*</code> counterparts in C++17 STL/Boost &ndash; it would be nice to add these. This includes such things as <code>.emplace()</code> and <code>.try_emplace()</code> but more fundamentally would probably involve trolling <code>std::unordered_*</code> and copying its ~full API (and likely some of a decent impl too). That said what's available already acquits itself reasonably well. (Historically this was first written before C++11 and hasn't been given the full-on C++1x overhaul but instead merely the essentials thereof.)</dd></dl>
<h3>Thread safety</h3>
<p >Same as for <code>unordered_map&lt;&gt;</code>.</p>
<h3>Impl notes</h3>
<p >You should get much of what you need to grok this just by reading the above and possibly looking at the Data section doc-headers under <code>private:</code>. Essentially, to repeat/recap: there's the <code>list&lt;pair&lt;const Key, Mapped&gt;&gt;</code> to store the actual values, in order (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a>); <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> come directly from there.</p>
<p >When lookup by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> is needed, the <code>unordered_set</code> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a> comes into play. This is arguably the only real mechanical trickiness. It actually stores <code>Iterator</code>s into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> but in such a way as to allow seamless lookup from a mere <code>const Key&amp;</code>; so <code>m_value_iter_set.find(key)</code> "magically" either finds <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a></code> &ndash; then the key is not in <code>*this</code> &ndash; or the iterator into the actual key/mapped-value store in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a>. Using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a> is easy; but a bit of internal infrastructure is necessary to have it work. Namely we have support class template <code><a class="el" href="classflow_1_1util_1_1Linked__hash__key.html" title="The internal-use key/iterator-wrapper, used as the key type in internal-use set-type Linked_hash_key_...">Linked_hash_key</a>&lt;Key, Iterator&gt;</code>, and the <code>unordered_set m_value_iter_set</code> actually stores those guys, not raw <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> copies; so it is a wrapper around an <code>Iterator</code> <em>or</em> a <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> (union-style). <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a> stores <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> wrappers, while lookup attempts use the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> wrapper form to pass into <code>m_value_iter_set.find()</code>.</p>
<p >An earlier version of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a> instead used a simple <code>unordered_map&lt;Key, Iterator&gt;</code> instead of the <code>unordered_set&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__key.html" title="The internal-use key/iterator-wrapper, used as the key type in internal-use set-type Linked_hash_key_...">Linked_hash_key</a>&lt;Key, Iterator&gt;&gt;</code>; so a lookup by key was just that. Eventually we replaced it with the more complex solution simply to avoid storing 2 copies of each <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> (one in the list, one in the map); as the <code>Iterator</code> itself includes a pointer to the thing containing the corresponding <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> in the first place. So this saves memory as well as various <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> copying.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key_t</td><td>Key type. We omit formal requirements, as it is tedious and full of corner cases depending on what you plan to invoke (e.g., whether you use move-semantics for keys). Please use common sense knowing the basic data structures involved as explained above. That said: if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> is of non-trivial size, it is good to have it have performant move-constructibility and move-assignability and then make use of it via move-aware APIs as suggested in the doc header above. </td></tr>
    <tr><td class="paramname">Mapped_t</td><td>The 2nd (satellite) part of the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a> pair type. Same commentary as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> applies here. </td></tr>
    <tr><td class="paramname">Hash_t</td><td>Hasher type. Same requirements and behavior as <code>boost::unordered_set&lt;&gt;</code> counterpart. If using the default value for <a class="el" href="classHash.html">Hash</a> (<code>boost::hash&lt;Key&gt;</code>), and the default object is passed to ctor (<code><a class="el" href="classHash.html">Hash</a>{}</code>) (this is typical), but there is no hash-function already defined for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, then the easiest way to define it is: make a <code>size_t hash_value(Key)</code> free function in the same namespace as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>. </td></tr>
    <tr><td class="paramname">Pred_t</td><td>Equality-determiner type. Same requirements and behavior as <code>boost::unordered_set&lt;&gt;</code> counterpart. If using the default value for <a class="el" href="classPred.html">Pred</a> (<code>std::equal_to&lt;Key&gt;</code>), and the default object is passed to ctor (<code><a class="el" href="classPred.html">Pred</a>{}</code>) (this is typical), but there is no equality op defined for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, then the easiest way to define it is: make an operator-method or free function such that <code>k1 == k2</code> (where <code>k1</code> and <code>k2</code> are <code>Key</code>s) determines equality or lack thereof. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00117">117</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa81b082d4967a366aeb30fa644bb4605" name="aa81b082d4967a366aeb30fa644bb4605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81b082d4967a366aeb30fa644bb4605">&#9670;&nbsp;</a></span>Const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Const_iterator =  typename Value_list::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00159">159</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a616e1be6dd8a0e20a2a7dce501864039" name="a616e1be6dd8a0e20a2a7dce501864039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616e1be6dd8a0e20a2a7dce501864039">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00188">188</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ac5425ac3f7f0b5760b92312b60753adb" name="ac5425ac3f7f0b5760b92312b60753adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5425ac3f7f0b5760b92312b60753adb">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_pointer =  const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00180">180</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a6a762084112e0def72d1e94493bba1f4" name="a6a762084112e0def72d1e94493bba1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a762084112e0def72d1e94493bba1f4">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_reference =  const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00184">184</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a4ca606e926a239c4e94d428aadf1f74d" name="a4ca606e926a239c4e94d428aadf1f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca606e926a239c4e94d428aadf1f74d">&#9670;&nbsp;</a></span>Const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Const_reverse_iterator =  typename Value_list::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00165">165</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a8f8574ed84883500dbb67270facdb328" name="a8f8574ed84883500dbb67270facdb328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8574ed84883500dbb67270facdb328">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for difference of <code>size_type</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00153">153</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a232ad8dd1cfa23d0377c8b3db872219a" name="a232ad8dd1cfa23d0377c8b3db872219a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232ad8dd1cfa23d0377c8b3db872219a">&#9670;&nbsp;</a></span>Hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classHash.html">::Hash</a> =  Hash_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for template arg. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00129">129</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a816dda3b07a92e4446347b71f420f82f" name="a816dda3b07a92e4446347b71f420f82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816dda3b07a92e4446347b71f420f82f">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::hasher =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classHash.html">Hash</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00174">174</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a0fcf7b6069c82bb96bd31e9351f21704" name="a0fcf7b6069c82bb96bd31e9351f21704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcf7b6069c82bb96bd31e9351f21704">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Iterator =  typename Value_list::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into a mutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00156">156</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a18d16a268b95319c8611d57951c3317b" name="a18d16a268b95319c8611d57951c3317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d16a268b95319c8611d57951c3317b">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00186">186</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1c528ba7ead507ad4ecf2760937173db" name="a1c528ba7ead507ad4ecf2760937173db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c528ba7ead507ad4ecf2760937173db">&#9670;&nbsp;</a></span>Key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Key =  Key_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for template arg. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00123">123</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a39f8b89d9bc13270c601b89c62b74191" name="a39f8b89d9bc13270c601b89c62b74191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f8b89d9bc13270c601b89c62b74191">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::key_equal =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classPred.html">Pred</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00176">176</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="abe6b472c1256b3661c73018fd07ca446" name="abe6b472c1256b3661c73018fd07ca446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6b472c1256b3661c73018fd07ca446">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::key_type =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00168">168</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a7eb9e2d5cdb340c0ec938a88ce2ef5d7" name="a7eb9e2d5cdb340c0ec938a88ce2ef5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">&#9670;&nbsp;</a></span>Mapped</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Mapped =  Mapped_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for template arg. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00126">126</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1e9995f0c063e81317c64e3f1a9924f7" name="a1e9995f0c063e81317c64e3f1a9924f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9995f0c063e81317c64e3f1a9924f7">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::mapped_type =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00170">170</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a18a7ba77b88c3dfa8547a54747a72bf6" name="a18a7ba77b88c3dfa8547a54747a72bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a7ba77b88c3dfa8547a54747a72bf6">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::pointer =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00178">178</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aea14e7770b9b7e7529753502f818505b" name="aea14e7770b9b7e7529753502f818505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea14e7770b9b7e7529753502f818505b">&#9670;&nbsp;</a></span>Pred</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classPred.html">::Pred</a> =  Pred_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for template arg. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00132">132</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a6d63f26c3fb953b0ab2856a3c76a22d6" name="a6d63f26c3fb953b0ab2856a3c76a22d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d63f26c3fb953b0ab2856a3c76a22d6">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::reference =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00182">182</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="acf6caa6709547211a33b894f0c267218" name="acf6caa6709547211a33b894f0c267218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6caa6709547211a33b894f0c267218">&#9670;&nbsp;</a></span>Reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Reverse_iterator =  typename Value_list::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into a mutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00162">162</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a135ce79aa68113033d3d5295bf6e3fdf" name="a135ce79aa68113033d3d5295bf6e3fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ce79aa68113033d3d5295bf6e3fdf">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses sizes/lengths of relevant things. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00151">151</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1bda4cef68dc1775ae5a02f0f349bb62" name="a1bda4cef68dc1775ae5a02f0f349bb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda4cef68dc1775ae5a02f0f349bb62">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Value =  std::pair&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> const, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for key/mapped-value pairs stored in the structure. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00135">135</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a29f69fa281255611a919ae0a042d81ef" name="a29f69fa281255611a919ae0a042d81ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f69fa281255611a919ae0a042d81ef">&#9670;&nbsp;</a></span>Value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Value_list =  std::list&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for doubly linked list of (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>) pairs. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00144">144</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1a7bf4c62aad92c36900c7974354dfcb" name="a1a7bf4c62aad92c36900c7974354dfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7bf4c62aad92c36900c7974354dfcb">&#9670;&nbsp;</a></span>Value_movable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Value_movable =  std::pair&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for key/mapped-value pair best-suited (perf-wise) as arg type for the moving <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a></code> overload. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00138">138</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a400decc79397fec52be13e1098e04661" name="a400decc79397fec52be13e1098e04661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400decc79397fec52be13e1098e04661">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::value_type =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00172">172</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0033ec6c091d68ac9804cae1675b93f" name="af0033ec6c091d68ac9804cae1675b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0033ec6c091d68ac9804cae1675b93f">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs empty structure with some basic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_buckets</td><td>Number of buckets for the unordered (hash) table. Special value -1 (default) will cause us to use whatever <code>unordered_set&lt;&gt;</code> would use by default. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>Instance of the hash function type (<code>hasher_obj(k) -&gt; size_t</code> should be hash of <code>Key k</code>). </td></tr>
    <tr><td class="paramname">pred</td><td>Instance of the equality function type (<code>pred(k1, k2)</code> should return <code>true</code> if and only if the <code>Key</code>s are equal by value). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00666">666</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aa5c23bc3d7a79eb3e334b80bf37b5529" name="aa5c23bc3d7a79eb3e334b80bf37b5529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c23bc3d7a79eb3e334b80bf37b5529">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs structure with some basic parameters, and values initialized from initializer list. </p>
<p >The values are inserted as if <code>insert(v)</code> was called for each pair <code>v</code> in <code>values</code> <b>in reverse order</b>. Since the canonical ordering places the <em>newest</em> (last inserted/<code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a></code>ed) element at the <em>front</em> of the ordering, that means that forward iteration through the set (right after this constructor runs) will yield values in the <em>same</em> order as in initializer list <code>values</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Values with which to fill the structure after initializing it. Typically you'd provide a series of key/value pairs like this: <code>{ { key1, value1 }, { key2, value2 }, ... }</code>. They will appear in iterated sequence in the same order as they appear in this list. </td></tr>
    <tr><td class="paramname">n_buckets</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">pred</td><td>See other constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00675">675</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00658">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_iter_set</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00630">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_list</a>.</p>

</div>
</div>
<a id="ae42dd8b8ecfd51d6414e4c8c8ac79924" name="ae42dd8b8ecfd51d6414e4c8c8ac79924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42dd8b8ecfd51d6414e4c8c8ac79924">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object that is a copy of the given source. </p>
<p >Equivalent to default-ction followed by <code>operator=(src)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00698">698</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ad440ab087f3335e9ba2664826d99f9e5" name="ad440ab087f3335e9ba2664826d99f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad440ab087f3335e9ba2664826d99f9e5">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object by making it equal to the given source, while the given source becomes as-if default-cted. </p>
<p >Equivalent to default-ction followed by <code>operator=(std::move(src))</code>.</p>
<p >This is a constant-time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00705">705</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a585b7d184077a8644d764d104feed76a" name="a585b7d184077a8644d764d104feed76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585b7d184077a8644d764d104feed76a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00976">976</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00849">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert_impl()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00865">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert_impl_mv()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00969">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::newest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a585b7d184077a8644d764d104feed76a_icgraph.svg" width="352" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2385c71b4970ba71af8479900117ab79" name="a2385c71b4970ba71af8479900117ab79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2385c71b4970ba71af8479900117ab79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01011">1011</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a0e0722bbd2cc5ba9192f299545b9d0ed" name="a0e0722bbd2cc5ba9192f299545b9d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0722bbd2cc5ba9192f299545b9d0ed">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01004">1004</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00997">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_newest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a0e0722bbd2cc5ba9192f299545b9d0ed_icgraph.svg" width="354" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4deb6b537745b164988fed8755722999" name="a4deb6b537745b164988fed8755722999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deb6b537745b164988fed8755722999">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01025">1025</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01018">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_oldest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a4deb6b537745b164988fed8755722999_icgraph.svg" width="328" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acb81c78165446043355a1e3f0cc42c65" name="acb81c78165446043355a1e3f0cc42c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81c78165446043355a1e3f0cc42c65">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510" title="Returns number of elements stored.">size()</a> == 0</code>. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00961">961</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00961">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00961">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::clear()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_acb81c78165446043355a1e3f0cc42c65_cgraph.svg" width="130" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_acb81c78165446043355a1e3f0cc42c65_icgraph.svg" width="130" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad1640cce76b51f0fa0d8c1e95b682808" name="ad1640cce76b51f0fa0d8c1e95b682808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1640cce76b51f0fa0d8c1e95b682808">&#9670;&nbsp;</a></span>const_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> but operating on immutable <code>*this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00997">997</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01004">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cbegin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ad1640cce76b51f0fa0d8c1e95b682808_cgraph.svg" width="354" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af841fbe9ea76f962a56828098934199d" name="af841fbe9ea76f962a56828098934199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af841fbe9ea76f962a56828098934199d">&#9670;&nbsp;</a></span>const_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01067">1067</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01074">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crbegin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_af841fbe9ea76f962a56828098934199d_cgraph.svg" width="351" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a93725b3e4e10c7841fb34ca9ac5aff47" name="a93725b3e4e10c7841fb34ca9ac5aff47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93725b3e4e10c7841fb34ca9ac5aff47">&#9670;&nbsp;</a></span>const_past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns special reverse iterator indicating the position just past the reverse-iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "newest," element in the reverse-iteration order. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01081">1081</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01088">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crend()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a93725b3e4e10c7841fb34ca9ac5aff47_cgraph.svg" width="332" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad29dc85660cc2ed821cd887bff0ed953" name="ad29dc85660cc2ed821cd887bff0ed953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29dc85660cc2ed821cd887bff0ed953">&#9670;&nbsp;</a></span>const_past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> but operating on immutable <code>*this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01018">1018</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01025">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cend()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ad29dc85660cc2ed821cd887bff0ed953_cgraph.svg" width="328" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8f75f926f679c06727298db80b18ea67" name="a8f75f926f679c06727298db80b18ea67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f75f926f679c06727298db80b18ea67">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or 1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00894">894</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00894">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00894">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::count()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a8f75f926f679c06727298db80b18ea67_cgraph.svg" width="134" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a8f75f926f679c06727298db80b18ea67_icgraph.svg" width="134" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a85d426d7711d31be672f504593783887" name="a85d426d7711d31be672f504593783887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d426d7711d31be672f504593783887">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01074">1074</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01067">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_oldest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a85d426d7711d31be672f504593783887_icgraph.svg" width="351" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a146bacf7c55bc513217fc0c8a951cfd8" name="a146bacf7c55bc513217fc0c8a951cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146bacf7c55bc513217fc0c8a951cfd8">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01088">1088</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01081">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_newest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a146bacf7c55bc513217fc0c8a951cfd8_icgraph.svg" width="332" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aff10ef8e0f54d49462c1a651efca6424" name="aff10ef8e0f54d49462c1a651efca6424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff10ef8e0f54d49462c1a651efca6424">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if container is empty. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01101">1101</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01101">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01101">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::empty()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aff10ef8e0f54d49462c1a651efca6424_cgraph.svg" width="136" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aff10ef8e0f54d49462c1a651efca6424_icgraph.svg" width="136" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abbc31f275883d1076755d2b179bc66d6" name="abbc31f275883d1076755d2b179bc66d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc31f275883d1076755d2b179bc66d6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00990">990</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00983">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_oldest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_abbc31f275883d1076755d2b179bc66d6_icgraph.svg" width="327" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1f223c371de3409879887bbb3a558b65" name="a1f223c371de3409879887bbb3a558b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f223c371de3409879887bbb3a558b65">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01032">1032</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a58c1ef46da85774193ad4153e56460ad" name="a58c1ef46da85774193ad4153e56460ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c1ef46da85774193ad4153e56460ad">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element pointed to by the given valid iterator. </p>
<p >Behavior undefined if it is not valid. <code>it</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator of element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator one position past (i.e., "older") than <code>it</code>, before <code>*it</code> was removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00921">921</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00921">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00921">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a58c1ef46da85774193ad4153e56460ad_cgraph.svg" width="134" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a58c1ef46da85774193ad4153e56460ad_icgraph.svg" width="134" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a50ca10ae279f49663ba17df190f36fab" name="a50ca10ae279f49663ba17df190f36fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ca10ae279f49663ba17df190f36fab">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_newest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_past_oldest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>). </p>
<p >Behavior undefined if a given iterator is invalid, or if the range is invalid. Corner case: an empty range is allowed; then this no-ops. Unless no-op, <code>it_newest</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it_newest</td><td>Iterator of first ("newest") element to erase. </td></tr>
    <tr><td class="paramname">it_past_oldest</td><td>Iterator of one past last ("oldest") element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>it_past_oldest</code> copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00931">931</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00921">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a50ca10ae279f49663ba17df190f36fab_cgraph.svg" width="304" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad3e9ea0a2c3675577b4582b6a7f59312" name="ad3e9ea0a2c3675577b4582b6a7f59312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e9ea0a2c3675577b4582b6a7f59312">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element with the given key, if it exists. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it existed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key such that its equal's (if found) element will be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased (0 or 1). </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00944">944</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00878">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ad3e9ea0a2c3675577b4582b6a7f59312_cgraph.svg" width="295" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9a18e44447eb0b848f1ed4c6d947427d" name="a9a18e44447eb0b848f1ed4c6d947427d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a18e44447eb0b848f1ed4c6d947427d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find value at the given key in the map. </p>
<p >Key presence is determined identically to how it would be done in an <code>unordered_set&lt;Key, <a class="el" href="classHash.html">Hash</a>, <a class="el" href="classPred.html">Pred</a>&gt;</code>, with the particular <a class="el" href="classHash.html">Hash</a> and <a class="el" href="classPred.html">Pred</a> instances given to ctor (typically their default-cted instances, typically occupying no memory).</p>
<p >The returned iterator (if valid) can be used to mutate the element inside the map; though only the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> is mutable; the <code>const Key</code> is immutable.</p>
<p >Any subsequent writes to the referred-to (by returned iterator) area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00878">878</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00878">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00944">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00878">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00836">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator[]()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a9a18e44447eb0b848f1ed4c6d947427d_cgraph.svg" width="124" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a9a18e44447eb0b848f1ed4c6d947427d_icgraph.svg" width="319" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a50b55a895a78341363146459f45f345c" name="a50b55a895a78341363146459f45f345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b55a895a78341363146459f45f345c">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload but in a <code>const</code> context: the returned iterator is to immutable memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00886">886</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00878">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a50b55a895a78341363146459f45f345c_cgraph.svg" width="286" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac99cc54acf0b5a74e8e7a1f5ca30c2eb" name="ac99cc54acf0b5a74e8e7a1f5ca30c2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; if key already in <code>*this</code> makes no change. </p>
<p >See also the overload which can avoid a copy and destructively move the key and mapped-value instead.</p>
<p >Return value indicates various info of interest about what occurred or did not occur. If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected (use <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> upon consulting the return value, if this is desirable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>The key/mapped-value pair to attempt to insert. A copy of this value is placed in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair whose second element is true if and only if the insertion occurred; and whose first element is an iterator pointing to either the newly inserted element or already present one with a key equal to <code>key_and_mapped.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00800">800</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05600">flow::net_flow::Node::close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ac99cc54acf0b5a74e8e7a1f5ca30c2eb_icgraph.svg" width="1583" height="332"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6444fd8206c662fe4ebe61a91acb3eb9" name="a6444fd8206c662fe4ebe61a91acb3eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6444fd8206c662fe4ebe61a91acb3eb9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload, except that (if key not already present in <code>*this</code>) the key and mapped-value are moved, not copied, into <code>*this</code>. </p>
<dl class="section note"><dt>Note</dt><dd><code>key_and_mapped</code> pointee must be of type <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb" title="Short-hand for key/mapped-value pair best-suited (perf-wise) as arg type for the moving insert() over...">Value_movable</a>, a/k/a <code>pair&lt;Key, Mapped&gt;</code> &ndash; not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a>, a/k/a <code>pair&lt;const Key, Mapped&gt;</code> &ndash; otherwise the other <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a> overload may get invoked, and copying may occur contrary to your intention. E.g., use <code>std::make_pair&lt;Key, Mapped&gt;()</code> or <code>"decltype(*this)::Value_movable{}"</code>. (For a move to occur, the source-object can't be <code>const</code>; so that's why.) </dd>
<dd>
You can often also use <code>x[std::move(key)] = std::move(value)</code>, particularly if you know <code>key</code> isn't in there, or you are OK with replacing the value if it is. In those cases it's probably more convenient, no pairs or <code>Value_movable</code>s to worry oneself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>The key/mapped-value pair to attempt to insert (both key and mapped-value are moved-from, if insertion occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other overload. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00813">813</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="afd8f1651012750223c078e645de0ead0" name="afd8f1651012750223c078e645de0ead0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8f1651012750223c078e645de0ead0">&#9670;&nbsp;</a></span>insert_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a> so that <code>key_and_mapped</code>'s copy is inserted into the structure. </p>
<p >Pre-condition is that <code>key_and_mapped.first</code> is not in the structure (else behavior undefined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>Same as in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as in <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a>.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00849">849</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00976">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_afd8f1651012750223c078e645de0ead0_cgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2f16297dae7c3f384e833e5ce22fd86e" name="a2f16297dae7c3f384e833e5ce22fd86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f16297dae7c3f384e833e5ce22fd86e">&#9670;&nbsp;</a></span>insert_impl_mv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert_impl_mv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afd8f1651012750223c078e645de0ead0" title="Helper that modifies m_value_list and m_value_iter_set so that key_and_mapped&#39;s copy is inserted into...">insert_impl()</a>, except <code>key_and_mapped</code> components are <code>move()</code>d into <code>*this</code> instead of being copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>Same as in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as in <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a>.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00865">865</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00976">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a2f16297dae7c3f384e833e5ce22fd86e_cgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a059c278705edc45e9b2660f17a295837" name="a059c278705edc45e9b2660f17a295837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059c278705edc45e9b2660f17a295837">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max number of elements that can be stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code> + <code>list&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01108">1108</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a43b0e5555bd112c464d4ab053fb3d06c" name="a43b0e5555bd112c464d4ab053fb3d06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b0e5555bd112c464d4ab053fb3d06c">&#9670;&nbsp;</a></span>newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator; or <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00969">969</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00976">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a43b0e5555bd112c464d4ab053fb3d06c_cgraph.svg" width="312" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3155305b98475f232236ec395ec925e4" name="a3155305b98475f232236ec395ec925e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3155305b98475f232236ec395ec925e4">&#9670;&nbsp;</a></span>oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01039">1039</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01046">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rbegin()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a3155305b98475f232236ec395ec925e4_cgraph.svg" width="311" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad621b7defed9015b5d0eeca0301450ba" name="ad621b7defed9015b5d0eeca0301450ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621b7defed9015b5d0eeca0301450ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object with a copy of the given source. </p>
<p >We become equal to <code>src</code> but independent of it to a common-sense extent. In addition, the hasher instance and equality predicate are copied from <code>src</code>. Finally, a reasonable attempt is made to also make the internal structure of the hash map to be similar to that of `src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. No-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00713">713</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00658">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_iter_set</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00630">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_list</a>.</p>

</div>
</div>
<a id="ad08522b4af94f87b543649e367afd643" name="ad08522b4af94f87b543649e367afd643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08522b4af94f87b543649e367afd643">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted. </p>
<p >This is a constant-time operation, plus whatever is the cost of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65" title="Makes it so that size() == 0.">clear()</a></code> (linear in pre-op <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510" title="Returns number of elements stored.">size()</a></code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied; except no-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00778">778</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l01910">flow::util::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ad08522b4af94f87b543649e367afd643_cgraph.svg" width="312" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a18e4a04383d686564b3c0cc3383b3880" name="a18e4a04383d686564b3c0cc3383b3880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e4a04383d686564b3c0cc3383b3880">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mapped_t &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either finds the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value at the given key, or if not found inserts one with a default-constructed <code>Mapped{}</code>; then returns reference to the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>. </p>
<p >That ref can be used to read and/or modify that value directly. See also the overload which can avoid a copy and destructively move the key instead.</p>
<p >If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected.</p>
<p >So it is ~equivalent to</p>
<ul>
<li>(<code>key</code> is in map) <code>return this-&gt;find(key)-&gt;second</code>; or</li>
<li>(otherwise) <code>return this-&gt;insert(key, Mapped{}).first-&gt;second</code>.</li>
</ul>
<p >As long as the value is not removed from the map, the reference will continue to be valid.</p>
<p >Any subsequent writes to the referred-to area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find or insert if not found. A copy of this value is placed in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value directly inside the data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00825">825</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ae8766bd2c286c40e1036cf3836558d55" name="ae8766bd2c286c40e1036cf3836558d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8766bd2c286c40e1036cf3836558d55">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mapped_t &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to attempt to insert (key is moved-from, if insertion occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other overload. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00836">836</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00878">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ae8766bd2c286c40e1036cf3836558d55_cgraph.svg" width="319" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0a4e24934208292fb4096b7e036d5227" name="a0a4e24934208292fb4096b7e036d5227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4e24934208292fb4096b7e036d5227">&#9670;&nbsp;</a></span>past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01053">1053</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01060">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rend()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a0a4e24934208292fb4096b7e036d5227_cgraph.svg" width="335" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9135b5521dd34bea817b2326b04737f3" name="a9135b5521dd34bea817b2326b04737f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9135b5521dd34bea817b2326b04737f3">&#9670;&nbsp;</a></span>past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns special iterator indicating the position just past the iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "oldest," element in the iteration order. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00983">983</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00990">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::end()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a9135b5521dd34bea817b2326b04737f3_cgraph.svg" width="327" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2bba3816cc1c1d0f43b0d8205f04ec66" name="a2bba3816cc1c1d0f43b0d8205f04ec66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bba3816cc1c1d0f43b0d8205f04ec66">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01046">1046</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01039">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::oldest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a2bba3816cc1c1d0f43b0d8205f04ec66_icgraph.svg" width="311" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a84a797e0ff66fe4044f5a551bee4540e" name="a84a797e0ff66fe4044f5a551bee4540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a797e0ff66fe4044f5a551bee4540e">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01060">1060</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01053">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_newest()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a84a797e0ff66fe4044f5a551bee4540e_icgraph.svg" width="335" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a97ea7121aa85856c9d977777f6c7c510" name="a97ea7121aa85856c9d977777f6c7c510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ea7121aa85856c9d977777f6c7c510">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;.</code> </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01095">1095</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l01095">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00759">flow::net_flow::Event_set::ev_type_to_socks_map_sizes_to_str()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l01095">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a97ea7121aa85856c9d977777f6c7c510_cgraph.svg" width="124" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a97ea7121aa85856c9d977777f6c7c510_icgraph.svg" width="1571" height="442"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac8393b9576ef14102a467e317f443471" name="ac8393b9576ef14102a467e317f443471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8393b9576ef14102a467e317f443471">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>. </p>
<p >This is a constant-time operation, as internal representations are swapped instead of any copy-assignment.</p>
<dl class="section see"><dt>See also</dt><dd>The <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471" title="Swaps the contents of this structure and other.">swap()</a></code> free function. It is generally best (equivalent but covers more generic cases) to use the ADL-enabled <code>swap(a, b)</code> pattern instead of this member function. That is: <code>using std::swap; ...; swap(a, b);</code>. (Details are outside our scope here; but in short ADL will cause the right thing to happen.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00789">789</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00658">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_iter_set</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00630">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_list</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l01114">flow::util::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01114">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ac8393b9576ef14102a467e317f443471_cgraph.svg" width="286" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ac8393b9576ef14102a467e317f443471_icgraph.svg" width="299" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a283501e0657922191813c9a465ea0748" name="a283501e0657922191813c9a465ea0748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283501e0657922191813c9a465ea0748">&#9670;&nbsp;</a></span>touch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order. </p>
<p >Behavior undefined if iterator invalid.</p>
<p >The iterator continues to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to an element of the structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00900">900</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ad5252a028dae9a6cee1e7fccabc37d8f" name="ad5252a028dae9a6cee1e7fccabc37d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5252a028dae9a6cee1e7fccabc37d8f">&#9670;&nbsp;</a></span>touch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key was found (even if it was already "newest"); <code>false</code> if not found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00906">906</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaac7b774853aa9a83e2935634fd5e7a6" name="aaac7b774853aa9a83e2935634fd5e7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac7b774853aa9a83e2935634fd5e7a6">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>val1.swap(val2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01114">1114</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00789">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aaac7b774853aa9a83e2935634fd5e7a6_cgraph.svg" width="454" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a49ceba9fd4f7a5b63be0b5e11e02056d" name="a49ceba9fd4f7a5b63be0b5e11e02056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ceba9fd4f7a5b63be0b5e11e02056d">&#9670;&nbsp;</a></span>m_value_iter_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#acb68e7985082dd9cbe7b1c67dd3b54a1">Linked_hash_key_set</a>&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>, true&gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_iter_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data structure that allows the amortized-constant-time (as in <code>unordered_set</code>) implementation of <code>this-&gt;find(key)</code>, where <code>key</code> is <code>const Key&amp;</code>. </p>
<p >Namely, then, given a <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, it gets us an <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> &ndash; the central data store &ndash; or a null iterator if not-found.</p>
<h3>Design</h3>
<p >(There is quick intro in Impl section of the class doc header.) Ignoring various technicalities and C++isms, ultimately it stores <code>Iterator</code>s while supporting the <b>find</b> operation that</p>
<ul>
<li>takes a <code>const Key&amp; key</code>; and</li>
<li>yields the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> <code>it</code> stored therein (if any) such that<ul>
<li>it-&gt;second <em>equals by value</em> (via <a class="el" href="classHash.html">Hash</a> and <a class="el" href="classPred.html">Pred</a>) the <code>key</code>.</li>
</ul>
</li>
</ul>
<p >This find-op must <a class="el" href="classHash.html">Hash</a> the <code>key</code>; and then perform a (series of) <a class="el" href="classPred.html">Pred</a> comparisons between <code>key</code> and the <code>Key</code>s stored at <code>Iterator</code>s within that hash-bucket.</p>
<p ><em>How</em> this is accomplished is encapsulated inside <a class="el" href="namespaceflow_1_1util.html#acb68e7985082dd9cbe7b1c67dd3b54a1" title="The lookup structure used inside Linked_hash_map and Linked_hash_set.">Linked_hash_key_set</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__key.html" title="The internal-use key/iterator-wrapper, used as the key type in internal-use set-type Linked_hash_key_...">Linked_hash_key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__key__hash.html" title="The internal-use Hash functor wrapper, used as the hasher type in internal-use set-type Linked_hash_k...">Linked_hash_key_hash</a>, and <a class="el" href="classflow_1_1util_1_1Linked__hash__key__pred.html" title="The internal-use Pred functor wrapper, used as the key-equality-determiner type in internal-use set-t...">Linked_hash_key_pred</a> helper (internally-used only) types. This is abstracted away; the bottom line is <code>m_value_iter_set.find(key)-&gt;iter()</code> yields the proper <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> (assuming <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a></code> didn't yield <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a></code>).</p>
<p >Similarly <code>m_value_iter_set.insert(iter)</code> &ndash; where <code>iter</code> is an <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> &ndash; just works.</p>
<h3>Performance</h3>
<p >Anything they'll need to do to this set (namely <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a></code> and <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a></code>) carries the same performance cost as if they used a straight <code>unordered_map&lt;&gt;</code>, so by definition it is acceptable. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00658">658</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00675">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00713">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator=()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00789">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap()</a>.</p>

</div>
</div>
<a id="ac636005479265a02045cac776f71c213" name="ac636005479265a02045cac776f71c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac636005479265a02045cac776f71c213">&#9670;&nbsp;</a></span>m_value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a29f69fa281255611a919ae0a042d81ef">Value_list</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::m_value_list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual values &ndash; which, as in <code>unordered_map&lt;K, M&gt;</code>, are instances of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a> = <code>pair&lt;const Key, Mapped&gt;</code> &ndash; are stored in here, in the order in which user would iterate over them. </p>
<p >If <code>Value v</code> is in this list, then no <code>Value v1 == v</code> can be elsewhere in the list. The order is semantically defined to be from "newest" to "oldest." Therefore, any newly inserted value goes at the <em>start</em> of the list. Similarly, any "touched" value is moved to the <em>start</em> of the list (see <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>).</p>
<p >This ordering is what a normal <code>unordered_map&lt;K, M&gt;</code> would not supply (it's in the name!) but that we advertise.</p>
<h3>Design</h3>
<p >This is very much the central structure in a <code>*this</code>; its iterator type <em>is</em> our exposed <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a>. Straight-up, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> supplies every single required operation (or at least ones on top of which any required ops could be implemented). There is exactly one exception to this: <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find(const Key&amp;)</a></code>. It too could be implemented with <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac636005479265a02045cac776f71c213" title="The actual values  which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;const Key,...">m_value_list</a> alone, but a linear search (linear-time worst- and average-case) would be necessary (unacceptable). Because of that we have <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a49ceba9fd4f7a5b63be0b5e11e02056d" title="Data structure that allows the amortized-constant-time (as in unordered_set) implementation of this-&gt;...">m_value_iter_set</a>. See that guy's doc header.</p>
<h3>Performance</h3>
<p >Moving a value from anywhere to either end of the list is a constant-time operation (assuming the source location's iterator is known). Hence <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> is constant-time. Moreover, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> does <em>not</em> involve a copy of a <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a> (it only involves assigning, internally, a few linked list pointers). Also note that insertion is similarly constant-time. Finally, erasure is also constant-time. These are the basic operations needed. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00630">630</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00675">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00713">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator=()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00789">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 15 2026 00:49:02 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
