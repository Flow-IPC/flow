<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Linked__hash__map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a map that combines the lookup speed of a <code>boost::unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of an <code>std::list&lt;&gt;</code>.  
 <a href="classflow_1_1util_1_1Linked__hash__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map__coll__graph.svg" width="311" height="239"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af8b3b1128da79536a4c86e9feadb0c66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> = std::pair&lt; Key const, Mapped &gt;</td></tr>
<tr class="memdesc:af8b3b1128da79536a4c86e9feadb0c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for key/mapped-value pairs stored in the structure.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">More...</a><br /></td></tr>
<tr class="separator:af8b3b1128da79536a4c86e9feadb0c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33cde46cfc7ea7e7366c842b09dae30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:ab33cde46cfc7ea7e7366c842b09dae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for index into array of items, where items are all applicable objects including <code>Value</code>s and <code>Key</code>s.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">More...</a><br /></td></tr>
<tr class="separator:ab33cde46cfc7ea7e7366c842b09dae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033e6ec5c7dd0e9b08ba7fa9490f41ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a033e6ec5c7dd0e9b08ba7fa9490f41ce">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a033e6ec5c7dd0e9b08ba7fa9490f41ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a033e6ec5c7dd0e9b08ba7fa9490f41ce">More...</a><br /></td></tr>
<tr class="separator:a033e6ec5c7dd0e9b08ba7fa9490f41ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f55a43df7939163f3ad5b713eb20c99"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a> = typename Value_list::iterator</td></tr>
<tr class="memdesc:a2f55a43df7939163f3ad5b713eb20c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">More...</a><br /></td></tr>
<tr class="separator:a2f55a43df7939163f3ad5b713eb20c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2185f193ced2c3c0bf566b06f54b7c83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> = typename Value_list::const_iterator</td></tr>
<tr class="memdesc:a2185f193ced2c3c0bf566b06f54b7c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">More...</a><br /></td></tr>
<tr class="separator:a2185f193ced2c3c0bf566b06f54b7c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f09acd8df06d9479840862b228463d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Reverse_iterator</a> = typename Value_list::reverse_iterator</td></tr>
<tr class="memdesc:a18f09acd8df06d9479840862b228463d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into a mutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">More...</a><br /></td></tr>
<tr class="separator:a18f09acd8df06d9479840862b228463d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10095310ddb7fe3d7cf35d957cc1c477"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Const_reverse_iterator</a> = typename Value_list::const_reverse_iterator</td></tr>
<tr class="memdesc:a10095310ddb7fe3d7cf35d957cc1c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into an immutable structure of this type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">More...</a><br /></td></tr>
<tr class="separator:a10095310ddb7fe3d7cf35d957cc1c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57eb929f45956c9dd2de271d59509cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac57eb929f45956c9dd2de271d59509cc">key_type</a> = Key</td></tr>
<tr class="memdesc:ac57eb929f45956c9dd2de271d59509cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Key</code> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac57eb929f45956c9dd2de271d59509cc">More...</a><br /></td></tr>
<tr class="separator:ac57eb929f45956c9dd2de271d59509cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4b2bf1d3c8c99b5b6667ace94c8ff2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#add4b2bf1d3c8c99b5b6667ace94c8ff2">mapped_type</a> = Mapped</td></tr>
<tr class="memdesc:add4b2bf1d3c8c99b5b6667ace94c8ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Mapped</code> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#add4b2bf1d3c8c99b5b6667ace94c8ff2">More...</a><br /></td></tr>
<tr class="separator:add4b2bf1d3c8c99b5b6667ace94c8ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0885cc03a4dffbaffe810b6cd8e28f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af0885cc03a4dffbaffe810b6cd8e28f6">value_type</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a></td></tr>
<tr class="memdesc:af0885cc03a4dffbaffe810b6cd8e28f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Key</code>/<code>Mapped</code> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af0885cc03a4dffbaffe810b6cd8e28f6">More...</a><br /></td></tr>
<tr class="separator:af0885cc03a4dffbaffe810b6cd8e28f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaf16f8986f32d223e2123b14652bb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#adeaf16f8986f32d223e2123b14652bb3">hasher</a> = Hash</td></tr>
<tr class="memdesc:adeaf16f8986f32d223e2123b14652bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Hash</code> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#adeaf16f8986f32d223e2123b14652bb3">More...</a><br /></td></tr>
<tr class="separator:adeaf16f8986f32d223e2123b14652bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba81d115e3073afb88d5eb1cd85125e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6ba81d115e3073afb88d5eb1cd85125e">key_equal</a> = Pred</td></tr>
<tr class="memdesc:a6ba81d115e3073afb88d5eb1cd85125e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Pred</code> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6ba81d115e3073afb88d5eb1cd85125e">More...</a><br /></td></tr>
<tr class="separator:a6ba81d115e3073afb88d5eb1cd85125e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96567fe2fdd1de19954ddef1617c1610"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a96567fe2fdd1de19954ddef1617c1610">pointer</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> *</td></tr>
<tr class="memdesc:a96567fe2fdd1de19954ddef1617c1610"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>Key</code>/<code>Mapped</code> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a96567fe2fdd1de19954ddef1617c1610">More...</a><br /></td></tr>
<tr class="separator:a96567fe2fdd1de19954ddef1617c1610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657eef8b8299a7c87d48a6e373a6db3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a657eef8b8299a7c87d48a6e373a6db3a">const_pointer</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const *</td></tr>
<tr class="memdesc:a657eef8b8299a7c87d48a6e373a6db3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const Key</code>/<code>Mapped</code> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a657eef8b8299a7c87d48a6e373a6db3a">More...</a><br /></td></tr>
<tr class="separator:a657eef8b8299a7c87d48a6e373a6db3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a28e2ed92e3ef8aff3fe392abd4a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a756a28e2ed92e3ef8aff3fe392abd4a8">reference</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &amp;</td></tr>
<tr class="memdesc:a756a28e2ed92e3ef8aff3fe392abd4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>Key</code>/<code>Mapped</code> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a756a28e2ed92e3ef8aff3fe392abd4a8">More...</a><br /></td></tr>
<tr class="separator:a756a28e2ed92e3ef8aff3fe392abd4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d0a782f7dee3fefaae51e85d05657b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a82d0a782f7dee3fefaae51e85d05657b">const_reference</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;</td></tr>
<tr class="memdesc:a82d0a782f7dee3fefaae51e85d05657b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const Key</code>/<code>Mapped</code> pair type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a82d0a782f7dee3fefaae51e85d05657b">More...</a><br /></td></tr>
<tr class="separator:a82d0a782f7dee3fefaae51e85d05657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f09f98b4089a8c3ffd0b7f732923b44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1f09f98b4089a8c3ffd0b7f732923b44">iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a></td></tr>
<tr class="memdesc:a1f09f98b4089a8c3ffd0b7f732923b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1f09f98b4089a8c3ffd0b7f732923b44">More...</a><br /></td></tr>
<tr class="separator:a1f09f98b4089a8c3ffd0b7f732923b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5383264c89ac63cc8827b18063f2ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2b5383264c89ac63cc8827b18063f2ca">const_iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a></td></tr>
<tr class="memdesc:a2b5383264c89ac63cc8827b18063f2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2b5383264c89ac63cc8827b18063f2ca">More...</a><br /></td></tr>
<tr class="separator:a2b5383264c89ac63cc8827b18063f2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab99f2ee682a21a0abffbaf14d18ba739"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab99f2ee682a21a0abffbaf14d18ba739">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>(-1), Hash const &amp;hasher_instance=Hash(), Pred const &amp;key_equal_instance=Pred())</td></tr>
<tr class="memdesc:ab99f2ee682a21a0abffbaf14d18ba739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty structure with some basic parameters.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ab99f2ee682a21a0abffbaf14d18ba739">More...</a><br /></td></tr>
<tr class="separator:ab99f2ee682a21a0abffbaf14d18ba739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd21d7c1ff342b91ad9a8ea85a9c0d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9fd21d7c1ff342b91ad9a8ea85a9c0d7">Linked_hash_map</a> (std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &gt; values, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>(-1), Hash const &amp;hasher_instance=Hash(), Pred const &amp;key_equal_instance=Pred())</td></tr>
<tr class="memdesc:a9fd21d7c1ff342b91ad9a8ea85a9c0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs structure with some basic parameters, and values initialized from initializer list.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9fd21d7c1ff342b91ad9a8ea85a9c0d7">More...</a><br /></td></tr>
<tr class="separator:a9fd21d7c1ff342b91ad9a8ea85a9c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9916fa373399e71fd72f5a97d2b0e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2d9916fa373399e71fd72f5a97d2b0e6">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> const &amp;src)</td></tr>
<tr class="memdesc:a2d9916fa373399e71fd72f5a97d2b0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object that is a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2d9916fa373399e71fd72f5a97d2b0e6">More...</a><br /></td></tr>
<tr class="separator:a2d9916fa373399e71fd72f5a97d2b0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee7a7164ec56bfd75886624c8540a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac0ee7a7164ec56bfd75886624c8540a5">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ac0ee7a7164ec56bfd75886624c8540a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac0ee7a7164ec56bfd75886624c8540a5">More...</a><br /></td></tr>
<tr class="separator:ac0ee7a7164ec56bfd75886624c8540a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdba28273d24b962c76b1926a93d9772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acdba28273d24b962c76b1926a93d9772">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> const &amp;src)</td></tr>
<tr class="memdesc:acdba28273d24b962c76b1926a93d9772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object with a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#acdba28273d24b962c76b1926a93d9772">More...</a><br /></td></tr>
<tr class="separator:acdba28273d24b962c76b1926a93d9772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f597ec2dcb9fd1d50ff40ca482232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa05f597ec2dcb9fd1d50ff40ca482232">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aa05f597ec2dcb9fd1d50ff40ca482232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aa05f597ec2dcb9fd1d50ff40ca482232">More...</a><br /></td></tr>
<tr class="separator:aa05f597ec2dcb9fd1d50ff40ca482232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7a4a3047c90f0ab26ae1a4ec7b9963"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963">insert</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;key_and_mapped)</td></tr>
<tr class="memdesc:aae7a4a3047c90f0ab26ae1a4ec7b9963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert the given key/mapped-value pair into the map.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963">More...</a><br /></td></tr>
<tr class="separator:aae7a4a3047c90f0ab26ae1a4ec7b9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06ac5737a9189f29ce9355d33a81c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa06ac5737a9189f29ce9355d33a81c8b">find</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:aa06ac5737a9189f29ce9355d33a81c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find value at the given key in the map.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aa06ac5737a9189f29ce9355d33a81c8b">More...</a><br /></td></tr>
<tr class="separator:aa06ac5737a9189f29ce9355d33a81c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8c1fd9a157d99d0a6417ad34f74e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abb8c1fd9a157d99d0a6417ad34f74e52">find</a> (Key const &amp;key) const</td></tr>
<tr class="memdesc:abb8c1fd9a157d99d0a6417ad34f74e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find value at the given key in the map.  <a href="classflow_1_1util_1_1Linked__hash__map.html#abb8c1fd9a157d99d0a6417ad34f74e52">More...</a><br /></td></tr>
<tr class="separator:abb8c1fd9a157d99d0a6417ad34f74e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a462e0299e3da43f4f41b86205cd520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a462e0299e3da43f4f41b86205cd520">count</a> (Key const &amp;key) const</td></tr>
<tr class="memdesc:a1a462e0299e3da43f4f41b86205cd520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a key is equivalent to the given one is present in the map: either 1 or 0.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1a462e0299e3da43f4f41b86205cd520">More...</a><br /></td></tr>
<tr class="separator:a1a462e0299e3da43f4f41b86205cd520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d1d95f11148f7ed30a7dd92193563a"><td class="memItemLeft" align="right" valign="top">Mapped &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a60d1d95f11148f7ed30a7dd92193563a">operator[]</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:a60d1d95f11148f7ed30a7dd92193563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>insert(Value(key, Mapped())).first-&gt;second</code> (but avoids unnecessarily invoking <code>Mapped()</code>/generally strives for better performance).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a60d1d95f11148f7ed30a7dd92193563a">More...</a><br /></td></tr>
<tr class="separator:a60d1d95f11148f7ed30a7dd92193563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1321c368f128cb7abdbb9e8fa0abfc34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1321c368f128cb7abdbb9e8fa0abfc34">front</a> ()</td></tr>
<tr class="memdesc:a1321c368f128cb7abdbb9e8fa0abfc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1321c368f128cb7abdbb9e8fa0abfc34">More...</a><br /></td></tr>
<tr class="separator:a1321c368f128cb7abdbb9e8fa0abfc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb7505e57af6c01e4e4fefd9215c0d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6eb7505e57af6c01e4e4fefd9215c0d2">back</a> ()</td></tr>
<tr class="memdesc:a6eb7505e57af6c01e4e4fefd9215c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6eb7505e57af6c01e4e4fefd9215c0d2">More...</a><br /></td></tr>
<tr class="separator:a6eb7505e57af6c01e4e4fefd9215c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a99fd89e114b1efffce15c974e76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a775a99fd89e114b1efffce15c974e76e">const_front</a> () const</td></tr>
<tr class="memdesc:a775a99fd89e114b1efffce15c974e76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a775a99fd89e114b1efffce15c974e76e">More...</a><br /></td></tr>
<tr class="separator:a775a99fd89e114b1efffce15c974e76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04001f6ec7789a5715cc9a135db876a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af04001f6ec7789a5715cc9a135db876a">const_back</a> () const</td></tr>
<tr class="memdesc:af04001f6ec7789a5715cc9a135db876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af04001f6ec7789a5715cc9a135db876a">More...</a><br /></td></tr>
<tr class="separator:af04001f6ec7789a5715cc9a135db876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b397bc5f47417578c5698453458276a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a">touch</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;it)</td></tr>
<tr class="memdesc:a8b397bc5f47417578c5698453458276a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a valid iterator into the structure, makes the pointed to element "newest" by moving it from wherever it is to be first in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a">More...</a><br /></td></tr>
<tr class="separator:a8b397bc5f47417578c5698453458276a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746009717774ae07758093d75d33052a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a746009717774ae07758093d75d33052a">touch</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:a746009717774ae07758093d75d33052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a746009717774ae07758093d75d33052a">More...</a><br /></td></tr>
<tr class="separator:a746009717774ae07758093d75d33052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d49cf64db7d8eaff56089fd5682ecc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0d49cf64db7d8eaff56089fd5682ecc0">erase</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;it)</td></tr>
<tr class="memdesc:a0d49cf64db7d8eaff56089fd5682ecc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element pointed to by the given valid iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0d49cf64db7d8eaff56089fd5682ecc0">More...</a><br /></td></tr>
<tr class="separator:a0d49cf64db7d8eaff56089fd5682ecc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fed31c62ca52236abca34cef88441c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af0fed31c62ca52236abca34cef88441c">erase</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;it_newest, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;it_past_oldest)</td></tr>
<tr class="memdesc:af0fed31c62ca52236abca34cef88441c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>).  <a href="classflow_1_1util_1_1Linked__hash__map.html#af0fed31c62ca52236abca34cef88441c">More...</a><br /></td></tr>
<tr class="separator:af0fed31c62ca52236abca34cef88441c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5134b1294700d6905b8fdd650289b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3a5134b1294700d6905b8fdd650289b7">erase</a> (Key const &amp;key)</td></tr>
<tr class="memdesc:a3a5134b1294700d6905b8fdd650289b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element with the given key, if it exists.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a3a5134b1294700d6905b8fdd650289b7">More...</a><br /></td></tr>
<tr class="separator:a3a5134b1294700d6905b8fdd650289b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a07419164377068bc2af59d2b024da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad6a07419164377068bc2af59d2b024da">clear</a> ()</td></tr>
<tr class="memdesc:ad6a07419164377068bc2af59d2b024da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aba0949de5032e8dd6d75a48bcac9b060" title="Returns number of elements stored.">size()</a> == 0</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad6a07419164377068bc2af59d2b024da">More...</a><br /></td></tr>
<tr class="separator:ad6a07419164377068bc2af59d2b024da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d864e5d7aaeacd550a191b90eebd46c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8d864e5d7aaeacd550a191b90eebd46c">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;other)</td></tr>
<tr class="memdesc:a8d864e5d7aaeacd550a191b90eebd46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8d864e5d7aaeacd550a191b90eebd46c">More...</a><br /></td></tr>
<tr class="separator:a8d864e5d7aaeacd550a191b90eebd46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c854154d3ec15ab98905ebf9ee1f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac0c854154d3ec15ab98905ebf9ee1f20">begin</a> ()</td></tr>
<tr class="memdesc:ac0c854154d3ec15ab98905ebf9ee1f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac0c854154d3ec15ab98905ebf9ee1f20">More...</a><br /></td></tr>
<tr class="separator:ac0c854154d3ec15ab98905ebf9ee1f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b796f7ddb4dbc2f2e64ea25985d43b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8">newest</a> ()</td></tr>
<tr class="memdesc:a4b796f7ddb4dbc2f2e64ea25985d43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8">More...</a><br /></td></tr>
<tr class="separator:a4b796f7ddb4dbc2f2e64ea25985d43b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e94bd9656d06ee20050c797f6eb248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a83e94bd9656d06ee20050c797f6eb248">end</a> ()</td></tr>
<tr class="memdesc:a83e94bd9656d06ee20050c797f6eb248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a83e94bd9656d06ee20050c797f6eb248">More...</a><br /></td></tr>
<tr class="separator:a83e94bd9656d06ee20050c797f6eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf38a12a6f65110d7e3dae3836c5abee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee">past_oldest</a> ()</td></tr>
<tr class="memdesc:aaf38a12a6f65110d7e3dae3836c5abee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee">More...</a><br /></td></tr>
<tr class="separator:aaf38a12a6f65110d7e3dae3836c5abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe7332e582b6f51c1a2c5cb91c1d270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3fe7332e582b6f51c1a2c5cb91c1d270">cbegin</a> () const</td></tr>
<tr class="memdesc:a3fe7332e582b6f51c1a2c5cb91c1d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a3fe7332e582b6f51c1a2c5cb91c1d270">More...</a><br /></td></tr>
<tr class="separator:a3fe7332e582b6f51c1a2c5cb91c1d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda9f2cdcc5a1025183c0151a6e90bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aebda9f2cdcc5a1025183c0151a6e90bb">begin</a> () const</td></tr>
<tr class="memdesc:aebda9f2cdcc5a1025183c0151a6e90bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3fe7332e582b6f51c1a2c5cb91c1d270" title="Synonym of const_newest().">cbegin()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aebda9f2cdcc5a1025183c0151a6e90bb">More...</a><br /></td></tr>
<tr class="separator:aebda9f2cdcc5a1025183c0151a6e90bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ac8c4685ed84eac8407164f3bd8b84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84">const_newest</a> () const</td></tr>
<tr class="memdesc:a79ac8c4685ed84eac8407164f3bd8b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84">More...</a><br /></td></tr>
<tr class="separator:a79ac8c4685ed84eac8407164f3bd8b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459e8005102e85480432972f63642fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a459e8005102e85480432972f63642fa3">cend</a> () const</td></tr>
<tr class="memdesc:a459e8005102e85480432972f63642fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a459e8005102e85480432972f63642fa3">More...</a><br /></td></tr>
<tr class="separator:a459e8005102e85480432972f63642fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d5ce5ab802c9a066155cb6dd48f1ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a04d5ce5ab802c9a066155cb6dd48f1ae">end</a> () const</td></tr>
<tr class="memdesc:a04d5ce5ab802c9a066155cb6dd48f1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a459e8005102e85480432972f63642fa3" title="Synonym of const_past_oldest().">cend()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a04d5ce5ab802c9a066155cb6dd48f1ae">More...</a><br /></td></tr>
<tr class="separator:a04d5ce5ab802c9a066155cb6dd48f1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ab6e8a62d749a05a110182b0f97210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210">const_past_oldest</a> () const</td></tr>
<tr class="memdesc:a56ab6e8a62d749a05a110182b0f97210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210">More...</a><br /></td></tr>
<tr class="separator:a56ab6e8a62d749a05a110182b0f97210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744e1164473f7aa0c84ee94f550442d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a744e1164473f7aa0c84ee94f550442d3">rbegin</a> ()</td></tr>
<tr class="memdesc:a744e1164473f7aa0c84ee94f550442d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af098ce2f97e346ffb798fdef20157b07" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a744e1164473f7aa0c84ee94f550442d3">More...</a><br /></td></tr>
<tr class="separator:a744e1164473f7aa0c84ee94f550442d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af098ce2f97e346ffb798fdef20157b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af098ce2f97e346ffb798fdef20157b07">oldest</a> ()</td></tr>
<tr class="memdesc:af098ce2f97e346ffb798fdef20157b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af098ce2f97e346ffb798fdef20157b07">More...</a><br /></td></tr>
<tr class="separator:af098ce2f97e346ffb798fdef20157b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a1cedb57745b1f1ae61c0b6ffeec1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a82a1cedb57745b1f1ae61c0b6ffeec1a">rend</a> ()</td></tr>
<tr class="memdesc:a82a1cedb57745b1f1ae61c0b6ffeec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8783607ac3ae366759525ab67e79b54f" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a82a1cedb57745b1f1ae61c0b6ffeec1a">More...</a><br /></td></tr>
<tr class="separator:a82a1cedb57745b1f1ae61c0b6ffeec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783607ac3ae366759525ab67e79b54f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8783607ac3ae366759525ab67e79b54f">past_newest</a> ()</td></tr>
<tr class="memdesc:a8783607ac3ae366759525ab67e79b54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8783607ac3ae366759525ab67e79b54f">More...</a><br /></td></tr>
<tr class="separator:a8783607ac3ae366759525ab67e79b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a7d1d203dd1283176127e302b85e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aed5a7d1d203dd1283176127e302b85e7">crbegin</a> () const</td></tr>
<tr class="memdesc:aed5a7d1d203dd1283176127e302b85e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae415abb7c6b73bb42cde44b12113a154" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aed5a7d1d203dd1283176127e302b85e7">More...</a><br /></td></tr>
<tr class="separator:aed5a7d1d203dd1283176127e302b85e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae415abb7c6b73bb42cde44b12113a154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae415abb7c6b73bb42cde44b12113a154">const_oldest</a> () const</td></tr>
<tr class="memdesc:ae415abb7c6b73bb42cde44b12113a154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae415abb7c6b73bb42cde44b12113a154">More...</a><br /></td></tr>
<tr class="separator:ae415abb7c6b73bb42cde44b12113a154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcba3e940dd0b8126ca96b6338faf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9dcba3e940dd0b8126ca96b6338faf08">crend</a> () const</td></tr>
<tr class="memdesc:a9dcba3e940dd0b8126ca96b6338faf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae4e7882d9cbaea74f08b216b1e546cb8" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9dcba3e940dd0b8126ca96b6338faf08">More...</a><br /></td></tr>
<tr class="separator:a9dcba3e940dd0b8126ca96b6338faf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e7882d9cbaea74f08b216b1e546cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae4e7882d9cbaea74f08b216b1e546cb8">const_past_newest</a> () const</td></tr>
<tr class="memdesc:ae4e7882d9cbaea74f08b216b1e546cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae4e7882d9cbaea74f08b216b1e546cb8">More...</a><br /></td></tr>
<tr class="separator:ae4e7882d9cbaea74f08b216b1e546cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc92da73e1670a14bfa780cd6641134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134">empty</a> () const</td></tr>
<tr class="memdesc:afbc92da73e1670a14bfa780cd6641134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if container is empty.  <a href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134">More...</a><br /></td></tr>
<tr class="separator:afbc92da73e1670a14bfa780cd6641134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0949de5032e8dd6d75a48bcac9b060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aba0949de5032e8dd6d75a48bcac9b060">size</a> () const</td></tr>
<tr class="memdesc:aba0949de5032e8dd6d75a48bcac9b060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aba0949de5032e8dd6d75a48bcac9b060">More...</a><br /></td></tr>
<tr class="separator:aba0949de5032e8dd6d75a48bcac9b060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b07a93e11051e1cdb17ee9478b61321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2b07a93e11051e1cdb17ee9478b61321">max_size</a> () const</td></tr>
<tr class="memdesc:a2b07a93e11051e1cdb17ee9478b61321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max number of elements that can be stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2b07a93e11051e1cdb17ee9478b61321">More...</a><br /></td></tr>
<tr class="separator:a2b07a93e11051e1cdb17ee9478b61321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ade77a6fa3d84d5cb23b519601b5bd407"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ade77a6fa3d84d5cb23b519601b5bd407">Value_list</a> = std::list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &gt;</td></tr>
<tr class="memdesc:ade77a6fa3d84d5cb23b519601b5bd407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ade77a6fa3d84d5cb23b519601b5bd407">More...</a><br /></td></tr>
<tr class="separator:ade77a6fa3d84d5cb23b519601b5bd407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28527e53b183bdd4937e958b28c019e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a28527e53b183bdd4937e958b28c019e0">Value_list_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a></td></tr>
<tr class="memdesc:a28527e53b183bdd4937e958b28c019e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a28527e53b183bdd4937e958b28c019e0">More...</a><br /></td></tr>
<tr class="separator:a28527e53b183bdd4937e958b28c019e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb9174f029c4c3e44146d5e86fb5a1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#addb9174f029c4c3e44146d5e86fb5a1f">Value_list_const_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a></td></tr>
<tr class="memdesc:addb9174f029c4c3e44146d5e86fb5a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>const</code> iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs.  <a href="classflow_1_1util_1_1Linked__hash__map.html#addb9174f029c4c3e44146d5e86fb5a1f">More...</a><br /></td></tr>
<tr class="separator:addb9174f029c4c3e44146d5e86fb5a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccd98336b0a2739062365b222d1b02b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acccd98336b0a2739062365b222d1b02b">Key_to_value_iter_map</a> = boost::unordered_map&lt; Key, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a28527e53b183bdd4937e958b28c019e0">Value_list_iter</a>, Hash, Pred &gt;</td></tr>
<tr class="memdesc:acccd98336b0a2739062365b222d1b02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a hash map that maps <code>Key</code> to iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs.  <a href="classflow_1_1util_1_1Linked__hash__map.html#acccd98336b0a2739062365b222d1b02b">More...</a><br /></td></tr>
<tr class="separator:acccd98336b0a2739062365b222d1b02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad4ae26c5077ae7f7c6799b53f6efc8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad4ae26c5077ae7f7c6799b53f6efc8a8">insert_impl</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;key_and_mapped)</td></tr>
<tr class="memdesc:ad4ae26c5077ae7f7c6799b53f6efc8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">m_keys_into_list_map</a> so that <code>key_and_mapped</code>'s copy is inserted into the structure.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad4ae26c5077ae7f7c6799b53f6efc8a8">More...</a><br /></td></tr>
<tr class="separator:ad4ae26c5077ae7f7c6799b53f6efc8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3c2ebf269951f5fe2412b6a77303b5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ade77a6fa3d84d5cb23b519601b5bd407">Value_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba">m_value_list</a></td></tr>
<tr class="memdesc:a3c2ebf269951f5fe2412b6a77303b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual values &ndash; which, as in <code>unordered_map&lt;K, M&gt;</code>, are instances of <code>Value</code> = <code>pair&lt;Key, Mapped&gt;</code> &ndash; are stored in here, in the order in which user would iterate over them.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba">More...</a><br /></td></tr>
<tr class="separator:a3c2ebf269951f5fe2412b6a77303b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016890a8c1d3483041d19af810cb6867"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acccd98336b0a2739062365b222d1b02b">Key_to_value_iter_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867">m_keys_into_list_map</a></td></tr>
<tr class="memdesc:a016890a8c1d3483041d19af810cb6867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps each <code>Key K</code> that is in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> to an iterator into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> (note the iterator points to a <code>Value</code> instance, which itself contains a copy of <code>K</code> but also the <code>Mapped</code> value, in which the user likely has keen interest).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867">More...</a><br /></td></tr>
<tr class="separator:a016890a8c1d3483041d19af810cb6867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9bec37057b3abab90a9732d293116e5b"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </td></tr>
<tr class="memitem:a9bec37057b3abab90a9732d293116e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9bec37057b3abab90a9732d293116e5b">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;val1, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;val2)</td></tr>
<tr class="memdesc:a9bec37057b3abab90a9732d293116e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>val1.swap(val2)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9bec37057b3abab90a9732d293116e5b">More...</a><br /></td></tr>
<tr class="separator:a9bec37057b3abab90a9732d293116e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Mapped, typename Hash, typename Pred&gt;<br />
class flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;</div><p >An object of this class is a map that combines the lookup speed of a <code>boost::unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of an <code>std::list&lt;&gt;</code>. </p>
<p >The API is generally that of an <code>unordered_map&lt;&gt;</code>. The differences essentially all have to do with iterators. This map introduces a concept of "newness," which determines the iteration order. Moreover, <em>every</em> iterator remains valid except (of course) under erasure of the underlying element. Newness is defined as follows inductively: whenever an element is inserted, it is "newest," thus it is placed at the front of the iterator order. Furthermore, the methods <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> can be used to make any element "newest" (moved to the front of the iterator order). Iterator thus formed orders elements from newest to oldest (hence <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac0c854154d3ec15ab98905ebf9ee1f20" title="Synonym of newest().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a83e94bd9656d06ee20050c797f6eb248" title="Synonym of past_oldest().">end()</a>).</p>
<p >Performance expectations: The best way to determine a method's time needs is to imagine what it must do. If it must perform a lookup by key, that is an <code>unordered_map&lt;&gt;</code> lookup resulting in an (at least internal) iterator. If it must insert an element, it is always inserted at the start of a <code>list</code>; and also into an <code>unordered_map&lt;&gt;</code>. If it must erase an element based on an iterator, that element is erased from a list based on that iterator; and also by key from an <code>unordered_map&lt;&gt;</code>. Iteration itself is iteration along a <code>list</code>. But essentially, every operation is either near constant time or constant time. In terms of space needs, this essentially stores the values themselves in a <code>list</code>; and also a copy of each key in an <code>unordered_map&lt;&gt;</code>, which also stores a pointer or list iterator per element.</p>
<h3>Thread safety</h3>
<p >Same as for <code>unordered_map&lt;&gt;</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type. Same requirements and behavior as <code>unordered_map&lt;&gt;</code> counterpart. Also (is it "in particular"?): <code>Key</code> must be Assignable, which is STL-speak for: If <code>Key x, y</code> are objects of this type, then <code>x = y;</code> is valid and has all the usual semantics. (There are other requirements, but that's the "controversial" one of interest.) In particular, <code>Key</code> cannot be of the form <code>T const</code> &ndash; more commonly written as <code>const T</code> (but recall that, say, <code>const char*</code> = <code>char const *</code> really; which is therefore fine here). </td></tr>
    <tr><td class="paramname">Mapped</td><td>The 2nd (satellite) part of the <code>Value</code> pair type. Same requirements and behavior as <code>unordered_map&lt;&gt;</code> counterpart. Colloquially, in a K-&gt;V map, this is V, while formally the values stored are (K, V) pairs. </td></tr>
    <tr><td class="paramname">Hash</td><td>Hasher type. Same requirements and behavior as <code>unordered_map&lt;&gt;</code> counterpart. To get a hasher object, one must be able to call: <code>Hash h = Hash()</code>. To then hash a <code>Key</code>, one must be able to call <code>h(key)</code>. Typically one will simply define a <code>size_t hash_value(Key)</code> function, which will be activated via the default value for this template parameter. Defaults to <code>boost::hash&lt;Key&gt;</code>. </td></tr>
    <tr><td class="paramname">Pred</td><td>Equality functor type. Same requirements and behavior as <code>unordered_map&lt;&gt;</code> counterpart. Once a functor object <code>Pred e = Pred()</code> is obtained, <code>bool eq = e(a, b)</code> must return whether <code>a</code> equals <code>b</code>, where <code>a</code> and <code>b</code> are keys. Typically <code><a class="el" href="namespaceflow_1_1log.html#abfd655adc908d249fe66baf6e8e426e6" title="Checks for exact equality of two Verbosity_config objects.">operator==()</a></code> will be used via the default template parameter. Defaults to <code>std::equal_to&lt;Key&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00075">75</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2185f193ced2c3c0bf566b06f54b7c83" name="a2185f193ced2c3c0bf566b06f54b7c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2185f193ced2c3c0bf566b06f54b7c83">&#9670;&nbsp;</a></span>Const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Const_iterator =  typename Value_list::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00102">102</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a2b5383264c89ac63cc8827b18063f2ca" name="a2b5383264c89ac63cc8827b18063f2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5383264c89ac63cc8827b18063f2ca">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00131">131</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a657eef8b8299a7c87d48a6e373a6db3a" name="a657eef8b8299a7c87d48a6e373a6db3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657eef8b8299a7c87d48a6e373a6db3a">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_pointer =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>const Key</code>/<code>Mapped</code> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00123">123</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a82d0a782f7dee3fefaae51e85d05657b" name="a82d0a782f7dee3fefaae51e85d05657b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d0a782f7dee3fefaae51e85d05657b">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_reference =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>const Key</code>/<code>Mapped</code> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00127">127</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a10095310ddb7fe3d7cf35d957cc1c477" name="a10095310ddb7fe3d7cf35d957cc1c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10095310ddb7fe3d7cf35d957cc1c477">&#9670;&nbsp;</a></span>Const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Const_reverse_iterator =  typename Value_list::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into an immutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00108">108</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a033e6ec5c7dd0e9b08ba7fa9490f41ce" name="a033e6ec5c7dd0e9b08ba7fa9490f41ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033e6ec5c7dd0e9b08ba7fa9490f41ce">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for difference of <code>size_type</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00096">96</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="adeaf16f8986f32d223e2123b14652bb3" name="adeaf16f8986f32d223e2123b14652bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaf16f8986f32d223e2123b14652bb3">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::hasher =  Hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Hash</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00117">117</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a2f55a43df7939163f3ad5b713eb20c99" name="a2f55a43df7939163f3ad5b713eb20c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f55a43df7939163f3ad5b713eb20c99">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Iterator =  typename Value_list::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into a mutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00099">99</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1f09f98b4089a8c3ffd0b7f732923b44" name="a1f09f98b4089a8c3ffd0b7f732923b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f09f98b4089a8c3ffd0b7f732923b44">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00129">129</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a6ba81d115e3073afb88d5eb1cd85125e" name="a6ba81d115e3073afb88d5eb1cd85125e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba81d115e3073afb88d5eb1cd85125e">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::key_equal =  Pred</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Pred</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00119">119</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="acccd98336b0a2739062365b222d1b02b" name="acccd98336b0a2739062365b222d1b02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccd98336b0a2739062365b222d1b02b">&#9670;&nbsp;</a></span>Key_to_value_iter_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Key_to_value_iter_map =  boost::unordered_map&lt;Key, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a28527e53b183bdd4937e958b28c019e0">Value_list_iter</a>, Hash, Pred&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for a hash map that maps <code>Key</code> to iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00564">564</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ac57eb929f45956c9dd2de271d59509cc" name="ac57eb929f45956c9dd2de271d59509cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57eb929f45956c9dd2de271d59509cc">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::key_type =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Key</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00111">111</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="add4b2bf1d3c8c99b5b6667ace94c8ff2" name="add4b2bf1d3c8c99b5b6667ace94c8ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4b2bf1d3c8c99b5b6667ace94c8ff2">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::mapped_type =  Mapped</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Mapped</code> type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00113">113</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a96567fe2fdd1de19954ddef1617c1610" name="a96567fe2fdd1de19954ddef1617c1610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96567fe2fdd1de19954ddef1617c1610">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::pointer =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): pointer to <code>Key</code>/<code>Mapped</code> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00121">121</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a756a28e2ed92e3ef8aff3fe392abd4a8" name="a756a28e2ed92e3ef8aff3fe392abd4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a28e2ed92e3ef8aff3fe392abd4a8">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::reference =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): reference to <code>Key</code>/<code>Mapped</code> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00125">125</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a18f09acd8df06d9479840862b228463d" name="a18f09acd8df06d9479840862b228463d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f09acd8df06d9479840862b228463d">&#9670;&nbsp;</a></span>Reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Reverse_iterator =  typename Value_list::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into a mutable structure of this type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00105">105</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ab33cde46cfc7ea7e7366c842b09dae30" name="ab33cde46cfc7ea7e7366c842b09dae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33cde46cfc7ea7e7366c842b09dae30">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for index into array of items, where items are all applicable objects including <code>Value</code>s and <code>Key</code>s. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00094">94</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="af8b3b1128da79536a4c86e9feadb0c66" name="af8b3b1128da79536a4c86e9feadb0c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b3b1128da79536a4c86e9feadb0c66">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Value =  std::pair&lt;Key const, Mapped&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for key/mapped-value pairs stored in the structure. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00081">81</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ade77a6fa3d84d5cb23b519601b5bd407" name="ade77a6fa3d84d5cb23b519601b5bd407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade77a6fa3d84d5cb23b519601b5bd407">&#9670;&nbsp;</a></span>Value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Value_list =  std::list&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00087">87</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="addb9174f029c4c3e44146d5e86fb5a1f" name="addb9174f029c4c3e44146d5e86fb5a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9174f029c4c3e44146d5e86fb5a1f">&#9670;&nbsp;</a></span>Value_list_const_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Value_list_const_iter =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <code>const</code> iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00561">561</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a28527e53b183bdd4937e958b28c019e0" name="a28527e53b183bdd4937e958b28c019e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28527e53b183bdd4937e958b28c019e0">&#9670;&nbsp;</a></span>Value_list_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Value_list_iter =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for iterator into doubly linked list of (<code>Key</code>, <code>Mapped</code>) pairs. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00558">558</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="af0885cc03a4dffbaffe810b6cd8e28f6" name="af0885cc03a4dffbaffe810b6cd8e28f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0885cc03a4dffbaffe810b6cd8e28f6">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::value_type =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For container compliance (hence the irregular capitalization): <code>Key</code>/<code>Mapped</code> pair type. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00115">115</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab99f2ee682a21a0abffbaf14d18ba739" name="ab99f2ee682a21a0abffbaf14d18ba739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99f2ee682a21a0abffbaf14d18ba739">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash const &amp;&#160;</td>
          <td class="paramname"><em>hasher_instance</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>key_equal_instance</em> = <code>Pred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty structure with some basic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_buckets</td><td>Number of buckets for the unordered (hash) table. Special value -1 (default) will cause us to use whatever <code>unordered_map&lt;&gt;</code> would use by default. </td></tr>
    <tr><td class="paramname">hasher_instance</td><td>Instance of the hash function type (<code>hasher_instance(Key k)</code> should be <code>size_type</code>d hash of key <code>k</code>). </td></tr>
    <tr><td class="paramname">key_equal_instance</td><td>Instance of the equality function type (<code>key_equal_instance(Key k1, Key k2)</code> should return <code>true</code> if and only if <code>k1</code> equals <code>k2</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00622">622</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a9fd21d7c1ff342b91ad9a8ea85a9c0d7" name="a9fd21d7c1ff342b91ad9a8ea85a9c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd21d7c1ff342b91ad9a8ea85a9c0d7">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash const &amp;&#160;</td>
          <td class="paramname"><em>hasher_instance</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>key_equal_instance</em> = <code>Pred()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs structure with some basic parameters, and values initialized from initializer list. </p>
<p >The values are inserted as if <code>insert(v)</code> was called for each pair <code>v</code> in <code>values</code> <em>in reverse order</em>. Since the canonical ordering places the <em>newest</em> (last inserted/touch()ed) element at the <em>front</em> of the ordering, that means that forward iteration through the set (right after this constructor runs) will yield values in the <em>same</em> order as in initializer list <code>values</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Values with which to fill the structure after initializing it. Typically you'd provide a series of key/value pairs like this: <code>{{ key1, value1 }, { key2, value2 }, ...}</code>. They will appear in iterated sequence in the same order as they appear in this list. </td></tr>
    <tr><td class="paramname">n_buckets</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">hasher_instance</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">key_equal_instance</td><td>See other constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00631">631</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00614">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_keys_into_list_map</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00597">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_value_list</a>.</p>

</div>
</div>
<a id="a2d9916fa373399e71fd72f5a97d2b0e6" name="a2d9916fa373399e71fd72f5a97d2b0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9916fa373399e71fd72f5a97d2b0e6">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object that is a copy of the given source. </p>
<p >Equivalent to <code>operator=(src)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00661">661</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00676">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a2d9916fa373399e71fd72f5a97d2b0e6_cgraph.svg" width="394" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac0ee7a7164ec56bfd75886624c8540a5" name="ac0ee7a7164ec56bfd75886624c8540a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee7a7164ec56bfd75886624c8540a5">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object by making it equal to the given source, while the given source becomes as-if default-cted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00668">668</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00676">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_ac0ee7a7164ec56bfd75886624c8540a5_cgraph.svg" width="394" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6eb7505e57af6c01e4e4fefd9215c0d2" name="a6eb7505e57af6c01e4e4fefd9215c0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb7505e57af6c01e4e4fefd9215c0d2">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">::Value</a> &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a>)</code>. </p>
<p >All other comments for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1321c368f128cb7abdbb9e8fa0abfc34" title="Returns reference to mutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(this...">front()</a> apply analogously.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable <code>Mapped</code> value directly inside the data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00845">845</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ac0c854154d3ec15ab98905ebf9ee1f20" name="ac0c854154d3ec15ab98905ebf9ee1f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c854154d3ec15ab98905ebf9ee1f20">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00951">951</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aebda9f2cdcc5a1025183c0151a6e90bb" name="aebda9f2cdcc5a1025183c0151a6e90bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebda9f2cdcc5a1025183c0151a6e90bb">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3fe7332e582b6f51c1a2c5cb91c1d270" title="Synonym of const_newest().">cbegin()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3fe7332e582b6f51c1a2c5cb91c1d270" title="Synonym of const_newest().">cbegin()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00986">986</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a3fe7332e582b6f51c1a2c5cb91c1d270" name="a3fe7332e582b6f51c1a2c5cb91c1d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe7332e582b6f51c1a2c5cb91c1d270">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00979">979</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a459e8005102e85480432972f63642fa3" name="a459e8005102e85480432972f63642fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459e8005102e85480432972f63642fa3">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01000">1000</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ad6a07419164377068bc2af59d2b024da" name="ad6a07419164377068bc2af59d2b024da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a07419164377068bc2af59d2b024da">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aba0949de5032e8dd6d75a48bcac9b060" title="Returns number of elements stored.">size()</a> == 0</code>. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00926">926</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="af04001f6ec7789a5715cc9a135db876a" name="af04001f6ec7789a5715cc9a135db876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04001f6ec7789a5715cc9a135db876a">&#9670;&nbsp;</a></span>const_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">::Value</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable back ("oldest") element in the structure; formally equivalent to <code>*(--this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>)</code>. </p>
<p >All other comments for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a775a99fd89e114b1efffce15c974e76e" title="Returns reference to immutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(th...">const_front()</a> apply analogously.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to immutable <code>Mapped</code> value directly inside the data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00861">861</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a775a99fd89e114b1efffce15c974e76e" name="a775a99fd89e114b1efffce15c974e76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a99fd89e114b1efffce15c974e76e">&#9670;&nbsp;</a></span>const_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">::Value</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a79ac8c4685ed84eac8407164f3bd8b84" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>)</code>. </p>
<p >OK to call when <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>; but behavior undefined if you attempt to access the result in any way if either <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a> when this was called; or if <code>!empty()</code> at that time, but the underlying element is erased at time of access. If not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a> when this was called, then resulting reference continues to be valid as long as the underlying element is not erased; however, in the future the reference (while referring to the same element) may not refer to front ("newest") element any longer. (Informally, most uses would only call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1321c368f128cb7abdbb9e8fa0abfc34" title="Returns reference to mutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(this...">front()</a> when <code>!empty()</code>, and would access it immediately and but once. However, I'm listing the corner cases above.)</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to immutable <code>Mapped</code> value directly inside the data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00853">853</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a79ac8c4685ed84eac8407164f3bd8b84" name="a79ac8c4685ed84eac8407164f3bd8b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ac8c4685ed84eac8407164f3bd8b84">&#9670;&nbsp;</a></span>const_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00972">972</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ae415abb7c6b73bb42cde44b12113a154" name="ae415abb7c6b73bb42cde44b12113a154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae415abb7c6b73bb42cde44b12113a154">&#9670;&nbsp;</a></span>const_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01042">1042</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="ae4e7882d9cbaea74f08b216b1e546cb8" name="ae4e7882d9cbaea74f08b216b1e546cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e7882d9cbaea74f08b216b1e546cb8">&#9670;&nbsp;</a></span>const_past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01056">1056</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a56ab6e8a62d749a05a110182b0f97210" name="a56ab6e8a62d749a05a110182b0f97210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ab6e8a62d749a05a110182b0f97210">&#9670;&nbsp;</a></span>const_past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::const_past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00993">993</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1a462e0299e3da43f4f41b86205cd520" name="a1a462e0299e3da43f4f41b86205cd520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a462e0299e3da43f4f41b86205cd520">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::count </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times a key is equivalent to the given one is present in the map: either 1 or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or 1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00813">813</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aed5a7d1d203dd1283176127e302b85e7" name="aed5a7d1d203dd1283176127e302b85e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a7d1d203dd1283176127e302b85e7">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae415abb7c6b73bb42cde44b12113a154" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae415abb7c6b73bb42cde44b12113a154" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01049">1049</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a9dcba3e940dd0b8126ca96b6338faf08" name="a9dcba3e940dd0b8126ca96b6338faf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcba3e940dd0b8126ca96b6338faf08">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a10095310ddb7fe3d7cf35d957cc1c477">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae4e7882d9cbaea74f08b216b1e546cb8" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae4e7882d9cbaea74f08b216b1e546cb8" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01063">1063</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="afbc92da73e1670a14bfa780cd6641134" name="afbc92da73e1670a14bfa780cd6641134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc92da73e1670a14bfa780cd6641134">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if container is empty. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01076">1076</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a83e94bd9656d06ee20050c797f6eb248" name="a83e94bd9656d06ee20050c797f6eb248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e94bd9656d06ee20050c797f6eb248">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaf38a12a6f65110d7e3dae3836c5abee" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator.">past_oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00965">965</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a04d5ce5ab802c9a066155cb6dd48f1ae" name="a04d5ce5ab802c9a066155cb6dd48f1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d5ce5ab802c9a066155cb6dd48f1ae">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a459e8005102e85480432972f63642fa3" title="Synonym of const_past_oldest().">cend()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a459e8005102e85480432972f63642fa3" title="Synonym of const_past_oldest().">cend()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01007">1007</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a0d49cf64db7d8eaff56089fd5682ecc0" name="a0d49cf64db7d8eaff56089fd5682ecc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d49cf64db7d8eaff56089fd5682ecc0">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element pointed to by the given valid iterator. </p>
<p >Behavior undefined if it is not valid. <code>it</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator of element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator one position past (i.e., "older") than <code>it</code>, before <code>*it</code> was removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00889">889</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="af0fed31c62ca52236abca34cef88441c" name="af0fed31c62ca52236abca34cef88441c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fed31c62ca52236abca34cef88441c">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it_newest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it_past_oldest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>). </p>
<p >Behavior undefined if a given iterator is invalid. <code>it_newest</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it_newest</td><td>Iterator of first ("newest") element to erase. </td></tr>
    <tr><td class="paramname">it_past_oldest</td><td>Iterator of one past last ("oldest") element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>it_past_oldest</code> copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00897">897</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a3a5134b1294700d6905b8fdd650289b7" name="a3a5134b1294700d6905b8fdd650289b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5134b1294700d6905b8fdd650289b7">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element with the given key, if it exists. </p>
<p >Return value indicates various info of interest about what occurred or did not occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key such that its equal's (if found) element will be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased (0 or 1). </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00910">910</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aa06ac5737a9189f29ce9355d33a81c8b" name="aa06ac5737a9189f29ce9355d33a81c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06ac5737a9189f29ce9355d33a81c8b">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find value at the given key in the map. </p>
<p >Key presence is determined according to the <code>Pred</code> template parameter which determines equality of 2 given keys; and via the <code>Hash</code> template parameter that enables efficient hash-based lookup. The returned iterator (if valid) can be used to mutate the elements inside the map.</p>
<p >As long as the value is not removed from the map, the reference will continue to be valid.</p>
<p >Any subsequent writes to the referred to (by returned iterator) area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it, call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a83e94bd9656d06ee20050c797f6eb248" title="Synonym of past_oldest().">end()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00797">797</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="abb8c1fd9a157d99d0a6417ad34f74e52" name="abb8c1fd9a157d99d0a6417ad34f74e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8c1fd9a157d99d0a6417ad34f74e52">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find value at the given key in the map. </p>
<p >Key presence is determined according to the <code>Pred</code> template parameter which determines equality of 2 given keys; and via the <code>Hash</code> template parameter that enables efficient hash-based lookup. The returned iterator (if valid) cannot be used to mutate the elements inside the map.</p>
<p >As long as the value is not removed from the map, the iterator will continue to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a56ab6e8a62d749a05a110182b0f97210" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00805">805</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a1321c368f128cb7abdbb9e8fa0abfc34" name="a1321c368f128cb7abdbb9e8fa0abfc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1321c368f128cb7abdbb9e8fa0abfc34">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">::Value</a> &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable front ("newest") element in the structure; formally equivalent to <code>*(this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4b796f7ddb4dbc2f2e64ea25985d43b8" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator.">newest()</a>)</code>. </p>
<p >OK to call when <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>; but behavior undefined if you attempt to access the result in any way if either <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a> when this was called; or if <code>!empty()</code> at that time, but the underlying element is erased at time of access. If not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a> when this was called, then resulting reference continues to be valid as long as the underlying element is not erased; however, in the future the reference (while referring to the same element) might not refer to front ("newest") element any longer. (Informally, most uses would only call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1321c368f128cb7abdbb9e8fa0abfc34" title="Returns reference to mutable front (&quot;newest&quot;) element in the structure; formally equivalent to *(this...">front()</a> when <code>!empty()</code>, and would access it immediately and but once. However, I'm listing the corner cases above.)</p>
<p >Note that if <code>Mapped&amp; x</code> is returned, then although <code>x</code> is mutable, in actuality <code>x.first</code> is const; so only <code>x.second</code> is truly mutable. You must not write to the key (such as via a <code>const_cast&lt;&gt;</code>); doing so will result in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable value directly inside the data structure; or to undefined location if currently <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#afbc92da73e1670a14bfa780cd6641134" title="Returns true if and only if container is empty.">empty()</a>. Note that only the <code>Mapped</code> part of <code>Value</code> is mutable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00837">837</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aae7a4a3047c90f0ab26ae1a4ec7b9963" name="aae7a4a3047c90f0ab26ae1a4ec7b9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7a4a3047c90f0ab26ae1a4ec7b9963">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert the given key/mapped-value pair into the map. </p>
<p >If the key is already present in the map, does nothing. Return value indicates various info of interest about what occurred or did not occur. Key presence is determined according to the <code>Pred</code> template parameter which determines equality of 2 given keys; and via the <code>Hash</code> template parameter that enables efficient hash-based lookup. If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>The key/mapped-value pair to attempt to insert. This value is copied, and the copy is inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair whose second element is true if and only if the insertion occurred; and whose first element is an iterator pointing to either the newly inserted element or already present one with a key equal to <code>key_and_mapped.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00761">761</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05689">flow::net_flow::Node::close_connection_immediately()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aae7a4a3047c90f0ab26ae1a4ec7b9963_icgraph.svg" width="1643" height="699"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad4ae26c5077ae7f7c6799b53f6efc8a8" name="ad4ae26c5077ae7f7c6799b53f6efc8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ae26c5077ae7f7c6799b53f6efc8a8">&#9670;&nbsp;</a></span>insert_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::insert_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Value</a> const &amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that modifies <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">m_keys_into_list_map</a> so that <code>key_and_mapped</code>'s copy is inserted into the structure. </p>
<p >Pre-condition is that <code>key_and_mapped.first</code> is not in the structure (else behavior undefined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>Same as in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963" title="Attempts to insert the given key/mapped-value pair into the map.">insert()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as in <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aae7a4a3047c90f0ab26ae1a4ec7b9963" title="Attempts to insert the given key/mapped-value pair into the map.">insert()</a>.first</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00781">781</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a2b07a93e11051e1cdb17ee9478b61321" name="a2b07a93e11051e1cdb17ee9478b61321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b07a93e11051e1cdb17ee9478b61321">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max number of elements that can be stored. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;</code> + <code>list&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01083">1083</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a4b796f7ddb4dbc2f2e64ea25985d43b8" name="a4b796f7ddb4dbc2f2e64ea25985d43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b796f7ddb4dbc2f2e64ea25985d43b8">&#9670;&nbsp;</a></span>newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00944">944</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="af098ce2f97e346ffb798fdef20157b07" name="af098ce2f97e346ffb798fdef20157b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af098ce2f97e346ffb798fdef20157b07">&#9670;&nbsp;</a></span>oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01014">1014</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aa05f597ec2dcb9fd1d50ff40ca482232" name="aa05f597ec2dcb9fd1d50ff40ca482232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05f597ec2dcb9fd1d50ff40ca482232">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object making it equal to the given source, while the given source becomes as-if default-cted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied (unless it <em>is</em> <code>*this</code>; then no-op). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00749">749</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="basic__blob_8hpp_source.html#l01659">flow::util::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aa05f597ec2dcb9fd1d50ff40ca482232_cgraph.svg" width="312" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acdba28273d24b962c76b1926a93d9772" name="acdba28273d24b962c76b1926a93d9772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdba28273d24b962c76b1926a93d9772">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object with a copy of the given source. </p>
<p >We become equal to <code>src</code> but independent of it to the max extent possible (if you've got pointers stored in there, for example, the pointers are copied, not the values at those pointers). In addition, the hasher instance and equality predicate are copied from <code>src</code>. Finally, a reasonable attempt is made to also make the internal structure of the hash map to be similar to that of `src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00676">676</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00614">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_keys_into_list_map</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00597">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_value_list</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00661">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_acdba28273d24b962c76b1926a93d9772_icgraph.svg" width="394" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a60d1d95f11148f7ed30a7dd92193563a" name="a60d1d95f11148f7ed30a7dd92193563a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d1d95f11148f7ed30a7dd92193563a">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mapped &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>insert(Value(key, Mapped())).first-&gt;second</code> (but avoids unnecessarily invoking <code>Mapped()</code>/generally strives for better performance). </p>
<p >Less formally, it either finds the value at the given key, or if not found inserts one with a default-constructed value; then returns reference to the in-structure stored <code>Mapped</code> value which can be used to to read and/or modify that value directly.</p>
<p >Note that if <code>Mapped&amp; x</code> is returned, then although <code>x</code> is mutable, in actuality <code>x.first</code> is <code>const</code>; so only <code>x.second</code> is truly mutable. You must not write to the key (such as via a <code>const_cast&lt;&gt;</code>); doing so will result in undefined behavior.</p>
<p >If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected.</p>
<p >As long as the value is not removed from the map, the reference will continue to be valid.</p>
<p >Any subsequent writes to the referred to area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it, call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find or insert if not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable Mapped value directly inside the data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00819">819</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a8783607ac3ae366759525ab67e79b54f" name="a8783607ac3ae366759525ab67e79b54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8783607ac3ae366759525ab67e79b54f">&#9670;&nbsp;</a></span>past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01028">1028</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aaf38a12a6f65110d7e3dae3836c5abee" name="aaf38a12a6f65110d7e3dae3836c5abee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf38a12a6f65110d7e3dae3836c5abee">&#9670;&nbsp;</a></span>past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2f55a43df7939163f3ad5b713eb20c99">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00958">958</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a744e1164473f7aa0c84ee94f550442d3" name="a744e1164473f7aa0c84ee94f550442d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744e1164473f7aa0c84ee94f550442d3">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af098ce2f97e346ffb798fdef20157b07" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af098ce2f97e346ffb798fdef20157b07" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01021">1021</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a82a1cedb57745b1f1ae61c0b6ffeec1a" name="a82a1cedb57745b1f1ae61c0b6ffeec1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a1cedb57745b1f1ae61c0b6ffeec1a">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18f09acd8df06d9479840862b228463d">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8783607ac3ae366759525ab67e79b54f" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8783607ac3ae366759525ab67e79b54f" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01035">1035</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="aba0949de5032e8dd6d75a48bcac9b060" name="aba0949de5032e8dd6d75a48bcac9b060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0949de5032e8dd6d75a48bcac9b060">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ab33cde46cfc7ea7e7366c842b09dae30">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored. </p>
<p >Same performance as of <code>unordered_map&lt;&gt;.</code> </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01070">1070</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00761">flow::net_flow::Event_set::ev_type_to_socks_map_sizes_to_str()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_aba0949de5032e8dd6d75a48bcac9b060_icgraph.svg" width="1571" height="518"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8d864e5d7aaeacd550a191b90eebd46c" name="a8d864e5d7aaeacd550a191b90eebd46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d864e5d7aaeacd550a191b90eebd46c">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>. </p>
<p >This is a constant-time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00933">933</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00614">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_keys_into_list_map</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00597">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::m_value_list</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l01089">flow::util::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l01089">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a8d864e5d7aaeacd550a191b90eebd46c_cgraph.svg" width="286" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a8d864e5d7aaeacd550a191b90eebd46c_icgraph.svg" width="299" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8b397bc5f47417578c5698453458276a" name="a8b397bc5f47417578c5698453458276a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b397bc5f47417578c5698453458276a">&#9670;&nbsp;</a></span>touch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::touch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2185f193ced2c3c0bf566b06f54b7c83">Const_iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a valid iterator into the structure, makes the pointed to element "newest" by moving it from wherever it is to be first in the iteration order. </p>
<p >Behavior undefined if iterator invalid.</p>
<p >The iterator continues to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to an element of the structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00868">868</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<a id="a746009717774ae07758093d75d33052a" name="a746009717774ae07758093d75d33052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746009717774ae07758093d75d33052a">&#9670;&nbsp;</a></span>touch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key. </p>
<p >Return value indicates various info of interest about what occurred or did not occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key was found (even if it was already "newest"); <code>false</code> if not found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00874">874</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9bec37057b3abab90a9732d293116e5b" name="a9bec37057b3abab90a9732d293116e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bec37057b3abab90a9732d293116e5b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt; &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>val1.swap(val2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l01089">1089</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__map_8hpp_source.html#l00933">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::swap()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Linked__hash__map_a9bec37057b3abab90a9732d293116e5b_cgraph.svg" width="454" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a016890a8c1d3483041d19af810cb6867" name="a016890a8c1d3483041d19af810cb6867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016890a8c1d3483041d19af810cb6867">&#9670;&nbsp;</a></span>m_keys_into_list_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acccd98336b0a2739062365b222d1b02b">Key_to_value_iter_map</a>&gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::m_keys_into_list_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps each <code>Key K</code> that is in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> to an iterator into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> (note the iterator points to a <code>Value</code> instance, which itself contains a copy of <code>K</code> but also the <code>Mapped</code> value, in which the user likely has keen interest). </p>
<p >This supplies the one capability <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> alone cannot: near-constant-time lookup of a <code>Value</code> or a <code>Mapped</code> by <code>Key</code> (a linear search would be necessary).</p>
<p >The <code>unique_ptr&lt;&gt;</code> wrapper remains constant after setting it to non-null. Why have it at all? Because in at least one constructor we are unable to determine all the constructor arguments by the time the constructor body executes, and we don't want to construct the map until then.</p>
<h3>Performance</h3>
<p >Anything they'll need to do to this map carries the same performance cost as if they used a straight <code>unordered_map&lt;&gt;</code>, so by definition it is acceptable. The only operation this does not provide is iteration and insertion in the proper order, and that's done through <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> instead. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00614">614</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00631">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00676">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::operator=()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00933">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::swap()</a>.</p>

</div>
</div>
<a id="a3c2ebf269951f5fe2412b6a77303b5ba" name="a3c2ebf269951f5fe2412b6a77303b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2ebf269951f5fe2412b6a77303b5ba">&#9670;&nbsp;</a></span>m_value_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Mapped , typename Hash , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ade77a6fa3d84d5cb23b519601b5bd407">Value_list</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key, Mapped, Hash, Pred &gt;::m_value_list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual values &ndash; which, as in <code>unordered_map&lt;K, M&gt;</code>, are instances of <code>Value</code> = <code>pair&lt;Key, Mapped&gt;</code> &ndash; are stored in here, in the order in which user would iterate over them. </p>
<p >If <code>Value v</code> is in this list, then no <code>Value v1 == v</code> can be elsewhere in the list. The order is semantically defined to be from "newest" to "oldest." Therefore, any newly inserted value goes at the START of the list. Similarly, any "touched" value is moved to the START of the list (see <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> and other methods that are documented as "touching" the referenced key). This ordering is what a normal <code>unordered_map&lt;K, M&gt;</code> would not supply (it's in the name!) but that we advertise.</p>
<p >Since <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">m_keys_into_list_map</a> stores keys, why store the keys here duplicately? Answer: that way we can expose iterators into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> directly to the user; so that they can take an iterator <code>I</code> and directly access the key and mapped value via <code>I-&gt;first</code> and <code>I-&gt;second</code>, respectively &ndash; as is expected of any map container. This does, however, come at some memory cost.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000150">Todo:</a></b></dt><dd>It is probably possible to cut down on the memory cost of storing, for each element, a copy of the <code>Key</code> in <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a> (in addition to the mandatory one in the lookup table <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a016890a8c1d3483041d19af810cb6867" title="Maps each Key K that is in m_value_list to an iterator into m_value_list (note the iterator points to...">m_keys_into_list_map</a>). Perhaps the key copy would be replaced by an iterator back into <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3c2ebf269951f5fe2412b6a77303b5ba" title="The actual values – which, as in unordered_map&lt;K, M&gt;, are instances of Value = pair&lt;Key,...">m_value_list</a>. A custom iterator class would be necessary to properly dereference this (this is non-trivial given that <code>operator*()</code> would have to return a reference to a pair which is no longer stored anywhere in this hypothetical design). Moreover, iterators exposed to the user would become invalid the same way an <code>unordered_map&lt;&gt;</code> iterator does due to seemingly unrelated changes. Finally, the memory savings would not even exist for <code>Key</code> types roughly the size of a pointer. All in all, not a slam-dunk....</dd></dl>
<h3>Performance</h3>
<p >Moving a value from anywhere to either end of the list is a constant-time operation (assuming the source location's iterator is known). Hence <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> is constant-time. Moreover, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8b397bc5f47417578c5698453458276a" title="Given a valid iterator into the structure, makes the pointed to element &quot;newest&quot; by moving it from wh...">touch()</a> does NOT involve a copy of a <code>Value</code> (it only involves assigning, internally, a few linked list pointers). Also note that insertion is similarly constant-time (but does, necessarily, require a <code>Value</code> copy as for any container). Finally, erasure is also constant-time. These are the only operations needed. </p>

<p class="definition">Definition at line <a class="el" href="linked__hash__map_8hpp_source.html#l00597">597</a> of file <a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="linked__hash__map_8hpp_source.html#l00631">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::Linked_hash_map()</a>, <a class="el" href="linked__hash__map_8hpp_source.html#l00676">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::operator=()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l00933">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="linked__hash__map_8hpp_source.html">linked_hash_map.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 19 2024 22:46:53 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
