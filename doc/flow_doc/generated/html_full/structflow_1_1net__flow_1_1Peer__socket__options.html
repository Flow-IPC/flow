<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Peer_socket_options Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structflow_1_1net__flow_1_1Peer__socket__options-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Peer_socket_options Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A set of low-level options affecting a single <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  
 <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="options_8hpp_source.html">options.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Peer_socket_options:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Peer__socket__options__coll__graph.svg" width="868" height="311"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42ce94dbc5d8be28134261c2eb18b245"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Congestion_control_strategy_choice</a> { <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245a13d31c1bffdbda8309c52bb997064862">S_CLASSIC</a> = 0
, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245a656db2a2ff0f24f703b6ac341e97537e">S_CLASSIC_BANDWIDTH_ESTIMATED</a>
 }</td></tr>
<tr class="memdesc:a42ce94dbc5d8be28134261c2eb18b245"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible choices for congestion control strategy for the socket.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">More...</a><br /></td></tr>
<tr class="separator:a42ce94dbc5d8be28134261c2eb18b245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65db0c4fdf22bf5723dc3018174b4aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Options_description</a> = boost::program_options::options_description</td></tr>
<tr class="memdesc:ad65db0c4fdf22bf5723dc3018174b4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for boost.program_options config options description. See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d94acf3c746c8f59c91ffa824ef8bd" title="Analogous to Node_options::setup_config_parsing().">setup_config_parsing()</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">More...</a><br /></td></tr>
<tr class="separator:ad65db0c4fdf22bf5723dc3018174b4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cbfb464f3251f63a06c753c986d277"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> = <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">flow::Fine_duration</a></td></tr>
<tr class="memdesc:a78cbfb464f3251f63a06c753c986d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time duration, with fine precision, that can be positive, zero, or negative (unless a specific option specifies an additional constraint to that effect).  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">More...</a><br /></td></tr>
<tr class="separator:a78cbfb464f3251f63a06c753c986d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac31b91c6f8c7b0d7a4e29fd218e5f9dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac31b91c6f8c7b0d7a4e29fd218e5f9dc">Peer_socket_options</a> ()</td></tr>
<tr class="memdesc:ac31b91c6f8c7b0d7a4e29fd218e5f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> with values equal to those used by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> when the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> creator chooses not to supply custom options.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac31b91c6f8c7b0d7a4e29fd218e5f9dc">More...</a><br /></td></tr>
<tr class="separator:ac31b91c6f8c7b0d7a4e29fd218e5f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d94acf3c746c8f59c91ffa824ef8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d94acf3c746c8f59c91ffa824ef8bd">setup_config_parsing</a> (<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Options_description</a> *opts_desc)</td></tr>
<tr class="memdesc:aa6d94acf3c746c8f59c91ffa824ef8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1" title="Modifies a boost.program_options options description object to enable subsequent parsing of a command...">Node_options::setup_config_parsing()</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d94acf3c746c8f59c91ffa824ef8bd">More...</a><br /></td></tr>
<tr class="separator:aa6d94acf3c746c8f59c91ffa824ef8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeaaf832a38a5e334789e81e214686ea7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">m_st_max_block_size</a></td></tr>
<tr class="memdesc:aeaaf832a38a5e334789e81e214686ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of block that we will strive to (and will, assuming at least that many bytes are available in Send buffer) pack into each outgoing DATA packet.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7">More...</a><br /></td></tr>
<tr class="separator:aeaaf832a38a5e334789e81e214686ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f18c8222ade5f99b83a85e0203ff130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8f18c8222ade5f99b83a85e0203ff130">m_st_connect_retransmit_period</a></td></tr>
<tr class="memdesc:a8f18c8222ade5f99b83a85e0203ff130"><td class="mdescLeft">&#160;</td><td class="mdescRight">How often to resend SYN or SYN_ACK while SYN_ACK or SYN_ACK_ACK, respectively, has not been received.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8f18c8222ade5f99b83a85e0203ff130">More...</a><br /></td></tr>
<tr class="separator:a8f18c8222ade5f99b83a85e0203ff130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75171c4f1086d0aa38248ae5ffba884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac75171c4f1086d0aa38248ae5ffba884">m_st_connect_retransmit_timeout</a></td></tr>
<tr class="memdesc:ac75171c4f1086d0aa38248ae5ffba884"><td class="mdescLeft">&#160;</td><td class="mdescRight">How long from the first SYN or SYN_ACK to allow for connection handshake before aborting connection.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac75171c4f1086d0aa38248ae5ffba884">More...</a><br /></td></tr>
<tr class="separator:ac75171c4f1086d0aa38248ae5ffba884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6086022691700f5e5d2dc87ca92fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8ca6086022691700f5e5d2dc87ca92fd">m_st_snd_buf_max_size</a></td></tr>
<tr class="memdesc:a8ca6086022691700f5e5d2dc87ca92fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes that the Send buffer can hold.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a8ca6086022691700f5e5d2dc87ca92fd">More...</a><br /></td></tr>
<tr class="separator:a8ca6086022691700f5e5d2dc87ca92fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171480324f26432928738532cb3c8556"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a171480324f26432928738532cb3c8556">m_st_rcv_buf_max_size</a></td></tr>
<tr class="memdesc:a171480324f26432928738532cb3c8556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes that the Receive buffer can hold.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a171480324f26432928738532cb3c8556">More...</a><br /></td></tr>
<tr class="separator:a171480324f26432928738532cb3c8556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a31f63eea6f89952a89ea0385d9a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad9a31f63eea6f89952a89ea0385d9a2e">m_st_rcv_flow_control_on</a></td></tr>
<tr class="memdesc:ad9a31f63eea6f89952a89ea0385d9a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether flow control (a/k/a receive window a/k/a rcv_wnd management) is enabled.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad9a31f63eea6f89952a89ea0385d9a2e">More...</a><br /></td></tr>
<tr class="separator:ad9a31f63eea6f89952a89ea0385d9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d16c98186187fdffadcfb853d58410"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d16c98186187fdffadcfb853d58410">m_st_rcv_buf_max_size_slack_percent</a></td></tr>
<tr class="memdesc:aa6d16c98186187fdffadcfb853d58410"><td class="mdescLeft">&#160;</td><td class="mdescRight">% of rcv-buf-max-size such that if Receive buffer stores up to (100 + this many) % of rcv-buf-max-size bytes, the bytes will still be accepted.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d16c98186187fdffadcfb853d58410">More...</a><br /></td></tr>
<tr class="separator:aa6d16c98186187fdffadcfb853d58410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af483d0292f363e7dbf14dc7a2dd49f3f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#af483d0292f363e7dbf14dc7a2dd49f3f">m_st_rcv_buf_max_size_to_advertise_percent</a></td></tr>
<tr class="memdesc:af483d0292f363e7dbf14dc7a2dd49f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">% of rcv-buf-max-size that has to be freed, since the last receive window advertisement, via user popping data from Receive buffer, before we must send a receive window advertisement.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#af483d0292f363e7dbf14dc7a2dd49f3f">More...</a><br /></td></tr>
<tr class="separator:af483d0292f363e7dbf14dc7a2dd49f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78ca6cf3c6da3bc24cea40d522f0bdb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#af78ca6cf3c6da3bc24cea40d522f0bdb">m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</a></td></tr>
<tr class="memdesc:af78ca6cf3c6da3bc24cea40d522f0bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit on the size of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a>, expressed as what percentage the maximal size of that structure times max-block-size is of the maximal receive buffer size.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#af78ca6cf3c6da3bc24cea40d522f0bdb">More...</a><br /></td></tr>
<tr class="separator:af78ca6cf3c6da3bc24cea40d522f0bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ccb9e8cd0715ca78e0710d2a6db06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#add7ccb9e8cd0715ca78e0710d2a6db06">m_st_delayed_ack_timer_period</a></td></tr>
<tr class="memdesc:add7ccb9e8cd0715ca78e0710d2a6db06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum amount of time to delay sending ACK with individual packet's acknowledgment since receiving that individual packet.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#add7ccb9e8cd0715ca78e0710d2a6db06">More...</a><br /></td></tr>
<tr class="separator:add7ccb9e8cd0715ca78e0710d2a6db06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a76f7ae03e258b30b04c7350481de6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7a76f7ae03e258b30b04c7350481de6">m_st_max_full_blocks_before_ack_send</a></td></tr>
<tr class="memdesc:ad7a76f7ae03e258b30b04c7350481de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are at least this many TIMES max-block-size bytes' worth of individual acknowledgments to be sent, then the delayed ACK timer is to be short-circuited, and the accumulated acknowledgments are to be sent as soon as possible.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7a76f7ae03e258b30b04c7350481de6">More...</a><br /></td></tr>
<tr class="separator:ad7a76f7ae03e258b30b04c7350481de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35e6014182ccfcbee6bed4571a8360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360">m_st_rexmit_on</a></td></tr>
<tr class="memdesc:a6c35e6014182ccfcbee6bed4571a8360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to enable reliability via retransmission.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360">More...</a><br /></td></tr>
<tr class="separator:a6c35e6014182ccfcbee6bed4571a8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37da87848d01220c7e58f90e6764ba"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a0b37da87848d01220c7e58f90e6764ba">m_st_max_rexmissions_per_packet</a></td></tr>
<tr class="memdesc:a0b37da87848d01220c7e58f90e6764ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If retransmission is enabled and a given packet is retransmitted this many times and has to be retransmitted yet again, the connection is reset.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a0b37da87848d01220c7e58f90e6764ba">More...</a><br /></td></tr>
<tr class="separator:a0b37da87848d01220c7e58f90e6764ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02afb5ed4201d83c87a3a30fcbdda489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a02afb5ed4201d83c87a3a30fcbdda489">m_st_init_drop_timeout</a></td></tr>
<tr class="memdesc:a02afb5ed4201d83c87a3a30fcbdda489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once socket enters ESTABLISHED state, this is the value for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2d8aded3761028967fd3abb464e64936" title="The Drop Timeout: Time period between the next time m_snd_drop_timer schedules a Drop Timer and that ...">Peer_socket::m_snd_drop_timeout</a> until the first RTT measurement is made (the first valid acknowledgment arrives).  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a02afb5ed4201d83c87a3a30fcbdda489">More...</a><br /></td></tr>
<tr class="separator:a02afb5ed4201d83c87a3a30fcbdda489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ca4ecd9d8bfc8710bda71687c4ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a638ca4ecd9d8bfc8710bda71687c4ea3">m_st_drop_packet_exactly_after_drop_timeout</a></td></tr>
<tr class="memdesc:a638ca4ecd9d8bfc8710bda71687c4ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, when scheduling Drop Timer, schedule it for Drop Timeout relative to the send time of the earliest In-flight packet at the time.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a638ca4ecd9d8bfc8710bda71687c4ea3">More...</a><br /></td></tr>
<tr class="separator:a638ca4ecd9d8bfc8710bda71687c4ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f4da1892e2157e60772ed74298b2b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac6f4da1892e2157e60772ed74298b2b2">m_st_drop_all_on_drop_timeout</a></td></tr>
<tr class="memdesc:ac6f4da1892e2157e60772ed74298b2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, when the Drop Timer fires, all In-flight packets are to be considered Dropped (and thus the timer is to be disabled).  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac6f4da1892e2157e60772ed74298b2b2">More...</a><br /></td></tr>
<tr class="separator:ac6f4da1892e2157e60772ed74298b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d5eb1b4e37317478c3b25bc3c8c245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae7d5eb1b4e37317478c3b25bc3c8c245">m_st_out_of_order_ack_restarts_drop_timer</a></td></tr>
<tr class="memdesc:ae7d5eb1b4e37317478c3b25bc3c8c245"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an In-flight packet is acknowledged, but it is not the earliest In-flight packet (i.e., it's an out-of-order acknowledgment), and this is <code>true</code>, the timer is restarted.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae7d5eb1b4e37317478c3b25bc3c8c245">More...</a><br /></td></tr>
<tr class="separator:ae7d5eb1b4e37317478c3b25bc3c8c245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cbcdd64a4366740ff9e55b39c977ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7cbcdd64a4366740ff9e55b39c977ba">m_st_snd_pacing_enabled</a></td></tr>
<tr class="memdesc:ad7cbcdd64a4366740ff9e55b39c977ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables packet pacing, which attempts to spread out, without sacrificing overall send throughput, outgoing low-level packets to prevent loss.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad7cbcdd64a4366740ff9e55b39c977ba">More...</a><br /></td></tr>
<tr class="separator:ad7cbcdd64a4366740ff9e55b39c977ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3d420992e19e5addb7193d607e82e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a3d420992e19e5addb7193d607e82e4">m_st_snd_bandwidth_est_sample_period_floor</a></td></tr>
<tr class="memdesc:a2a3d420992e19e5addb7193d607e82e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When estimating the available send bandwidth, each sample must be compiled over at least this long of a time period, even if the SRTT is lower.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a3d420992e19e5addb7193d607e82e4">More...</a><br /></td></tr>
<tr class="separator:a2a3d420992e19e5addb7193d607e82e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca69056d3029193823f0c0ae630f5759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Congestion_control_strategy_choice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aca69056d3029193823f0c0ae630f5759">m_st_cong_ctl_strategy</a></td></tr>
<tr class="memdesc:aca69056d3029193823f0c0ae630f5759"><td class="mdescLeft">&#160;</td><td class="mdescRight">The congestion control algorithm to use for the connection or connections.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aca69056d3029193823f0c0ae630f5759">More...</a><br /></td></tr>
<tr class="separator:aca69056d3029193823f0c0ae630f5759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637811d19d4a2b4d9b3ab79742aadff8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a637811d19d4a2b4d9b3ab79742aadff8">m_st_cong_ctl_init_cong_wnd_blocks</a></td></tr>
<tr class="memdesc:a637811d19d4a2b4d9b3ab79742aadff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial size of the congestion window, given in units of max-block-size-sized blocks.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a637811d19d4a2b4d9b3ab79742aadff8">More...</a><br /></td></tr>
<tr class="separator:a637811d19d4a2b4d9b3ab79742aadff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdc21e84373dd96494a76f11603335e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a1bdc21e84373dd96494a76f11603335e">m_st_cong_ctl_max_cong_wnd_blocks</a></td></tr>
<tr class="memdesc:a1bdc21e84373dd96494a76f11603335e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant that determines the CWND limit in <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html#a9c6cac4d5409855f5e39f4411d787ad9" title="Returns true if and only if the stored CWND is &gt;= a certain constant maximum value.">Congestion_control_classic_data::congestion_window_at_limit()</a> and <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html#a7b798f3211fd2214477355b95e2d10d2" title="If congestion_window_at_limit(), sets CWND to the limit value.">Congestion_control_classic_data::clamp_congestion_window()</a> (in multiples of max-block-size).  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a1bdc21e84373dd96494a76f11603335e">More...</a><br /></td></tr>
<tr class="separator:a1bdc21e84373dd96494a76f11603335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8fcb08dfb0d1ebcc21e02940c149e8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2c8fcb08dfb0d1ebcc21e02940c149e8">m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</a></td></tr>
<tr class="memdesc:a2c8fcb08dfb0d1ebcc21e02940c149e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Drop Timeout, set congestion window to this value times max-block-size.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2c8fcb08dfb0d1ebcc21e02940c149e8">More...</a><br /></td></tr>
<tr class="separator:a2c8fcb08dfb0d1ebcc21e02940c149e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7ab1e27acd52d8fa3aadc9eb13d116"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a7ab1e27acd52d8fa3aadc9eb13d116">m_st_cong_ctl_cong_avoidance_increment_blocks</a></td></tr>
<tr class="memdesc:a2a7ab1e27acd52d8fa3aadc9eb13d116"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multiple of max-block-size by which to increment CWND in congestion avoidance mode after receiving at least a full CWND's worth of clean acknowledgments.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a2a7ab1e27acd52d8fa3aadc9eb13d116">More...</a><br /></td></tr>
<tr class="separator:a2a7ab1e27acd52d8fa3aadc9eb13d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfe97128c9f5f62ff26d73047dec2e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeccfe97128c9f5f62ff26d73047dec2e">m_st_cong_ctl_classic_wnd_decay_percent</a></td></tr>
<tr class="memdesc:aeccfe97128c9f5f62ff26d73047dec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In classic congestion control, RFC 5681 specifies the window should be halved on loss; this option allows one to use a custom percentage instead.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeccfe97128c9f5f62ff26d73047dec2e">More...</a><br /></td></tr>
<tr class="separator:aeccfe97128c9f5f62ff26d73047dec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02a9d91ef5e5c13ea95ea35624da1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#afd02a9d91ef5e5c13ea95ea35624da1a">m_dyn_drop_timeout_ceiling</a></td></tr>
<tr class="memdesc:afd02a9d91ef5e5c13ea95ea35624da1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceiling to impose on the Drop Timeout.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#afd02a9d91ef5e5c13ea95ea35624da1a">More...</a><br /></td></tr>
<tr class="separator:afd02a9d91ef5e5c13ea95ea35624da1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2551f2995f5830e0461bec6fdd9035e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae2551f2995f5830e0461bec6fdd9035e">m_dyn_drop_timeout_backoff_factor</a></td></tr>
<tr class="memdesc:ae2551f2995f5830e0461bec6fdd9035e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever the Drop Timer fires, upon the requisite Dropping of packet(s), the DTO (Drop Timeout) is set to its current value times this factor, and then the timer is rescheduled accordingly.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ae2551f2995f5830e0461bec6fdd9035e">More...</a><br /></td></tr>
<tr class="separator:ae2551f2995f5830e0461bec6fdd9035e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38c0bbba5edbb4964a3914ccf56018f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac38c0bbba5edbb4964a3914ccf56018f">m_dyn_rcv_wnd_recovery_timer_period</a></td></tr>
<tr class="memdesc:ac38c0bbba5edbb4964a3914ccf56018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the mode triggered by rcv-buf-max-size-to-advertise-percent being exceeded is in effect, to counteract the possibility of ACK loss the receive window is periodically advertised subsequently &ndash; with the period given by this option &ndash; until either some new data arrive or rcv-wnd-recovery-max-period is exceeded.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ac38c0bbba5edbb4964a3914ccf56018f">More...</a><br /></td></tr>
<tr class="separator:ac38c0bbba5edbb4964a3914ccf56018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e3340cecf792f0fd815b55dd25f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a371e3340cecf792f0fd815b55dd25f60">m_dyn_rcv_wnd_recovery_max_period</a></td></tr>
<tr class="memdesc:a371e3340cecf792f0fd815b55dd25f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate amount of time since the beginning of rcv_wnd recovery due to rcv-buf-max-size-to-advertise-percent until we give up and end that phase.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a371e3340cecf792f0fd815b55dd25f60">More...</a><br /></td></tr>
<tr class="separator:a371e3340cecf792f0fd815b55dd25f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad0015d953f3079a326ba6dce5d0bff89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad0015d953f3079a326ba6dce5d0bff89">setup_config_parsing_helper</a> (<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Options_description</a> *opts_desc, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *target, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;defaults_source, <a class="el" href="classbool.html">bool</a> printout_only)</td></tr>
<tr class="memdesc:ad0015d953f3079a326ba6dce5d0bff89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad0015d953f3079a326ba6dce5d0bff89">More...</a><br /></td></tr>
<tr class="separator:ad0015d953f3079a326ba6dce5d0bff89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ade95ba3f5a7ed233a2e5f9e244ed6170"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ade95ba3f5a7ed233a2e5f9e244ed6170">Node_options</a></td></tr>
<tr class="memdesc:ade95ba3f5a7ed233a2e5f9e244ed6170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two <code>struct</code>s work together (since <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> contains an instance of us).  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ade95ba3f5a7ed233a2e5f9e244ed6170">More...</a><br /></td></tr>
<tr class="separator:ade95ba3f5a7ed233a2e5f9e244ed6170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3954beff8f73e2d6f566f4e15c30219c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a3954beff8f73e2d6f566f4e15c30219c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a3954beff8f73e2d6f566f4e15c30219c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, along with its current value, to the given <code>ostream</code>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#a3954beff8f73e2d6f566f4e15c30219c">More...</a><br /></td></tr>
<tr class="separator:a3954beff8f73e2d6f566f4e15c30219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aad968d3e7e9c3f284bea03e799d5fbc0">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;strategy_choice)</td></tr>
<tr class="memdesc:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> from a standard input stream.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#aad968d3e7e9c3f284bea03e799d5fbc0">More...</a><br /></td></tr>
<tr class="separator:aad968d3e7e9c3f284bea03e799d5fbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ab9f537c84f77e9b8fa742fc5dc6d5693">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;strategy_choice)</td></tr>
<tr class="memdesc:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> to a standard <code>ostream</code> &ndash; the reverse of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aad968d3e7e9c3f284bea03e799d5fbc0" title="Deserializes a Peer_socket_options::Congestion_control_strategy_choice enum from a standard input str...">operator&gt;&gt;()</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__options.html#ab9f537c84f77e9b8fa742fc5dc6d5693">More...</a><br /></td></tr>
<tr class="separator:ab9f537c84f77e9b8fa742fc5dc6d5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A set of low-level options affecting a single <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<p >All comments for <code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> apply equally to <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> (except, of course, those pertaining to the nested <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> instance).</p>
<dl class="section see"><dt>See also</dt><dd><code>struct</code> <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00035">35</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a78cbfb464f3251f63a06c753c986d277" name="a78cbfb464f3251f63a06c753c986d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cbfb464f3251f63a06c753c986d277">&#9670;&nbsp;</a></span>Fine_duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">flow::net_flow::Peer_socket_options::Fine_duration</a> =  <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">flow::Fine_duration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A time duration, with fine precision, that can be positive, zero, or negative (unless a specific option specifies an additional constraint to that effect). </p>
<p >This is used for most (all?) time-based options in <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>.</p>
<p >This used to be an alias from <code>duration&lt;uint16_t, Fine_duration::period&gt;</code> to <code>Fine_duration_non_neg</code>, meaning it was specifcally intended to be non-negative. That constraint made sense for all time-based options at the time and probably still does... but there was a problem: In Boost 1.50, the non-negative implementation integer type caused a comparison to -1 somewhere inside their headers, which triggered a (reasonable) gcc-4.2 warning. Ironically, in Boost 1.48, using a negative-allowing type caused some other comparison triggering a similar warning. Anyway, as of Boost 1.50, I've decided to bite the bullet and use a negative-allowing type after all (which causes no warning in that version) and enforce any required non-negativeness (or even positiveness, where applicable) explicitly when calling <code>VALIDATE_CHECK()</code> at option parse time. (That was way longer an explanation than this deserved.) </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00059">59</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

</div>
</div>
<a id="ad65db0c4fdf22bf5723dc3018174b4aa" name="ad65db0c4fdf22bf5723dc3018174b4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65db0c4fdf22bf5723dc3018174b4aa">&#9670;&nbsp;</a></span>Options_description</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">flow::net_flow::Peer_socket_options::Options_description</a> =  boost::program_options::options_description</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for boost.program_options config options description. See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aa6d94acf3c746c8f59c91ffa824ef8bd" title="Analogous to Node_options::setup_config_parsing().">setup_config_parsing()</a>. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00040">40</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a42ce94dbc5d8be28134261c2eb18b245" name="a42ce94dbc5d8be28134261c2eb18b245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ce94dbc5d8be28134261c2eb18b245">&#9670;&nbsp;</a></span>Congestion_control_strategy_choice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">flow::net_flow::Peer_socket_options::Congestion_control_strategy_choice</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible choices for congestion control strategy for the socket. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a42ce94dbc5d8be28134261c2eb18b245a13d31c1bffdbda8309c52bb997064862" name="a42ce94dbc5d8be28134261c2eb18b245a13d31c1bffdbda8309c52bb997064862"></a>S_CLASSIC&#160;</td><td class="fielddoc"><p >Classic (Reno-style) AIMD congestion control. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42ce94dbc5d8be28134261c2eb18b245a656db2a2ff0f24f703b6ac341e97537e" name="a42ce94dbc5d8be28134261c2eb18b245a656db2a2ff0f24f703b6ac341e97537e"></a>S_CLASSIC_BANDWIDTH_ESTIMATED&#160;</td><td class="fielddoc"><p >Classic congestion control but with loss resulting in a window chosen from an outgoing bandwidth estimate. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00062">62</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac31b91c6f8c7b0d7a4e29fd218e5f9dc" name="ac31b91c6f8c7b0d7a4e29fd218e5f9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31b91c6f8c7b0d7a4e29fd218e5f9dc">&#9670;&nbsp;</a></span>Peer_socket_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Peer_socket_options::Peer_socket_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> with values equal to those used by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> when the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> creator chooses not to supply custom options. </p>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00184">184</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa6d94acf3c746c8f59c91ffa824ef8bd" name="aa6d94acf3c746c8f59c91ffa824ef8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d94acf3c746c8f59c91ffa824ef8bd">&#9670;&nbsp;</a></span>setup_config_parsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket_options::setup_config_parsing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Options_description</a> *&#160;</td>
          <td class="paramname"><em>opts_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1" title="Modifies a boost.program_options options description object to enable subsequent parsing of a command...">Node_options::setup_config_parsing()</a>. </p>
<p >See that method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts_desc</td><td>The <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa" title="Short-hand for boost.program_options config options description. See setup_config_parsing().">Options_description</a> object into which to load the help information, defaults, and mapping to members of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00478">478</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

<p class="reference">References <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Peer__socket__options_aa6d94acf3c746c8f59c91ffa824ef8bd_cgraph.svg" width="570" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad0015d953f3079a326ba6dce5d0bff89" name="ad0015d953f3079a326ba6dce5d0bff89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0015d953f3079a326ba6dce5d0bff89">&#9670;&nbsp;</a></span>setup_config_parsing_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket_options::setup_config_parsing_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Options_description</a> *&#160;</td>
          <td class="paramname"><em>opts_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>defaults_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>printout_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>. </p>
<p >See that method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts_desc</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>. </td></tr>
    <tr><td class="paramname">target</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>. </td></tr>
    <tr><td class="paramname">defaults_source</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>. </td></tr>
    <tr><td class="paramname">printout_only</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a07d18f7e934d079835f5367fbf7d6d1b" title="Loads the full set of boost.program_options config options into the given Options_description,...">Node_options::setup_config_parsing_helper()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00271">271</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

<p class="reference">References <a class="el" href="cong__ctl_8cpp_source.html#l00115">flow::net_flow::Congestion_control_selector::get_ids()</a>, <a class="el" href="options_8hpp_source.html#l00325">m_dyn_drop_timeout_backoff_factor</a>, <a class="el" href="options_8hpp_source.html#l00317">m_dyn_drop_timeout_ceiling</a>, <a class="el" href="options_8hpp_source.html#l00339">m_dyn_rcv_wnd_recovery_max_period</a>, <a class="el" href="options_8hpp_source.html#l00333">m_dyn_rcv_wnd_recovery_timer_period</a>, <a class="el" href="options_8hpp_source.html#l00314">m_st_cong_ctl_classic_wnd_decay_percent</a>, <a class="el" href="options_8hpp_source.html#l00306">m_st_cong_ctl_cong_avoidance_increment_blocks</a>, <a class="el" href="options_8hpp_source.html#l00299">m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</a>, <a class="el" href="options_8hpp_source.html#l00277">m_st_cong_ctl_init_cong_wnd_blocks</a>, <a class="el" href="options_8hpp_source.html#l00296">m_st_cong_ctl_max_cong_wnd_blocks</a>, <a class="el" href="options_8hpp_source.html#l00270">m_st_cong_ctl_strategy</a>, <a class="el" href="options_8hpp_source.html#l00121">m_st_connect_retransmit_period</a>, <a class="el" href="options_8hpp_source.html#l00124">m_st_connect_retransmit_timeout</a>, <a class="el" href="options_8hpp_source.html#l00191">m_st_delayed_ack_timer_period</a>, <a class="el" href="options_8hpp_source.html#l00240">m_st_drop_all_on_drop_timeout</a>, <a class="el" href="options_8hpp_source.html#l00233">m_st_drop_packet_exactly_after_drop_timeout</a>, <a class="el" href="options_8hpp_source.html#l00226">m_st_init_drop_timeout</a>, <a class="el" href="options_8hpp_source.html#l00114">m_st_max_block_size</a>, <a class="el" href="options_8hpp_source.html#l00198">m_st_max_full_blocks_before_ack_send</a>, <a class="el" href="options_8hpp_source.html#l00220">m_st_max_rexmissions_per_packet</a>, <a class="el" href="options_8hpp_source.html#l00248">m_st_out_of_order_ack_restarts_drop_timer</a>, <a class="el" href="options_8hpp_source.html#l00141">m_st_rcv_buf_max_size</a>, <a class="el" href="options_8hpp_source.html#l00160">m_st_rcv_buf_max_size_slack_percent</a>, <a class="el" href="options_8hpp_source.html#l00171">m_st_rcv_buf_max_size_to_advertise_percent</a>, <a class="el" href="options_8hpp_source.html#l00150">m_st_rcv_flow_control_on</a>, <a class="el" href="options_8hpp_source.html#l00183">m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</a>, <a class="el" href="options_8hpp_source.html#l00214">m_st_rexmit_on</a>, <a class="el" href="options_8hpp_source.html#l00267">m_st_snd_bandwidth_est_sample_period_floor</a>, <a class="el" href="options_8hpp_source.html#l00134">m_st_snd_buf_max_size</a>, and <a class="el" href="options_8hpp_source.html#l00258">m_st_snd_pacing_enabled</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00478">setup_config_parsing()</a>, and <a class="el" href="options_8cpp_source.html#l00080">flow::net_flow::Node_options::setup_config_parsing_helper()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Peer__socket__options_ad0015d953f3079a326ba6dce5d0bff89_cgraph.svg" width="374" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Peer__socket__options_ad0015d953f3079a326ba6dce5d0bff89_icgraph.svg" width="550" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ade95ba3f5a7ed233a2e5f9e244ed6170" name="ade95ba3f5a7ed233a2e5f9e244ed6170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade95ba3f5a7ed233a2e5f9e244ed6170">&#9670;&nbsp;</a></span>Node_options</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two <code>struct</code>s work together (since <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> contains an instance of us). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00348">348</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

</div>
</div>
<a id="a3954beff8f73e2d6f566f4e15c30219c" name="a3954beff8f73e2d6f566f4e15c30219c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3954beff8f73e2d6f566f4e15c30219c">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the name of each option in the given <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, along with its current value, to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">opts</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8cpp_source.html#l00484">484</a> of file <a class="el" href="options_8cpp_source.html">options.cpp</a>.</p>

</div>
</div>
<a id="ab9f537c84f77e9b8fa742fc5dc6d5693" name="ab9f537c84f77e9b8fa742fc5dc6d5693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f537c84f77e9b8fa742fc5dc6d5693">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy_choice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> to a standard <code>ostream</code> &ndash; the reverse of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aad968d3e7e9c3f284bea03e799d5fbc0" title="Deserializes a Peer_socket_options::Congestion_control_strategy_choice enum from a standard input str...">operator&gt;&gt;()</a>. </p>
<p >Writes a space-less token to the given stream based on the given strategy <code>enum</code> value. This enables a few key things to work, including output of defaults and values in the help via <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>, and conversion to <code>string</code> via <code>boost::lexical_cast</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">strategy_choice</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cong__ctl_8cpp_source.html#l00146">146</a> of file <a class="el" href="cong__ctl_8cpp_source.html">cong_ctl.cpp</a>.</p>

</div>
</div>
<a id="aad968d3e7e9c3f284bea03e799d5fbc0" name="aad968d3e7e9c3f284bea03e799d5fbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad968d3e7e9c3f284bea03e799d5fbc0">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Peer_socket_options::Congestion_control_strategy_choice</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy_choice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> <code>enum</code> from a standard input stream. </p>
<p >Reads a single space-delimited token from the given stream. Maps that token to an aforementioned enumeration value. If the token is not recognized or cannot be read, some reasonable default strategy is chosen. This enables a few key things to work, including parsing from config file/command line via and conversion from <code>string</code> via <code>boost::lexical_cast</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream from which to deserialize. </td></tr>
    <tr><td class="paramname">strategy_choice</td><td>Reference to <code>enum</code> value which to set to the mapped strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245" title="The possible choices for congestion control strategy for the socket.">Peer_socket_options::Congestion_control_strategy_choice</a> stream inserter <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators should use the <a class="el" href="namespaceflow_1_1util.html#a18a29d6a6e65c3b96c52b5cad5971266" title="Deserializes an enum class value from a standard input stream.">flow::util::istream_to_enum()</a> pattern which is much easier than the overwrought old thing in there now involving two <code>map</code>s. Perhaps add a generic <code>enum_to_strings()</code> to provide the body for <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__selector.html#aca9ae5272088f3ef8fb81f40cc85224c" title="Returns a list of strings, called IDs, each of which textually represents a distinct Congestion_contr...">net_flow::Congestion_control_selector::get_ids()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cong__ctl_8cpp_source.html#l00124">124</a> of file <a class="el" href="cong__ctl_8cpp_source.html">cong_ctl.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae2551f2995f5830e0461bec6fdd9035e" name="ae2551f2995f5830e0461bec6fdd9035e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2551f2995f5830e0461bec6fdd9035e">&#9670;&nbsp;</a></span>m_dyn_drop_timeout_backoff_factor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_backoff_factor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whenever the Drop Timer fires, upon the requisite Dropping of packet(s), the DTO (Drop Timeout) is set to its current value times this factor, and then the timer is rescheduled accordingly. </p>
<p >RFC 6298 recommends 2. Another value might be 1 (disable feature). The lower the more aggressive. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00325">325</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="afd02a9d91ef5e5c13ea95ea35624da1a" name="afd02a9d91ef5e5c13ea95ea35624da1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd02a9d91ef5e5c13ea95ea35624da1a">&#9670;&nbsp;</a></span>m_dyn_drop_timeout_ceiling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_dyn_drop_timeout_ceiling</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ceiling to impose on the Drop Timeout. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00317">317</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a371e3340cecf792f0fd815b55dd25f60" name="a371e3340cecf792f0fd815b55dd25f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e3340cecf792f0fd815b55dd25f60">&#9670;&nbsp;</a></span>m_dyn_rcv_wnd_recovery_max_period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_dyn_rcv_wnd_recovery_max_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate amount of time since the beginning of rcv_wnd recovery due to rcv-buf-max-size-to-advertise-percent until we give up and end that phase. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00339">339</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="ac38c0bbba5edbb4964a3914ccf56018f" name="ac38c0bbba5edbb4964a3914ccf56018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38c0bbba5edbb4964a3914ccf56018f">&#9670;&nbsp;</a></span>m_dyn_rcv_wnd_recovery_timer_period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_dyn_rcv_wnd_recovery_timer_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When the mode triggered by rcv-buf-max-size-to-advertise-percent being exceeded is in effect, to counteract the possibility of ACK loss the receive window is periodically advertised subsequently &ndash; with the period given by this option &ndash; until either some new data arrive or rcv-wnd-recovery-max-period is exceeded. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00333">333</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="aeccfe97128c9f5f62ff26d73047dec2e" name="aeccfe97128c9f5f62ff26d73047dec2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccfe97128c9f5f62ff26d73047dec2e">&#9670;&nbsp;</a></span>m_st_cong_ctl_classic_wnd_decay_percent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_cong_ctl_classic_wnd_decay_percent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In classic congestion control, RFC 5681 specifies the window should be halved on loss; this option allows one to use a custom percentage instead. </p>
<p >This should be a value in [1, 100] to have the window decay to that percentage of its previous value, or 0 to use the RFC 5681-recommended constant (50). </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00314">314</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a2a7ab1e27acd52d8fa3aadc9eb13d116" name="a2a7ab1e27acd52d8fa3aadc9eb13d116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7ab1e27acd52d8fa3aadc9eb13d116">&#9670;&nbsp;</a></span>m_st_cong_ctl_cong_avoidance_increment_blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_avoidance_increment_blocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multiple of max-block-size by which to increment CWND in congestion avoidance mode after receiving at least a full CWND's worth of clean acknowledgments. </p>
<p >RFC 5681 (classic Reno) mandates this is set to 1, but we allow it to be overridden. The special value 0 causes the RFC value to be used. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00306">306</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a2c8fcb08dfb0d1ebcc21e02940c149e8" name="a2c8fcb08dfb0d1ebcc21e02940c149e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8fcb08dfb0d1ebcc21e02940c149e8">&#9670;&nbsp;</a></span>m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_cong_ctl_cong_wnd_on_drop_timeout_blocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On Drop Timeout, set congestion window to this value times max-block-size. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00299">299</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a637811d19d4a2b4d9b3ab79742aadff8" name="a637811d19d4a2b4d9b3ab79742aadff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637811d19d4a2b4d9b3ab79742aadff8">&#9670;&nbsp;</a></span>m_st_cong_ctl_init_cong_wnd_blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_cong_ctl_init_cong_wnd_blocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial size of the congestion window, given in units of max-block-size-sized blocks. </p>
<p >The special value 0 means RFC 5681's automatic max-block-size-based computation should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00277">277</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a1bdc21e84373dd96494a76f11603335e" name="a1bdc21e84373dd96494a76f11603335e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdc21e84373dd96494a76f11603335e">&#9670;&nbsp;</a></span>m_st_cong_ctl_max_cong_wnd_blocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_cong_ctl_max_cong_wnd_blocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constant that determines the CWND limit in <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html#a9c6cac4d5409855f5e39f4411d787ad9" title="Returns true if and only if the stored CWND is &gt;= a certain constant maximum value.">Congestion_control_classic_data::congestion_window_at_limit()</a> and <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html#a7b798f3211fd2214477355b95e2d10d2" title="If congestion_window_at_limit(), sets CWND to the limit value.">Congestion_control_classic_data::clamp_congestion_window()</a> (in multiples of max-block-size). </p>
<p >When choosing this value, use these constraints:</p>
<ul>
<li>This limits total outgoing throughput. The throughput B will be &lt;= CWND/RTT, where RTT is roughly the RTT of the connection, and CWND == max-cong-wnd-blocks * max-block-size. Therefore, choose B and RTT values and set max-cong-wnd-blocks = B * RTT / max-block-size (B in bytes/second, RTT in seconds).</li>
<li>Until we implement Receive window, this value should be much (say, 4x) less than the size of the Receive buffer, to avoid situations where even a well-behaving user (i.e., user that <code>receive()</code>s all data ASAP) cannot keep up with reading data off Receive buffer, forcing <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> to drop large swaths of incoming traffic. If CWND is much smaller than Receive buffer size, then this avoids that problem.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000121">Todo:</a></b></dt><dd>Reconsider this value after Receive window feature is implemented. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00296">296</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="aca69056d3029193823f0c0ae630f5759" name="aca69056d3029193823f0c0ae630f5759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca69056d3029193823f0c0ae630f5759">&#9670;&nbsp;</a></span>m_st_cong_ctl_strategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a42ce94dbc5d8be28134261c2eb18b245">Congestion_control_strategy_choice</a> flow::net_flow::Peer_socket_options::m_st_cong_ctl_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The congestion control algorithm to use for the connection or connections. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00270">270</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="a8f18c8222ade5f99b83a85e0203ff130" name="a8f18c8222ade5f99b83a85e0203ff130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f18c8222ade5f99b83a85e0203ff130">&#9670;&nbsp;</a></span>m_st_connect_retransmit_period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_st_connect_retransmit_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How often to resend SYN or SYN_ACK while SYN_ACK or SYN_ACK_ACK, respectively, has not been received. </p>
<p >In other words, this controls the pause between retries during the connection opening phase, by either side, if the other side is not responding with the appropriate response. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00121">121</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ac75171c4f1086d0aa38248ae5ffba884" name="ac75171c4f1086d0aa38248ae5ffba884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75171c4f1086d0aa38248ae5ffba884">&#9670;&nbsp;</a></span>m_st_connect_retransmit_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_st_connect_retransmit_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How long from the first SYN or SYN_ACK to allow for connection handshake before aborting connection. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00124">124</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="add7ccb9e8cd0715ca78e0710d2a6db06" name="add7ccb9e8cd0715ca78e0710d2a6db06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ccb9e8cd0715ca78e0710d2a6db06">&#9670;&nbsp;</a></span>m_st_delayed_ack_timer_period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_st_delayed_ack_timer_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum amount of time to delay sending ACK with individual packet's acknowledgment since receiving that individual packet. </p>
<p >If set to zero duration, any given individual acknowledgment is sent within a non-blocking amount of time of its DATA packet being read. Inspired by RFC 1122-4.2.3.2. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00191">191</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ac6f4da1892e2157e60772ed74298b2b2" name="ac6f4da1892e2157e60772ed74298b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f4da1892e2157e60772ed74298b2b2">&#9670;&nbsp;</a></span>m_st_drop_all_on_drop_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_drop_all_on_drop_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, when the Drop Timer fires, all In-flight packets are to be considered Dropped (and thus the timer is to be disabled). </p>
<p >If <code>false</code>, only the earliest In-flight packet is to be considered Dropped (and thus the timer is to restart). RFC 6298 recommends <code>false</code>. <code>true</code> is more aggressive. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00240">240</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="a638ca4ecd9d8bfc8710bda71687c4ea3" name="a638ca4ecd9d8bfc8710bda71687c4ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638ca4ecd9d8bfc8710bda71687c4ea3">&#9670;&nbsp;</a></span>m_st_drop_packet_exactly_after_drop_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_drop_packet_exactly_after_drop_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, when scheduling Drop Timer, schedule it for Drop Timeout relative to the send time of the earliest In-flight packet at the time. </p>
<p >If <code>false</code>, also schedule DTO relative to the time of scheduling. The latter is less aggressive and is recommended by RFC 6298. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00233">233</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="a02afb5ed4201d83c87a3a30fcbdda489" name="a02afb5ed4201d83c87a3a30fcbdda489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02afb5ed4201d83c87a3a30fcbdda489">&#9670;&nbsp;</a></span>m_st_init_drop_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_st_init_drop_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once socket enters ESTABLISHED state, this is the value for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2d8aded3761028967fd3abb464e64936" title="The Drop Timeout: Time period between the next time m_snd_drop_timer schedules a Drop Timer and that ...">Peer_socket::m_snd_drop_timeout</a> until the first RTT measurement is made (the first valid acknowledgment arrives). </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00226">226</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="aeaaf832a38a5e334789e81e214686ea7" name="aeaaf832a38a5e334789e81e214686ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaf832a38a5e334789e81e214686ea7">&#9670;&nbsp;</a></span>m_st_max_block_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_max_block_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of block that we will strive to (and will, assuming at least that many bytes are available in Send buffer) pack into each outgoing DATA packet. </p>
<p >It is assumed the other side is following the same policiy (any packets that do not &ndash; i.e., exceed this size &ndash; are dropped). This is an important control; the higher it is the better for performance AS LONG AS it's not so high it undergoes IP fragmentation (or does that even happen in UDP? if not, even worse &ndash; it'll just be dropped and not sent!). The performance impact is major; e.g., assuming no fragmentation/dropping, we've seen a ~1500 byte MBS result in 20-30% higher throughput than 1024 byte MBS.</p>
<p >Additionally, if using <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> module with no reliability feature &ndash; i.e., if you want to perform FEC or something else outside the Flow protocol &ndash; then it is absolutely essential that EVERY <code>send*()</code> call provides a buffer whose size is a multiple of max-block-size. Otherwise packet boundaries will not be what you expect, and you will get what seems to be corrupted data at the application layer (since our stream-based API has no way of knowing where your message begins or ends). Alternatively you can encode message terminators or packet sizes, but since in unreliable mode integrity of a given block is guaranteed only if all blocks align with max-block-size boundaries, you'll still probably be screwed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000120">Todo:</a></b></dt><dd>max-block-size should be dynamically determined (but overridable by this option). That is a complex topic, however, with considerations such as MTU discovery, ICMP errors, and who knows what else. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00114">114</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="node_8cpp_source.html#l01111">flow::net_flow::Node::max_block_size()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00343">flow::net_flow::Peer_socket::max_block_size()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00348">flow::net_flow::Peer_socket::max_block_size_multiple()</a>, <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ad7a76f7ae03e258b30b04c7350481de6" name="ad7a76f7ae03e258b30b04c7350481de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a76f7ae03e258b30b04c7350481de6">&#9670;&nbsp;</a></span>m_st_max_full_blocks_before_ack_send</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_max_full_blocks_before_ack_send</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there are at least this many TIMES max-block-size bytes' worth of individual acknowledgments to be sent, then the delayed ACK timer is to be short-circuited, and the accumulated acknowledgments are to be sent as soon as possible. </p>
<p >Inspired by RFC 5681. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00198">198</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a0b37da87848d01220c7e58f90e6764ba" name="a0b37da87848d01220c7e58f90e6764ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37da87848d01220c7e58f90e6764ba">&#9670;&nbsp;</a></span>m_st_max_rexmissions_per_packet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_max_rexmissions_per_packet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If retransmission is enabled and a given packet is retransmitted this many times and has to be retransmitted yet again, the connection is reset. </p>
<p >Should be positive. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00220">220</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ae7d5eb1b4e37317478c3b25bc3c8c245" name="ae7d5eb1b4e37317478c3b25bc3c8c245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d5eb1b4e37317478c3b25bc3c8c245">&#9670;&nbsp;</a></span>m_st_out_of_order_ack_restarts_drop_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_out_of_order_ack_restarts_drop_timer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an In-flight packet is acknowledged, but it is not the earliest In-flight packet (i.e., it's an out-of-order acknowledgment), and this is <code>true</code>, the timer is restarted. </p>
<p >Otherwise the timer continues to run. The former is less aggressive. RFC 6298 wording is ambiguous on what it recommends (not clear if cumulative ACK only, or if SACK also qualifies). </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00248">248</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="a171480324f26432928738532cb3c8556" name="a171480324f26432928738532cb3c8556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171480324f26432928738532cb3c8556">&#9670;&nbsp;</a></span>m_st_rcv_buf_max_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of bytes that the Receive buffer can hold. </p>
<p >This determines how many bytes can be received in the background by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> without user doing any receive()s. It is also rounded up to to the nearest multiple of max-block-size. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00141">141</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="aa6d16c98186187fdffadcfb853d58410" name="aa6d16c98186187fdffadcfb853d58410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d16c98186187fdffadcfb853d58410">&#9670;&nbsp;</a></span>m_st_rcv_buf_max_size_slack_percent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size_slack_percent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>% of rcv-buf-max-size such that if Receive buffer stores up to (100 + this many) % of rcv-buf-max-size bytes, the bytes will still be accepted. </p>
<p >In other words, this allows the max Receive buffer to hold slightly more than rcv-buf-max-size bytes. However, the current Receive buffer capacity advertised to the other side of the connection will be based on the non-inflated rcv-buf-max-size. This option provides some protection against the fact that the receive window value sent to the other side will lag behind reality somewhat. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00160">160</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="af483d0292f363e7dbf14dc7a2dd49f3f" name="af483d0292f363e7dbf14dc7a2dd49f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af483d0292f363e7dbf14dc7a2dd49f3f">&#9670;&nbsp;</a></span>m_st_rcv_buf_max_size_to_advertise_percent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_rcv_buf_max_size_to_advertise_percent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>% of rcv-buf-max-size that has to be freed, since the last receive window advertisement, via user popping data from Receive buffer, before we must send a receive window advertisement. </p>
<p >Normally we send rcv_wnd to the other side opportunistically in every ACK; but there can be situations when there is no packet to acknowledge, and hence we must specifically make a packet just to send over rcv_wnd. Typically we should only need to do this if the buffer was exceeded and is now significantly freed. This value must be in [1, 100], but anything over 50 is probably pushing it. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00171">171</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ad9a31f63eea6f89952a89ea0385d9a2e" name="ad9a31f63eea6f89952a89ea0385d9a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a31f63eea6f89952a89ea0385d9a2e">&#9670;&nbsp;</a></span>m_st_rcv_flow_control_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_rcv_flow_control_on</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether flow control (a/k/a receive window a/k/a rcv_wnd management) is enabled. </p>
<p >If this is disabled, an infinite rcv_wnd will always be advertised to the sender; so if the Receive buffer is exceeded packets are dropped as normal, but the sender will not know it should stop sending until Receive buffer space is freed. If this is enabled, we keep the sender informed of how much Receive buffer space is available, so it can suspend the flow as necessary. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00150">150</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="af78ca6cf3c6da3bc24cea40d522f0bdb" name="af78ca6cf3c6da3bc24cea40d522f0bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78ca6cf3c6da3bc24cea40d522f0bdb">&#9670;&nbsp;</a></span>m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket_options::m_st_rcv_max_packets_after_unrecvd_packet_ratio_percent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The limit on the size of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a>, expressed as what percentage the maximal size of that structure times max-block-size is of the maximal receive buffer size. </p>
<p >For example, if this is 200, then <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> can represent up to roughly 2x as many full-sized blocks as the Receive buffer can. This should also by far exceed any sender congestion window max size to avoid packet loss.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">Peer_socket::m_rcv_packets_with_gaps</a> for details. </dd>
<dd>
<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed" title="The queue of DATA packets received while in Int_state::S_SYN_RCVD state before the Syn_ack_ack_packet...">Peer_socket::m_rcv_syn_rcvd_data_q</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00183">183</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a6c35e6014182ccfcbee6bed4571a8360" name="a6c35e6014182ccfcbee6bed4571a8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35e6014182ccfcbee6bed4571a8360">&#9670;&nbsp;</a></span>m_st_rexmit_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_rexmit_on</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to enable reliability via retransmission. </p>
<p >If <code>false</code>, a detected lost packet may have implications on congestion control (speed at which further data are sent) but will not cause that packet to be resent; receiver application code either has to be OK with missing packets or must implement its own reliability (e.g., FEC). Packets may also be delivered in an order different from the way they were sent. If <code>true</code>, the receiver need not worry about it, as any lost packets will be retransmitted with no participation from the application code on either side, as in TCP. Also as in TCP, this adds order preservation, so that the stream of bytes sent will be exactly equal to the stream of bytes received. Retransmission removes the requirement for the very exacting block-based way in which <code>send()</code> and friends must be called.</p>
<p >This option must have the same value on both sides of the connection, or the server will refuse the connection. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00214">214</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="info_8cpp_source.html#l00322">flow::net_flow::Peer_socket_info::output()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00364">flow::net_flow::Peer_socket::rexmit_on()</a>, and <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<a id="a2a3d420992e19e5addb7193d607e82e4" name="a2a3d420992e19e5addb7193d607e82e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3d420992e19e5addb7193d607e82e4">&#9670;&nbsp;</a></span>m_st_snd_bandwidth_est_sample_period_floor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Fine_duration</a> flow::net_flow::Peer_socket_options::m_st_snd_bandwidth_est_sample_period_floor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When estimating the available send bandwidth, each sample must be compiled over at least this long of a time period, even if the SRTT is lower. </p>
<p >Normally a sample is collected over at least an SRTT, but computing a bandwidth sample over a quite short time period can produce funky results, hence this floor. Send bandwidth estimation is used at least for some forms of congestion control. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00267">267</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="a8ca6086022691700f5e5d2dc87ca92fd" name="a8ca6086022691700f5e5d2dc87ca92fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca6086022691700f5e5d2dc87ca92fd">&#9670;&nbsp;</a></span>m_st_snd_buf_max_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_options::m_st_snd_buf_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of bytes that the Send buffer can hold. </p>
<p >This determines how many bytes user can <code>send()</code> while peer cannot send over network until send() refuses to take any more bytes. Notew that any value given will be increased, if necessary, to the nearest multiple of max-block-size. This is important to preserve message boundaries when operating in unreliable mode (guaranteed max-block-size-sized chunks of data will be sent out in their entirety instead of being fragmented). </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00134">134</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06144">flow::net_flow::Node::sock_validate_options()</a>.</p>

</div>
</div>
<a id="ad7cbcdd64a4366740ff9e55b39c977ba" name="ad7cbcdd64a4366740ff9e55b39c977ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cbcdd64a4366740ff9e55b39c977ba">&#9670;&nbsp;</a></span>m_st_snd_pacing_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket_options::m_st_snd_pacing_enabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables packet pacing, which attempts to spread out, without sacrificing overall send throughput, outgoing low-level packets to prevent loss. </p>
<p >If disabled, any packet that is allowed by congestion/flow control to be sent over the wire is immediately sent to the UDP net-stack; so for example if 200 packets are ready to send and are allowed to be sent, they're sent at the same time. If enabled, they will be spread out over a reasonable time period instead. Excessive burstiness can lead to major packet drops, so this can really help. </p>

<p class="definition">Definition at line <a class="el" href="options_8hpp_source.html#l00258">258</a> of file <a class="el" href="options_8hpp_source.html">options.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="options_8cpp_source.html#l00271">setup_config_parsing_helper()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>net_flow/<a class="el" href="options_8hpp_source.html">options.hpp</a></li>
<li>net_flow/<a class="el" href="options_8cpp_source.html">options.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 5 2025 22:39:35 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
