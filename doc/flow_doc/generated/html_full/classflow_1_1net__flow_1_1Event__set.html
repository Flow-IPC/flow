<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Event_set Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html">Event_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1net__flow_1_1Event__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Event_set Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A user-set collection of sockets and desired conditions on those sockets (such as: "socket has data
to read"), with the ability to wait for those conditions to become true and signal the user when so.  
 <a href="classflow_1_1net__flow_1_1Event__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Event_set:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set__inherit__graph.svg" width="395" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Event_set:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set__coll__graph.svg" width="2463" height="2150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__equals.html">Socket_as_any_equals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality predicate class used in storing various sockets of types wrapped as <code>boost::any</code>s in the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> type.  <a href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__equals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__hash.html">Socket_as_any_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher class used in storing various sockets of types wrapped as <code>boost::any</code>s in the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> type.  <a href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2855bd159b6e63bf448ed1f41b608975"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">State</a> { <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>
, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>
, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>
 }</td></tr>
<tr class="memdesc:a2855bd159b6e63bf448ed1f41b608975"><td class="mdescLeft">&#160;</td><td class="mdescRight">A state of an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">More...</a><br /></td></tr>
<tr class="separator:a2855bd159b6e63bf448ed1f41b608975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cc3a286c8a11c986d2a59ec1e39a71"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> { <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">S_PEER_SOCKET_READABLE</a>
, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">S_PEER_SOCKET_WRITABLE</a>
, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2">S_SERVER_SOCKET_ACCEPTABLE</a>
 }</td></tr>
<tr class="memdesc:a19cc3a286c8a11c986d2a59ec1e39a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of event or condition of interest supported by class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">More...</a><br /></td></tr>
<tr class="separator:a19cc3a286c8a11c986d2a59ec1e39a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592b3ce6602051bd9994216041a3cbdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">util::Linked_hash_set</a>&lt; boost::any, <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__hash.html">Socket_as_any_hash</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__equals.html">Socket_as_any_equals</a> &gt;</td></tr>
<tr class="memdesc:a592b3ce6602051bd9994216041a3cbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of sockets of one type, used to communicate sets of desired and resulting events in various <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> APIs.  <a href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">More...</a><br /></td></tr>
<tr class="separator:a592b3ce6602051bd9994216041a3cbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da325d6cb993b975eec99adaafd3dce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_handler</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(<a class="el" href="classbool.html">bool</a>)&gt;</td></tr>
<tr class="memdesc:a9da325d6cb993b975eec99adaafd3dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for custom handler passed to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, which is executed when one or more active events detected, or interrupted as if by signal.  <a href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">More...</a><br /></td></tr>
<tr class="separator:a9da325d6cb993b975eec99adaafd3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Event_set &gt; &gt;</a></td></tr>
<tr class="memitem:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> = boost::shared_ptr&lt; Event_set &gt;</td></tr>
<tr class="memdesc:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to mutable values of type <code>Target_type::element_type</code> (a-la <code>T*</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">More...</a><br /></td></tr>
<tr class="separator:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a> = Const_target_ptr</td></tr>
<tr class="memdesc:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to immutable values of type <code>Target_type::element_type</code> (a-la <code>T const *</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">More...</a><br /></td></tr>
<tr class="separator:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:accb662e50999e2d0800f59a7a131bffa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#accb662e50999e2d0800f59a7a131bffa">~Event_set</a> ()</td></tr>
<tr class="memdesc:accb662e50999e2d0800f59a7a131bffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly.  <a href="classflow_1_1net__flow_1_1Event__set.html#accb662e50999e2d0800f59a7a131bffa">More...</a><br /></td></tr>
<tr class="separator:accb662e50999e2d0800f59a7a131bffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8453cccdaaf22ea6b027c5de9738f0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0">state</a> () const</td></tr>
<tr class="memdesc:a8453cccdaaf22ea6b027c5de9738f0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current State of the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0">More...</a><br /></td></tr>
<tr class="separator:a8453cccdaaf22ea6b027c5de9738f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4275ad4f93ae274f7f88fd257ce33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aafa4275ad4f93ae274f7f88fd257ce33">node</a> () const</td></tr>
<tr class="memdesc:aafa4275ad4f93ae274f7f88fd257ce33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#aafa4275ad4f93ae274f7f88fd257ce33">More...</a><br /></td></tr>
<tr class="separator:aafa4275ad4f93ae274f7f88fd257ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae292072a84d07c867536e3de3b878e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e">close</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9ae292072a84d07c867536e3de3b878e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all stored resources (any desired events, result events, and any handler saved by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>) and moves state to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">State::S_CLOSED</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e">More...</a><br /></td></tr>
<tr class="separator:a9ae292072a84d07c867536e3de3b878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496b760adb19356b4aee9a17ca13b523"><td class="memTemplParams" colspan="2">template&lt;typename Socket &gt; </td></tr>
<tr class="memitem:a496b760adb19356b4aee9a17ca13b523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523">add_wanted_socket</a> (typename Socket::Ptr sock, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a496b760adb19356b4aee9a17ca13b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given socket to the set of sockets we want to know are "ready" by the definition of the given event type.  <a href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523">More...</a><br /></td></tr>
<tr class="separator:a496b760adb19356b4aee9a17ca13b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bd92001ec9ca3623a0e84a50043bb9"><td class="memTemplParams" colspan="2">template&lt;typename Socket &gt; </td></tr>
<tr class="memitem:ac3bd92001ec9ca3623a0e84a50043bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9">remove_wanted_socket</a> (typename Socket::Ptr sock, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ac3bd92001ec9ca3623a0e84a50043bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9">More...</a><br /></td></tr>
<tr class="separator:ac3bd92001ec9ca3623a0e84a50043bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e47fc394c09acf4d100a640e090a7aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa">swap_wanted_sockets</a> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> *target_set, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a6e47fc394c09acf4d100a640e090a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently exchanges the current set of sockets we want to know are "ready" by the definiton of the given event type.  <a href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa">More...</a><br /></td></tr>
<tr class="separator:a6e47fc394c09acf4d100a640e090a7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ddd6fb8874d85869157bae2ffda69b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a86ddd6fb8874d85869157bae2ffda69b">clear_wanted_sockets</a> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a86ddd6fb8874d85869157bae2ffda69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <code>swap_wanted_sockets(&amp;sockets, ev_type, err_code)</code>, where originally <code>sockets</code> is empty and is afterwards cleared; but more efficient.  <a href="classflow_1_1net__flow_1_1Event__set.html#a86ddd6fb8874d85869157bae2ffda69b">More...</a><br /></td></tr>
<tr class="separator:a86ddd6fb8874d85869157bae2ffda69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976144f6e525190344eb4e51620f9fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a976144f6e525190344eb4e51620f9fd9">events_wanted</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a976144f6e525190344eb4e51620f9fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if at least one wanted event for at least one socket is registered (via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">swap_wanted_sockets()</a>, etc.).  <a href="classflow_1_1net__flow_1_1Event__set.html#a976144f6e525190344eb4e51620f9fd9">More...</a><br /></td></tr>
<tr class="separator:a976144f6e525190344eb4e51620f9fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412214de6a4f3a1ff1e86ddb1975f47b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b">poll</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a412214de6a4f3a1ff1e86ddb1975f47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for all previously described events that currently hold, saves them for retrieval via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., and returns.  <a href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b">More...</a><br /></td></tr>
<tr class="separator:a412214de6a4f3a1ff1e86ddb1975f47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133c518168fe3922ab6729a99077dd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f">sync_wait</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a133c518168fe3922ab6729a99077dd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks indefinitely until one or more of the previously described events hold &ndash; or the wait is interrupted; saves them for retrieval via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc.  <a href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f">More...</a><br /></td></tr>
<tr class="separator:a133c518168fe3922ab6729a99077dd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7272a3b8975ff72edd3db3f777e930f1"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a7272a3b8975ff72edd3db3f777e930f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a7272a3b8975ff72edd3db3f777e930f1">sync_wait</a> (const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7272a3b8975ff72edd3db3f777e930f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the other <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> but will stop waiting if the timeout given as argument expires.  <a href="classflow_1_1net__flow_1_1Event__set.html#a7272a3b8975ff72edd3db3f777e930f1">More...</a><br /></td></tr>
<tr class="separator:a7272a3b8975ff72edd3db3f777e930f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dfb881ab3a9488a6a60dd83ad21c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85">async_wait</a> (const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_handler</a> &amp;on_event, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a43dfb881ab3a9488a6a60dd83ad21c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves object to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state, saves the given handler to be executed later (in a different, unspecified thread), when one or more of the previously described events hold; and immediately returns.  <a href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85">More...</a><br /></td></tr>
<tr class="separator:a43dfb881ab3a9488a6a60dd83ad21c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3122100c044da08495fac737998f60db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db">async_wait_finish</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a3122100c044da08495fac737998f60db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves object from <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a>, and forgets any handler saved by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, or does nothing if state is already INACTIVE.  <a href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db">More...</a><br /></td></tr>
<tr class="separator:a3122100c044da08495fac737998f60db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314635daf8fdf3805868baff8b42cfc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a314635daf8fdf3805868baff8b42cfc9">events_detected</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a314635daf8fdf3805868baff8b42cfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the last wait, if any, detected at least one event.  <a href="classflow_1_1net__flow_1_1Event__set.html#a314635daf8fdf3805868baff8b42cfc9">More...</a><br /></td></tr>
<tr class="separator:a314635daf8fdf3805868baff8b42cfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b26f25a2e76e3c61b4760b59de5b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25">emit_result_sockets</a> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> *target_set, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a72b26f25a2e76e3c61b4760b59de5b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.  <a href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25">More...</a><br /></td></tr>
<tr class="separator:a72b26f25a2e76e3c61b4760b59de5b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6379c7fe127c26fd4cdc9752ccf9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#afb6379c7fe127c26fd4cdc9752ccf9e2">clear_result_sockets</a> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a> ev_type, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:afb6379c7fe127c26fd4cdc9752ccf9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <code>emit_result_sockets(&amp;sockets, ev_type, err_code)</code>, where originally <code>sockets</code> is empty and is afterwards cleared; but more efficient.  <a href="classflow_1_1net__flow_1_1Event__set.html#afb6379c7fe127c26fd4cdc9752ccf9e2">More...</a><br /></td></tr>
<tr class="separator:afb6379c7fe127c26fd4cdc9752ccf9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64e128595b701e37256ff79d782c146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ab64e128595b701e37256ff79d782c146">clear</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ab64e128595b701e37256ff79d782c146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets all sockets stored in this object in any fashion.  <a href="classflow_1_1net__flow_1_1Event__set.html#ab64e128595b701e37256ff79d782c146">More...</a><br /></td></tr>
<tr class="separator:ab64e128595b701e37256ff79d782c146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a47e4e6d304a6a381e7469fe87c547738"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">Mutex</a> = <a class="el" href="namespaceflow_1_1util.html#a9c7a5df07c2e86c788de9e6bbaee77d5">util::Mutex_recursive</a></td></tr>
<tr class="memdesc:a47e4e6d304a6a381e7469fe87c547738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for reentrant mutex type.  <a href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">More...</a><br /></td></tr>
<tr class="separator:a47e4e6d304a6a381e7469fe87c547738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6ff0e1ad4c13220a371045101a5eff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a7e6ff0e1ad4c13220a371045101a5eff">Lock_guard</a> = <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">Mutex</a> &gt;</td></tr>
<tr class="memdesc:a7e6ff0e1ad4c13220a371045101a5eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for RAII lock guard of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738" title="Short-hand for reentrant mutex type.">Mutex</a>. Use instead of <code>boost::lock_guard</code> for <code>release()</code> at least.  <a href="classflow_1_1net__flow_1_1Event__set.html#a7e6ff0e1ad4c13220a371045101a5eff">More...</a><br /></td></tr>
<tr class="separator:a7e6ff0e1ad4c13220a371045101a5eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac46b4e327b3781faab4853a290877"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">util::Linked_hash_map</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> &gt;</td></tr>
<tr class="memdesc:affac46b4e327b3781faab4853a290877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for type storing a set of socket sets &ndash; one per possible <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> <code>enum</code> value.  <a href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">More...</a><br /></td></tr>
<tr class="separator:affac46b4e327b3781faab4853a290877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7b8e6cf7046b6905015301a203cd88f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a7b8e6cf7046b6905015301a203cd88f5">Event_set</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a7b8e6cf7046b6905015301a203cd88f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object; initializes all values to well-defined but possibly meaningless values (0, empty, etc.).  <a href="classflow_1_1net__flow_1_1Event__set.html#a7b8e6cf7046b6905015301a203cd88f5">More...</a><br /></td></tr>
<tr class="separator:a7b8e6cf7046b6905015301a203cd88f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e16d91f81860eb2a6c971863548e466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8e16d91f81860eb2a6c971863548e466">ok_to_mod_socket_set</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a8e16d91f81860eb2a6c971863548e466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that ensures the state of <code>*this</code> is such that one may modify the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">m_can</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">m_want</a> socket sets.  <a href="classflow_1_1net__flow_1_1Event__set.html#a8e16d91f81860eb2a6c971863548e466">More...</a><br /></td></tr>
<tr class="separator:a8e16d91f81860eb2a6c971863548e466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a17c404f0ce43da5fec53a550da9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a13a17c404f0ce43da5fec53a550da9be">sync_wait_impl</a> (const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a13a17c404f0ce43da5fec53a550da9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the public <code>sync_wait(max_wait)</code> but uses a <code>Fine_clock</code>-based <code>Fine_duration</code> non-template type for implementation convenience and to avoid code bloat in specifying timeout.  <a href="classflow_1_1net__flow_1_1Event__set.html#a13a17c404f0ce43da5fec53a550da9be">More...</a><br /></td></tr>
<tr class="separator:a13a17c404f0ce43da5fec53a550da9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a79d75ea514f571d9f6bd2cfcad502f22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a79d75ea514f571d9f6bd2cfcad502f22">empty_ev_type_to_socks_map</a> ()</td></tr>
<tr class="memdesc:a79d75ea514f571d9f6bd2cfcad502f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a maximally empty <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>: it will have all possible Event_type as keys but only empty <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> sets as values.  <a href="classflow_1_1net__flow_1_1Event__set.html#a79d75ea514f571d9f6bd2cfcad502f22">More...</a><br /></td></tr>
<tr class="separator:a79d75ea514f571d9f6bd2cfcad502f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edced1cb69b2cad299ee32e652ccea7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a0edced1cb69b2cad299ee32e652ccea7">clear_ev_type_to_socks_map</a> (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> *ev_type_to_socks_map)</td></tr>
<tr class="memdesc:a0edced1cb69b2cad299ee32e652ccea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that clears each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> set inside an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a0edced1cb69b2cad299ee32e652ccea7">More...</a><br /></td></tr>
<tr class="separator:a0edced1cb69b2cad299ee32e652ccea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9505b886c78169fe35b527f4e01855"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aed9505b886c78169fe35b527f4e01855">ev_type_to_socks_map_entry_is_empty</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Ev_type_to_socks_map::Value</a> &amp;ev_type_and_socks)</td></tr>
<tr class="memdesc:aed9505b886c78169fe35b527f4e01855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional helper that checks whether a given <code>pair</code> in an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a> contains an empty set of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> or not.  <a href="classflow_1_1net__flow_1_1Event__set.html#aed9505b886c78169fe35b527f4e01855">More...</a><br /></td></tr>
<tr class="separator:aed9505b886c78169fe35b527f4e01855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e241ae4dfe1ea54de6027052bc2135"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19e241ae4dfe1ea54de6027052bc2135">ev_type_to_socks_map_sizes_to_str</a> (const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> &amp;ev_type_to_socks_map)</td></tr>
<tr class="memdesc:a19e241ae4dfe1ea54de6027052bc2135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns a loggable string summarizing the sizes of the socket sets, by type, stored in an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>.  <a href="classflow_1_1net__flow_1_1Event__set.html#a19e241ae4dfe1ea54de6027052bc2135">More...</a><br /></td></tr>
<tr class="separator:a19e241ae4dfe1ea54de6027052bc2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04c117b15179ba37a94f6836c63497b"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ae04c117b15179ba37a94f6836c63497b">sock_as_any_to_str</a> (const boost::any &amp;sock_as_any)</td></tr>
<tr class="memdesc:ae04c117b15179ba37a94f6836c63497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns a loggable string representing the socket stored in the given <code>boost::any</code> that stores a value allowed by the members of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> <code>enum</code>.  <a href="classflow_1_1net__flow_1_1Event__set.html#ae04c117b15179ba37a94f6836c63497b">More...</a><br /></td></tr>
<tr class="separator:ae04c117b15179ba37a94f6836c63497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a56925e15b38d285f387e10bfb18f93c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a56925e15b38d285f387e10bfb18f93c9">m_state</a></td></tr>
<tr class="memdesc:a56925e15b38d285f387e10bfb18f93c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a>. Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that.  <a href="classflow_1_1net__flow_1_1Event__set.html#a56925e15b38d285f387e10bfb18f93c9">More...</a><br /></td></tr>
<tr class="separator:a56925e15b38d285f387e10bfb18f93c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af635301685a4a331142e1ac8a791a65d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af635301685a4a331142e1ac8a791a65d">m_node</a></td></tr>
<tr class="memdesc:af635301685a4a331142e1ac8a791a65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aafa4275ad4f93ae274f7f88fd257ce33" title="Node that produced this Event_set.">node()</a>. Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that.  <a href="classflow_1_1net__flow_1_1Event__set.html#af635301685a4a331142e1ac8a791a65d">More...</a><br /></td></tr>
<tr class="separator:af635301685a4a331142e1ac8a791a65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fa5dbda4ffd95b35dee57fc01b90ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce">m_want</a></td></tr>
<tr class="memdesc:af4fa5dbda4ffd95b35dee57fc01b90ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets, categorized by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> of interest, to check for "ready" status (as defined in the doc header for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>), in the next wait (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state).  <a href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce">More...</a><br /></td></tr>
<tr class="separator:af4fa5dbda4ffd95b35dee57fc01b90ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8a102c621b1536659973b2d6b33822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822">m_can</a></td></tr>
<tr class="memdesc:abf8a102c621b1536659973b2d6b33822"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets, categorized by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> of interest, that were found to be "ready" (as defined in the doc header for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>), during the last wait (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state).  <a href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822">More...</a><br /></td></tr>
<tr class="separator:abf8a102c621b1536659973b2d6b33822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f6ddb0d0258cc029c435a8ed0f89f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a59f6ddb0d0258cc029c435a8ed0f89f7">m_on_event</a></td></tr>
<tr class="memdesc:a59f6ddb0d0258cc029c435a8ed0f89f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">During <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>, stores the handler (a <code>void</code> function with 1 <code>bool</code> argument) that will be called once one or more events are found to hold.  <a href="classflow_1_1net__flow_1_1Event__set.html#a59f6ddb0d0258cc029c435a8ed0f89f7">More...</a><br /></td></tr>
<tr class="separator:a59f6ddb0d0258cc029c435a8ed0f89f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8d103341b6450f3390dc6ce24ccdef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ada8d103341b6450f3390dc6ce24ccdef">m_baseline_check_pending</a></td></tr>
<tr class="memdesc:ada8d103341b6450f3390dc6ce24ccdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">While in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>, if this is <code>true</code>, an exhaustive check of all desired events is yet to be performed (in thread W); if <code>false</code>, it has alredy been performed (in thread W), and only "delta" checks need to be checked from now on during this wait.  <a href="classflow_1_1net__flow_1_1Event__set.html#ada8d103341b6450f3390dc6ce24ccdef">More...</a><br /></td></tr>
<tr class="separator:ada8d103341b6450f3390dc6ce24ccdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda853ab017dd9bfcfb71b601d15698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a0dda853ab017dd9bfcfb71b601d15698">m_mutex</a></td></tr>
<tr class="memdesc:a0dda853ab017dd9bfcfb71b601d15698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting ALL data in this object.  <a href="classflow_1_1net__flow_1_1Event__set.html#a0dda853ab017dd9bfcfb71b601d15698">More...</a><br /></td></tr>
<tr class="separator:a0dda853ab017dd9bfcfb71b601d15698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa321c69146b8575e4d0e3b15c67d4f08"><td class="memItemLeft" align="right" valign="top">static const boost::unordered_map&lt; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>, <a class="el" href="classflow_1_1Function.html">Function</a>&lt; <a class="el" href="classbool.html">bool</a>(const <a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *, const boost::any &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aa321c69146b8575e4d0e3b15c67d4f08">S_EV_TYPE_TO_IS_ACTIVE_NODE_MTD</a></td></tr>
<tr class="memdesc:aa321c69146b8575e4d0e3b15c67d4f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from each possible <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> method that determines whether the condition defined by that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> is currently true for the socket wrapped in the <code>boost::any</code> argument passed to the method.  <a href="classflow_1_1net__flow_1_1Event__set.html#aa321c69146b8575e4d0e3b15c67d4f08">More...</a><br /></td></tr>
<tr class="separator:aa321c69146b8575e4d0e3b15c67d4f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6db9d28bd448a131448276ee03de1e6d">Node</a></td></tr>
<tr class="memdesc:a6db9d28bd448a131448276ee03de1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> documentation header.  <a href="classflow_1_1net__flow_1_1Event__set.html#a6db9d28bd448a131448276ee03de1e6d">More...</a><br /></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aebbf2b8f19e2b3d887fe234cd5bdcffc">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">Event_set::State</a> <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0">state</a>)</td></tr>
<tr class="memdesc:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> state to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Event__set.html#aebbf2b8f19e2b3d887fe234cd5bdcffc">More...</a><br /></td></tr>
<tr class="separator:aebbf2b8f19e2b3d887fe234cd5bdcffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57b16fd356cacb8432a8ce7b021b54c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac57b16fd356cacb8432a8ce7b021b54c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type)</td></tr>
<tr class="memdesc:ac57b16fd356cacb8432a8ce7b021b54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given event type to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Event__set.html#ac57b16fd356cacb8432a8ce7b021b54c">More...</a><br /></td></tr>
<tr class="separator:ac57b16fd356cacb8432a8ce7b021b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Event_set &gt; &gt;</a></td></tr>
<tr class="memitem:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides syntactic-sugary way to perform a <code>static_pointer_cast&lt;&gt;</code> from a compatible smart pointer type <code>From_ptr</code>, typically <code>From_ptr::element_type</code> being in the same class hierarchy as <code>Target_ptr::element_type</code>.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">More...</a><br /></td></tr>
<tr class="separator:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but adds <code>const</code>-ness (immutability) to the pointed-to type.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">More...</a><br /></td></tr>
<tr class="separator:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">dynamic_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">More...</a><br /></td></tr>
<tr class="separator:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">dynamic_const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8" title="Identical to ptr_cast() but adds const-ness (immutability) to the pointed-to type.">const_ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">More...</a><br /></td></tr>
<tr class="separator:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A user-set collection of sockets and desired conditions on those sockets (such as: "socket has data
to read"), with the ability to wait for those conditions to become true and signal the user when so. </p>
<dl class="section note"><dt>Note</dt><dd>Important: With the somewhat more recent availability of the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> hierarchy, which slickly adds boost.asio-event-loop-integration to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> hierarchy, public use of this class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> should be avoided for those already using a boost.asio event loop. It is both significantly simpler &ndash; and a bit faster &ndash; to use Peer_socket::async_send(), Server_socket::async_accept(), etc. &ndash; as well as a bit faster. IN PARTICULAR, the complex discussion in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header regarding <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> with a glue socket is something one should skip over if one could just integrate directly into a boost.asio loop. </dd>
<dd>
Advice: Even if you don't already use a boost.asio event loop, consider doing so before giving up and going for an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> glue pattern as described in this class doc header. Your application may be sigificantly simpler and more maintainable as a result. </dd>
<dd>
Advice: In general, please read the bird's eye view of the entire set of I/O ops in <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>; this is found in <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> doc header. This should help hugely in choosing the right type of operating mode in the context of a non-trivial application, possibly featuring other types of I/O in addition to the Flow protocol. </dd>
<dd>
All that said, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is a very important facility and is, at the very least, built-upon internally for all but the basic non-blocking ops. Advanced users should understand it (even if they don't use it directly).</dd></dl>
<p>This fulfills the same role as BSD sockets' <code>select()</code> (and its more powerful non-portable equivalents like epoll, kqueue, etc.). In addition to the feature set provided by functions such as <code>select()</code>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> provides a way to work together with the OS's built-in <code>select()</code> equivalent; that is to say it provides a way to add Flow-protocol sockets into an event loop written in terms of <code>select()</code> or spritiually similar facilities (epoll, kqueue, etc.).</p>
<p >The simplest way to use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is to not use it directly at all. Instead, use the blocking methods such as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>. Such methods will internally construct an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> with the target socket and perform work (namely some <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a> calls) on it, hidden from the caller. This mode of operation is analogous to BSD sockets' blocking functions (e.g., <code>recv()</code> in blocking mode &ndash; POSIX <code>O_NONBLOCK</code> bit set / WinSock <code>FIONBIO</code> mode is enabled).</p>
<p >This is often insufficient, as in event loops of any complexity. The next simplest way to use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is to use a synchronous wait. To do so, construct an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>, add the desired <em>(socket, desired event on that socket)</em> pairs to it (see the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">swap_wanted_sockets()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9" title="Opposite of add_wanted_socket().">remove_wanted_socket()</a> methods), then perform <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (with an optional timeout). Once that method returns (which happens once either 1 or more events are active, there is a timeout, or wait is interrupted via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a>), examine which events (if any) were found to be active, then perform the appropriate operation (e.g., <code>serv-&gt;accept()</code> if Acceptable, <code>sock-&gt;send()</code> if Writable) on each active socket/event pair. This mode of operation is analogous to <code>FD_SET(); select(); FD_ISSET()</code> or <code>epoll_ctl(); epoll_wait()</code>. The key feature is that the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (like <code>select()</code> or <code>epoll_wait()</code>) call blocks the calling thread until there are events or a timeout or a global interrupt (the latter similar to POSIX <code>EINTR</code> caused by a signal). Additionally, the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b" title="Checks for all previously described events that currently hold, saves them for retrieval via emit_res...">Event_set::poll()</a> method is analogous to a <code>select()</code> call with a 0 timeout.</p>
<p >The above is sufficient when writing an event loop that works <em>only</em> with Flow-protocol sockets. However, many practical applications will use an event loop that works with Flow-protocol sockets and other resources (e.g., TCP sockets, pipes) simultaneously. Then what?</p><ul>
<li>If you have a boost.asio event loop, then (again) the best way to use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is by not using it directly; instead use <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> hierarchy to use Flow-protocol sockets as 1st-class-citizen boost.asio-style I/O objects. Internally, again, an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> will be indirectly used; but one would not use it directly.</li>
<li>Otherwise &ndash; if there is no boost.asio event loop, and it's impractical to convert to using one (generally a a good idea but may not be practical under time constraints), then direct use the core <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> feature (namely <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>) is just the ticket.</li>
</ul>
<p >We now discuss <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>. The basic deficiency of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> is simply that it will only wake up if there's a Flow-protocol event and knows nothing about anything else. Similarly, your <code>select()</code>-or-equivalent-of-choice will know nothing of Flow-protocol events, since it can only work with standard file descriptors (or whatever), not Flow sockets. For this case <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> provides asynchronous waiting. As before, you'll construct an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> and add some desired sockets/events. Then, call <code>async_wait(F)</code>, where <code>F()</code> is a function. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> will IMMEDIATELY return. However, another, unspecified, thread will wait for the desired condition(s) to become true. Once that occurs, that unspecified thread will call <code>F()</code>. <code>F()</code> can do whatever you want (but see restrictions documented on <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>); however in the use case described in this paragraph it will probably want to do something that will wake up the <code>select()</code> (or <code>epoll_wait()</code>, or ...) of your main event loop. For example, you can set up a Unix domain socket or pipe and add it into your <code>select()</code> (or equivalent's) event set; and then have <code>F()</code> write 1 byte to it. Once this occurs, that <code>select()</code> (etc.) will wake up; you can call <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a></code> and then check the active Flow-protocol events using the same techniques as shown in the preceding paragraph, after having called <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>.</p>
<p >The following illustrates the preceding paragraph. In this example, we are interested in a single TCP socket from which to read; and a single Flow socket from which to read. This can be extended to more native and Flow socket types, more sockets, and more sophisticated native mechanisms than <code>select()</code>; but basically this is it. (However, in case of <code>select()</code> and its peculiar <code>FD_SET()</code> semantics, please note that this examples combines <code>sel_read_set</code> to handle both the special local "linking" socket <code>comm_sock</code> and the TCP-readable socket <code>tcp_sock</code>. If you want to check for another type of event than being "readable" &ndash; e.g., "writable" &ndash; then with <code>select()</code> you'd need to make a separate event set, perhaps named <code>sel_write_set</code>, and it would not be handling <code>comm_sock</code>, in whose case we only care about readability. Note also that the example event loop iteration shown below models situation where <code>tcp_sock</code> and <code>flow_sock</code> happen to both become readable just about at the same time, causing <code>select()</code> to return with 2 sockets in readable state simultaneously for illustration purposes. Realistically probably one would become readable; then in another loop iteration the other would... but this would be annoyingly lengthy to show; and though this is less probable, it's still possible.</p>
<div class="fragment"><div class="line"><span class="comment">// NOTE: ASCII art arrows |--------&gt; (etc.) indicate thread execution.  &quot;U&quot; is the user thread.</span></div>
<div class="line"><span class="comment">//       &quot;K&quot; is unspecified kernel &quot;thread.&quot;  &quot;W&quot; is unspecified `net_flow` working thread.</span></div>
<div class="line"><span class="comment">//       T (cont.) just means thread T was already running up to the point we are illustrating.</span></div>
<div class="line"> </div>
<div class="line">U (cont.)</div>
<div class="line">| Set up local socket (e.g., Unix domain socket or localhost TCP socket) comm_sock.</div>
<div class="line">| Set up select() native socket set sel_read_set, for native &quot;readable&quot; events.</div>
<div class="line">| Set up net_flow::<a class="code hl_class" href="classflow_1_1net__flow_1_1Event__set.html">Event_set</a> flow_set.</div>
<div class="line">| FD_SET(comm_sock, sel_read_set);</div>
<div class="line">| Set up native TCP peer socket tcp_sock.</div>
<div class="line">| Set up Flow peer socket flow_sock.</div>
<div class="line">| FD_SET(tcp_sock, sel_read_set);</div>
<div class="line">| flow_set.<a class="code hl_function" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523">add_wanted_socket</a>(flow_sock, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>::S_PEER_SOCKET_READABLE);</div>
<div class="line">| Event loop begins here. &lt;--------------------------------------+ K (cont.)             W (cont.)</div>
<div class="line">|   flow_set.<a class="code hl_function" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85">async_wait</a>(handle_flow_ev);                         | | ...                 | ...</div>
<div class="line">|     Inform W. -&gt;                                               | | ...                 | flow_set -&gt; WAITING.</div>
<div class="line">|   select(2, sel_read_set, NULL, NULL, ...positive-timeout...); | | ...                 | ...</div>
<div class="line">|     ...select() blocking...                                    | | ...                 | ...</div>
<div class="line">|     ...                                                        | | ...                 | ...</div>
<div class="line">|     ...                                                        | | tcp_sock readable!  | ...</div>
<div class="line">|     ...                                                        | | &lt;- Tell select().   |</div>
<div class="line">|     K says tcp_sock readable! Get ready to return!             | | ...                 | flow_sock readable!</div>
<div class="line">|                                                                | |                     | handle_flow_ev():</div>
<div class="line">|                                                                | |                     |   Write 1 -&gt; comm_sock.</div>
<div class="line">|                                                                | | comm_sock readable! |</div>
<div class="line">|                                                                | | &lt;- Tell select().   |</div>
<div class="line">|     K says comm_sock readable, and that&#39;s it.  Return!         | | ...                 | ...</div>
<div class="line">|   flow_set.<a class="code hl_function" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db">async_wait_finish</a>();                                | v                     | ...</div>
<div class="line">|     Inform W. -&gt;                                               |                       | ...</div>
<div class="line">|   if (FD_ISSET(tcp_sock, sel_read_set))                        |                       | flow_set -&gt; INACTIVE.</div>
<div class="line">|     Non-blocking recv(tcp_sock) until exhausted!               |                       v</div>
<div class="line">|   if (FD_ISSET(comm_sock, sel_read_set))                       |</div>
<div class="line">|     In this example we&#39;ve only 1 Flow socket and event, so: \  |</div>
<div class="line">|     flow_sock.async_receive() until exhausted!                 |</div>
<div class="line">| Event loop ends here. -----------------------------------------+</div>
<div class="line">v</div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html">flow::net_flow::Event_set</a></div><div class="ttdoc">A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8hpp_source.html#l00247">event_set.hpp:254</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a19cc3a286c8a11c986d2a59ec1e39a71"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">flow::net_flow::Event_set::Event_type</a></div><div class="ttdeci">Event_type</div><div class="ttdoc">Type of event or condition of interest supported by class Event_set.</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8hpp_source.html#l00306">event_set.hpp:307</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a3122100c044da08495fac737998f60db"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db">flow::net_flow::Event_set::async_wait_finish</a></div><div class="ttdeci">bool async_wait_finish(Error_code *err_code=0)</div><div class="ttdoc">Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l00215">event_set.cpp:215</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a43dfb881ab3a9488a6a60dd83ad21c85"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85">flow::net_flow::Event_set::async_wait</a></div><div class="ttdeci">bool async_wait(const Event_handler &amp;on_event, Error_code *err_code=0)</div><div class="ttdoc">Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l00072">event_set.cpp:72</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a496b760adb19356b4aee9a17ca13b523"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523">flow::net_flow::Event_set::add_wanted_socket</a></div><div class="ttdeci">bool add_wanted_socket(typename Socket::Ptr sock, Event_type ev_type, Error_code *err_code=0)</div><div class="ttdoc">Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8hpp_source.html#l01015">event_set.hpp:1015</a></div></div>
</div><!-- fragment --><p >The above are informal suggestions for use. Here is the more formal description of operation of an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is a simple state machine with three states: INACTIVE, WAITING, CLOSED. After construction (which is done by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in a factory fashion), <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is in INACTIVE state. CLOSED means the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> has been <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>d, or the originating <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has been destroyed. It is not possible to perform any operations on a CLOSED <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>, nor is it possible to exit the CLOSED state. A CLOSED <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> stores no resources and will be deleted via <code>shared_ptr&lt;&gt;</code> mechanics once all user references to it are gone.</p>
<p >The rest of the time, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> switches back and forth between INACTIVE and WAITING. In INACTIVE, you may set and examine the desired sockets/events. The following are supported (see also <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a> <code>enum</code> values)</p>
<ul>
<li><em><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> Readable</em>: true if and only if <code>sock-&gt;receive()</code> with unlimited target buffer space would return either a non-zero number of bytes or indicate an error. (Therefore "not Readable" means it would return 0 but no error.)</li>
<li><em><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> Writable</em>: same but with <code>sock-&gt;send()</code>. Note, however, that typically this is more likely to be immediately true on a given socket; if there's space in the Send buffer for a certain small amount of data, then the socket owning it is Writable; whereas data have to actually have arrived from the other side for it to be Readable. Nevertheless, if network conditions are such that the Send buffer cannot be purged via sending its contents to the other side, then eventually it won't be Writable either (so don't count on writability without checking).</li>
<li><em><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> Acceptable</em>: true if and only if <code>serv-&gt;accept()</code> would return either a non-null <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a> or indicate an error. (Therefore "not Acceptable" means it would return null but no error.)</li>
</ul>
<p >The desired events can be specified with <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">swap_wanted_sockets()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9" title="Opposite of add_wanted_socket().">remove_wanted_socket()</a>. Note that all of these methods are efficient (no copying of socket sets involved). Also note that all the socket objects passed to an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> must come from the same <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> as that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>; else behavior is undefined.</p>
<p >Also in INACTIVE, you may examine the results of the last wait, if any. Do this using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc. Note that these methods are also efficient (no copying) and can only be used once for each wait (all subsequent uses yield empty socket sets).</p>
<p >In WAITING state, a wait for the specified events has started. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b" title="Checks for all previously described events that currently hold, saves them for retrieval via emit_res...">poll()</a> change state from INACTIVE to WAITING. In WAITING state, all of the above methods return errors. The following pieces of code change state back to INACTIVE: <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (once an event is true, or timeout), <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b" title="Checks for all previously described events that currently hold, saves them for retrieval via emit_res...">poll()</a> (immediately), and an unspecified non-user thread if <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> was used, and an event has been asynchronously detected.</p>
<p >In particular, if <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> e</code> is used by 1 thread, and that thread performs only <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>s for waiting, user code will never be able to observe the WAITING state, as <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> will go INACTIVE-&gt;WAITING-&gt;INACTIVE internally.</p>
<h3>Relationship between 2 different <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects</h3>
<p >They are entirely independent. In particular, you may put the same socket+event combo into 2 different <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects and wait on both Event_sets simultaneously. If that socket/event holds for both <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects at the same time, both will be signalled. I informally recommend against using this. For example, if the event is "sock is
Readable," and you will <code>receive()</code> as a result, which of the two <code>receive()</code> calls gets what data? However there may be a reasonable use case for the Acceptable event.</p>
<h3>Signals and interruption</h3>
<p >Any POSIX blocking function, once it has started waiting, will exit with <code>errno == EINTR</code> if a signal is delivered. (Sometimes this is just annoying, but sometimes it's useful: if SIGTERM handler sets some global terminate flag, then the signal delivery will immediately break out of the blocking call, so the flag can be immediately checked by the main code (and then the program can cleanly exit, for example).) <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> support similar functionality. Call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a> to interrupt any <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> object(s) within that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> currently in WAITING state. They enter INACTIVE state, and it is indicated to the user of each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> or <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> that the reason for the wait's finish was an interruption (see those functions for details on how this is communicated). Conceptually this is similar to POSIX blocking <code>select()</code> or blocking <code>recv()</code> returning -1/<code>EINTR</code>.</p>
<p >To actually cause signals to trigger <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a> (as occurs by default, conceptually, in POSIX programs w/r/t <code>EINTR</code>), the user has two basic options. They can either register signal handlers that'll explicitly invoke that method; or they can let <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> do so automatically for SIGINT and SIGTERM. This is controlled by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> option <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#aea7861f3c7739f8e588293d16a2de447" title="If and only if this is true, the Node will detect SIGINT and SIGTERM (or your OS&#39;s version thereof); ...">Node_options::m_st_capture_interrupt_signals_internally</a>.</p>
<h3>Thread safety</h3>
<p >Same as for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. (Briefly: all operations safe for simultaneous execution on separate or the same object.) An informal recommendation, however, is to only use a given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in one thread. Otherwise things will get confusing, quickly, with no practical benefit of which I, at least, am aware.</p>
<h3>Implementation notes</h3>
<p >The crux of the implementation is in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, as all other wait types are built on it. Therefore there is a giant comment inside that method that is required reading for understanding this class's innards (which, IMO, are some of the trickiest logic in all of the library).</p>
<p >As with <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, much of the implementation (as opposed to interface) of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> functionality resides in class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. In particular anything to do with thread W is in <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. The actual code is in <a class="el" href="event__set_8cpp.html">event_set.cpp</a>, but since the logic involves <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> state, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is subservient to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, in terms of objects it makes more sense to keep it in class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. However, when no <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> state is involved, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> logic is actually typically coded in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> methods, to a greater extent than in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, which are mere data stores in comparison. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00247">247</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="affac46b4e327b3781faab4853a290877" name="affac46b4e327b3781faab4853a290877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac46b4e327b3781faab4853a290877">&#9670;&nbsp;</a></span>Ev_type_to_socks_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">flow::net_flow::Event_set::Ev_type_to_socks_map</a> =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">util::Linked_hash_map</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for type storing a set of socket sets &ndash; one per possible <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> <code>enum</code> value. </p>
<p >In practice, the key set for a value of this type is all Event_type members; use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a79d75ea514f571d9f6bd2cfcad502f22" title="Creates a maximally empty Ev_type_to_socks_map: it will have all possible Event_type as keys but only...">empty_ev_type_to_socks_map()</a> to create a maximally empty such structure. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00798">798</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="a9da325d6cb993b975eec99adaafd3dce" name="a9da325d6cb993b975eec99adaafd3dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da325d6cb993b975eec99adaafd3dce">&#9670;&nbsp;</a></span>Event_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">flow::net_flow::Event_set::Event_handler</a> =  <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void (<a class="el" href="classbool.html">bool</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for custom handler passed to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, which is executed when one or more active events detected, or interrupted as if by signal. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>Perhaps <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> and other APIs of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> taking handlers should be templated on handler type for syntactic sugar. Though, currently, this would be no faster (it is internally stored as this type anyway and must be so), nor would it actually improve call code which needs no explicit cast (an object of this type will implicitly be substituted as a conversion from whatever compatible-with-this-signature construction they used). So on balance, this currently appears superior. After all writing non-template bodies is easier/nicer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00386">386</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="a7e6ff0e1ad4c13220a371045101a5eff" name="a7e6ff0e1ad4c13220a371045101a5eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6ff0e1ad4c13220a371045101a5eff">&#9670;&nbsp;</a></span>Lock_guard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a7e6ff0e1ad4c13220a371045101a5eff">flow::net_flow::Event_set::Lock_guard</a> =  <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">Mutex</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for RAII lock guard of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738" title="Short-hand for reentrant mutex type.">Mutex</a>. Use instead of <code>boost::lock_guard</code> for <code>release()</code> at least. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00791">791</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="a47e4e6d304a6a381e7469fe87c547738" name="a47e4e6d304a6a381e7469fe87c547738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e4e6d304a6a381e7469fe87c547738">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">flow::net_flow::Event_set::Mutex</a> =  <a class="el" href="namespaceflow_1_1util.html#a9c7a5df07c2e86c788de9e6bbaee77d5">util::Mutex_recursive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for reentrant mutex type. </p>
<p >We explicitly rely on reentrant behavior, so this isn't "just in case." (One shouldn't use reentrant mutexes "just in case"; it should be entirely conscious and on-purpose; one should use non-reentrant mutexes, all else being equal.)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd>This doc header for <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738" title="Short-hand for reentrant mutex type.">Event_set::Mutex</a> should specify what specific behavior requires mutex reentrance, so that for example one could reevaluate whether there's a sleeker code pattern that would avoid it. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00788">788</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="a592b3ce6602051bd9994216041a3cbdc" name="a592b3ce6602051bd9994216041a3cbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592b3ce6602051bd9994216041a3cbdc">&#9670;&nbsp;</a></span>Sockets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">flow::net_flow::Event_set::Sockets</a> =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">util::Linked_hash_set</a>&lt;boost::any, <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__hash.html">Socket_as_any_hash</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__equals.html">Socket_as_any_equals</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of sockets of one type, used to communicate sets of desired and resulting events in various <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> APIs. </p>
<p >As a rule, a given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> object will store sockets of one underlying type; meaning the <code>boost::any</code>s stored inside one such set can ALL be <code>boost::any_cast&lt;&gt;</code> to the <em>same</em> type. Which type that is is usually determined by the associated <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> value, typically supplied alongside a <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> set in another argument. For example, if <code>ev_type == <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" title="Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...">Event_type::S_PEER_SOCKET_READABLE</a></code>, then every <code>boost::any</code> in the set can be decoded as follows: <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> sock = any_cast&lt;<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>&gt;(sock_as_any)</code>, where <code>sock_as_any</code> is an element in a <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a>.</p>
<p >As of this writing, the type is chronologically ordered; meaning sockets will be stored in order from latest to oldest to be inserted into the structure. E.g., <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a> will produce a set containing of readable sockets, in reverse chronological order in which they were detected as being readable. This may or may not be useful in debugging.</p>
<p >This type is also used internally extensively.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>Is it necessary to have <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Event_set::Sockets</a> be aliased to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html" title="An object of this class is a set that combines the lookup speed of an unordered_set&lt;&gt; and ordering an...">util::Linked_hash_set</a>? <code>unordered_set</code> would also work and take somewhat less memory and computational overhead. It would become unordered, instead of ordered chronologically, but that seems like a price possibly worth paying.</dd></dl>
<p >Note, also, the to-do in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a> doc header, regarding using <code>variant</code> instead of <code>any</code>. Not only would that be faster and arguably safer, being compile-time in nature; but we'd get hashing/equality for free &ndash; hence the code would be much pithier (no need for <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__hash.html" title="Hasher class used in storing various sockets of types wrapped as boost::anys in the Sockets type.">Socket_as_any_hash</a> or <a class="el" href="classflow_1_1net__flow_1_1Event__set_1_1Socket__as__any__equals.html" title="Equality predicate class used in storing various sockets of types wrapped as boost::anys in the Socke...">Socket_as_any_equals</a>). </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00372">372</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a19cc3a286c8a11c986d2a59ec1e39a71" name="a19cc3a286c8a11c986d2a59ec1e39a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cc3a286c8a11c986d2a59ec1e39a71">&#9670;&nbsp;</a></span>Event_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">flow::net_flow::Event_set::Event_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of event or condition of interest supported by class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<p >When specifying interest in some socket reaching a certain condition, or when requesting the results of that interest, the user essentially specifies a pair of data: an enumeration value of this type and a socket of a certain type (that type is specified in the very name of the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>). For example, I may be interested in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" title="Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...">Event_type::S_PEER_SOCKET_READABLE</a> becoming true for <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> <code>sock</code>. The precise meaning is documented for each enumeration value.</p>
<h3>Implementation notes</h3>
<p >You will note a few different structures, such as <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">Event_set::m_want</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">Event_set::m_can</a>, are keyed by this type. Doing it that way, instead of simply having a simpler <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">Event_set::m_want</a>-like structure (etc.) exist 3x, has its plusses and minuses. Historically, this was actually implemented that other way first, but I wanted to play with <code>boost::any</code> to see if it makes the code more elegant. It has certainly resulted in significantly fewer methods and less code; and in code that is more generic (and, in principle, extensible if we somehow come up with another event type of interest); and less bug-prone. The code is also arguably more opaque and harder to grok right off the bat, as it's more abstract. Finally, from the user's point of view, it is slightly harder to use in that when emitting results of an <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>::[a]<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a></code>, one must <code>any_cast&lt;&gt;</code> to the proper socket type &ndash; easy but requires a small learning curve. I'll say overall it is better this way than the other way.</p>
<p >In terms of extending this <code>enum</code>, which seems unlikely, the following would be involved. Add a value for the <code>enum</code>; then add clauses for it in Socket_as_any_hash::operator(), Socket_as_any_equals::operator(), <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ae04c117b15179ba37a94f6836c63497b" title="Helper that returns a loggable string representing the socket stored in the given boost::any that sto...">Event_set::sock_as_any_to_str()</a>. Extend the structures in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a79d75ea514f571d9f6bd2cfcad502f22" title="Creates a maximally empty Ev_type_to_socks_map: it will have all possible Event_type as keys but only...">Event_set::empty_ev_type_to_socks_map()</a> and S_EV_TYPE_TO_IS_ACTIVE_NODE_MTD. The latter will need a new method written in <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that checks for whether the condition of this type currently holds for the given socket &ndash; whose type, by the way, you will need to decide and document in the doc header for the new <code>enum</code> value. Finally, you'll need to find all situations throughout the code where the condition may change from not holding to holding and possibly save it into <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab" title="All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...">Node::m_sock_events</a> when detected (for example, see when <code>m_sock_events[S_PEER_SOCKET_READABLE]</code> is <code>insert()</code>ed into). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" name="a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88"></a>S_PEER_SOCKET_READABLE&#160;</td><td class="fielddoc"><p >Event type specifying the condition of interest wherein a target <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> sock</code> is such that calling <code>sock-&gt;receive()</code> would yield either non-zero ("successfully dequeued
received data") or zero and an error (but not zero and NO error). </p>
<p >In other words, specifies the condition where a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is Readable.</p>
<p >In <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Event_set::Sockets</a> structures associated with this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a>, <code>boost::any</code> elements wrap the type: <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. <code>boost::any_cast&lt;&gt;</code> to that type to obtain the socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02" name="a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02"></a>S_PEER_SOCKET_WRITABLE&#160;</td><td class="fielddoc"><p >Event type specifying the condition of interest wherein a target <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> sock</code> is such that calling <code>sock-&gt;send()</code> with a non-empty buffer would yield either non-zero ("successfully enqueued
data to be sent") or zero and an error (but not zero and NO error). </p>
<p >In other words, specifies the condition where a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is Writable.</p>
<p >In <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Event_set::Sockets</a> structures associated with this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a>, <code>boost::any</code> elements wrap the type: <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. <code>boost::any_cast&lt;&gt;</code> to that type to obtain the socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2" name="a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2"></a>S_SERVER_SOCKET_ACCEPTABLE&#160;</td><td class="fielddoc"><p >Event type specifying the condition of interest wherein a target <code><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> serv</code> is such that calling <code>serv-&gt;accept()</code> would yield either non-null ("successfully accepted a ready conneection") or null and an error (but not null and NO error). </p>
<p >In other words, specifies the condition where a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> is Acceptable.</p>
<p >In <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Event_set::Sockets</a> structures associated with this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a>, <code>boost::any</code> elements wrap the type: <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a>. <code>boost::any_cast&lt;&gt;</code> to that type to obtain the socket. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00306">306</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="a2855bd159b6e63bf448ed1f41b608975" name="a2855bd159b6e63bf448ed1f41b608975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2855bd159b6e63bf448ed1f41b608975">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">flow::net_flow::Event_set::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A state of an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" name="a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657"></a>S_INACTIVE&#160;</td><td class="fielddoc"><p >Default state; valid <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> that is not currently waiting on events. </p>
<p >All user operations are valid in this state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" name="a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906"></a>S_WAITING&#160;</td><td class="fielddoc"><p >Waiting state: valid <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> that is currently waiting on previously described events. </p>
<p >In this state only <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> may be called without resulting in an error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" name="a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f"></a>S_CLOSED&#160;</td><td class="fielddoc"><p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has disowned the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>; all further operations will result in error. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00259">259</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="accb662e50999e2d0800f59a7a131bffa" name="accb662e50999e2d0800f59a7a131bffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb662e50999e2d0800f59a7a131bffa">&#9670;&nbsp;</a></span>~Event_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Event_set::~Event_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boring destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00054">54</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

</div>
</div>
<a id="a7b8e6cf7046b6905015301a203cd88f5" name="a7b8e6cf7046b6905015301a203cd88f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8e6cf7046b6905015301a203cd88f5">&#9670;&nbsp;</a></span>Event_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Event_set::Event_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object; initializes all values to well-defined but possibly meaningless values (0, empty, etc.). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use subsequently. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00042">42</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00881">flow::net_flow::Node::event_set_create()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a7b8e6cf7046b6905015301a203cd88f5_icgraph.svg" width="955" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a496b760adb19356b4aee9a17ca13b523" name="a496b760adb19356b4aee9a17ca13b523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496b760adb19356b4aee9a17ca13b523">&#9670;&nbsp;</a></span>add_wanted_socket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::add_wanted_socket </td>
          <td>(</td>
          <td class="paramtype">typename Socket::Ptr&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given socket to the set of sockets we want to know are "ready" by the definition of the given event type. </p>
<p >See individual Event_type enumeration members' doc comments for exact definition of readiness for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>. For example, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" title="Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...">Event_type::S_PEER_SOCKET_READABLE</a> means we want to know when <code>sock-&gt;receive()</code> would yield either some data or an error, but not no data and no error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Socket</td><td>type to which <code>ev_type</code> applies. E.g., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> for PEER_SOCKET_READABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to add. Must be from the same <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> as the one originating this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </td></tr>
    <tr><td class="paramname">ev_type</td><td>The condition we are interested in <code>sock</code> reaching. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: error::Code::S_EVENT_SET_ALREADY_EXISTS, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l01015">1015</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a8f3a13ffefc4897da606c86e60a4422f">flow::net_flow::error::S_EVENT_SET_EVENT_ALREADY_EXISTS</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a496b760adb19356b4aee9a17ca13b523_cgraph.svg" width="392" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a43dfb881ab3a9488a6a60dd83ad21c85" name="a43dfb881ab3a9488a6a60dd83ad21c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dfb881ab3a9488a6a60dd83ad21c85">&#9670;&nbsp;</a></span>async_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::async_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>on_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves object to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state, saves the given handler to be executed later (in a different, unspecified thread), when one or more of the previously described events hold; and immediately returns. </p>
<p >State will go back to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> when the handler fires; or when <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> is called by the user (whichever happens first). State may also change to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">State::S_CLOSED</a> if <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a></code> is called, or the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is destroyed. The saved handler will be forgotten at that time. Once INACTIVE is entered, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., are to be used to access the detected events. on_event() must take one bool argument. If this argument is <code>false</code>, use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., to access the detected events. If this argument is <code>true</code>, then <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a> was invoked and has interrupted this wait (conceptually similar to <code>EINTR</code> in POSIX). In the latter case, do no use <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., as no events are active due to the interruption.</p>
<p >In a non-error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will be INACTIVE before the call and WAITING after it. In an error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will not change, and the method will return immediately. Additionally, on_event() will NEVER be called, if another thread calls <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a></code> before <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> is called, and before the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is destroyed. So don't do that.</p>
<p >Restrictions on what <code>on_event()</code> is allowed to do: It is allowed to do anything except make any <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> call related to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> originating the current <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>; doing so results in undefined behavior. Informally, it also must not block; spending significant time in <code>on_event()</code> will disrupt the functionality of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. Even more informally, the goal of <code>on_event()</code> should be to quickly signal the user's thread(s) that the events hold (using the technique of the user's choice) and then return &ndash; beyond that, the handling of the ready events should be in the user's thread(s).</p>
<p >Tip: Call <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> before checking the saved results, using <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>. Doing so BEFORE any events are detected will finish this asynchronous wait. Doing so AFTER any events are detected will be a harmless NOOP.</p>
<p >Tip: Use lambdas (or <code>bind()</code>) to make <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> asynchronously call any arbitrary function or method with any arbitrary arguments &ndash; NOT just a free <code>void</code> function with 1 argument. Outside the scope of discussion here, but if this doesn't ring a bell, please look into lambdas (<code>bind()</code> as a backup).</p>
<p >Rationale for no timeout argument: Since the caller of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> retains flow control without blocking, the user code can enforce its own timeout logic, if necessary, and simply call <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> when desired. In fact that is just what <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (with timeout argument) does internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_event</td><td>The function to call as soon as as one or more events previously described hold, AND <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a></code> is still <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>. (Also see above tip.) <code>on_event(bool was_interrupted)</code> will be called. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482adccb025a96014a74a1435481ec2b58ac" title="Attempted to wait on or poll an event set while already waiting on that event set.">error::Code::S_EVENT_SET_DOUBLE_WAIT_OR_POLL</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00072">72</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00756">ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="event__set_8cpp_source.html#l00917">flow::net_flow::Node::event_set_async_wait()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00904">m_node</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482adccb025a96014a74a1435481ec2b58ac">flow::net_flow::error::S_EVENT_SET_DOUBLE_WAIT_OR_POLL</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5cbb0762dc20632c76db479f40237492">flow::net_flow::error::S_EVENT_SET_NO_EVENTS</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a43dfb881ab3a9488a6a60dd83ad21c85_cgraph.svg" width="534" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a43dfb881ab3a9488a6a60dd83ad21c85_icgraph.svg" width="515" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3122100c044da08495fac737998f60db" name="a3122100c044da08495fac737998f60db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3122100c044da08495fac737998f60db">&#9670;&nbsp;</a></span>async_wait_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::async_wait_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves object from <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a>, and forgets any handler saved by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, or does nothing if state is already INACTIVE. </p>
<p >Use this to cut short an asynchronous wait started by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>. After return, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., can be used to check the active events (if any) detected during the last wait.</p>
<p >In a non-error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will be <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> or <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> before the call and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> after it. In an error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will not change.</p>
<p >You might call <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a> while another thread is executing a timeout-less <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (which is also invoked by blocking methods like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>). However that will cause that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> to NEVER return. So don't do that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). In particular, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> being <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> when the method starts is not an error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00215">215</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00926">m_on_event</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a3122100c044da08495fac737998f60db_cgraph.svg" width="158" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a3122100c044da08495fac737998f60db_icgraph.svg" width="526" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab64e128595b701e37256ff79d782c146" name="ab64e128595b701e37256ff79d782c146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64e128595b701e37256ff79d782c146">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forgets all sockets stored in this object in any fashion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if no error occurred (*err_code is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00705">705</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00747">clear_ev_type_to_socks_map()</a>, <a class="el" href="event__set_8cpp_source.html#l00761">ev_type_to_socks_map_sizes_to_str()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, and <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_ab64e128595b701e37256ff79d782c146_cgraph.svg" width="718" height="199"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_ab64e128595b701e37256ff79d782c146_icgraph.svg" width="147" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0edced1cb69b2cad299ee32e652ccea7" name="a0edced1cb69b2cad299ee32e652ccea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edced1cb69b2cad299ee32e652ccea7">&#9670;&nbsp;</a></span>clear_ev_type_to_socks_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Event_set::clear_ev_type_to_socks_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> *&#160;</td>
          <td class="paramname"><em>ev_type_to_socks_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that clears each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> set inside an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>. </p>
<p >Thus, it is equivalent to <code>*ev_type_to_socks_map = <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a79d75ea514f571d9f6bd2cfcad502f22" title="Creates a maximally empty Ev_type_to_socks_map: it will have all possible Event_type as keys but only...">empty_ev_type_to_socks_map()</a></code>, but perhaps faster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_type_to_socks_map</td><td>Target map. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00747">747</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, <a class="el" href="event__set_8cpp_source.html#l00917">flow::net_flow::Node::event_set_async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l01332">flow::net_flow::Node::event_set_close_worker()</a>, <a class="el" href="event__set_8cpp_source.html#l01421">flow::net_flow::Node::interrupt_all_waits_worker()</a>, and <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a0edced1cb69b2cad299ee32e652ccea7_icgraph.svg" width="2078" height="1012"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afb6379c7fe127c26fd4cdc9752ccf9e2" name="afb6379c7fe127c26fd4cdc9752ccf9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6379c7fe127c26fd4cdc9752ccf9e2">&#9670;&nbsp;</a></span>clear_result_sockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::clear_result_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <code>emit_result_sockets(&amp;sockets, ev_type, err_code)</code>, where originally <code>sockets</code> is empty and is afterwards cleared; but more efficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_type</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>Same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00649">649</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00722">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00649">clear_result_sockets()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00852">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00649">clear_result_sockets()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_afb6379c7fe127c26fd4cdc9752ccf9e2_cgraph.svg" width="395" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_afb6379c7fe127c26fd4cdc9752ccf9e2_icgraph.svg" width="174" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a86ddd6fb8874d85869157bae2ffda69b" name="a86ddd6fb8874d85869157bae2ffda69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ddd6fb8874d85869157bae2ffda69b">&#9670;&nbsp;</a></span>clear_wanted_sockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::clear_wanted_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <code>swap_wanted_sockets(&amp;sockets, ev_type, err_code)</code>, where originally <code>sockets</code> is empty and is afterwards cleared; but more efficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_type</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">swap_wanted_sockets()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00527">527</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00722">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">clear_wanted_sockets()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00852">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00527">clear_wanted_sockets()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a86ddd6fb8874d85869157bae2ffda69b_cgraph.svg" width="404" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a86ddd6fb8874d85869157bae2ffda69b_icgraph.svg" width="183" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9ae292072a84d07c867536e3de3b878e" name="a9ae292072a84d07c867536e3de3b878e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae292072a84d07c867536e3de3b878e">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Event_set::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all stored resources (any desired events, result events, and any handler saved by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>) and moves state to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">State::S_CLOSED</a>. </p>
<p >In particular <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will have disowned this object by the time <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a> returns.</p>
<p >You might call <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a> while state is <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>, but if a timeout-less <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> is executing in another thread, it will NEVER return. Similarly, if state is currently WAITING due to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>, the handler saved by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a> will NEVER be called. So don't do that. However, first closing one or more sockets being waited on by those calls and THEN calling <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a></code> is perfectly safe, in that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> will exit, or the handler will be called. (In fact when <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> shuts down it does just that.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00464">464</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00464">close()</a>, <a class="el" href="event__set_8cpp_source.html#l01273">flow::net_flow::Node::event_set_close()</a>, <a class="el" href="error_2error_8hpp_source.html#l00168">flow::error::exec_void_and_throw_on_error()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="util__fwd_8hpp_source.html#l00955">FLOW_UTIL_WHERE_AM_I_STR</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00904">m_node</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00464">close()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a9ae292072a84d07c867536e3de3b878e_cgraph.svg" width="708" height="159"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a9ae292072a84d07c867536e3de3b878e_icgraph.svg" width="147" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a72b26f25a2e76e3c61b4760b59de5b25" name="a72b26f25a2e76e3c61b4760b59de5b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b26f25a2e76e3c61b4760b59de5b25">&#9670;&nbsp;</a></span>emit_result_sockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::emit_result_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> *&#160;</td>
          <td class="paramname"><em>target_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sockets that satisfy the condition of the given Event_type detected during the last wait. </p>
<p >More precisely, moves all sockets satisfying that condition detected during the last wait (if any) into the set provided by the user. Because it is a move (for efficiency among other reasons), the subsequent calls to the same method will yield empty sets (until the next wait operation). Calling before any wait will also yield an empty set.</p>
<p >Note that the accumulated sockets are NOT preserved across waits. That is, if you start a wait, the preceding wait's results are wiped out.</p>
<h3>Rationale</h3>
<p >Making the method a one-off that returns nothing after the first invocation (per wait) allows for thread safety without sacrificing efficiency by adding set copy.</p>
<h3>How to use</h3>
<p >First, prepare a (usually empty) target socket set structure. Second, call <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a> to transfer the results to it. Third, for each socket of interest, <code>any_cast&lt;&gt;</code> it from <code>boost::any</code> to the socket pointer of the appropriate type. (Recall that <code>boost::any</code> stores an object of any type inside it, so to get access to that you must know to what to cast it; but this is easy, since by specifying <code>ev_type</code> you are implying a certain socket type.) Example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1util_1_1Linked__hash__set.html">Event_set::Sockets</a> readable_socks; <span class="comment">// Note this contains boost::any&#39;s as elements, regardless of `ev_type`.</span></div>
<div class="line">event_set-&gt;emit_result_sockets(&amp;readable_socks, <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">Event_set::Event_type::S_PEER_SOCKET_READABLE</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; readable_sock_as_any : readable_socks)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Since we asked for S_PEER_SOCKET_READABLE, we know results are all Peer_sockets.  Cast to that type:</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> readable_sock = boost::any_cast&lt;Peer_socket::Ptr&gt;(readable_sock_as_any);</div>
<div class="line">  <span class="comment">// PEER_SOCKET_READABLE indicates readiness to receive() to yield data or an error.  We can now do so!</span></div>
<div class="line">  readable_sock-&gt;receive(...); <span class="comment">// Details of this call left to reader.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">flow::net_flow::Event_set::Event_type::S_PEER_SOCKET_READABLE</a></div><div class="ttdeci">@ S_PEER_SOCKET_READABLE</div><div class="ttdoc">Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...</div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Linked__hash__set_html"><div class="ttname"><a href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a></div><div class="ttdoc">An object of this class is a set that combines the lookup speed of an unordered_set&lt;&gt; and ordering an...</div><div class="ttdef"><b>Definition:</b> <a href="linked__hash__set_8hpp_source.html#l00047">linked_hash_set.hpp:48</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_aa4f1af88393042e60159a3a67f0accbc"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;::Ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Peer_socket &gt; Ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00118">shared_ptr_alias_holder.hpp:118</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_set</td><td>Pointer to set of sockets to which to load the current internal set of result sockets of type <code>ev_type</code> found during the last wait. Any elements here at call time will be removed. </td></tr>
    <tr><td class="paramname">ev_type</td><td>The condition we are interested in which sockets have reached during the last wait. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">Event_set::emit_result_sockets()</a> sets a <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> structure which stores <code>boost:any</code>s each of which stores either a <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a></code> or a <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a></code>; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> should be changed to store C++17 <code>std::variant</code>s. Performance, both internally and externally, would improve by using this type-safe compile-time mechanism (which is akin to <code>union</code>s but much more pleasant to use). At the time this feature was written, Flow was in C++11, so <code>variant</code>s were not available, and the author wanted to play around with <code>any</code>s instead of haxoring old-school <code>union</code>s. <code>variant</code> is much nicer, however, and the dynamic nature of <code>any</code> is entirely unnecessary here. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00613">613</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00722">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00613">emit_result_sockets()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00852">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::size()</a>, and <a class="el" href="linked__hash__set_8hpp_source.html#l00729">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00613">emit_result_sockets()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a72b26f25a2e76e3c61b4760b59de5b25_cgraph.svg" width="546" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a72b26f25a2e76e3c61b4760b59de5b25_icgraph.svg" width="170" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a79d75ea514f571d9f6bd2cfcad502f22" name="a79d75ea514f571d9f6bd2cfcad502f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d75ea514f571d9f6bd2cfcad502f22">&#9670;&nbsp;</a></span>empty_ev_type_to_socks_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Event_set::Ev_type_to_socks_map</a> flow::net_flow::Event_set::empty_ev_type_to_socks_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a maximally empty <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>: it will have all possible Event_type as keys but only empty <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> sets as values. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00736">736</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">S_PEER_SOCKET_READABLE</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">S_PEER_SOCKET_WRITABLE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71afb218b0110d3f9f26ee089bad2e0eba2">S_SERVER_SOCKET_ACCEPTABLE</a>.</p>

</div>
</div>
<a id="aed9505b886c78169fe35b527f4e01855" name="aed9505b886c78169fe35b527f4e01855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9505b886c78169fe35b527f4e01855">&#9670;&nbsp;</a></span>ev_type_to_socks_map_entry_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::ev_type_to_socks_map_entry_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af8b3b1128da79536a4c86e9feadb0c66">Ev_type_to_socks_map::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ev_type_and_socks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functional helper that checks whether a given <code>pair</code> in an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a> contains an empty set of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc" title="A set of sockets of one type, used to communicate sets of desired and resulting events in various Eve...">Sockets</a> or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_type_and_socks</td><td>A value (key and mapped, not just mapped) from an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the socket set is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00756">756</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, <a class="el" href="event__set_8cpp_source.html#l01084">flow::net_flow::Node::event_set_fire_if_got_events()</a>, <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>, <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_aed9505b886c78169fe35b527f4e01855_icgraph.svg" width="2082" height="928"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a19e241ae4dfe1ea54de6027052bc2135" name="a19e241ae4dfe1ea54de6027052bc2135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e241ae4dfe1ea54de6027052bc2135">&#9670;&nbsp;</a></span>ev_type_to_socks_map_sizes_to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::net_flow::Event_set::ev_type_to_socks_map_sizes_to_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> &amp;&#160;</td>
          <td class="paramname"><em>ev_type_to_socks_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns a loggable string summarizing the sizes of the socket sets, by type, stored in an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877" title="Short-hand for type storing a set of socket sets – one per possible Event_type enum value.">Ev_type_to_socks_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_type_to_socks_map</td><td>A valid such map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Loggable string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00761">761</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00342">flow::util::ostream_op_to_string()</a>, and <a class="el" href="linked__hash__map_8hpp_source.html#l01070">flow::util::Linked_hash_map&lt; Key, Mapped, Hash, Pred &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, and <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a19e241ae4dfe1ea54de6027052bc2135_cgraph.svg" width="507" height="160"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a19e241ae4dfe1ea54de6027052bc2135_icgraph.svg" width="2082" height="847"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a314635daf8fdf3805868baff8b42cfc9" name="a314635daf8fdf3805868baff8b42cfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314635daf8fdf3805868baff8b42cfc9">&#9670;&nbsp;</a></span>events_detected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::events_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the last wait, if any, detected at least one event. </p>
<p >In other words, returns <code>true</code> if and only if <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a> would currently emit at least one socket, if tried with all possible Event_type.</p>
<p >One can still use <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a></code> to get the specific events after calling this.</p>
<dl class="section note"><dt>Note</dt><dd>Conceptually, this is a bit like when <code>select()</code> returns 0 or higher; and one uses the check of whether its return value is 0 or non-zero. Non-zero is actually some complex index thing, but often that detail is not necessary (much like <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a></code> is unnecessary, analogously), as the mere presence or absence of 1+ events is enough information. For example, if only one event for one socket is being waited on, one can check this and confidently perform the appropriate I/O operation for that one socket, if and only if this returns <code>true</code> &ndash; or <code>select()</code> would return non-zero. Slightly more wastefully, but still not bad at all, is when (say) 2 event types are being waited on, but for only 1 socket. In that case <code>true</code> return =&gt; just perform both I/O operations; one OR both of them should yield something (and the one that doesn't hardly uses any resources). Similarly, even if you're waiting on a few sockets, if it's a limited number (like, say, 2-3), then indiscriminately trying all possible I/O on all 2-3 sockets is only slightly wasteful: and the code is quite a bit shorter than carefully checking <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a></code> (or doing <code>FD_ISSET()</code>, etc., in the analogous <code>select()</code> code). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3e273da0f7d2f231dbfaab8d07fd5ecd" title="Attempted to check wait results while still waiting.">error::Code::S_EVENT_SET_RESULT_CHECK_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are active events; <code>false</code> if there are no active events (then <code>*err_code</code> is success) or there was an error (<code>*err_code</code> is failure; i.e., <code>bool(*err_code) == true</code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00576">576</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00756">ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="event__set_8cpp_source.html#l00761">ev_type_to_socks_map_sizes_to_str()</a>, <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3e273da0f7d2f231dbfaab8d07fd5ecd">flow::net_flow::error::S_EVENT_SET_RESULT_CHECK_WHEN_WAITING</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a314635daf8fdf3805868baff8b42cfc9_cgraph.svg" width="698" height="160"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a314635daf8fdf3805868baff8b42cfc9_icgraph.svg" width="154" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a976144f6e525190344eb4e51620f9fd9" name="a976144f6e525190344eb4e51620f9fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976144f6e525190344eb4e51620f9fd9">&#9670;&nbsp;</a></span>events_wanted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::events_wanted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if at least one wanted event for at least one socket is registered (via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">swap_wanted_sockets()</a>, etc.). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are wanted events; <code>false</code> if there are no wanted events (then <code>*err_code</code> is success) or there was an error (<code>*err_code</code> is failure; i.e., <code>bool(*err_code) == true</code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00553">553</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00756">ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a976144f6e525190344eb4e51620f9fd9_cgraph.svg" width="342" height="78"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a976144f6e525190344eb4e51620f9fd9_icgraph.svg" width="147" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aafa4275ad4f93ae274f7f88fd257ce33" name="aafa4275ad4f93ae274f7f88fd257ce33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa4275ad4f93ae274f7f88fd257ce33">&#9670;&nbsp;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> * flow::net_flow::Event_set::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<p >Note that this may change the moment the method returns (but only to null).</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to (guaranteed valid) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>; null if <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> is S_CLOSED. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00066">66</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, and <a class="el" href="event__set_8hpp_source.html#l00904">m_node</a>.</p>

</div>
</div>
<a id="a8e16d91f81860eb2a6c971863548e466" name="a8e16d91f81860eb2a6c971863548e466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e16d91f81860eb2a6c971863548e466">&#9670;&nbsp;</a></span>ok_to_mod_socket_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::ok_to_mod_socket_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that ensures the state of <code>*this</code> is such that one may modify the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">m_can</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">m_want</a> socket sets. </p>
<p >Pre-condition: <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a0dda853ab017dd9bfcfb71b601d15698" title="Mutex protecting ALL data in this object.">m_mutex</a> is locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>If <code>false</code> returned, sets this to the reason why socket sets are not OK to modify. Otherwise sets it to success. Possible errors: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if OK to modify; <code>false</code> if not OK to modify. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00675">675</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79">flow::net_flow::error::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8hpp_source.html#l01015">add_wanted_socket()</a>, <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00649">clear_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">clear_wanted_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00613">emit_result_sockets()</a>, <a class="el" href="event__set_8hpp_source.html#l01052">remove_wanted_socket()</a>, and <a class="el" href="event__set_8cpp_source.html#l00493">swap_wanted_sockets()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a8e16d91f81860eb2a6c971863548e466_icgraph.svg" width="412" height="527"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a412214de6a4f3a1ff1e86ddb1975f47b" name="a412214de6a4f3a1ff1e86ddb1975f47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412214de6a4f3a1ff1e86ddb1975f47b">&#9670;&nbsp;</a></span>poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for all previously described events that currently hold, saves them for retrieval via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc., and returns. </p>
<p >This is akin to a non-blocking <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (which does not exist; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b" title="Checks for all previously described events that currently hold, saves them for retrieval via emit_res...">poll()</a> does), a/k/a a <code>select()</code> with a timeout of zero.</p>
<p >In a non-error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will be <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> before and after the call. In an error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482adccb025a96014a74a1435481ec2b58ac" title="Attempted to wait on or poll an event set while already waiting on that event set.">error::Code::S_EVENT_SET_DOUBLE_WAIT_OR_POLL</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00266">266</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00747">clear_ev_type_to_socks_map()</a>, <a class="el" href="event__set_8cpp_source.html#l01017">flow::net_flow::Node::event_set_check_baseline()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="event__set_8hpp_source.html#l00934">m_baseline_check_pending</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00904">m_node</a>, <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>, <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae">flow::net_flow::error::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482adccb025a96014a74a1435481ec2b58ac">flow::net_flow::error::S_EVENT_SET_DOUBLE_WAIT_OR_POLL</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657">S_INACTIVE</a>, and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906">S_WAITING</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a412214de6a4f3a1ff1e86ddb1975f47b_cgraph.svg" width="919" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a412214de6a4f3a1ff1e86ddb1975f47b_icgraph.svg" width="515" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac3bd92001ec9ca3623a0e84a50043bb9" name="ac3bd92001ec9ca3623a0e84a50043bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd92001ec9ca3623a0e84a50043bb9">&#9670;&nbsp;</a></span>remove_wanted_socket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::remove_wanted_socket </td>
          <td>(</td>
          <td class="paramtype">typename Socket::Ptr&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opposite of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">See</td><td><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to remove. </td></tr>
    <tr><td class="paramname">ev_type</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a96f464959b6ce918048a2167c23f1c0b" title="Attempted to work with an event that does not exist in the event set.">error::Code::S_EVENT_SET_EVENT_DOES_NOT_EXIST</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l01052">1052</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="linked__hash__set_8hpp_source.html#l00671">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::erase()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a96f464959b6ce918048a2167c23f1c0b">flow::net_flow::error::S_EVENT_SET_EVENT_DOES_NOT_EXIST</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_ac3bd92001ec9ca3623a0e84a50043bb9_cgraph.svg" width="412" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae04c117b15179ba37a94f6836c63497b" name="ae04c117b15179ba37a94f6836c63497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04c117b15179ba37a94f6836c63497b">&#9670;&nbsp;</a></span>sock_as_any_to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::net_flow::Event_set::sock_as_any_to_str </td>
          <td>(</td>
          <td class="paramtype">const boost::any &amp;&#160;</td>
          <td class="paramname"><em>sock_as_any</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns a loggable string representing the socket stored in the given <code>boost::any</code> that stores a value allowed by the members of <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> <code>enum</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock_as_any</td><td>See above. <code>sock_as_any.empty()</code> is also allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Loggable string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00777">777</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00342">flow::util::ostream_op_to_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l01129">flow::net_flow::Node::event_set_all_check_delta()</a>, and <a class="el" href="event__set_8cpp_source.html#l01017">flow::net_flow::Node::event_set_check_baseline()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_ae04c117b15179ba37a94f6836c63497b_cgraph.svg" width="515" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_ae04c117b15179ba37a94f6836c63497b_icgraph.svg" width="2091" height="830"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8453cccdaaf22ea6b027c5de9738f0f0" name="a8453cccdaaf22ea6b027c5de9738f0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8453cccdaaf22ea6b027c5de9738f0f0">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">Event_set::State</a> flow::net_flow::Event_set::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current State of the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<p >Note that this may change the moment the method returns.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00060">60</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, and <a class="el" href="event__set_8hpp_source.html#l00901">m_state</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l01509">operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a8453cccdaaf22ea6b027c5de9738f0f0_icgraph.svg" width="331" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6e47fc394c09acf4d100a640e090a7aa" name="a6e47fc394c09acf4d100a640e090a7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e47fc394c09acf4d100a640e090a7aa">&#9670;&nbsp;</a></span>swap_wanted_sockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::swap_wanted_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a592b3ce6602051bd9994216041a3cbdc">Sockets</a> *&#160;</td>
          <td class="paramname"><em>target_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficiently exchanges the current set of sockets we want to know are "ready" by the definiton of the given event type. </p>
<p >See individual Event_type enumeration members' doc comments for exact definition of readiness for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>. For example, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" title="Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...">Event_type::S_PEER_SOCKET_READABLE</a> means we want to know when <code>sock-&gt;receive()</code> would yield either some data or an error, but not no data and no error. Use this to perform arbitrarily complex operations on the internal set storing sockets of interest for the given event type <code>ev_type</code>, when the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9" title="Opposite of add_wanted_socket().">remove_wanted_socket()</a> methods are insufficient. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1util_1_1Linked__hash__set.html">Event_set::Sockets</a> socks;</div>
<div class="line"><span class="comment">// Exchange of our empty `socks` with what&#39;s in `es`.</span></div>
<div class="line">es-&gt;swap_wanted_sockets(&amp;socks, Event_type::S_PEER_SOCKET_READBLE);</div>
<div class="line"><span class="comment">// ...Remove every 3rd socket from `socks`, and log `socks.size()`....</span></div>
<div class="line"><span class="comment">// Now put the modified socket set back into `es`.</span></div>
<div class="line">es-&gt;swap_wanted_sockets(&amp;socks, Event_type::S_PEER_SOCKET_READBLE);</div>
</div><!-- fragment --><h3>Rationale</h3>
<p >The swap paradigm (precursor to the "move" paradigm added in C++11) allows arbitrarily complex operations without sacrificing performance or thread safety.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_set</td><td>Pointer to set of sockets to which to load the current internal set. Currently contained sockets must be from the same <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that originated this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </td></tr>
    <tr><td class="paramname">ev_type</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">add_wanted_socket()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a3f2c29ade2454001982c033a37fd9c79" title="Attempted to write to an event set, while a wait operation was pending on that event set.">error::Code::S_EVENT_SET_IMMUTABLE_WHEN_WAITING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00493">493</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8hpp_source.html#l00910">m_want</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00852">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::size()</a>, <a class="el" href="linked__hash__set_8hpp_source.html#l00729">flow::util::Linked_hash_set&lt; Key, Hash, Pred &gt;::swap()</a>, and <a class="el" href="event__set_8cpp_source.html#l00493">swap_wanted_sockets()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00493">swap_wanted_sockets()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a6e47fc394c09acf4d100a640e090a7aa_cgraph.svg" width="562" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a6e47fc394c09acf4d100a640e090a7aa_icgraph.svg" width="186" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7272a3b8975ff72edd3db3f777e930f1" name="a7272a3b8975ff72edd3db3f777e930f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7272a3b8975ff72edd3db3f777e930f1">&#9670;&nbsp;</a></span>sync_wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::sync_wait </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the other <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> but will stop waiting if the timeout given as argument expires. </p>
<p >If the timeout expires, it is the error code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. This is akin to a <code>select()</code> call with a finite timeout.</p>
<p >An additional error situation is possible in addition to that described in the 2nd/3rd paragraphs of the other <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>'s doc header: if this is <code><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a></code>d during the wait, and the wait times out, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a> will be emitted when this timeout is detected. On the positive side, that means <code>sync_wait(timeout)</code> will eventually exit no matter what.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<p >No guarantees are made as to the accuracy of the timeout timer, although you can optimistically provide arbitrarily precise values for <code>max_wait</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: Same as the other <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> plus: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). Timeout expiring IS an error, in particular. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l01092">1092</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00031">flow::util::chrono_duration_to_fine_duration()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a7272a3b8975ff72edd3db3f777e930f1_cgraph.svg" width="979" height="354"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a133c518168fe3922ab6729a99077dd3f" name="a133c518168fe3922ab6729a99077dd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133c518168fe3922ab6729a99077dd3f">&#9670;&nbsp;</a></span>sync_wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::sync_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks indefinitely until one or more of the previously described events hold &ndash; or the wait is interrupted; saves them for retrieval via <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a>, etc. </p>
<p >; and returns. This is akin to a <code>select()</code> call with no (i.e., infinite) timeout.</p>
<p >The special case of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a> interrupting this wait &ndash; which is conceptually similar to <code>EINTR</code> in POSIX &ndash; manifests itself as <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>. In this case, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a72b26f25a2e76e3c61b4760b59de5b25" title="Gets the sockets that satisfy the condition of the given Event_type detected during the last wait.">emit_result_sockets()</a> (etc.) should not be used, as one should assume no events are active due to the interruption.</p>
<p >In a non-error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will be <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">State::S_INACTIVE</a> before and after the call, unless underlying <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is destroyed, in which case the final state may be <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a6abcbd1be8478aa03e76aec9c540e14f" title="Node has disowned the Peer_socket; all further operations will result in error.">State::S_CLOSED</a>. In an error invocation, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a> will not change, and the method will return immediately. Additionally, the method will NEVER return, if another thread calls <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">close()</a></code> or <code>this-&gt;<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a3122100c044da08495fac737998f60db" title="Moves object from State::S_WAITING to State::S_INACTIVE, and forgets any handler saved by async_wait(...">async_wait_finish()</a></code> during this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> (so don't do that).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5cbb0762dc20632c76db479f40237492" title="Attempted to wait on an event set without specifying event on which to wait.">error::Code::S_EVENT_SET_NO_EVENTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482adccb025a96014a74a1435481ec2b58ac" title="Attempted to wait on or poll an event set while already waiting on that event set.">error::Code::S_EVENT_SET_DOUBLE_WAIT_OR_POLL</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae643fd244bd1d6b483295cb9f356b0ae" title="Attempted operation on an event set, when that event set was closed.">error::Code::S_EVENT_SET_CLOSED</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if no error occurred (<code>*err_code</code> is success). </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00458">458</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00458">sync_wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00458">sync_wait()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a133c518168fe3922ab6729a99077dd3f_cgraph.svg" width="147" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a133c518168fe3922ab6729a99077dd3f_icgraph.svg" width="147" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a13a17c404f0ce43da5fec53a550da9be" name="a13a17c404f0ce43da5fec53a550da9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a17c404f0ce43da5fec53a550da9be">&#9670;&nbsp;</a></span>sync_wait_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::sync_wait_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the public <code>sync_wait(max_wait)</code> but uses a <code>Fine_clock</code>-based <code>Fine_duration</code> non-template type for implementation convenience and to avoid code bloat in specifying timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>See the public <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a> <em>with</em> a <code>max_wait</code> argument. <code>"duration&lt;Rep, Period&gt;::max()"</code> maps to the value <code>Fine_duration::max()</code> for this argument. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">sync_wait()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l00336">336</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>, <a class="el" href="event__set_8cpp_source.html#l00756">ev_type_to_socks_map_entry_is_empty()</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="event__set_8hpp_source.html#l00920">m_can</a>, <a class="el" href="event__set_8hpp_source.html#l00937">m_mutex</a>, <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5">flow::net_flow::error::S_WAIT_INTERRUPTED</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8hpp_source.html#l01092">sync_wait()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a13a17c404f0ce43da5fec53a550da9be_cgraph.svg" width="935" height="354"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_a13a17c404f0ce43da5fec53a550da9be_icgraph.svg" width="331" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6db9d28bd448a131448276ee03de1e6d" name="a6db9d28bd448a131448276ee03de1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9d28bd448a131448276ee03de1e6d">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> documentation header. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00776">776</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

</div>
</div>
<a id="ac57b16fd356cacb8432a8ce7b021b54c" name="ac57b16fd356cacb8432a8ce7b021b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57b16fd356cacb8432a8ce7b021b54c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given event type to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">ev_type</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01532">1532</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

</div>
</div>
<a id="aebbf2b8f19e2b3d887fe234cd5bdcffc" name="aebbf2b8f19e2b3d887fe234cd5bdcffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbf2b8f19e2b3d887fe234cd5bdcffc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">Event_set::State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> state to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="event__set_8cpp_source.html#l01509">1509</a> of file <a class="el" href="event__set_8cpp_source.html">event_set.cpp</a>.</p>

<p class="reference">References <a class="el" href="event__set_8cpp_source.html#l00060">state()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Event__set_aebbf2b8f19e2b3d887fe234cd5bdcffc_cgraph.svg" width="331" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada8d103341b6450f3390dc6ce24ccdef" name="ada8d103341b6450f3390dc6ce24ccdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8d103341b6450f3390dc6ce24ccdef">&#9670;&nbsp;</a></span>m_baseline_check_pending</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Event_set::m_baseline_check_pending</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>, if this is <code>true</code>, an exhaustive check of all desired events is yet to be performed (in thread W); if <code>false</code>, it has alredy been performed (in thread W), and only "delta" checks need to be checked from now on during this wait. </p>
<p >See details in giant comment block inside <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">async_wait()</a>. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00934">934</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>.</p>

</div>
</div>
<a id="abf8a102c621b1536659973b2d6b33822" name="abf8a102c621b1536659973b2d6b33822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8a102c621b1536659973b2d6b33822">&#9670;&nbsp;</a></span>m_can</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> flow::net_flow::Event_set::m_can</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sockets, categorized by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> of interest, that were found to be "ready" (as defined in the doc header for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>), during the last wait (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state). </p>
<p >For each WAITING period, each set in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#abf8a102c621b1536659973b2d6b33822" title="The sockets, categorized by Event_type of interest, that were found to be &quot;ready&quot; (as defined in the ...">m_can</a> following that period must be a subset of the corresponding <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#af4fa5dbda4ffd95b35dee57fc01b90ce" title="The sockets, categorized by Event_type of interest, to check for &quot;ready&quot; status (as defined in the do...">m_want</a> set when entering that period.</p>
<p >E.g., <code>m_can[S_PEER_SOCKET_READABLE]</code> after WAITING is a subset of <code>m_want[S_PEER_SOCKET_READABLE]</code> when just starting WAITING. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00920">920</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00649">clear_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00613">emit_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>, <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>

</div>
</div>
<a id="a0dda853ab017dd9bfcfb71b601d15698" name="a0dda853ab017dd9bfcfb71b601d15698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dda853ab017dd9bfcfb71b601d15698">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a47e4e6d304a6a381e7469fe87c547738">Mutex</a> flow::net_flow::Event_set::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex protecting ALL data in this object. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00937">937</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8hpp_source.html#l01015">add_wanted_socket()</a>, <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>, <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00649">clear_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">clear_wanted_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00464">close()</a>, <a class="el" href="event__set_8cpp_source.html#l00613">emit_result_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>, <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>, <a class="el" href="event__set_8cpp_source.html#l00066">node()</a>, <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, <a class="el" href="event__set_8hpp_source.html#l01052">remove_wanted_socket()</a>, <a class="el" href="event__set_8cpp_source.html#l00060">state()</a>, <a class="el" href="event__set_8cpp_source.html#l00493">swap_wanted_sockets()</a>, and <a class="el" href="event__set_8cpp_source.html#l00336">sync_wait_impl()</a>.</p>

</div>
</div>
<a id="af635301685a4a331142e1ac8a791a65d" name="af635301685a4a331142e1ac8a791a65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af635301685a4a331142e1ac8a791a65d">&#9670;&nbsp;</a></span>m_node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a>* flow::net_flow::Event_set::m_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#aafa4275ad4f93ae274f7f88fd257ce33" title="Node that produced this Event_set.">node()</a>. Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00904">904</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00464">close()</a>, <a class="el" href="event__set_8cpp_source.html#l00066">node()</a>, and <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>.</p>

</div>
</div>
<a id="a59f6ddb0d0258cc029c435a8ed0f89f7" name="a59f6ddb0d0258cc029c435a8ed0f89f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f6ddb0d0258cc029c435a8ed0f89f7">&#9670;&nbsp;</a></span>m_on_event</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9da325d6cb993b975eec99adaafd3dce">Event_handler</a> flow::net_flow::Event_set::m_on_event</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a>, stores the handler (a <code>void</code> function with 1 <code>bool</code> argument) that will be called once one or more events are found to hold. </p>
<p ><code>m_on_event.empty()</code> at all other times. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00926">926</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>.</p>

</div>
</div>
<a id="a56925e15b38d285f387e10bfb18f93c9" name="a56925e15b38d285f387e10bfb18f93c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56925e15b38d285f387e10bfb18f93c9">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975">State</a> flow::net_flow::Event_set::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a8453cccdaaf22ea6b027c5de9738f0f0" title="Current State of the Event_set.">state()</a>. Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00901">901</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00215">async_wait_finish()</a>, <a class="el" href="event__set_8cpp_source.html#l00464">close()</a>, <a class="el" href="event__set_8cpp_source.html#l00576">events_detected()</a>, <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>, <a class="el" href="event__set_8cpp_source.html#l00675">ok_to_mod_socket_set()</a>, <a class="el" href="event__set_8cpp_source.html#l00266">poll()</a>, and <a class="el" href="event__set_8cpp_source.html#l00060">state()</a>.</p>

</div>
</div>
<a id="af4fa5dbda4ffd95b35dee57fc01b90ce" name="af4fa5dbda4ffd95b35dee57fc01b90ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fa5dbda4ffd95b35dee57fc01b90ce">&#9670;&nbsp;</a></span>m_want</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#affac46b4e327b3781faab4853a290877">Ev_type_to_socks_map</a> flow::net_flow::Event_set::m_want</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sockets, categorized by <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> of interest, to check for "ready" status (as defined in the doc header for each <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a>), in the next wait (<a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a48954e0be2947224e80cdfc2283af906" title="Waiting state: valid Event_set that is currently waiting on previously described events.">State::S_WAITING</a> state). </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00910">910</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8hpp_source.html#l01015">add_wanted_socket()</a>, <a class="el" href="event__set_8cpp_source.html#l00072">async_wait()</a>, <a class="el" href="event__set_8cpp_source.html#l00705">clear()</a>, <a class="el" href="event__set_8cpp_source.html#l00527">clear_wanted_sockets()</a>, <a class="el" href="event__set_8cpp_source.html#l00553">events_wanted()</a>, <a class="el" href="event__set_8hpp_source.html#l01052">remove_wanted_socket()</a>, and <a class="el" href="event__set_8cpp_source.html#l00493">swap_wanted_sockets()</a>.</p>

</div>
</div>
<a id="aa321c69146b8575e4d0e3b15c67d4f08" name="aa321c69146b8575e4d0e3b15c67d4f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa321c69146b8575e4d0e3b15c67d4f08">&#9670;&nbsp;</a></span>S_EV_TYPE_TO_IS_ACTIVE_NODE_MTD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::unordered_map&lt; <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a>, <a class="el" href="classflow_1_1Function.html">Function</a>&lt; <a class="el" href="classbool.html">bool</a>(const <a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *, const boost::any &amp;)&gt; &gt; flow::net_flow::Event_set::S_EV_TYPE_TO_IS_ACTIVE_NODE_MTD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping from each possible <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> method that determines whether the condition defined by that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_type</a> is currently true for the socket wrapped in the <code>boost::any</code> argument passed to the method. </p>
<p >E.g., <code>bool Node::sock_is_readable(const boost::any sock_as_any) const</code> is to return true if and only if <code>sock = boost::any_cast&lt;<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>&gt;(sock_as_any)</code> &ndash; which is a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> &ndash; would yield non-zero or zero and error if one were to execute <code>sock-&gt;receive()</code>. Note that the latter condition is defined by the doc comment on <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88" title="Event type specifying the condition of interest wherein a target Peer_socket sock is such that callin...">Event_type::S_PEER_SOCKET_READABLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="event__set_8hpp_source.html#l00897">897</a> of file <a class="el" href="event__set_8hpp_source.html">event_set.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="event__set_8cpp_source.html#l01017">flow::net_flow::Node::event_set_check_baseline()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="event__set_8hpp_source.html">event_set.hpp</a></li>
<li>net_flow/<a class="el" href="event__set_8cpp_source.html">event_set.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 18 2024 00:14:51 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
