<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::log::Config Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1log.html">log</a></li><li class="navelem"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classflow_1_1log_1_1Config-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::log::Config Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class used to configure the filtering and logging behavior of <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s; its use in your custom <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s is optional but encouraged; supports dynamically changing filter settings even while concurrent logging occurs.  
 <a href="classflow_1_1log_1_1Config.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="config_8hpp_source.html">config.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::log::Config:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config__coll__graph.svg" width="1010" height="435"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html">Atomic_raw_sev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial wrapper of <code>atomic&lt;raw_sev_t&gt;</code> which adds a couple of things to make it possible to construct, and therefore use, a <code>vector</code> of such <code>atomic</code>s.  <a href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1log_1_1Config_1_1Component__config.html">Component_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of config stored for each distinct (as determined by <a class="el" href="classflow_1_1log_1_1Component.html#a3ff8ff4d75add447b3e10ded5430833d" title="Returns typeid(Payload), where Payload was the template param used when calling the originating one-a...">Component::payload_type()</a>, essentially C++ built-in <code>std::type_info</code>) component payload type (in English &ndash; component <code>enum class</code>).  <a href="structflow_1_1log_1_1Config_1_1Component__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aabb6bf7c67b40faeab764ad695b63b9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a> = <a class="el" href="classflow_1_1log_1_1Component.html#a287888e2943b312f4febc3e8e130fc80">Component::enum_raw_t</a></td></tr>
<tr class="memdesc:aabb6bf7c67b40faeab764ad695b63b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned index into the flat union of component tables maintained by a <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, combining potentially multiple user component <code>enum</code> tables.  <a href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">More...</a><br /></td></tr>
<tr class="separator:aabb6bf7c67b40faeab764ad695b63b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5fa60a6334b988ec54ef1d68763f7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a8d5fa60a6334b988ec54ef1d68763f7c">Component_to_union_idx_func</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; <a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>(const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a8d5fa60a6334b988ec54ef1d68763f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a function that takes a <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> (storing a payload of some generic component <code>enum</code> member of the logging user's choice) and returns its corresponding flat union component index.  <a href="classflow_1_1log_1_1Config.html#a8d5fa60a6334b988ec54ef1d68763f7c">More...</a><br /></td></tr>
<tr class="separator:a8d5fa60a6334b988ec54ef1d68763f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20ba1556441155d7086282f76d051f61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a20ba1556441155d7086282f76d051f61">Config</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> most_verbose_sev_default=<a class="el" href="classflow_1_1log_1_1Config.html#a94e6c81a4e3dd9b41c1b468f7d7c1a90">S_MOST_VERBOSE_SEV_DEFAULT</a>)</td></tr>
<tr class="memdesc:a20ba1556441155d7086282f76d051f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a conceptually blank but functional set of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>.  <a href="classflow_1_1log_1_1Config.html#a20ba1556441155d7086282f76d051f61">More...</a><br /></td></tr>
<tr class="separator:a20ba1556441155d7086282f76d051f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2f471079c285065c692b8e796ad787"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#add2f471079c285065c692b8e796ad787">Config</a> (const <a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;src)</td></tr>
<tr class="memdesc:add2f471079c285065c692b8e796ad787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs <code>*this</code> to be equal to <code>src</code> config object.  <a href="classflow_1_1log_1_1Config.html#add2f471079c285065c692b8e796ad787">More...</a><br /></td></tr>
<tr class="separator:add2f471079c285065c692b8e796ad787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab067e9e513530e7484a30f568b1e11d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ab067e9e513530e7484a30f568b1e11d5">Config</a> (<a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ab067e9e513530e7484a30f568b1e11d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For now at least there's no reason for move-construction.  <a href="classflow_1_1log_1_1Config.html#ab067e9e513530e7484a30f568b1e11d5">More...</a><br /></td></tr>
<tr class="separator:ab067e9e513530e7484a30f568b1e11d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c9a16ebb764e4fcc4208a55c2e785d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a60c9a16ebb764e4fcc4208a55c2e785d">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;)=delete</td></tr>
<tr class="memdesc:a60c9a16ebb764e4fcc4208a55c2e785d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For now at least there's no reason for copy assignment.  <a href="classflow_1_1log_1_1Config.html#a60c9a16ebb764e4fcc4208a55c2e785d">More...</a><br /></td></tr>
<tr class="separator:a60c9a16ebb764e4fcc4208a55c2e785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a787b8026d84814bf4edcc91432447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ac8a787b8026d84814bf4edcc91432447">operator=</a> (<a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ac8a787b8026d84814bf4edcc91432447"><td class="mdescLeft">&#160;</td><td class="mdescRight">For now at least there's no reason for move assignment.  <a href="classflow_1_1log_1_1Config.html#ac8a787b8026d84814bf4edcc91432447">More...</a><br /></td></tr>
<tr class="separator:ac8a787b8026d84814bf4edcc91432447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae429a329e31a41ba75f94578b0e7f26c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c">output_whether_should_log</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> sev, const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;component) const</td></tr>
<tr class="memdesc:ae429a329e31a41ba75f94578b0e7f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key output of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, this computes the verbosity-filtering answer to <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a> based on the given log-call-site severity and component and the verbosity configuration in this <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, including the value at <code>*(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>)</code>, the value from <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a>, and the config from <code>configure_component_verbosity*()</code>.  <a href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c">More...</a><br /></td></tr>
<tr class="separator:ae429a329e31a41ba75f94578b0e7f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6376bf2af57f655c1cdf00791e6a2f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f">output_component_to_ostream</a> (std::ostream *os, const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;component) const</td></tr>
<tr class="memdesc:a6376bf2af57f655c1cdf00791e6a2f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, this writes a string representation of the given component value to the given <code>ostream</code>, if possible.  <a href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f">More...</a><br /></td></tr>
<tr class="separator:a6376bf2af57f655c1cdf00791e6a2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116df84f1735ade2c4b9b265c4bdd36a"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:a116df84f1735ade2c4b9b265c4bdd36a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a">init_component_to_union_idx_mapping</a> (<a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a> enum_to_num_offset, size_t enum_sparse_length)</td></tr>
<tr class="memdesc:a116df84f1735ade2c4b9b265c4bdd36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a generically-typed <code>enum class</code> that represents the full set of the calling module's possible component values that it will supply at subsequent log call sites from that module.  <a href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a">More...</a><br /></td></tr>
<tr class="separator:a116df84f1735ade2c4b9b265c4bdd36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146a60d96256dbaed4f5f0e7dcd8f529"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:a146a60d96256dbaed4f5f0e7dcd8f529"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529">init_component_names</a> (const boost::unordered_multimap&lt; Component_payload, std::string &gt; &amp;component_names, <a class="el" href="classbool.html">bool</a> output_components_numerically=false, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> payload_type_prefix_or_empty=<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>())</td></tr>
<tr class="memdesc:a146a60d96256dbaed4f5f0e7dcd8f529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the string names of each member of the <code>enum class Component_payload</code> earlier registered via <code>init_component_to_union_idx_mapping&lt;Component_payload&gt;()</code>.  <a href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529">More...</a><br /></td></tr>
<tr class="separator:a146a60d96256dbaed4f5f0e7dcd8f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac562cc0132f6cfa81b42c332400033ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae">configure_default_verbosity</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> most_verbose_sev_default, <a class="el" href="classbool.html">bool</a> reset)</td></tr>
<tr class="memdesc:ac562cc0132f6cfa81b42c332400033ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default verbosity to the given value, to be used by subsequent <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> calls whenever one supplies it a component for which no per-component verbosity is configured at that time; optionally wipes out all existing per-component verbosities for a constructor-like reset.  <a href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae">More...</a><br /></td></tr>
<tr class="separator:ac562cc0132f6cfa81b42c332400033ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde40890c0dc1fa8956451f44251dc8"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:adfde40890c0dc1fa8956451f44251dc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8">configure_component_verbosity</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> most_verbose_sev, Component_payload component_payload)</td></tr>
<tr class="memdesc:adfde40890c0dc1fa8956451f44251dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the per-component verbosity for the given component to the given value, to be used by subsequent <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> calls whenever one supplies it the same component value.  <a href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8">More...</a><br /></td></tr>
<tr class="separator:adfde40890c0dc1fa8956451f44251dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f266ee7e22d1090ab4de76e532cab89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89">configure_component_verbosity_by_name</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> most_verbose_sev, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> component_name)</td></tr>
<tr class="memdesc:a2f266ee7e22d1090ab4de76e532cab89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a>, but the component is to be specified by its registered string name, well suited to interpreting text config files.  <a href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89">More...</a><br /></td></tr>
<tr class="separator:a2f266ee7e22d1090ab4de76e532cab89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a12f1147ae51ee6f9645dcd46e67c8410"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:a12f1147ae51ee6f9645dcd46e67c8410"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a12f1147ae51ee6f9645dcd46e67c8410">standard_component_payload_enum_sparse_length</a> ()</td></tr>
<tr class="memdesc:a12f1147ae51ee6f9645dcd46e67c8410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns highest numeric value in the given component-payload <code>enum</code>, plus 1, assuming that <code>enum</code> was created using the <a class="el" href="config__enum__start__hdr_8macros_8hpp.html">config_enum_start_hdr.macros.hpp</a> mechanism with all requirements followed by user.  <a href="classflow_1_1log_1_1Config.html#a12f1147ae51ee6f9645dcd46e67c8410">More...</a><br /></td></tr>
<tr class="separator:a12f1147ae51ee6f9645dcd46e67c8410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81da2c80d99cdd43c66a0df2eed64c70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70">this_thread_verbosity_override</a> ()</td></tr>
<tr class="memdesc:a81da2c80d99cdd43c66a0df2eed64c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to this thread's <em>mutable</em> verbosity override, for querying or assignment alike.  <a href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70">More...</a><br /></td></tr>
<tr class="separator:a81da2c80d99cdd43c66a0df2eed64c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025990297cc07d51aaec277af203dfe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Scoped__setter.html">util::Scoped_setter</a>&lt; <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe">this_thread_verbosity_override_auto</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> most_verbose_sev_or_none)</td></tr>
<tr class="memdesc:ab025990297cc07d51aaec277af203dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>*(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>) = most_verbose_sev_or_none</code>; and returns an object that shall restore it to its current value when it goes out of scope.  <a href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe">More...</a><br /></td></tr>
<tr class="separator:ab025990297cc07d51aaec277af203dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1b16be31f5dcfba9536a377c9d29abb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a1b16be31f5dcfba9536a377c9d29abb6">m_use_human_friendly_time_stamps</a></td></tr>
<tr class="memdesc:a1b16be31f5dcfba9536a377c9d29abb6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> setting: If <code>true</code>, time stamps will include a (deterministically formatted) date, time, time zone, all in the OS's current time zone; else raw # of seconds passed since POSIX (Unix) Epoch (1970, Jan 1, 00:00, GMT).  <a href="classflow_1_1log_1_1Config.html#a1b16be31f5dcfba9536a377c9d29abb6">More...</a><br /></td></tr>
<tr class="separator:a1b16be31f5dcfba9536a377c9d29abb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a94e6c81a4e3dd9b41c1b468f7d7c1a90"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a94e6c81a4e3dd9b41c1b468f7d7c1a90">S_MOST_VERBOSE_SEV_DEFAULT</a> = <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">Sev::S_INFO</a></td></tr>
<tr class="memdesc:a94e6c81a4e3dd9b41c1b468f7d7c1a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommended default/catch-all most-verbose-severity value if no specific config is given.  <a href="classflow_1_1log_1_1Config.html#a94e6c81a4e3dd9b41c1b468f7d7c1a90">More...</a><br /></td></tr>
<tr class="separator:a94e6c81a4e3dd9b41c1b468f7d7c1a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a02531ef4a8e85f074cc2a347c1771b81"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a02531ef4a8e85f074cc2a347c1771b81">Component_payload_type_to_cfg_map</a> = boost::unordered_map&lt; std::type_index, <a class="el" href="structflow_1_1log_1_1Config_1_1Component__config.html">Component_config</a> &gt;</td></tr>
<tr class="memdesc:a02531ef4a8e85f074cc2a347c1771b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for fast-lookup map from distinct <code>Component_payload</code> type to the config for that component <code>enum</code>.  <a href="classflow_1_1log_1_1Config.html#a02531ef4a8e85f074cc2a347c1771b81">More...</a><br /></td></tr>
<tr class="separator:a02531ef4a8e85f074cc2a347c1771b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae76e3367bd497f5b00f46e48b3a39c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c">raw_sev_t</a> = <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td></tr>
<tr class="memdesc:acae76e3367bd497f5b00f46e48b3a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">How we store a <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> (a mere <code>enum</code> itself) in a certain data structure.  <a href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c">More...</a><br /></td></tr>
<tr class="separator:acae76e3367bd497f5b00f46e48b3a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c7d62daba9625b0309b31da287585"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585">Component_union_idx_to_sev_map</a> = std::vector&lt; <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html">Atomic_raw_sev</a> &gt;</td></tr>
<tr class="memdesc:a3c5c7d62daba9625b0309b31da287585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for fast-lookup, thread-safe-for-RW mapping from flat-union-component-table index to max allowed severity for that component.  <a href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585">More...</a><br /></td></tr>
<tr class="separator:a3c5c7d62daba9625b0309b31da287585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed54fc7cef5b0ba4eadf97daf79be7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#aa1ed54fc7cef5b0ba4eadf97daf79be7">Component_name_to_union_idx_map</a> = boost::unordered_map&lt; std::string, <a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a> &gt;</td></tr>
<tr class="memdesc:aa1ed54fc7cef5b0ba4eadf97daf79be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for fast-lookup map from normalized component name to its flat-union-component-table index.  <a href="classflow_1_1log_1_1Config.html#aa1ed54fc7cef5b0ba4eadf97daf79be7">More...</a><br /></td></tr>
<tr class="separator:aa1ed54fc7cef5b0ba4eadf97daf79be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663307a81245b621e12680d3a4d83df2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a663307a81245b621e12680d3a4d83df2">Component_union_idx_to_name_map</a> = boost::unordered_map&lt; <a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>, std::string &gt;</td></tr>
<tr class="memdesc:a663307a81245b621e12680d3a4d83df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for map that is essentially the inverse of <code>Component_name_to_union_idx_map</code>.  <a href="classflow_1_1log_1_1Config.html#a663307a81245b621e12680d3a4d83df2">More...</a><br /></td></tr>
<tr class="separator:a663307a81245b621e12680d3a4d83df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af2d963a6e1e9e0fc5809764d5718e938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#af2d963a6e1e9e0fc5809764d5718e938">component_to_union_idx</a> (const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;component) const</td></tr>
<tr class="memdesc:af2d963a6e1e9e0fc5809764d5718e938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a component in the form user provides it at log call sites, returns its index in the flat component union table, as registered via <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>; or <code>component_union_idx_t(-1)</code> if <code>component.payload_type()</code> was not registed.  <a href="classflow_1_1log_1_1Config.html#af2d963a6e1e9e0fc5809764d5718e938">More...</a><br /></td></tr>
<tr class="separator:af2d963a6e1e9e0fc5809764d5718e938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6877cec4b070e18a40090f080e76ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#aee6877cec4b070e18a40090f080e76ca">store_severity_by_component</a> (<a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a> component_union_idx, <a class="el" href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c">raw_sev_t</a> most_verbose_sev_or_none)</td></tr>
<tr class="memdesc:aee6877cec4b070e18a40090f080e76ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that for the given flat-union-component-index saves the given per-component verbosity, or removes it.  <a href="classflow_1_1log_1_1Config.html#aee6877cec4b070e18a40090f080e76ca">More...</a><br /></td></tr>
<tr class="separator:aee6877cec4b070e18a40090f080e76ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a428c0ae690c951c1667e24afb6ef43de"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a428c0ae690c951c1667e24afb6ef43de">normalized_component_name</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name)</td></tr>
<tr class="memdesc:a428c0ae690c951c1667e24afb6ef43de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized version of given component name.  <a href="classflow_1_1log_1_1Config.html#a428c0ae690c951c1667e24afb6ef43de">More...</a><br /></td></tr>
<tr class="separator:a428c0ae690c951c1667e24afb6ef43de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7be5337621d131ef084ba69ad95f1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a2a7be5337621d131ef084ba69ad95f1b">normalize_component_name</a> (std::string *name)</td></tr>
<tr class="memdesc:a2a7be5337621d131ef084ba69ad95f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes given component name in place.  <a href="classflow_1_1log_1_1Config.html#a2a7be5337621d131ef084ba69ad95f1b">More...</a><br /></td></tr>
<tr class="separator:a2a7be5337621d131ef084ba69ad95f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae447f7751eb63baefb04fdeeeff95fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html#a02531ef4a8e85f074cc2a347c1771b81">Component_payload_type_to_cfg_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ae447f7751eb63baefb04fdeeeff95fda">m_component_cfgs_by_payload_type</a></td></tr>
<tr class="memdesc:ae447f7751eb63baefb04fdeeeff95fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast-lookup map from distinct <code>Component_payload</code> type to the config for that component <code>enum</code>.  <a href="classflow_1_1log_1_1Config.html#ae447f7751eb63baefb04fdeeeff95fda">More...</a><br /></td></tr>
<tr class="separator:ae447f7751eb63baefb04fdeeeff95fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409818a2192ee2544b442b2ea957a76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html">Atomic_raw_sev</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a409818a2192ee2544b442b2ea957a76c">m_verbosity_default</a></td></tr>
<tr class="memdesc:a409818a2192ee2544b442b2ea957a76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most verbose (highest) <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> for which <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return true, when the input component is null or lacks a per-component configured verbosity.  <a href="classflow_1_1log_1_1Config.html#a409818a2192ee2544b442b2ea957a76c">More...</a><br /></td></tr>
<tr class="separator:a409818a2192ee2544b442b2ea957a76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6b4511883c815e81f6427909ed829f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585">Component_union_idx_to_sev_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f">m_verbosities_by_component</a></td></tr>
<tr class="memdesc:a6b6b4511883c815e81f6427909ed829f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps from flat union component index to most verbose (highest) <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> for which <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return true, when the input component is not null and maps to that flat union index via <a class="el" href="classflow_1_1log_1_1Config.html#af2d963a6e1e9e0fc5809764d5718e938" title="Given a component in the form user provides it at log call sites, returns its index in the flat compo...">component_to_union_idx()</a>.  <a href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f">More...</a><br /></td></tr>
<tr class="separator:a6b6b4511883c815e81f6427909ed829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb8f5805d2093d13625a528d78919c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html#a663307a81245b621e12680d3a4d83df2">Component_union_idx_to_name_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#a35cb8f5805d2093d13625a528d78919c">m_component_names_by_union_idx</a></td></tr>
<tr class="memdesc:a35cb8f5805d2093d13625a528d78919c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps each flat union component index to its <em>output</em> component name as registered in <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a>.  <a href="classflow_1_1log_1_1Config.html#a35cb8f5805d2093d13625a528d78919c">More...</a><br /></td></tr>
<tr class="separator:a35cb8f5805d2093d13625a528d78919c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9decea94f2d3297a2b24bc6de7c4657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html#aa1ed54fc7cef5b0ba4eadf97daf79be7">Component_name_to_union_idx_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Config.html#ad9decea94f2d3297a2b24bc6de7c4657">m_component_union_idxs_by_name</a></td></tr>
<tr class="memdesc:ad9decea94f2d3297a2b24bc6de7c4657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps each distinct component name as registered in <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> to its flat union component index.  <a href="classflow_1_1log_1_1Config.html#ad9decea94f2d3297a2b24bc6de7c4657">More...</a><br /></td></tr>
<tr class="separator:ad9decea94f2d3297a2b24bc6de7c4657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class used to configure the filtering and logging behavior of <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s; its use in your custom <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s is optional but encouraged; supports dynamically changing filter settings even while concurrent logging occurs. </p>
<p >If you are reading this to know how to configure an existing <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a>, then you don't need further background; just see this API to know how to configure such <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s in a uniform way.</p>
<p >If you are, instead, reading this when implementing a new custom <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a>, then please see implementation recommendations in <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> doc header before continuing here.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Class <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> doc header is wordy and might be hard to follow; rewrite for clarity/flow/size.</dd></dl>
<h3>Synopsis: How do I use it to configure a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a>? Just tell me!</h3>
<p >Really it's pretty easy to use it, but it's much easier to see how it's done by example rather than a formal-ish description (which is nevertheless below, in the next section of this doc header). To use <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> with a <code><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a></code>-supporting <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> in your <a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a>-using module M:</p>
<ul>
<li>Declare the component <code>enum</code> inside the module M. Declare and define the associated index-to-name map for that <code>enum</code>. While it is possible to manually do this, we provide some tools to utterly minimize the boiler-plate required (which would be considerable otherwise). The files <code>config_enum_{start|end}.macros.[hc]pp</code> are those tools.<ul>
<li>Start with <a class="el" href="config__enum__start__hdr_8macros_8hpp.html">config_enum_start_hdr.macros.hpp</a>.</li>
</ul>
</li>
<li>In module M, use this new component <code>enum</code> (totally separate from any others, such as Flow's <a class="el" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce" title="The flow::log::Component payload enumeration comprising various log components used by Flow&#39;s own int...">flow::Flow_log_component</a>) at log call sites. More precisely, either pass a value to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> ctor or to <a class="el" href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95" title="For the rest of the block within which this macro is instantiated, causes all FLOW_LOG_....">FLOW_LOG_SET_CONTEXT()</a>.<ul>
<li>An example is the pervasive logging done by various Flow sub-modules with the exception of <a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a> itself (which ironically doesn't do all that much logging, chicken/egg). Look for <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> and <a class="el" href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95" title="For the rest of the block within which this macro is instantiated, causes all FLOW_LOG_....">FLOW_LOG_SET_CONTEXT()</a> mentions.</li>
</ul>
</li>
<li>Outside module M, in the program which uses module M &ndash; perhaps along with other modules such as Flow itself &ndash; probably around startup, set up your new <code><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a></code>. Call <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">Config::init_component_to_union_idx_mapping()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">Config::init_component_names()</a> to register M's <code>enum</code> &ndash; AND again for every other logging module besides M (such as Flow itself). Call <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">Config::configure_default_verbosity()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">Config::configure_component_verbosity()</a> (and friend) to configure verbosity levels. Finally, create the specific <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and give it a pointer to this <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>.<ul>
<li>Examples of this can almost certainly be found in certain test programs outside of Flow code proper. Again, setting <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> and specific <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code> object's config shouldn't be done in libraries/modules but normally at the program level, such as around <code>main()</code>.</li>
<li>After this, the logging itself can begin (including from multiple threads). Concurrently with logging &ndash; which will often call <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> and potentially <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> &ndash; you may not safely call any of the above <code>init_*()</code> or <code>configure_*()</code> methods, with the following important exceptions:<ul>
<li>You may call <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">Config::configure_default_verbosity()</a> safely concurrently with logging to dynamically change verbosity setting.</li>
<li>You may call <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">Config::configure_component_verbosity()</a> or <a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89" title="Like configure_component_verbosity(), but the component is to be specified by its registered string n...">Config::configure_component_verbosity_by_name()</a> similarly.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>What <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> controls and how</h3>
<p >Let's get into it more formally.</p>
<p >Firstly, <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> simply stores simple scalars controlling output behavior. For example, the public member <a class="el" href="classflow_1_1log_1_1Config.html#a1b16be31f5dcfba9536a377c9d29abb6" title="Config setting: If true, time stamps will include a (deterministically formatted) date,...">m_use_human_friendly_time_stamps</a> controls the style of time stamps in the final output. It's just a data store for such things.</p>
<p >Secondly, <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> knows how to <em>understand</em> the <em>component</em> values supplied at every single log call site in your program. (This also ties in to the next thing we discuss, verbosity config.) See <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> doc header. Now, here's how <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> understands components. In your program, you will use various <code><a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a></code>-using libraries or modules &ndash; including (but not necessarily limited to!) Flow itself. Each module is likely to feature their own component table, in the form of an <code>enum class</code>. For example, Flow itself has <code>enum class Flow_log_component</code> (see common.hpp).</p><ul>
<li>So, suppose there are two modules, M1 and M2 (e.g., M1 might be Flow itself). Each will define a component table <code>enum class</code>, C1 and C2, respectively. You are to <em>register</em> C1; and separately/similarly C2; using an <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> for each of C1 and C2. (All of this applies for any number of modules and enums, not just two.)</li>
<li>The <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> maintains a single, merged <em>component union</em> table, which will (after registration) map <em>every</em> <code>C1::</code> enumeration member AND <em>every</em> <code>C2::</code> member to a distinct <em>component union index</em> integer. (For example, in the <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> call, you can specify that C1's members will map to union indices 1000, 1001, ...; and C2's to 2000, 2001, ....) These flat union indices between C1 and C2 must never clash.</li>
<li>The <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> also maintains a single, distinct <em>name</em> string, for each component. An optional feature is provided to auto-prepend a prefix configured for each registered <code>enum class</code> (e.g., "C1_" for all <code>C1::</code> members, "C2_" for all <code>C2::</code> members). One provides (for each of C1, C2) this optional prefix and a simple map from the <code>enum</code> members to their distinct string names. Use <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a>.</li>
<li>After registering each of C1 and C2 with <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a>, in your <em>program</em> (e.g., in <code>main()</code>) but outside the modules M1 and M2 <em>themselves</em>, the <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> now has:<ul>
<li>The ability to map an incoming <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">log::Component</a> (as supplied to <a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2" title="Given a message and its severity, logs that message and possibly severity WITHOUT checking whether it...">Logger::do_log()</a>) to its index in the flat <code><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a></code>-internal union of all component <code>enum</code> values.</li>
<li>Having obtained that flat index, quickly obtain its distinct component name.</li>
<li>Conversely, suppose one passes in a distinct component name. <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> can now quickly map that string to its flat index in the union table of all component <code>enum</code> values.</li>
</ul>
</li>
<li>The following two features are built on this mapping of multiple individual component tables onto a single flat "union" table of components built inside the <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>; as well as on the aforementioned mapping of union table index to component name string; and vice versa.</li>
</ul>
<p >Thirdly, and crucially, the verbosity filtering (<a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a>) for the client <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> is entirely implemented via the <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> output method; so <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a> can simply forward to that method. Here is how one configures its behavior in <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>. At construction, or in a subsequent <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> call, one sets the <em>default verbosity</em>, meaning the most-verbose <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> that <code>should_log()</code> would let through when no per-component verbosity for the log call site's specified <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> is configured. In addition, assuming more fine-grained (per-component) verbosity config is desired, one can call <code>configure_component_verbosity*()</code> to set the most-verbose <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> for when <code>should_log()</code> is passed that specific <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> payload.</p>
<p >Setting per-component verbosity can be done by its <code>enum</code> value. Or one can use the overload that takes the component's distinct (among <em>all</em> source component <code>enum</code> tables registered before) string name; in which case the aforementioned performant name-to-index mapping is used internally to set the proper union component's verbosity.</p>
<p >(Note that order of calls matters: <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> wipes out effects of any individual, per-component <code>configure_component_verbosity*()</code> executed prior to it. It is typical (in a given round of applying config) to first call <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> and then make 0 or more <code>configure_component_verbosity*()</code> calls for various individual components.)</p>
<p >Fourthly, <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> is a significant helper for your <a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2" title="Given a message and its severity, logs that message and possibly severity WITHOUT checking whether it...">Logger::do_log()</a> when actually printing the ultimate character representation of the user's message and metadata. The metadata (<a class="el" href="structflow_1_1log_1_1Msg__metadata.html" title="Simple data store containing all of the information generated at every logging call site by flow::log...">Msg_metadata</a>) includes a <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>; that method will output its string representation to the <code>ostream</code> given to it. To do so it will use the aforementioned ability to quickly map the <code>C1::</code> or <code>C2::</code> member to the flat union index to that index's distinct name (the same name optionally used to configure verbosity of that component, as explained above).</p>
<p >Or one can opt to print the flat numeric index of the component instead; in which case the reverse name-to-union-idx is not needed.</p>
<h3>Thread safety</h3>
<p >Formally, <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> is thread-safe for all operations when concurrent access is to separate <code><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a></code>s. There are no <code>static</code> data involved. Formally, <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> is generally NOT thread-safe when concurrent read and write access is w/r/t to a single <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>; this includes read/write of any public data members and read/write in the form <code>const</code>/otherwise method calls. Informally, one could use an outside mutex, including in any <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> implementation that uses <code>*this</code>, but we recommend against this for performance reasons; and see below "exception."</p>
<p >Also formally for a given <code>*this</code>: The logging phase is assumed to begin after all <code>init_*()</code> calls and any initial <code>configure_*()</code> calls; at this point <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> may be used at will by any thread; but the pre-logging-phase non-<code>const</code> calls are no longer allowed.</p>
<p >There is an important exception to the assertion that <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> <code>*this</code> one must NOT call any write methods once the logging phase has begun. Informally, this exception should make it possible to use <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> safely <em>and yet</em> dynamically allow changes to <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> without any expensive outside mutex. The exception is as follows:</p>
<p >Assume, as is proper, that you've called all needed <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> before any concurrent logging and have now started to log &ndash; you are in the logging phase. Now assume you want to change verbosity settings during this logging-at-large phase; this is common, for example, when some dynamic config file changes verbosity settings for your program. The following is safe: You may call <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> and/or <code>configure_component_verbosity*()</code> while expecting the changes to take effect promptly in all threads; namely, <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will reflect the change there; and <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> does not care. Perf-wise, little to nothing is sacrified (internally, a lock-free implementation is used).</p>
<p >Corner case: It is also safe to call <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> and/or <code>configure_component_verbosity*()</code> concurrently with themselves. Naturally, it is a race as to which thread "wins." Moreover, <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> with <code>reset == true</code> is equivalent to removing the verbosity setting for each individual component; but only each removal itself is atomic, not the overall batch operation; so concurrent execution with another <code>configure_*_verbosity()</code> call may result in an interleaved (but valid) verbosity table. Informally, we recommend against any design that would allow concurrent <code>configure_*()</code> calls on <code>*this</code>; it does not seem wise. It does however result in well-defined behavior as described. The real aim, though, is not this corner case but only the main case of a series of <code>configure_*()</code> calls in thread 1, while logging may be going on in other threads.</p>
<h3>Optional: Thread-local verbosity override</h3>
<p >In a pinch, it may be desirable &ndash; <em>temporarily</em> and <em>in a given thread of execution only</em> &ndash; to change the current verbosity config. To do so in a given scope <code>{}</code> simply do this:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">// In this { scope } temporarily let-through only error messages or more severe.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> overrider = <a class="code hl_function" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe">flow::log::Config::this_thread_verbosity_override_auto</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a4aee6034ce9dbc2b5c36f27c80abe021">flow::log::Sev::S_WARNING</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Now let&#39;s create 3,000 threads each of which would normally log a few &quot;starting thread&quot; startup INFO messages!</span></div>
<div class="line">  m_thread_pool = std::make_unique&lt;flow::async::Cross_thread_task_loop&gt;(get_logger(), <span class="stringliteral">&quot;huge_pool&quot;</span>, 3000);</div>
<div class="line">  m_thread_pool-&gt;start();</div>
<div class="line">} <span class="comment">// Previous thread-local verbosity is restored (whether there was one, or none) upon exit from {block}.</span></div>
<div class="ttc" id="aclassflow_1_1log_1_1Config_html_ab025990297cc07d51aaec277af203dfe"><div class="ttname"><a href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe">flow::log::Config::this_thread_verbosity_override_auto</a></div><div class="ttdeci">static util::Scoped_setter&lt; Sev &gt; this_thread_verbosity_override_auto(Sev most_verbose_sev_or_none)</div><div class="ttdoc">Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...</div><div class="ttdef"><b>Definition:</b> <a href="config_8cpp_source.html#l00260">config.cpp:260</a></div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04a4aee6034ce9dbc2b5c36f27c80abe021"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a4aee6034ce9dbc2b5c36f27c80abe021">flow::log::Sev::S_WARNING</a></div><div class="ttdeci">@ S_WARNING</div><div class="ttdoc">Message indicates a &quot;bad&quot; condition that is not frequent enough to be of severity Sev::S_TRACE.</div></div>
</div><!-- fragment --><p> You may also query the current setting via <code>*(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>)</code>. Direct assignment of a <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">Sev</a> to the latter is allowed, but generally it is both safer and easier to use the RAII pattern via <a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe" title="Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...">this_thread_verbosity_override_auto()</a> for setting/restoring the override.</p>
<p >The value <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf" title="Not an actual value but rather stores the highest numerical payload, useful for validity checks.">Sev::S_END_SENTINEL</a> indicates the thread-local verbosity override is disabled; and is the initial (default) state in any thread. However, generally, it is recommended to use the RAII pattern via <a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe" title="Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...">this_thread_verbosity_override_auto()</a> instead of direct assignment, for safe and easy save/restore.</p>
<p >Note there are no thread-safety concerns with this feature, as it is entirely thread-local. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00199">199</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa1ed54fc7cef5b0ba4eadf97daf79be7" name="aa1ed54fc7cef5b0ba4eadf97daf79be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ed54fc7cef5b0ba4eadf97daf79be7">&#9670;&nbsp;</a></span>Component_name_to_union_idx_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#aa1ed54fc7cef5b0ba4eadf97daf79be7">flow::log::Config::Component_name_to_union_idx_map</a> =  boost::unordered_map&lt;std::string, <a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for fast-lookup map from normalized component name to its flat-union-component-table index. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00807">807</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="a02531ef4a8e85f074cc2a347c1771b81" name="a02531ef4a8e85f074cc2a347c1771b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02531ef4a8e85f074cc2a347c1771b81">&#9670;&nbsp;</a></span>Component_payload_type_to_cfg_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#a02531ef4a8e85f074cc2a347c1771b81">flow::log::Config::Component_payload_type_to_cfg_map</a> =  boost::unordered_map&lt;std::type_index, <a class="el" href="structflow_1_1log_1_1Config_1_1Component__config.html">Component_config</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for fast-lookup map from distinct <code>Component_payload</code> type to the config for that component <code>enum</code>. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00684">684</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="a8d5fa60a6334b988ec54ef1d68763f7c" name="a8d5fa60a6334b988ec54ef1d68763f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5fa60a6334b988ec54ef1d68763f7c">&#9670;&nbsp;</a></span>Component_to_union_idx_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#a8d5fa60a6334b988ec54ef1d68763f7c">flow::log::Config::Component_to_union_idx_func</a> =  <a class="el" href="classflow_1_1Function.html">Function</a>&lt;<a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a> (const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for a function that takes a <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> (storing a payload of some generic component <code>enum</code> member of the logging user's choice) and returns its corresponding flat union component index. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00214">214</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="aabb6bf7c67b40faeab764ad695b63b9d" name="aabb6bf7c67b40faeab764ad695b63b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb6bf7c67b40faeab764ad695b63b9d">&#9670;&nbsp;</a></span>component_union_idx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">flow::log::Config::component_union_idx_t</a> =  <a class="el" href="classflow_1_1log_1_1Component.html#a287888e2943b312f4febc3e8e130fc80">Component::enum_raw_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned index into the flat union of component tables maintained by a <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, combining potentially multiple user component <code>enum</code> tables. </p>
<p >Also suitable for non-negative offsets against such indices. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00208">208</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="a663307a81245b621e12680d3a4d83df2" name="a663307a81245b621e12680d3a4d83df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663307a81245b621e12680d3a4d83df2">&#9670;&nbsp;</a></span>Component_union_idx_to_name_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#a663307a81245b621e12680d3a4d83df2">flow::log::Config::Component_union_idx_to_name_map</a> =  boost::unordered_map&lt;<a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>, std::string&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for map that is essentially the inverse of <code>Component_name_to_union_idx_map</code>. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00810">810</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="a3c5c7d62daba9625b0309b31da287585" name="a3c5c7d62daba9625b0309b31da287585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5c7d62daba9625b0309b31da287585">&#9670;&nbsp;</a></span>Component_union_idx_to_sev_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585">flow::log::Config::Component_union_idx_to_sev_map</a> =  std::vector&lt;<a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html">Atomic_raw_sev</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for fast-lookup, thread-safe-for-RW mapping from flat-union-component-table index to max allowed severity for that component. </p>
<h3>Rationale</h3>
<p >2 things will jump out at many readers: 1: It is a <code>vector</code>, instead of the seemingly more elegant and essentially as-fast <code>unordered_map&lt;component_union_idx_t, Sev&gt;</code>. 2: It stores <code>atomic&lt;raw_sev_t&gt;</code> and not simply <code>Sev</code>. The reason for both is thread safety, to wit for 2 operations: writing to it via <code>configure_component_verbosity*()</code> vs. reading from it in <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>. In one makes the two mutually safe for concurrent execution in a given <code>*this</code>, it becomes possible to safely configure per-component verbosity even while the rest of the system is concurrently logging like crazy. So how does this type accomplish that? Tackling the 2 decisions in order:</p>
<p >Firstly assume for simplicity that <code>component_union_idx_t</code> is <code>size_t</code>; and that <code>Sev</code> and <code>raw_sev_t</code> are essentially the same thing (enough so for this discussion anyway). Now consider an <code>X</code> of this map type. If it were a <code>..._map&lt;size_t, ...&gt;</code>, then <code>X[A] = B;</code> might change the internal structure of the map (hash table, tree, whatever); accessing <code>X[C]</code> for <em>any</em> <code>C</code> would not be safe, as it could catch it in a halfway state among other dangers. If it is a <code>vector&lt;...&gt;</code>, however, then <code>X[A] = B;</code> either results in undefined-behavior &ndash; if <code>X.size() &gt;= A</code> &ndash; or works fine, in that the buffer inside <code>X</code> does not change structure. (However, this does indeed require that <code>X</code> is sized to allow for all possible values of <code>A</code>. It also makes <code>X</code> sparse and hence larger than it otherwise would require. The latter is seen as likely negligible given the number of components used in reality vs. how much RAM modern computers have; to shrink it further and improve the set-all operation's speed is why we use single-byte <code>raw_sev_t</code> and not <code>Sev</code>. As for pre-sizing, that explains the need for <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> arg <code>enum_sparse_length</code>. TL;DR: It makes it so that the address in the reference <code>X[A]</code> never changes for a given <code>A</code>, as long as no <code>resize()</code> or equivalent occurs throughout.</p>
<p >Given that, why <code>atomic&lt;raw_sev_t&gt;</code> and not <code>raw_sev_t</code> alone? Well, even though <code>X[A]</code> address never changes and is thus thread-safe at the <code>X</code> level, the <code>= B;</code> assignment itself isn't thread-safe against reading the value. Now, the extent to which it's not "thread-safe" depends on hairy low-level details; wrapping it in <code>atomic&lt;&gt;</code> allows one to explicitly control the level of thread safety and the associated performance trade-off (potentially significant since <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> is called at every single log call site). With <code>atomic&lt;&gt;</code> one can use <code>memory_order</code> specifications when storing and reading to control this. Further details are discussed at the read and write sites, but that's why <code>atomic&lt;&gt;</code> is used.</p>
<h3>Why the wrapper <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a> around the <code>atomic&lt;&gt;</code>?</h3>
<p >Short version: It's because <code>vector&lt;&gt;</code> effectively cannot be initialized due to <code>atomic&lt;&gt;</code> not being copy-constructible. (However <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a>, after construction, is identical to <code>atomic&lt;raw_sev_t&gt;</code>, effectively a <code>using</code>-alias at that point.) Long version: See doc header for <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a>.</p>
<h3>Performance</h3>
<p >The lookup by index could not be any faster: it adds the index to a base integer and done. This is even somewhat faster than an <code>unordered_map&lt;&gt;</code> which is also constant-time but a bit more involved. The writing and reading of the <code>atomic&lt;&gt;</code> can be faster than with an explicit mutex lock/unlock bracketing but can be somewhat slower than an unprotected assignment/read; or it can be exactly equal; the point is that is under our control via <code>memory_order</code> spec; again, see details at the read and write sites. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00796">796</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="acae76e3367bd497f5b00f46e48b3a39c" name="acae76e3367bd497f5b00f46e48b3a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae76e3367bd497f5b00f46e48b3a39c">&#9670;&nbsp;</a></span>raw_sev_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c">flow::log::Config::raw_sev_t</a> =  <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How we store a <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> (a mere <code>enum</code> itself) in a certain data structure. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00687">687</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a20ba1556441155d7086282f76d051f61" name="a20ba1556441155d7086282f76d051f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ba1556441155d7086282f76d051f61">&#9670;&nbsp;</a></span>Config() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::log::Config::Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev_default</em> = <code><a class="el" href="classflow_1_1log_1_1Config.html#a94e6c81a4e3dd9b41c1b468f7d7c1a90">S_MOST_VERBOSE_SEV_DEFAULT</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a conceptually blank but functional set of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>. </p>
<p >Namely, no component <code>enum</code>s are yet registered (call <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> to register 0 or more such <code>enum</code> tables). The default verbosity is set to <code>most_verbose_sev_default</code>.</p>
<p >While you can and should register <code>enum</code>s after this, if you don't then the object's outputs will act as follows:</p><ul>
<li><a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will simply return <code>true</code> if and only if <code>sev</code> is no more verbose than <code>most_verbose_sev_default</code> arg to this ctor. <code>component</code> is ignored in the decision.</li>
<li><a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> will print nothing to the <code>ostream</code> arg and hence will return <code>false</code>.</li>
</ul>
<p >Note that &ndash; particularly in a pinch and in simple applications &ndash; this is perfectly reasonable, simple behavior. One doesn't always need per-component verbosity configuration abilities; and one definitely doesn't always need to print the component name/index in the log output. But if one does need these things, then you can register <code>enum</code>s as explained in class doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">most_verbose_sev_default</td><td>Same as in <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00031">31</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

</div>
</div>
<a id="add2f471079c285065c692b8e796ad787" name="add2f471079c285065c692b8e796ad787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2f471079c285065c692b8e796ad787">&#9670;&nbsp;</a></span>Config() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::log::Config::Config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs <code>*this</code> to be equal to <code>src</code> config object. </p>
<p >Performance-wise, this will copy internal per-component tables (in addition to a few scalars). These tables are conceptually unions of potentially multiple long <code>enum</code>s; so this probably shouldn't be done often, but typically <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> is constructed at startup or during rare config change events.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this copy construction occurs very soon after a <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> or <code>configure_component_verbosity*()</code> call in a <em>different</em> thread completes, then it is possible that call's effect won't register in the resulting <code>*this</code>. In the case of <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> with <code>reset == true</code> the clearing of the per-component verbosities may register only partially in that situation, though <code>*this</code> will still be valid. Since "very soon" cannot be formally defined, it is therefore best to make such a copy in the same thread as the last verbosity-modifying call on <code>src</code>. (On the other hand, even otherwise results in valid behavior, but it may not be quite as deterministic as preferred and clean.)</dd></dl>
<p >The warning above is due to the subtlety in the <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a> copy ctor doc header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab067e9e513530e7484a30f568b1e11d5" name="ab067e9e513530e7484a30f568b1e11d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab067e9e513530e7484a30f568b1e11d5">&#9670;&nbsp;</a></span>Config() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::log::Config::Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For now at least there's no reason for move-construction. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Reconsider providing a <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> move constructor. I just didn't need to deal with it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2d963a6e1e9e0fc5809764d5718e938" name="af2d963a6e1e9e0fc5809764d5718e938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d963a6e1e9e0fc5809764d5718e938">&#9670;&nbsp;</a></span>component_to_union_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">Config::component_union_idx_t</a> flow::log::Config::component_to_union_idx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a component in the form user provides it at log call sites, returns its index in the flat component union table, as registered via <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>; or <code>component_union_idx_t(-1)</code> if <code>component.payload_type()</code> was not registed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>A <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> value as from a log call site. Undefined behavior if <code>component.empty()</code> (null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index into the flat component union table (0 or higher); or <code>component_union_idx_t(-1)</code>. See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00040">40</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8hpp_source.html#l00862">m_component_cfgs_by_payload_type</a>, <a class="el" href="log_8cpp_source.html#l00186">flow::log::Component::payload_enum_raw_value()</a>, and <a class="el" href="log_8cpp_source.html#l00178">flow::log::Component::payload_type_index()</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8hpp_source.html#l01058">configure_component_verbosity()</a>, <a class="el" href="config_8hpp_source.html#l00971">init_component_names()</a>, <a class="el" href="config_8cpp_source.html#l00145">output_component_to_ostream()</a>, and <a class="el" href="config_8cpp_source.html#l00177">output_whether_should_log()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_af2d963a6e1e9e0fc5809764d5718e938_cgraph.svg" width="763" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_af2d963a6e1e9e0fc5809764d5718e938_icgraph.svg" width="796" height="254"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adfde40890c0dc1fa8956451f44251dc8" name="adfde40890c0dc1fa8956451f44251dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfde40890c0dc1fa8956451f44251dc8">&#9670;&nbsp;</a></span>configure_component_verbosity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::log::Config::configure_component_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Component_payload&#160;</td>
          <td class="paramname"><em>component_payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the per-component verbosity for the given component to the given value, to be used by subsequent <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> calls whenever one supplies it the same component value. </p>
<p >See also <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a>.</p>
<p >This only works (and will return <code>true</code>) if <code>init_component_to_union_idx_mapping&lt;Component_payload&gt;()</code> has been called. Otherwise it returns <code>false</code> (caller may <code>assert()</code> against this result if it is felt justified).</p>
<p >See class doc header section "What Config controls and how" for more discussion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">most_verbose_sev</td><td>The most-verbose (numerically highest) <code>Sev sev</code> value such that <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return <code>true</code>, when <code><a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> component</code> is not null and has <code><a class="el" href="classflow_1_1log_1_1Component.html#a656f5868adbd8c58c493981fe1764699" title="Returns reference to immutable payload stored in *this; undefined behavior if empty() == true.">Component::payload</a>&lt;Component_payload&gt;()</code> return a value equal to <code>component_payload</code>. </td></tr>
    <tr><td class="paramname">component_payload</td><td>The component for which verbosity is being set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> otherwise. See above for more. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l01058">1058</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">References <a class="el" href="config_8cpp_source.html#l00040">component_to_union_idx()</a>, and <a class="el" href="config_8cpp_source.html#l00055">store_severity_by_component()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_adfde40890c0dc1fa8956451f44251dc8_cgraph.svg" width="978" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2f266ee7e22d1090ab4de76e532cab89" name="a2f266ee7e22d1090ab4de76e532cab89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f266ee7e22d1090ab4de76e532cab89">&#9670;&nbsp;</a></span>configure_component_verbosity_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::log::Config::configure_component_verbosity_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>component_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a>, but the component is to be specified by its registered string name, well suited to interpreting text config files. </p>
<p >The meaning of verbosity is the same as in the other overload.</p>
<p >This only works (and will return <code>true</code>) if <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> has been called in such a way as to successfully associate a component in the flat union table with the name equal (after normalization of both sides) to <code>component_name</code>. If the name is unknown, it returns <code>false</code>.</p>
<p >Name normalization consists of conversion to upper case according to the classic ("C") locale.</p>
<p >See class doc header section "What Config controls and how" for more discussion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">most_verbose_sev</td><td>The most-verbose (numerically highest) <code>Sev sev</code> value such that <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return <code>true</code>, when <code><a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> component</code> is not null and has an associated string name equal to <code>component_name</code> (post-normalization of both sides of comparison). </td></tr>
    <tr><td class="paramname">component_name</td><td>The component for which verbosity is being set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> otherwise. See above for more. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00127">127</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8hpp_source.html#l00923">m_component_union_idxs_by_name</a>, <a class="el" href="config_8cpp_source.html#l00233">normalized_component_name()</a>, and <a class="el" href="config_8cpp_source.html#l00055">store_severity_by_component()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a2f266ee7e22d1090ab4de76e532cab89_cgraph.svg" width="387" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac562cc0132f6cfa81b42c332400033ae" name="ac562cc0132f6cfa81b42c332400033ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac562cc0132f6cfa81b42c332400033ae">&#9670;&nbsp;</a></span>configure_default_verbosity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::configure_default_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev_default</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default verbosity to the given value, to be used by subsequent <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> calls whenever one supplies it a component for which no per-component verbosity is configured at that time; optionally wipes out all existing per-component verbosities for a constructor-like reset. </p>
<p >This is fairly intuitive; the only aspect one might find non-obvious is <code>reset == true</code> mode. In that mode all per-component verbosities are forgotten, as after construction. An intended use scenario is when reading a hypothetical config file describing new, dynamic <em>overall</em> verbosity settings to replace any existing ones. Such a config file would probably specify the catch-all (default) verbosity; then 0 or more per-component "exception" verbosities. Hence once would call this method with <code>reset == true</code> accordingly to reset everything and set the default; then one would call <code>configure_component_verbosity*()</code> for each "exception."</p>
<p ><code>reset == true</code> is technically slower than otherwise, though it is doubtful one would call us frequently enough for it to matter. The perf cost of <code>!reset</code> is constant time and basically that of a scalar assignment. The perf cost of <code>reset == true</code> is that plus the cost of about N <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> calls, where N is the highest flat-union-component-table implied by the <code>enum_sparse_length</code> arg to <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> calls to date. In practice doing this when outside config changes is unlikely to be a perf issue.</p>
<h3>Thread safety on <code>*this</code></h3>
<p >If called, it must be called after all <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> calls have completed. It is safe to call concurrently with <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>, meaning dynamic config of verbosities is allowed. See formal details in thread safety notes in class <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">most_verbose_sev_default</td><td>The most-verbose (numerically highest) <code>Sev sev</code> value such that <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return <code>true</code>, when <code><a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> component</code> is either null or has no per-component verbosity configured at that time. </td></tr>
    <tr><td class="paramname">reset</td><td>If <code>false</code> then per-component verbosities are left unchanged; else they are wiped out, meaning only the catch-all setting has subsequent effect in <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00109">109</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8hpp_source.html#l00906">m_verbosities_by_component</a>, <a class="el" href="config_8hpp_source.html#l00877">m_verbosity_default</a>, and <a class="el" href="config_8cpp_source.html#l00055">store_severity_by_component()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_ac562cc0132f6cfa81b42c332400033ae_cgraph.svg" width="415" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a146a60d96256dbaed4f5f0e7dcd8f529" name="a146a60d96256dbaed4f5f0e7dcd8f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146a60d96256dbaed4f5f0e7dcd8f529">&#9670;&nbsp;</a></span>init_component_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::init_component_names </td>
          <td>(</td>
          <td class="paramtype">const boost::unordered_multimap&lt; Component_payload, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>output_components_numerically</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>payload_type_prefix_or_empty</em> = <code><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the string names of each member of the <code>enum class Component_payload</code> earlier registered via <code>init_component_to_union_idx_mapping&lt;Component_payload&gt;()</code>. </p>
<p >These are used subsequently (as of this writing) to (1) map name to index in one of the <code>configure_component_verbosity*()</code> methods; and (2) to map index to name in <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a>.</p>
<p >Behavior undefined if <code>init_component_to_union_idx_mapping&lt;Component_payload&gt;()</code> hasn't yet been called. Behavior undefined if <code>init_component_names&lt;Component_payload&gt;()</code> has already been called. (Informally, something safe might happen, depending, but in general it's a weird/bad idea, so don't.) Behavior undefined if any value in <code>component_names</code> is empty.</p>
<p >The recommended (but not mandatory) way to auto-generate a <code>component_names</code> map (as normally doing so by hand is tedious) is to use <code>config_enum_{start|end}_macros.[hc]pp</code>. As an example, Flow itself does it in common.hpp and <a class="el" href="common_8cpp.html">common.cpp</a>, defining both <a class="el" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce" title="The flow::log::Component payload enumeration comprising various log components used by Flow&#39;s own int...">flow::Flow_log_component</a> (the <code>enum</code>) and <a class="el" href="namespaceflow.html#abef6a1249edc3dd6c7f650235a84bfe4" title="The map generated by flow::log macro magic that maps each enumerated value in flow::Flow_log_componen...">flow::S_FLOW_LOG_COMPONENT_NAME_MAP</a> (the <code>component_names</code> map). Basically, via macro magic it names each component according to the <code>enum</code> member identifier's own name.</p>
<h3><code>component_names</code> meaning</h3>
<p >Some subtleties exist in interpreting <code>component_names</code>.</p>
<p >Firstly, each value (string name) in <code>component_names</code> &ndash; as well as <code>payload_type_prefix_or_empty</code> &ndash; is internally pre-normalized before any other work. Name normalization consists of conversion to upper case according to the classic ("C") locale. <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> will print in normalized form (if applicable); and <a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89" title="Like configure_component_verbosity(), but the component is to be specified by its registered string n...">configure_component_verbosity_by_name()</a> will normalize the input arg string before lookup.</p>
<p >If empty, <code>payload_type_prefix_or_empty</code> has no effect. Otherwise, its effect is as if it <em>were</em> empty, but as if <code>component_names[X]</code> had <code>payload_type_prefix_or_empty</code> prepended to its actual value at all times. Less formally, it's a constant to prefix every name; then if the program (perhaps around <code>main()</code>) simply manually provides a distinct, cosmetically useful "namespace-like" prefix in each <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> call, then it can 100% guarantee no name clashes, even if accidentally one of module X's component names A happened to equal an unrelated module Y's component name B. For example, A = B = "UTIL" is fairly likely to collide otherwise. It won't be an issue, if they end up being called "X_UTIL" and "Y_UTIL" ultimately, by supplying prefixes "X_" and "Y_" X and Y's <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> calls.</p>
<p >Within <code>component_names</code> if a value (name) is present 2+ times, behavior is undefined. Furthermore if <code>payload_type_prefix_or_empty + X</code>, where <code>X</code> is in <code>component_names</code>, is already stored in <code>*this</code>, behavior is undefined. Either way it's a name collision which should be entirely avoidable using <code>payload_type_prefix_or_empty</code> as shown above.</p>
<p >It is a multi-map, and key K is allowed to be present 2+ times mapping to 2+ distinct names. The reason this is supported is so one can (discouraged though it is &ndash; but for historical reasons tends to come up at times) declare an <code>enum</code> that includes a few mutually "aliased" members:</p><ul>
<li><code>Sweet_components::S_COOL_ENGINE</code> &lt;=&gt; "COOL_ENGINE" &lt;=&gt; 5</li>
<li><code>Sweet_components::S_ENGINE_ALIAS1</code> &lt;=&gt; "ENGINE_ALIAS1" &lt;=&gt; 5</li>
<li><code>Sweet_components::S_ENGINE_ALIAS2</code> &lt;=&gt; "ENGINE_ALIAS2" &lt;=&gt; 5 In that example, any of <code>S_{COOL_ENGINE|ENGINE_ALIAS{1|2}}</code> maps to the rather long name "COOL_ENGINE,ENGINE_ALIAS1,ENGINE_ALIAS2"; and <em>each</em> of "COOL_ENGINE", "ENGINE_ALIAS1", "ENGINE_ALIAS2" maps backwards to a single entry in the component-to-verbosity table. Hence if I configure verbosity X (using <code>configure_component_verbosity*()</code>) for COOL_ENGINE_ALIAS1, then verbosity X config will equally affect subsequent messages with specified component COOL_ENGINE and ENGINE_ALIAS2 as well.</li>
</ul>
<p >Detail: When concatenating component output names as just described, the prefix <code>payload_type_prefix_or_empty</code> is prepended only once. So, if the prefix is "SWEET-", then any one of the above 3 <code>enum</code> example members maps to the name "SWEET-COOL_ENGINE,ENGINE_ALIAS1,ENGINE_ALIAS2".</p>
<p ><code>output_components_numerically</code>, if and only if set to <code>true</code>, suppresses the default behavior which is to memorize the string to output (in <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a>) for a given <code>enum</code> value; instead it doesn't memorize this forward mapping. As a result, <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> will simply output the <em>numerical</em> value of the <code>enum</code> member from the flat union component table. This is a cosmetic output choice some prefer to the long-looking component names.</p>
<p >In addition, even if <code>!output_components_numerically</code>, but a subsequent <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> call encounters an <code>enum</code> value that you neglected to register via <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> (omitting it in <code>component_names</code> in particular), then it will also be printed numerically as if <code>output_components_numerically</code>.</p>
<p >Finally, even if <code>output_components_numerically == true</code>, the backwards mapping (from string name to component) is still memorized. Therefore one can still set <a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89" title="Like configure_component_verbosity(), but the component is to be specified by its registered string n...">configure_component_verbosity_by_name()</a> by string name. Again, in practice, I have seen this: <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> files will refer to component verbosities by component name, not unhelpful-looking number; but output log files still print them as numbers for brevity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_names</td><td>Mapping of each possible Component_payload value to its string representation, for both output and per-component config (namely verbosity config) subsequently. Details above. Empty names lead to undefined behavior. </td></tr>
    <tr><td class="paramname">output_components_numerically</td><td>If and only if <code>true</code>, <a class="el" href="classflow_1_1log_1_1Config.html#a6376bf2af57f655c1cdf00791e6a2f7f" title="An output of Config, this writes a string representation of the given component value to the given os...">output_component_to_ostream()</a> will output the flat numeric index for all <code>Component_payload</code>-passing log call sites; else it will print the string name from the map (but if not <em>in</em> the map, then it'll fall back to the flat index again). </td></tr>
    <tr><td class="paramname">payload_type_prefix_or_empty</td><td>Optional prefix helpful as a disambiguating "namespace" to preprend to values in <code>component_names</code>. Details above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00970">970</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">References <a class="el" href="config_8cpp_source.html#l00040">component_to_union_idx()</a>, <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="config_8hpp_source.html#l00916">m_component_names_by_union_idx</a>, <a class="el" href="config_8hpp_source.html#l00923">m_component_union_idxs_by_name</a>, <a class="el" href="config_8cpp_source.html#l00242">normalize_component_name()</a>, and <a class="el" href="config_8cpp_source.html#l00233">normalized_component_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a146a60d96256dbaed4f5f0e7dcd8f529_cgraph.svg" width="988" height="246"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a116df84f1735ade2c4b9b265c4bdd36a" name="a116df84f1735ade2c4b9b265c4bdd36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116df84f1735ade2c4b9b265c4bdd36a">&#9670;&nbsp;</a></span>init_component_to_union_idx_mapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::init_component_to_union_idx_mapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>&#160;</td>
          <td class="paramname"><em>enum_to_num_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>enum_sparse_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a generically-typed <code>enum class</code> that represents the full set of the calling module's possible component values that it will supply at subsequent log call sites from that module. </p>
<p >The caller supplies:</p><ul>
<li>The template argument <code>Component_payload</code>, which is an <code>enum</code> and is thus castable to the unsigned integer type <code>component_union_idx_t</code>.</li>
<li>The signed integer that shall be <em>added</em> to any log-call-site-supplied <code>enum</code> value in order to yield the flat-union index in <code>*this</code> merged table of all component <code>enum</code>s. For example, if we assume that no module will ever exceed 1,000 components in its <code>enum</code>, then module 1 can register its <code>enum</code> C1 with <code>enum_to_num_offset</code> 1,000, module 2 with 2,000, module 3 with 3,000, etc. Then the various C1 <code>enum</code> values 0, 1, ... will map to merged 1,000, 1,001, ...; C2's 0, 1, ... to 2,000, 2,001, ...; etc.<ul>
<li>This can be negative, because why not? Be careful.</li>
</ul>
</li>
<li>The "sparse size" of the <code>enum</code>. Details are below.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If this is not acceptable &ndash; maybe you want to pack them more tightly, or you have some other clever mapping in mind &ndash; then <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> might require a new feature (likely an overload of this method) which lets one simply provide the mapping in function (callback) form. In fact, in a previous version of Flow, this was provided; and in fact the present overload merely wrapped that more-general overload. We removed this primarily for perf reasons: Always using this numeric-offset technique allowed for an inlined implementation in the very-frequently-called (at every log call site) <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>. It would be possible to add it back in while <em>also</em> optimizing for the expected-to-be-used-typically offset technique, thus having essentially the best of both worlds (perf when possible, flexibility when necessary). However, since the "flexible" API appears unlikely to be needed, we decided it's over-engineering to keep it in &ndash; unless the need does appear in the future. In that case it should be possible to look in source control history and bring back its core elements (without removing the inlined offset-technique code path). At this stage this is not a formal to-do &ndash; more of a note for posterity.</dd></dl>
<p>Behavior is undefined if an index collision occurs here or in a subsequent <code>init_*()</code> or other relevant call. In particular take care to provide sufficient slack space (e.g., if you use <code>enum_to_num_offset</code> which are multiples of 5, then a collision will probably occur at some point).</p>
<p >If one has called <code>init_component_to_union_idx_mapping&lt;T&gt;()</code> with the same <code>T</code> in the past, then behavior is undefined, so don't. (Informally, depending on whether/how one has called <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> and <code>configure_component_verbosity*()</code>, this can actually be done safely and with well-defined results. However, I did not want to go down that rabbit hole. If it becomes practically necessary, which I doubt, we can revisit. This is not a formal to-do as of this writing.)</p>
<h3>Rationale for <code>enum_sparse_length</code></h3>
<p >A design is possible (and indeed was used for a very brief period of time) that avoids the need for this arg. Internally <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a> can be a nice, elegant <code>unordered_map&lt;component_union_idx_t, Sev&gt;</code>, in which case we need not know anything about how many <code>enum</code> values there can be, and as long as the various <code>enum</code>s' numeric values don't clash &ndash; which must and should easily be avoided by the user calling us here &ndash; everything works fine with this non-sparse data structure. However, to make <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a> a sparse <code>vector&lt;&gt;</code> (that uses <code>component_union_idx_t</code> as the key) &ndash; yet never need to <code>resize()</code> it when <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> is called &ndash; one must know <code>enum_sparse_length</code> ahead of time to ensure there is enough space in the <code>vector</code> ahead of time. Why would one use such an ugly (and somewhat space-wasting) structure instead, you ask? Answer: Short version: for efficient thread safety of <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>. Long version: See <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a> doc header. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Component.html#a3ff8ff4d75add447b3e10ded5430833d" title="Returns typeid(Payload), where Payload was the template param used when calling the originating one-a...">Component::payload_type()</a> doc header.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component_payload</td><td>See the doc header for the template param <code>Payload</code> on <a class="el" href="classflow_1_1log_1_1Component.html#a656f5868adbd8c58c493981fe1764699" title="Returns reference to immutable payload stored in *this; undefined behavior if empty() == true.">Component::payload()</a>. In addition, in our context, it must be convertible to <code>component_union_idx_t</code> (an unsigned integer). Informally, <code>Component_payload</code> must be a sane unsigned <code>enum</code> with end sentinel <code>S_END_SENTINEL</code>. The various input Component_payload types are distinguished via <code>typeid(Component_payload)</code> and further <code>type_index(typeid(Component_payload))</code>. I provide this implementation detail purely for general context; it should not be seen as relevant to how one uses the API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_to_num_offset</td><td>For each further-referenced <code>Component_payload</code> value C, its flat union index shall be <code>component_union_idx_t(C) + enum_to_num_offset</code>. So this is the "base" index for the <code>enum</code> you are registering, in the final flat table of components. </td></tr>
    <tr><td class="paramname">enum_sparse_length</td><td>Formally, one plus the highest numeric value of a <code>Component_payload</code> value that will ever be passed to <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> (directly; or indirectly if using <a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89" title="Like configure_component_verbosity(), but the component is to be specified by its registered string n...">configure_component_verbosity_by_name()</a>). Informally, we recommend that you (a) use the <a class="el" href="config__enum__start__hdr_8macros_8hpp.html">config_enum_start_hdr.macros.hpp</a> mechanism to create <code>Component_payload</code> type in the first place; and (b) therefore use <code>standard_component_payload_enum_sparse_length&lt;Component_payload&gt;()</code> for the present arg's value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00929">929</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00276">flow::util::key_exists()</a>, <a class="el" href="config_8hpp_source.html#l00862">m_component_cfgs_by_payload_type</a>, and <a class="el" href="config_8hpp_source.html#l00906">m_verbosities_by_component</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a116df84f1735ade2c4b9b265c4bdd36a_cgraph.svg" width="350" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2a7be5337621d131ef084ba69ad95f1b" name="a2a7be5337621d131ef084ba69ad95f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7be5337621d131ef084ba69ad95f1b">&#9670;&nbsp;</a></span>normalize_component_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::normalize_component_name </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes given component name in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer (not null) to string to potentially modify. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00242">242</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8hpp_source.html#l00971">init_component_names()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a2a7be5337621d131ef084ba69ad95f1b_icgraph.svg" width="386" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a428c0ae690c951c1667e24afb6ef43de" name="a428c0ae690c951c1667e24afb6ef43de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c0ae690c951c1667e24afb6ef43de">&#9670;&nbsp;</a></span>normalized_component_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::log::Config::normalized_component_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized version of given component name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Source name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00233">233</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00127">configure_component_verbosity_by_name()</a>, and <a class="el" href="config_8hpp_source.html#l00971">init_component_names()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a428c0ae690c951c1667e24afb6ef43de_icgraph.svg" width="394" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac8a787b8026d84814bf4edcc91432447" name="ac8a787b8026d84814bf4edcc91432447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a787b8026d84814bf4edcc91432447">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For now at least there's no reason for move assignment. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>Reconsider providing a <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> move assignment. I just didn't need to deal with it. </dd></dl>

</div>
</div>
<a id="a60c9a16ebb764e4fcc4208a55c2e785d" name="a60c9a16ebb764e4fcc4208a55c2e785d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c9a16ebb764e4fcc4208a55c2e785d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For now at least there's no reason for copy assignment. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>Reconsider providing a <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> copy assignment. I just didn't need to deal with it. </dd></dl>

</div>
</div>
<a id="a6376bf2af57f655c1cdf00791e6a2f7f" name="a6376bf2af57f655c1cdf00791e6a2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6376bf2af57f655c1cdf00791e6a2f7f">&#9670;&nbsp;</a></span>output_component_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::log::Config::output_component_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An output of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, this writes a string representation of the given component value to the given <code>ostream</code>, if possible. </p>
<p >Returns <code>true</code> if it wrote anything, <code>false</code> otherwise. Call this only after the full round of construction, <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>, and <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a>.</p>
<p >If the component's type (<code>component.payload_type()</code>) has not been properly registered via <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>, it returns <code>false</code> and writes nothing. Otherwise, if no name was registered (either because it wasn't included in a <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> call, or because in that call <code>output_components_numerically == true</code>), it will output the component's numeric index in the flat union table; and return <code>true</code>. Finally, if a name is indeed registered, it will output that string (details in <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> doc header) and also return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Pointer (not null) to the <code>ostream</code> to which to possibly write. </td></tr>
    <tr><td class="paramname">component</td><td>The component value from the log call site. <code>component.empty()</code> (no component) is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 1 or more characters have been written to <code>*os</code>; else <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00145">145</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8cpp_source.html#l00040">component_to_union_idx()</a>, <a class="el" href="log_8cpp_source.html#l00167">flow::log::Component::empty()</a>, and <a class="el" href="config_8hpp_source.html#l00916">m_component_names_by_union_idx</a>.</p>

<p class="reference">Referenced by <a class="el" href="ostream__log__msg__writer_8cpp_source.html#l00132">flow::log::Ostream_log_msg_writer::log_past_time_stamp()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a6376bf2af57f655c1cdf00791e6a2f7f_cgraph.svg" width="952" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a6376bf2af57f655c1cdf00791e6a2f7f_icgraph.svg" width="560" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae429a329e31a41ba75f94578b0e7f26c" name="ae429a329e31a41ba75f94578b0e7f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae429a329e31a41ba75f94578b0e7f26c">&#9670;&nbsp;</a></span>output_whether_should_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::log::Config::output_whether_should_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A key output of <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, this computes the verbosity-filtering answer to <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a> based on the given log-call-site severity and component and the verbosity configuration in this <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>, including the value at <code>*(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>)</code>, the value from <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a>, and the config from <code>configure_component_verbosity*()</code>. </p>
<p >Call this only after the full round of construction, <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>, and (initial) <code>configure_..._verbosity()</code>. In addition, it is specifically safe to concurrently set verbosity via <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> and/or <code>configure_component_verbosity*()</code>.</p>
<h3>Thread safety on <code>*this</code></h3>
<p >The last sentence means it's possible to change verbosities even while logging (which invokes us), as long as the <code>init_*()</code> stuff has all been completed. For formal details see notes on thread safety in class <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> doc header.</p>
<h3>Algorithm for computing return value</h3>
<p >It's a matter of comparing <code>sev</code> to <code>S</code>, where <code>S</code> is the applicable <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> verbosity setting. Return <code>true</code> if and only if <code>sev &lt;= S</code>.</p>
<p >What is <code>S</code>? It is the first available value of the following three bits of config:</p><ol type="1">
<li><code>S = *(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>)</code>...<ul>
<li>...unless it's <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf" title="Not an actual value but rather stores the highest numerical payload, useful for validity checks.">Sev::S_END_SENTINEL</a> (disabled, which is default); then:</li>
</ul>
</li>
<li><code>S</code> = the verbosity configured via <code>configure_component_verbosity*()</code> for <code>component</code>.<ul>
<li>...unless no such per-component verbosity was set; then:</li>
</ul>
</li>
<li><code>S</code> = the value given to <a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> or ctor, whichever happened later.<ul>
<li>This is always available.</li>
</ul>
</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe" title="Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...">this_thread_verbosity_override_auto()</a>. </dd>
<dd>
<a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a20ba1556441155d7086282f76d051f61" title="Constructs a conceptually blank but functional set of Config.">Config()</a>. </dd>
<dd>
<a class="el" href="classflow_1_1log_1_1Config.html#adfde40890c0dc1fa8956451f44251dc8" title="Sets the per-component verbosity for the given component to the given value, to be used by subsequent...">configure_component_verbosity()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#a2f266ee7e22d1090ab4de76e532cab89" title="Like configure_component_verbosity(), but the component is to be specified by its registered string n...">configure_component_verbosity_by_name()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>See <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a>. </td></tr>
    <tr><td class="paramname">component</td><td>See <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">Logger::should_log()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we recommend to let the associated message be logged; <code>false</code> to suppress it. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00177">177</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8cpp_source.html#l00040">component_to_union_idx()</a>, <a class="el" href="log_8cpp_source.html#l00167">flow::log::Component::empty()</a>, <a class="el" href="config_8hpp_source.html#l00906">m_verbosities_by_component</a>, <a class="el" href="config_8hpp_source.html#l00877">m_verbosity_default</a>, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf">flow::log::S_END_SENTINEL</a>, and <a class="el" href="config_8cpp_source.html#l00250">this_thread_verbosity_override()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_ae429a329e31a41ba75f94578b0e7f26c_cgraph.svg" width="983" height="231"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a12f1147ae51ee6f9645dcd46e67c8410" name="a12f1147ae51ee6f9645dcd46e67c8410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f1147ae51ee6f9645dcd46e67c8410">&#9670;&nbsp;</a></span>standard_component_payload_enum_sparse_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::log::Config::standard_component_payload_enum_sparse_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns highest numeric value in the given component-payload <code>enum</code>, plus 1, assuming that <code>enum</code> was created using the <a class="el" href="config__enum__start__hdr_8macros_8hpp.html">config_enum_start_hdr.macros.hpp</a> mechanism with all requirements followed by user. </p>
<p >This is useful for most invocations of <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> for its <code>enum_sparse_length</code> argument.</p>
<p >For example, if one wants to store a <code>vector</code> that uses <code>size_t(X)</code>, where <code>X</code> is a <code>Component_payload</code>, as an associative-key-like index, then the <code>vector</code> would have to be sized whatever the present method returns to guarantee no out-of-bounds error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a>, particularly the <code>enum_sparse_length</code> argument.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component_payload</td><td>An <code>enum class</code> type created by the mechanism prescribed in <a class="el" href="config__enum__start__hdr_8macros_8hpp.html">config_enum_start_hdr.macros.hpp</a>, using that mechanism and with user following the documented requirements therein. Alternatively (though it's not recommended) the following is sufficient if one makes the type some other way: <code>Component_payload::S_END_SENTINEL</code> must have the highest numeric value, without ties; and the backing type is unsigned and with a bit width no higher than that of <code>size_t</code> (<a class="el" href="classflow_1_1log_1_1Component.html#a287888e2943b312f4febc3e8e130fc80" title="The type Payload must be enum class Payload : enum_raw_t: an enum type encoded via this integer type.">Component::enum_raw_t</a> is what the aforementioned standard mechanism uses as of this writing). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l01076">1076</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

</div>
</div>
<a id="aee6877cec4b070e18a40090f080e76ca" name="aee6877cec4b070e18a40090f080e76ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6877cec4b070e18a40090f080e76ca">&#9670;&nbsp;</a></span>store_severity_by_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Config::store_severity_by_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html#aabb6bf7c67b40faeab764ad695b63b9d">component_union_idx_t</a>&#160;</td>
          <td class="paramname"><em>component_union_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c">raw_sev_t</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev_or_none</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that for the given flat-union-component-index saves the given per-component verbosity, or removes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_union_idx</td><td>Index into <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a>. -1 leads to undefined behavior. Out-of-bounds leads to undefined behavior. For rationale for the latter decision see doc header for <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a>. </td></tr>
    <tr><td class="paramname">most_verbose_sev_or_none</td><td>Either a cast of a valid <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> value indicating the most-verbose (highest) severity allowed to pass the <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> filter; or -1 to remove the per-component verbosity. Note that <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a9ed9d44ce5760f61ea506d5571343624" title="Sentinel log level that must not be specified for any actual message (at risk of undefined behavior s...">Sev::S_NONE</a></code> is valid in this context and would disable all logging for that component. Conversely -1 would mean the component is removed from the conceptual "map." </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00055">55</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8hpp_source.html#l00906">m_verbosities_by_component</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8hpp_source.html#l01058">configure_component_verbosity()</a>, <a class="el" href="config_8cpp_source.html#l00127">configure_component_verbosity_by_name()</a>, and <a class="el" href="config_8cpp_source.html#l00109">configure_default_verbosity()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_aee6877cec4b070e18a40090f080e76ca_icgraph.svg" width="415" height="192"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a81da2c80d99cdd43c66a0df2eed64c70" name="a81da2c80d99cdd43c66a0df2eed64c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81da2c80d99cdd43c66a0df2eed64c70">&#9670;&nbsp;</a></span>this_thread_verbosity_override()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> * flow::log::Config::this_thread_verbosity_override </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to this thread's <em>mutable</em> verbosity override, for querying or assignment alike. </p>
<p >The value of this override, at any given time, shall affect <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> return value. See <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>.</p>
<p >If you would like to query the current setting, use this method.</p>
<p >If you would like to <em>modify</em> the current setting, it is safer and easier to use <a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe" title="Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...">this_thread_verbosity_override_auto()</a> which supplies RAII-style auto-restore.</p>
<p >For each thread:</p><ul>
<li>Let <code>S = *(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>)</code>.</li>
<li>Originally <code>S == <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf" title="Not an actual value but rather stores the highest numerical payload, useful for validity checks.">Sev::S_END_SENTINEL</a></code>.<ul>
<li><a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> in this case will therefore disregard <code>S</code>, per its doc header.</li>
</ul>
</li>
<li>You may set <code>S</code> to any valid <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> value via direct assignment.<ul>
<li><a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> in this case will follow <code>S</code> and only <code>S</code>, per its doc header.</li>
<li><a class="el" href="classflow_1_1log_1_1Config.html#ab025990297cc07d51aaec277af203dfe" title="Sets *(this_thread_verbosity_override()) = most_verbose_sev_or_none; and returns an object that shall...">this_thread_verbosity_override_auto()</a> is a convenient way of doing this, as it'll take care of the next step with minimal effort:</li>
</ul>
</li>
<li>You may set <code>S</code> back to <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf" title="Not an actual value but rather stores the highest numerical payload, useful for validity checks.">Sev::S_END_SENTINEL</a>.<ul>
<li><a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will begin disregarding <code>S</code> again.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>See above. Note that, for any given thread, the returned pointer shall always be the same. </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00250">250</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf">flow::log::S_END_SENTINEL</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00177">output_whether_should_log()</a>, and <a class="el" href="config_8cpp_source.html#l00260">this_thread_verbosity_override_auto()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_a81da2c80d99cdd43c66a0df2eed64c70_icgraph.svg" width="370" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab025990297cc07d51aaec277af203dfe" name="ab025990297cc07d51aaec277af203dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab025990297cc07d51aaec277af203dfe">&#9670;&nbsp;</a></span>this_thread_verbosity_override_auto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Scoped__setter.html">util::Scoped_setter</a>&lt; <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> &gt; flow::log::Config::this_thread_verbosity_override_auto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>most_verbose_sev_or_none</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>*(<a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>) = most_verbose_sev_or_none</code>; and returns an object that shall restore it to its current value when it goes out of scope. </p>
<p >See class doc header for an example of use.</p>
<p >It is recommended to use this method instead of direct assignment to the location <a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a>, as then it'll be auto-restored.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Config.html#a81da2c80d99cdd43c66a0df2eed64c70" title="Returns pointer to this thread&#39;s mutable verbosity override, for querying or assignment alike.">this_thread_verbosity_override()</a> and <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">most_verbose_sev_or_none</td><td>A value suitable for <a class="el" href="classflow_1_1log_1_1Config.html#ac562cc0132f6cfa81b42c332400033ae" title="Sets the default verbosity to the given value, to be used by subsequent output_whether_should_log() c...">configure_default_verbosity()</a>; or the special value <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a6fba12db09e5bebfaa04f6372c41c2cf" title="Not an actual value but rather stores the highest numerical payload, useful for validity checks.">Sev::S_END_SENTINEL</a> which disables the override (meaning <code>C.output_whether_should_log()</code> shall actually follow the config in <code><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> C</code> and not any override). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object that, when it is destroyed, will restore the verbosity override to what it was before this call. (The object cannot be copied, to prevent a double-restore. It can however be moved-from.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00260">260</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="config_8cpp_source.html#l00250">this_thread_verbosity_override()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Config_ab025990297cc07d51aaec277af203dfe_cgraph.svg" width="336" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae447f7751eb63baefb04fdeeeff95fda" name="ae447f7751eb63baefb04fdeeeff95fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae447f7751eb63baefb04fdeeeff95fda">&#9670;&nbsp;</a></span>m_component_cfgs_by_payload_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html#a02531ef4a8e85f074cc2a347c1771b81">Component_payload_type_to_cfg_map</a> flow::log::Config::m_component_cfgs_by_payload_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast-lookup map from distinct <code>Component_payload</code> type to the config for that component <code>enum</code>. </p>
<p >The key is <code>std::type_index(std::type_info)</code>, a/k/a <a class="el" href="classflow_1_1log_1_1Component.html#ab071f597ddeee9ad0fdb9e40bff8d988" title="Convenience accessor that returns std::type_index(payload_type()), which can be used most excellently...">Component::payload_type_index()</a>. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00862">862</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00040">component_to_union_idx()</a>, and <a class="el" href="config_8hpp_source.html#l00929">init_component_to_union_idx_mapping()</a>.</p>

</div>
</div>
<a id="a35cb8f5805d2093d13625a528d78919c" name="a35cb8f5805d2093d13625a528d78919c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb8f5805d2093d13625a528d78919c">&#9670;&nbsp;</a></span>m_component_names_by_union_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html#a663307a81245b621e12680d3a4d83df2">Component_union_idx_to_name_map</a> flow::log::Config::m_component_names_by_union_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps each flat union component index to its <em>output</em> component name as registered in <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a>. </p>
<p >Note that a given index not being present in this map doesn't mean it's not a real component; but <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> caller may have intentionally not supplied it a forward-lookup name, so that instead the number itself would be output.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00916">916</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8hpp_source.html#l00971">init_component_names()</a>, and <a class="el" href="config_8cpp_source.html#l00145">output_component_to_ostream()</a>.</p>

</div>
</div>
<a id="ad9decea94f2d3297a2b24bc6de7c4657" name="ad9decea94f2d3297a2b24bc6de7c4657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9decea94f2d3297a2b24bc6de7c4657">&#9670;&nbsp;</a></span>m_component_union_idxs_by_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html#aa1ed54fc7cef5b0ba4eadf97daf79be7">Component_name_to_union_idx_map</a> flow::log::Config::m_component_union_idxs_by_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps each distinct component name as registered in <a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> to its flat union component index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Config.html#a146a60d96256dbaed4f5f0e7dcd8f529" title="Registers the string names of each member of the enum class Component_payload earlier registered via ...">init_component_names()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00923">923</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00127">configure_component_verbosity_by_name()</a>, and <a class="el" href="config_8hpp_source.html#l00971">init_component_names()</a>.</p>

</div>
</div>
<a id="a1b16be31f5dcfba9536a377c9d29abb6" name="a1b16be31f5dcfba9536a377c9d29abb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b16be31f5dcfba9536a377c9d29abb6">&#9670;&nbsp;</a></span>m_use_human_friendly_time_stamps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::log::Config::m_use_human_friendly_time_stamps</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> setting: If <code>true</code>, time stamps will include a (deterministically formatted) date, time, time zone, all in the OS's current time zone; else raw # of seconds passed since POSIX (Unix) Epoch (1970, Jan 1, 00:00, GMT). </p>
<p >In both cases time is expressed with microsecond resolution (but the accuracy is only as good as the computer's clock hardware and OS software allow, presumably, though this isn't in the purview of class <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a>). </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00663">663</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ostream__log__msg__writer_8cpp_source.html#l00035">flow::log::Ostream_log_msg_writer::Ostream_log_msg_writer()</a>.</p>

</div>
</div>
<a id="a6b6b4511883c815e81f6427909ed829f" name="a6b6b4511883c815e81f6427909ed829f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6b4511883c815e81f6427909ed829f">&#9670;&nbsp;</a></span>m_verbosities_by_component</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585">Component_union_idx_to_sev_map</a> flow::log::Config::m_verbosities_by_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps from flat union component index to most verbose (highest) <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> for which <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return true, when the input component is not null and maps to that flat union index via <a class="el" href="classflow_1_1log_1_1Config.html#af2d963a6e1e9e0fc5809764d5718e938" title="Given a component in the form user provides it at log call sites, returns its index in the flat compo...">component_to_union_idx()</a>. </p>
<p >First, read doc header for Component_union_idx_to_sev_map which described why and how the data structure works as a map; then return here.</p>
<p >Semantics are as follows:</p><ul>
<li>If <code>m_verbosities_by_component[X]</code> equals -1 cast appropriately, then that component key is <em>not</em> in the conceptual map (<code>map::find()</code> would return <code>end()</code>). This means no verbosity is configured for that individual component; note this is common-place in practice. One should then fall back to <a class="el" href="classflow_1_1log_1_1Config.html#a409818a2192ee2544b442b2ea957a76c" title="Most verbose (highest) log::Sev for which output_whether_should_log() will return true,...">m_verbosity_default</a>.</li>
<li>If <code>m_verbosities_by_component[X]</code> is out of range, same thing. However, that means they didn't properly call <a class="el" href="classflow_1_1log_1_1Config.html#a116df84f1735ade2c4b9b265c4bdd36a" title="Registers a generically-typed enum class that represents the full set of the calling module&#39;s possibl...">init_component_to_union_idx_mapping()</a> to allow for <code>X</code>. Nevertheless, that is allowed when <em>reading</em> (in <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a>) to avoid crashing for no great reason. It is however not allowed when <em>writing</em> (in <code>configure_*_verbosity()</code>), so they'd better get it right at that level. The idea is to be permissive at log call sites, which should not care about ANY of this and just want to log with their component in peace; but not-permissive when configuring the log system, done at the program driver level.</li>
<li>If <code>m_verbosities_by_component[X]</code> is in range and not -1, then that value cast to <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> is the verbosity for that individual component. (In particular, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a9ed9d44ce5760f61ea506d5571343624" title="Sentinel log level that must not be specified for any actual message (at risk of undefined behavior s...">Sev::S_NONE</a> which happens to be 0, means all logging is disabled for that component.)</li>
</ul>
<p >Note that some log systems will choose to not even allow any elements in <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a> and leave the config to <a class="el" href="classflow_1_1log_1_1Config.html#a409818a2192ee2544b442b2ea957a76c" title="Most verbose (highest) log::Sev for which output_whether_should_log() will return true,...">m_verbosity_default</a> exclusively; in this case <code>m_verbosities_by_component</code> is filled with -1 copies (or might even be empty, if they had never configured any components for whatever reason; by above semantics those have identical meanings). </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00906">906</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00109">configure_default_verbosity()</a>, <a class="el" href="config_8hpp_source.html#l00929">init_component_to_union_idx_mapping()</a>, <a class="el" href="config_8cpp_source.html#l00177">output_whether_should_log()</a>, and <a class="el" href="config_8cpp_source.html#l00055">store_severity_by_component()</a>.</p>

</div>
</div>
<a id="a409818a2192ee2544b442b2ea957a76c" name="a409818a2192ee2544b442b2ea957a76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409818a2192ee2544b442b2ea957a76c">&#9670;&nbsp;</a></span>m_verbosity_default</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html">Atomic_raw_sev</a> flow::log::Config::m_verbosity_default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most verbose (highest) <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a> for which <a class="el" href="classflow_1_1log_1_1Config.html#ae429a329e31a41ba75f94578b0e7f26c" title="A key output of Config, this computes the verbosity-filtering answer to Logger::should_log() based on...">output_whether_should_log()</a> will return true, when the input component is null or lacks a per-component configured verbosity. </p>
<p >Note that some log systems will choose to use only this and not even allow any elements in <a class="el" href="classflow_1_1log_1_1Config.html#a6b6b4511883c815e81f6427909ed829f" title="Maps from flat union component index to most verbose (highest) log::Sev for which output_whether_shou...">m_verbosities_by_component</a> (see its doc header for definition of containing or lacking an element).</p>
<h3>Rationale: Why <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a> instead of just <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04" title="Enumeration containing one of several message severity levels, ordered from highest to lowest.">log::Sev</a>?</h3>
<p >The reasoning is identical to that found in the discussion of why <code>atomic</code> is used in <a class="el" href="classflow_1_1log_1_1Config.html#a3c5c7d62daba9625b0309b31da287585" title="Short-hand for fast-lookup, thread-safe-for-RW mapping from flat-union-component-table index to max a...">Component_union_idx_to_sev_map</a>; see its doc header. (We don't have to store a <a class="el" href="classflow_1_1log_1_1Config.html#acae76e3367bd497f5b00f46e48b3a39c" title="How we store a log::Sev (a mere enum itself) in a certain data structure.">raw_sev_t</a>, as it's one lousy value and not a bulk container in this case, but we do anyway just to get the copyability for free without having to parameterize <a class="el" href="classflow_1_1log_1_1Config_1_1Atomic__raw__sev.html" title="Trivial wrapper of atomic&lt;raw_sev_t&gt; which adds a couple of things to make it possible to construct,...">Atomic_raw_sev</a> into a template. It's a tiny bit cheesy to avoid the latter just to keep the code briefer, but probably well within reasonableness.) </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00877">877</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="config_8cpp_source.html#l00109">configure_default_verbosity()</a>, and <a class="el" href="config_8cpp_source.html#l00177">output_whether_should_log()</a>.</p>

</div>
</div>
<a id="a94e6c81a4e3dd9b41c1b468f7d7c1a90" name="a94e6c81a4e3dd9b41c1b468f7d7c1a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e6c81a4e3dd9b41c1b468f7d7c1a90">&#9670;&nbsp;</a></span>S_MOST_VERBOSE_SEV_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> flow::log::Config::S_MOST_VERBOSE_SEV_DEFAULT = <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">Sev::S_INFO</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recommended default/catch-all most-verbose-severity value if no specific config is given. </p>

<p class="definition">Definition at line <a class="el" href="config_8hpp_source.html#l00219">219</a> of file <a class="el" href="config_8hpp_source.html">config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="verbosity__config_8cpp_source.html#l00044">flow::log::Verbosity_config::parse()</a>, and <a class="el" href="verbosity__config_8cpp_source.html#l00034">flow::log::Verbosity_config::Verbosity_config()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>log/<a class="el" href="config_8hpp_source.html">config.hpp</a></li>
<li>log/<a class="el" href="config_8cpp_source.html">config.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 10 2024 06:09:27 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
