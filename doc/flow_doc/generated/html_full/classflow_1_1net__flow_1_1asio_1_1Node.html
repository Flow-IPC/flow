<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::asio::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow_1_1asio.html">asio</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classflow_1_1net__flow_1_1asio_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::asio::Node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A subclass of <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> that adds the ability to easily and directly use <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> sockets in general boost.asio event loops.  
 <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::asio::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node__inherit__graph.svg" width="487" height="191"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::asio::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node__coll__graph.svg" width="2128" height="1872"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7db28ab33b1a9afcdcd1884e08f33bee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a7db28ab33b1a9afcdcd1884e08f33bee">Node</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger, <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *target_async_task_engine, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_endpoint, <a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *net_env_sim=0, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts=<a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>())</td></tr>
<tr class="memdesc:a7db28ab33b1a9afcdcd1884e08f33bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a7db28ab33b1a9afcdcd1884e08f33bee">More...</a><br /></td></tr>
<tr class="separator:a7db28ab33b1a9afcdcd1884e08f33bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ffa52a73f455142da9497ca10734d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d">async_task_engine</a> ()</td></tr>
<tr class="memdesc:a778ffa52a73f455142da9497ca10734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer (possibly null) for the <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a> used by any coming async I/O calls and inherited by any subsequently generated <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> objects.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d">More...</a><br /></td></tr>
<tr class="separator:a778ffa52a73f455142da9497ca10734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b29f0ae35a832b0c3c75cf0b577ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae">set_async_task_engine</a> (<a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *target_async_task_engine)</td></tr>
<tr class="memdesc:a0e6b29f0ae35a832b0c3c75cf0b577ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the value to be returned by next <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae">More...</a><br /></td></tr>
<tr class="separator:a0e6b29f0ae35a832b0c3c75cf0b577ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d21b9a18651cd234589f3b0b6d2971"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Handler &gt; </td></tr>
<tr class="memitem:a97d21b9a18651cd234589f3b0b6d2971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971">async_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const Handler &amp;on_result, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a97d21b9a18651cd234589f3b0b6d2971"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boost.asio asynchronous version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>, performing any necessary wait and connection in the background, and queueing the user-provided callback on the given boost.asio <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971">More...</a><br /></td></tr>
<tr class="separator:a97d21b9a18651cd234589f3b0b6d2971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ae97d499f6de21140b89218e52fc4c"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Handler &gt; </td></tr>
<tr class="memitem:af8ae97d499f6de21140b89218e52fc4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c">async_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const Handler &amp;on_result, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:af8ae97d499f6de21140b89218e52fc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (asynchronously blocking connect, with supplied metadata).  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c">More...</a><br /></td></tr>
<tr class="separator:af8ae97d499f6de21140b89218e52fc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee695d173c035d106ea7a9d078de3b9"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:a7ee695d173c035d106ea7a9d078de3b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a7ee695d173c035d106ea7a9d078de3b9">async_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const Handler &amp;on_result, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a7ee695d173c035d106ea7a9d078de3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>async_connect(to, on_result, duration::max(), opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a7ee695d173c035d106ea7a9d078de3b9">More...</a><br /></td></tr>
<tr class="separator:a7ee695d173c035d106ea7a9d078de3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5352db9d04c9d1e87b0cae848d0a5a90"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:a5352db9d04c9d1e87b0cae848d0a5a90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a5352db9d04c9d1e87b0cae848d0a5a90">async_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const Handler &amp;on_result, const boost::asio::const_buffer &amp;serialized_metadata, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a5352db9d04c9d1e87b0cae848d0a5a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>async_connect_with_metadata(to, on_result, duration::max(),
serialized_metadata, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a5352db9d04c9d1e87b0cae848d0a5a90">More...</a><br /></td></tr>
<tr class="separator:a5352db9d04c9d1e87b0cae848d0a5a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1net__flow_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1net__flow_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></td></tr>
<tr class="memitem:acd93ba39d6a9cdee60c2ad7da1085902 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">Node</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_endpoint, <a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *net_env_sim=0, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts=<a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>())</td></tr>
<tr class="memdesc:acd93ba39d6a9cdee60c2ad7da1085902 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">More...</a><br /></td></tr>
<tr class="separator:acd93ba39d6a9cdee60c2ad7da1085902 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c53c4848ea976b075a0b56f33eb118 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">~Node</a> () override</td></tr>
<tr class="memdesc:a16c53c4848ea976b075a0b56f33eb118 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">More...</a><br /></td></tr>
<tr class="separator:a16c53c4848ea976b075a0b56f33eb118 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae148cec361b59237996a4b30c6624b5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a> () const</td></tr>
<tr class="memdesc:aae148cec361b59237996a4b30c6624b5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is operating.  <a href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">More...</a><br /></td></tr>
<tr class="separator:aae148cec361b59237996a4b30c6624b5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb3dcb90f1dfc44a4343c0e89ce6b83 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">local_low_lvl_endpoint</a> () const</td></tr>
<tr class="memdesc:a4cb3dcb90f1dfc44a4343c0e89ce6b83 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">More...</a><br /></td></tr>
<tr class="separator:a4cb3dcb90f1dfc44a4343c0e89ce6b83 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c8393930110e2aa0823583e37cabd inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a893c8393930110e2aa0823583e37cabd inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an active connect to the specified remote Flow server.  <a href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">More...</a><br /></td></tr>
<tr class="separator:a893c8393930110e2aa0823583e37cabd inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a0e5492b9ea005cc12c20c8e7cec9a inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ae9a0e5492b9ea005cc12c20c8e7cec9a inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but sends, as part of the connection handshake, the user-supplied metadata, which the other side can access via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> after accepting the connection.  <a href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">More...</a><br /></td></tr>
<tr class="separator:ae9a0e5492b9ea005cc12c20c8e7cec9a inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:aba2e6fc905dbeef3ea9e31bf844f8da5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">More...</a><br /></td></tr>
<tr class="separator:aba2e6fc905dbeef3ea9e31bf844f8da5 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6725d69ea1a6457d88abb63cef6e6bb2 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (blocking connect, with supplied metadata).  <a href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">More...</a><br /></td></tr>
<tr class="separator:a6725d69ea1a6457d88abb63cef6e6bb2 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094b83973fd9af8b45d8f4cb3c14e35 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ac094b83973fd9af8b45d8f4cb3c14e35 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect(to, duration::max(), err_code, opt)s</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">More...</a><br /></td></tr>
<tr class="separator:ac094b83973fd9af8b45d8f4cb3c14e35 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1043586a0e6413b1118d6c090bf89 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6db1043586a0e6413b1118d6c090bf89 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2" title="A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...">sync_connect_with_metadata()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">More...</a><br /></td></tr>
<tr class="separator:a6db1043586a0e6413b1118d6c090bf89 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2cd6a6c328a2d5381308258d35d95d inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">listen</a> (<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts=0)</td></tr>
<tr class="memdesc:a3c2cd6a6c328a2d5381308258d35d95d inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a server on the given local Flow port and returns <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which can be used to accept subsequent incoming connections to this server.  <a href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">More...</a><br /></td></tr>
<tr class="separator:a3c2cd6a6c328a2d5381308258d35d95d inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100464cf0126dbbad39bde1c90a774f inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">event_set_create</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ad100464cf0126dbbad39bde1c90a774f inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> state with no sockets/events stored; returns this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">More...</a><br /></td></tr>
<tr class="separator:ad100464cf0126dbbad39bde1c90a774f inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1124027c715d674f113f2d961e4c6861 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">interrupt_all_waits</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a1124027c715d674f113f2d961e4c6861 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blocking operation's outcome was being interrupted.  <a href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">More...</a><br /></td></tr>
<tr class="separator:a1124027c715d674f113f2d961e4c6861 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779cc2429651696df1bca8de73534f3 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">set_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2779cc2429651696df1bca8de73534f3 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>) with the given options set.  <a href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">More...</a><br /></td></tr>
<tr class="separator:a2779cc2429651696df1bca8de73534f3 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b9c2b9a8a969f5e3715341c433aec inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">options</a> () const</td></tr>
<tr class="memdesc:a159b9c2b9a8a969f5e3715341c433aec inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s option set and returns that copy.  <a href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">More...</a><br /></td></tr>
<tr class="separator:a159b9c2b9a8a969f5e3715341c433aec inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7b471dd6cd3e3570930b48d30e577 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a> () const</td></tr>
<tr class="memdesc:a4bd7b471dd6cd3e3570930b48d30e577 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes of user data per received or sent block on connections generated from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, unless this value is overridden in the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (or friend).  <a href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">More...</a><br /></td></tr>
<tr class="separator:a4bd7b471dd6cd3e3570930b48d30e577 inherit pub_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a62307823b2aa4db4f6de5c0245461652"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">Handler_func</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;err_code, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a3ee868ebd8acd1788a5bed8cf66a349e">Peer_socket::Ptr</a> new_sock)&gt;</td></tr>
<tr class="memdesc:a62307823b2aa4db4f6de5c0245461652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the <code>Task_engine</code>-compatible connect <code>Handler</code> concrete type for class-internal code.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">More...</a><br /></td></tr>
<tr class="separator:a62307823b2aa4db4f6de5c0245461652"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a13e8070f5a4e4300e0138b63694884fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">net_flow::Peer_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a13e8070f5a4e4300e0138b63694884fc">sock_create</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts) override</td></tr>
<tr class="memdesc:a13e8070f5a4e4300e0138b63694884fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements superclass API.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a13e8070f5a4e4300e0138b63694884fc">More...</a><br /></td></tr>
<tr class="separator:a13e8070f5a4e4300e0138b63694884fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63171653725513e198b8baf60c3c1427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">net_flow::Server_socket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a63171653725513e198b8baf60c3c1427">serv_create</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts) override</td></tr>
<tr class="memdesc:a63171653725513e198b8baf60c3c1427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements superclass API.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a63171653725513e198b8baf60c3c1427">More...</a><br /></td></tr>
<tr class="separator:a63171653725513e198b8baf60c3c1427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf22e56b3c091645154719eeb49ff4a"><td class="memTemplParams" colspan="2">template&lt;typename Socket , typename Base_socket , typename Non_blocking_func_ret_type &gt; </td></tr>
<tr class="memitem:a0cf22e56b3c091645154719eeb49ff4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a">async_op</a> (typename Socket::Ptr sock, <a class="el" href="classflow_1_1Function.html">Function</a>&lt; Non_blocking_func_ret_type(<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *)&gt; &amp;&amp;non_blocking_func, Non_blocking_func_ret_type would_block_ret_val, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;, Non_blocking_func_ret_type)&gt; &amp;&amp;on_result)</td></tr>
<tr class="memdesc:a0cf22e56b3c091645154719eeb49ff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of core asynchronous transfer methods, namely <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a33adc635f29071b10ea59802405d9b6c" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a98186f8257f1f7b49dbbbc13c0dda7fe" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_receive()</a>, and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a8f374618b5d754321ac288cd6f1f50ea" title="boost.asio-style asynchronous version that essentially performs net_flow::Server_socket::sync_accept(...">asio::Server_socket::async_accept()</a>, once the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> has been obtain from socket in any one of those methods.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a">More...</a><br /></td></tr>
<tr class="separator:a0cf22e56b3c091645154719eeb49ff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecac8b38cd35267b1af57e2443a55ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#aecac8b38cd35267b1af57e2443a55ea0">async_connect_impl</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">Handler_func</a> &amp;&amp;on_result)</td></tr>
<tr class="memdesc:aecac8b38cd35267b1af57e2443a55ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation core of <code>async_connect*()</code> that gets rid of templated or missing arguments thereof.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#aecac8b38cd35267b1af57e2443a55ea0">More...</a><br /></td></tr>
<tr class="separator:aecac8b38cd35267b1af57e2443a55ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b99ea857df0cbbf2b26f6c84e8863a"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:ad0b99ea857df0cbbf2b26f6c84e8863a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">Handler_func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#ad0b99ea857df0cbbf2b26f6c84e8863a">handler_func</a> (Handler &amp;&amp;on_result)</td></tr>
<tr class="memdesc:ad0b99ea857df0cbbf2b26f6c84e8863a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a functor that essentially performs <code>post()</code> <code>on_result</code> onto <code>*async_task_engine()</code> in a way suitable for a boost.asio-compatible async-op.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#ad0b99ea857df0cbbf2b26f6c84e8863a">More...</a><br /></td></tr>
<tr class="separator:ad0b99ea857df0cbbf2b26f6c84e8863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5b688a4071b8ad58a776de8d3816b757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a5b688a4071b8ad58a776de8d3816b757">m_target_task_engine</a></td></tr>
<tr class="memdesc:a5b688a4071b8ad58a776de8d3816b757"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a5b688a4071b8ad58a776de8d3816b757">More...</a><br /></td></tr>
<tr class="separator:a5b688a4071b8ad58a776de8d3816b757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a62cd43d29137c6c9abc7d9dd731555f9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62cd43d29137c6c9abc7d9dd731555f9">Peer_socket</a></td></tr>
<tr class="memdesc:a62cd43d29137c6c9abc7d9dd731555f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> must be able to forward to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a" title="Implementation of core asynchronous transfer methods, namely asio::Peer_socket::async_send(),...">async_op()</a>, etc.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62cd43d29137c6c9abc7d9dd731555f9">More...</a><br /></td></tr>
<tr class="separator:a62cd43d29137c6c9abc7d9dd731555f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165381af6166d76afba06862c762367"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a2165381af6166d76afba06862c762367">Server_socket</a></td></tr>
<tr class="memdesc:a2165381af6166d76afba06862c762367"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> must be able to forward to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a" title="Implementation of core asynchronous transfer methods, namely asio::Peer_socket::async_send(),...">async_op()</a>, etc.  <a href="classflow_1_1net__flow_1_1asio_1_1Node.html#a2165381af6166d76afba06862c762367">More...</a><br /></td></tr>
<tr class="separator:a2165381af6166d76afba06862c762367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classflow_1_1net__flow_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classflow_1_1net__flow_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></td></tr>
<tr class="memitem:a1ecd7c03349fcb26b9692d300a759463 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">S_NUM_PORTS</a> = Port_space::S_NUM_PORTS</td></tr>
<tr class="memdesc:a1ecd7c03349fcb26b9692d300a759463 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow ports in the port space, including <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">More...</a><br /></td></tr>
<tr class="separator:a1ecd7c03349fcb26b9692d300a759463 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b913c5c759a465a9fcaa637ddaea99 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">S_NUM_SERVICE_PORTS</a> = Port_space::S_NUM_SERVICE_PORTS</td></tr>
<tr class="memdesc:aa1b913c5c759a465a9fcaa637ddaea99 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "service" ports (ones that can be reserved by number with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>).  <a href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">More...</a><br /></td></tr>
<tr class="separator:aa1b913c5c759a465a9fcaa637ddaea99 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aadcad6c19587cd0d788570194b2afd inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">S_NUM_EPHEMERAL_PORTS</a> = Port_space::S_NUM_EPHEMERAL_PORTS</td></tr>
<tr class="memdesc:a7aadcad6c19587cd0d788570194b2afd inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "ephemeral" ports (ones reserved locally at random with <code>Node::listen(S_PORT_ANY)</code> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>).  <a href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">More...</a><br /></td></tr>
<tr class="separator:a7aadcad6c19587cd0d788570194b2afd inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b593d90c246cb2e35fc6a0834e6876 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">S_FIRST_SERVICE_PORT</a> = Port_space::S_FIRST_SERVICE_PORT</td></tr>
<tr class="memdesc:a96b593d90c246cb2e35fc6a0834e6876 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest service port, making the range of service ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">S_NUM_SERVICE_PORTS</a> - 1].  <a href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">More...</a><br /></td></tr>
<tr class="separator:a96b593d90c246cb2e35fc6a0834e6876 inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1021e099c70c1a6e192e65f86debf inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">S_FIRST_EPHEMERAL_PORT</a> = Port_space::S_FIRST_EPHEMERAL_PORT</td></tr>
<tr class="memdesc:aa1d1021e099c70c1a6e192e65f86debf inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">S_NUM_EPHEMERAL_PORTS</a> - 1].  <a href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">More...</a><br /></td></tr>
<tr class="separator:aa1d1021e099c70c1a6e192e65f86debf inherit pub_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classflow_1_1net__flow_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classflow_1_1net__flow_1_1Node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename Peer_socket_impl_type &gt; </td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">sock_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:aa42efbce8c5ea908a253fca2e9b2a02c inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to newly created <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or sub-instance like <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>, depending on the template parameter.  <a href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">More...</a><br /></td></tr>
<tr class="separator:aa42efbce8c5ea908a253fca2e9b2a02c inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename Server_socket_impl_type &gt; </td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">serv_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts)</td></tr>
<tr class="memdesc:ab330b19f4039bab074251111789b568a inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c" title="Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...">sock_create_forward_plus_ctor_args()</a> but for Server_sockets.  <a href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">More...</a><br /></td></tr>
<tr class="separator:ab330b19f4039bab074251111789b568a inherit pro_methods_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classflow_1_1net__flow_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classflow_1_1net__flow_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></td></tr>
<tr class="memitem:ab13749ccdf4ab44445f21c77296ffa13 inherit pro_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a> = 0</td></tr>
<tr class="memdesc:ab13749ccdf4ab44445f21c77296ffa13 inherit pro_static_attribs_classflow_1_1net__flow_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type and value to supply as user-supplied metadata in SYN, if user chooses to use <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a></code> instead of <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">More...</a><br /></td></tr>
<tr class="separator:ab13749ccdf4ab44445f21c77296ffa13 inherit pro_static_attribs_classflow_1_1net__flow_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A subclass of <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> that adds the ability to easily and directly use <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> sockets in general boost.asio event loops. </p>
<p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, the superclass, provides the vast bulk of the functionality in this library, but the sockets it generates directly or indirectly (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a>) cannot be used directly in a boost.asio event loop (see reference below for background). It is possible to use the vanilla <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, etc., with <em>any</em> asynchronous event loop (boost.asio or native <code>epoll</code> or <code>select()</code>...) &ndash; notably by using a glue socket, as explained in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header. However, for those using the boost.asio <code>io_context</code> as the app's core main loop, this is not as easy as what one might desire. (Side note: I personally strongly recommend using boost.asio event loops instead of rolling one's own or the many alternatives I have seen. It is also on its way to ending up in the C++ standard library. Lastly, such a loop is used internally to implement <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>, so you know I like it, for what that's worth.)</p>
<p >Basically, if you use this <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> instead of <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, then you get everything in the latter plus the ability to use Flow-protocol sockets <code>{Server|Peer}_socket</code> with boost.asio as easily as and similarly to how one uses <code>boost::asio::ip::tcp::acceptor::async_*()</code> and <code>boost::asio::ip::tcp::socket::async_*()</code>, respectively.</p>
<p >The usage pattern is simple, assuming you understand tha basics of <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> &ndash; and especially if you are familiar with boost.asio's built-in <code>tcp::acceptor</code> and <code>tcp::socket</code> (and, of course, <code>boost::asio::io_context</code> that ties them and many more I/O objects together).</p>
<ul>
<li>First, simply create an <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> using the same form of constructor as you would with <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, plus an arg that's a pointer to the subsequently used target boost.asio <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>, which is memorized.<ul>
<li>All facilities from the regular <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> are available on this object (plus some minor boost.asio ones).</li>
</ul>
</li>
<li>Upon obtaining a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">net_flow::Server_socket::Ptr</a> via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>, cast it to its true polymorphic equivalent <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#ac7ed30d29e4ba6f344e58299ed343773" title="Short-hand for shared_ptr to Server_socket.">asio::Server_socket::Ptr</a>, via convenience method <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a5f28c0b6770b68994aa95ae5df50afc2" title="Convenience method that polymorphically casts from net_flow::Server_socket::Ptr to subclass pointer n...">net_flow::asio::Server_socket::cast()</a>: <code>auto serv = <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a5f28c0b6770b68994aa95ae5df50afc2" title="Convenience method that polymorphically casts from net_flow::Server_socket::Ptr to subclass pointer n...">asio::Server_socket::cast</a>(node.listen(...));</code>.<ul>
<li>All facilities from the superclass <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a> are available (plus some minor boost.asio ones).</li>
</ul>
</li>
<li>Similarly cast any <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">net_flow::Peer_socket::Ptr</a> to <code>asio</code> equivalent for any peer socket returned by <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">asio::Server_socket::accept()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">asio::Node::connect()</a> and similar.<ul>
<li>All facilities from the superclass <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> are available (plus some minor boost.asio ones).</li>
</ul>
</li>
<li>All <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> objects created by the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> subsequently will inherit the <code>Task_engine*</code> supplied in <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> constructor. However, you may overwrite these (or remove them, by setting to null) at any time via <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">Node::set_async_task_engine()</a>, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a2353700db774bce70be0862f6b68aff1" title="Overwrites the value to be returned by next async_task_engine().">Server_socket::set_async_task_engine()</a>, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a03a8a4b4ab5338d80b5d78a03279510a" title="Overwrites the value to be returned by next async_task_engine().">Peer_socket::set_async_task_engine()</a>.<ul>
<li>The only rule is this: <code>net_flow::asio::X::async_task_engine()</code> must not be null whenever one calls <code>net_flow::asio::X::async_F()</code>, where X is <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a>, or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a>; and <code>async_F()</code> is some async operation added on top of base class <code>net_flow::X</code> (which typically features <code>net_flow::X::F()</code> and <code>net_flow::X::sync_F()</code> &ndash; the non-blocking and thread-blocking versions of F, respectively).</li>
<li>The automatic inheriting of <code>Task_engine</code> pointer is as follows: <code><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> -listen-&gt; <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> -accept-&gt; <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> &lt;-connect- <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a></code>.<ul>
<li>For each op inside an "arrow," I mean to include all forms of it (<code>F</code> includes: <code>F()</code>, <code>sync_F()</code>, <code>async_F()</code>).</li>
<li>This pattern is more practical/reasonable for us than the boost.asio pattern of each object memorizing its <code>io_context</code> reference in its explicit constructor. That is because we fully embrace the factory-of-shared-pointers pattern, and boost.asio doesn't use that pattern. We also provide an explicit mutator however.</li>
<li>We also allow for a null <code>Task_engine*</code> &ndash; except when <code>async_*()</code> is actually performed. (boost.asio I/O objects seem to require a real <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>, even if not planning to do anything async. Note, though, that if you don't plan to do anything async with <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>, then you can just use vanilla <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>. Bottom line, you have (on this topic) <em>at least</em> as much flexibility as with boost.asio built-in I/O objects.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >Having thus obtained <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">asio::Server_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a> objects (and assigned each their desired boost.asio <code>io_context</code> loop(s) &ndash; essentially as one does with, e.g., <code>tcp::acceptor</code> and <code>tcp::socket</code> respectively) &ndash; you many now use the full range of I/O operations. Here is a bird's eye view of all operations available in the entire hierarchy. Note that conceptually this is essentially identical to boost.asio <code>tcp</code> I/O objects, but nomenclature and API decisions are in some cases somewhat different (I contend: with good reason).</p>
<ul>
<li>Non-blocking operations:<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">net_flow::Node::listen()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a>: Create an object listening for connections.<ul>
<li>Equivalent: <code>tcp::acceptor</code> constructor that takes a local endpoint arg.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">net_flow::Server_socket::accept()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>: Return a fully connected peer socket object, if one is immediately ready due to the listening done so far.<ul>
<li>Equivalent: <code>tcp::acceptor::accept()</code> after ensuring <code>tcp::acceptor::non_blocking(true)</code>. NetFlow null return value &lt;-&gt; TCP "would-block" error code.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">net_flow::Node::connect()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>: Return a connectING peer socket object immediately, as it tries to connected to the server socket on the remote side.<ul>
<li>Equivalent: <code>tcp::socket::connect()</code> after ensuring <code>tcp::socket::non_blocking(true)</code>.</li>
<li>Variations: see also <code>*_with_metadata()</code> for an added feature without direct TCP equivalent.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">net_flow::Peer_socket::send()</a>: Queue up at least 1 of the N given bytes to send to peer ASAP; or indicate no bytes could be <em>immediately</em> queued.<ul>
<li>Equivalent: <code>tcp::socket::send()</code> after ensuring <code>tcp::socket::non_blocking(true)</code>. NetFlow 0 return value &lt;-&gt; TCP "would-block" error code.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">net_flow::Peer_socket::receive()</a>: Dequeue at least 1 of the desired N bytes earlier received from peer; or indicate none were <em>immediately</em> available.<ul>
<li>Equivalent: <code>tcp::socket::receive()</code> after ensuring <code>tcp::socket::non_blocking(true)</code>. NetFlow 0 return value &lt;-&gt; TCP "would-block" error code.</li>
</ul>
</li>
</ul>
</li>
<li>Blocking operations:<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">net_flow::Server_socket::sync_accept()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>: Return a fully connected peer socket object, blocking thread if necessary to wait for a connection to come in and fully establish.<ul>
<li>Equivalent: <code>tcp::acceptor::accept()</code> after ensuring <code>tcp::acceptor::non_blocking(false)</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>reactor_pattern</code> mode, where the <a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a> call itself is left to aftermath of sync_accept().</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">net_flow::Node::sync_connect()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>: Return a connected peer socket object, blocking thread as needed to reach the remote server and fully establish connection.<ul>
<li>Equivalent: <code>tcp::socket::connect()</code> after ensuring <code>tcp::socket::non_blocking(false)</code>.</li>
<li>Variations: see also <code>*_with_metadata()</code> as above.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">net_flow::Peer_socket::sync_send()</a>: Queue up at least 1 of the N given bytes to send to peer ASAP, blocking thread if necessary to wait for this to become possible (internally, as determined by such things as flow control, congestion control, buffer size limits).<ul>
<li>Equivalent: <code>tcp::socket::send()</code> after ensuring <code>tcp::socket::non_blocking(false)</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>nullptr_t</code> mode, where the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> call itself is left to aftermath of sync_send().</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">net_flow::Peer_socket::sync_receive()</a>: Dequeue at least 1 of the desired N bytes from peer, blocking thread if necessary to wait for this to arrive from said remote peer.<ul>
<li>Equivalent: <code>tcp::socket::receive()</code> after ensuring <code>tcp::socket::non_blocking(false)</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>nullptr_t</code> mode, where the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code> call itself is left to aftermath of sync_receive().</li>
</ul>
</li>
</ul>
</li>
<li>Asynchronous operations (<code>asio::*</code> classes provide these):<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a8f374618b5d754321ac288cd6f1f50ea" title="boost.asio-style asynchronous version that essentially performs net_flow::Server_socket::sync_accept(...">asio::Server_socket::async_accept()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>: Obtain a fully connected peer socket object, waiting as necessary in background for a connection to come in and fully establish, then invoking user-provided callback as if by <code>post(io_context&amp;)</code>.<ul>
<li>Equivalent: <code>tcp::acceptor::async_accept()</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>reactor_pattern</code> mode, where the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">accept()</a></code> call itself is left to user handler.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">asio::Node::async_connect()</a> -&gt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a>: Return a fully connected peer socket object, waiting as necessary in background to reach the remote server and fully establish connection, then invoking user-provided callback as if by <code>post(io_context&amp;)</code>.<ul>
<li>Equivalent: <code>tcp::socket::async_connect()</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: see also <code>*_with_metadata()</code> as above.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a33adc635f29071b10ea59802405d9b6c" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_send()</a>: Queue up at least 1 of the N given bytes to send to peer ASAP, waiting as necessary in background for this to become possible (as explained above), then invoking user-provided callback as if by <code>post(io_context&amp;)</code>.<ul>
<li>Equivalent: <code>tcp::socket::async_send()</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>nullptr_t</code> mode, where the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">send()</a></code> call itself is left to user handler.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a98186f8257f1f7b49dbbbc13c0dda7fe" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_receive()</a>: Dequeue at least 1 of the desired N bytes from peer, waiting as necessary in background for this to arrive from said remote peer, then invoking user-provided callback as if by <code>post(io_context&amp;)</code>.<ul>
<li>Equivalent: <code>tcp::socket::async_receive()</code>.</li>
<li>Variations: optional timeout can be specified.</li>
<li>Variations: <code>nullptr_t</code> mode, where the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">receive()</a></code> call itself is left to user handler.</li>
</ul>
</li>
</ul>
</li>
<li>Awaiting socket events (status):<ul>
<li>Note that this is both a fundamental building block making much of the above work and simultaneously best to avoid using directly. In particular, boost.asio is (subjectively speaking) a way to write a cleaner event loop, and "Asynchronous operations" above allow Flow-protocol use with boost.asio proactors.</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a496b760adb19356b4aee9a17ca13b523" title="Adds the given socket to the set of sockets we want to know are &quot;ready&quot; by the definition of the give...">Event_set::add_wanted_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#ac3bd92001ec9ca3623a0e84a50043bb9" title="Opposite of add_wanted_socket().">Event_set::remove_wanted_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a6e47fc394c09acf4d100a640e090a7aa" title="Efficiently exchanges the current set of sockets we want to know are &quot;ready&quot; by the definiton of the ...">Event_set::swap_wanted_sockets()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a86ddd6fb8874d85869157bae2ffda69b" title="Identical to swap_wanted_sockets(&amp;sockets, ev_type, err_code), where originally sockets is empty and ...">Event_set::clear_wanted_sockets()</a>, and related: Specify the precise socket(s) for which to check on particular status; and the status(es) for which to wait (e.g., Readable, Writable, Acceptable).<ul>
<li>Equivalent (<code>select()</code>): <code>FD_SET()</code>, <code>FD_CLR()</code>, <code>FD_ZERO()</code>, etc.</li>
<li>Equivalent (<code>poll()</code>): The input events array.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a>: Synchronous I/O multiplexing, with indefinite blocking or finite timeout blocking.<ul>
<li>Equivalent: <code>select()</code> with null timeout (indefinite) or non-null, non-zero timeout (finite).</li>
<li>Equivalent: <code>poll()</code> with -1 timeout (indefinite) or positive timeout (finite).</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a412214de6a4f3a1ff1e86ddb1975f47b" title="Checks for all previously described events that currently hold, saves them for retrieval via emit_res...">Event_set::poll()</a>: Non-blocking I/O multiplexing, with an instant check for the socket status(es) of interest.<ul>
<li>Equivalent: <code>select()</code> with non-null, zero timeout.</li>
<li>Equivalent: <code>poll()</code> with 0 timeout.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>: Asynchronous I/O multiplixing, like sync_wait() but waits in background and executes user-provided callback from an unspecified thread. (A typical callback might set a <code>future</code> result; <code>post(io_context&amp;)</code> a task to some boost.asio event loop; perhaps set a flag that is periodically checked by some user thread; or send a byte over some quick IPC mechanism like a POSIX domain socket or loopback UDP socket &ndash; or even a condition variable.)<ul>
<li>Equivalents: none in POSIX, that I know of. Windows "overlapped" async I/O sounds vaguely like a distant cousin. boost.asio <code>tcp::socket::async_*</code> (<code>async_wait()</code> if relevant) can simulate it also, but that's like using a modern PC to emulate an old graphing calculator... it's only conceivably useful if you need to work with some old-school 3rd party I/O library perhaps.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Thread safety</h3>
<p >See <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> thread safety notes.</p>
<p >The one exception to the "concurrent write access to one Node is thread-safe without added locking" is for <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a>. See doc headers for <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> for more.</p>
<h3>Thread safety of destructor</h3>
<p >See <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a> thready safety notes. Note, in particular, however, that as of this writing you may <em>not</em> let <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> destruct if there are outstanding <code>{Node|Server|Peer}_socket::async_*()</code> operations. The ability to early-destruct during <code>sync_*()</code> does not extend to <code>async_*()</code>.</p>
<dl class="section see"><dt>See also</dt><dd>boost.asio doc: <a href="https://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html">https://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html</a>. </dd>
<dd>
Superclass <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">net_flow::Node</a>, companion classes <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">asio::Server_socket</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000058">Todo:</a></b></dt><dd>To enable reactor-style <code>async_*()</code> operations, meaning waiting for readability/writability/etc. but <em>not</em> performing the actual operation before calling the user handler, we provide a <code>nullptr_t</code>-style interface; like newer boost.asio versions we should deprecate this in favor of simpler <code>async_wait()</code> APIs. This would apply to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">net_flow::asio::Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">net_flow::asio::Server_socket</a> APIs. Similarly consider doing this for the <code>sync_*()</code> operations in the non-<code>asio</code> superclasses <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a>. Note that <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a> already exist; they are powerful but a bit complex to use in these simple situations. Hence the following hypothetical wrappers would be welcome replacements for the deprecated <code>nullptr_t</code> and "reactor-style" APIs in these classes: <code>net_flow::Peer_socket::sync_wait(Event_set::Event_type)</code>, <code>net_flow::asio::Peer_socket::async_wait(Event_set::Event_type)</code>, <code>net_flow::Server_socket::sync_wait()</code>, <code>net_flow::Server_socket::async_wait()</code>. (Timeout-arg versions would be desired also, as they exist now.)</dd></dl>
<p >The decision to make <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> thread-unsafe, by refusing to put locking around internal uses of <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a5b688a4071b8ad58a776de8d3816b757" title="See async_task_engine().">m_target_task_engine</a> &ndash; and in contrast to the rest of the main classes, which are generally thread-safe in this sense &ndash; was taken for the following reasons.</p><ol type="1">
<li>Less mandatory locking = avoids potential performance loss.</li>
<li>Realistically, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> is not commonly used; and if it <em>is</em> used, it's tough to contrive a situation where one needs to call it <em>while</em> other threads are carrying on async operations &ndash; so potential performance loss would be to provide a guarantee that wouldn't be very useful.</li>
<li>Furthermore, it seems wrong to encourage wildly changing around the service throughout the socket's life. Just don't.</li>
</ol>
<p >There are counter-arguments.</p><ol type="1">
<li>Saying <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> is safe for concurrent access is easier and cleaner than saying that EXCEPT certain methods.<ul>
<li>Well, that's a shame, but it's only a comment ultimately.</li>
</ul>
</li>
<li>If one <em>wanted</em> to use <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> concurrently with the methods against which it is thread-unsafe, they couldn't: async operations would require access to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> during their background work, and there's no good way to let user lock around those parts. In other words, we're not merely leaving locking to user; no user locking solution could possibly fully work.<ul>
<li>That's a true concern, but on balance it is defeated by reasons 2 and 3 above. (Realistically &ndash; doubt anyone would care; and don't want to encourage them to do strange stuff.)</li>
</ul>
</li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000059">Todo:</a></b></dt><dd>The <code>sync_*()</code> early-destruction functionality explained in "Thread safety of destructor" above could be extended to <code>async_*()</code>. This is not a huge deal but would be nice for consistency. Not allowing it currently is really a result of internal implementation concerns (it is easier to not account for this corner case). Alternatively, maybe we should go the other way and not support the somewhat-weird corner case in <code>sync_*()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00234">234</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a62307823b2aa4db4f6de5c0245461652" name="a62307823b2aa4db4f6de5c0245461652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62307823b2aa4db4f6de5c0245461652">&#9670;&nbsp;</a></span>Handler_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">flow::net_flow::asio::Node::Handler_func</a> =  <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void (const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a3ee868ebd8acd1788a5bed8cf66a349e">Peer_socket::Ptr</a> new_sock)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for the <code>Task_engine</code>-compatible connect <code>Handler</code> concrete type for class-internal code. </p>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00462">462</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7db28ab33b1a9afcdcd1884e08f33bee" name="a7db28ab33b1a9afcdcd1884e08f33bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db28ab33b1a9afcdcd1884e08f33bee">&#9670;&nbsp;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::asio::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *&#160;</td>
          <td class="paramname"><em>target_async_task_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *&#160;</td>
          <td class="paramname"><em>net_env_sim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>. </p>
<p >All docs from <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node</a> super-constructor apply.</p>
<p >The difference is you may supply a <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>. More details below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node()</a>. </td></tr>
    <tr><td class="paramname">target_async_task_engine</td><td>Initial value for <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>. For the effect this has see <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> doc header. </td></tr>
    <tr><td class="paramname">low_lvl_endpoint</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node()</a>. </td></tr>
    <tr><td class="paramname">net_env_sim</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">net_flow::Node::Node()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8cpp_source.html#l00029">29</a> of file <a class="el" href="asio_2node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a97d21b9a18651cd234589f3b0b6d2971" name="a97d21b9a18651cd234589f3b0b6d2971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d21b9a18651cd234589f3b0b6d2971">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Handler &amp;&#160;</td>
          <td class="paramname"><em>on_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The boost.asio asynchronous version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>, performing any necessary wait and connection in the background, and queueing the user-provided callback on the given boost.asio <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but instead of returning a connecting socket immediately, it returns and asycnhronously waits until the initial handshake either succeeds or fails, and then invokes the given callback (in manner equivalent to boost.asio <code>post(Task_engine&amp;)</code>), passing to it the connected socket or null, respectively, along with a success <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> or otherwise, respectively. Additionally, you can specify a timeout; not completing the connection by that time is a specific <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a>.</p>
<p >See subtleties about connect timeouts in <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a> doc header.</p>
<p >The following are the possible outcomes, in ALL cases ending with an <code>on_result()</code> invocation <code>post()</code>ed onto <code>Task_engine* <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a></code> as follows: <code>on_result(const Error_code&amp; err_code, asio::Peer_socket::Ptr)</code>, with the 2 args determined as follows.</p><ol type="1">
<li>Connection succeeds before the given timeout expires (or succeeds, if no timeout given). Socket is at least Writable at time of return. The new socket and a success code are passed to callback.</li>
<li>Connection fails before the given timeout expires (or fails, if no timeout given). null is passed in, and a non-success <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> is set to reason for connection failure and passed in. (Note that a built-in handshake timeout &ndash; NOT the given user timeout, if any &ndash; falls under this category.) <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>A user timeout is given, and the connection does not succeed before it expires. Reported similarly to 2, with specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. (Rationale: consistent with <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a> behavior.)</li>
</ol>
<p >On success, the <code><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a3ee868ebd8acd1788a5bed8cf66a349e" title="Short-hand for shared_ptr to Peer_socket.">asio::Peer_socket::Ptr</a> sock</code> passed to <code>on_result()</code> will have <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> == N-&gt;<a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a></code>, where N is the current <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>. You can overwrite it subsequently if desired.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<p >Corner case: <code>*this</code> <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> must exist throughout the async op, including when <code>on_result()</code> is actually executed in the appropriate thread.</p>
<p ><a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> other than success passed to <code>on_result()</code>: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99" title="Cannot ask to connect to &quot;any&quot; IP address. Use specific IP address.">error::Code::S_CANNOT_CONNECT_TO_IP_ANY</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090" title="Other side did not complete connection handshake within the allowed time; perhaps no one is listening...">error::Code::S_CONN_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aa220d89e1d0e34bab02ed2fc7512be9b" title="Other side refused connection.">error::Code::S_CONN_REFUSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4" title="Other side reset an established connection.">error::Code::S_CONN_RESET_BY_OTHER_SIDE</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5d57c6a6029d7c6a9e5442ac72ac7a6b" title="Node shutting down.">error::Code::S_NODE_SHUTTING_DOWN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Handler</td><td>A type such that if <code>Handler h</code>, then a function equivalent to <code>{ h(err_code, sock); }</code> can be <code>post()</code>ed onto an <code>Task_engine</code>, with <code>const Error_code&amp; err_code</code> and <code><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a3ee868ebd8acd1788a5bed8cf66a349e" title="Short-hand for shared_ptr to Peer_socket.">asio::Peer_socket::Ptr</a> sock</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">on_result</td><td>Callback whose invocation as explained above to add to <code>*async_task_engine()</code> as if by <code>post()</code>. Note: Use <code>bind_executor(S, F)</code> to bind your handler to the <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> <code>S</code>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and invoking <code>on_result()</code> with a timeout error code. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait &ndash; however, not really, as there is a built-in connection timeout that will expire. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00916">916</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">async_connect_impl()</a>, <a class="el" href="asio_2node_8hpp_source.html#l00966">handler_func()</a>, and <a class="el" href="node_8hpp_source.html#l01400">flow::net_flow::Node::S_DEFAULT_CONN_METADATA</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a97d21b9a18651cd234589f3b0b6d2971_cgraph.svg" width="986" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7ee695d173c035d106ea7a9d078de3b9" name="a7ee695d173c035d106ea7a9d078de3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee695d173c035d106ea7a9d078de3b9">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Handler &amp;&#160;</td>
          <td class="paramname"><em>on_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>async_connect(to, on_result, duration::max(), opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a> with no user timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">on_result</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00930">930</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">async_connect_impl()</a>, <a class="el" href="asio_2node_8hpp_source.html#l00966">handler_func()</a>, and <a class="el" href="node_8hpp_source.html#l01400">flow::net_flow::Node::S_DEFAULT_CONN_METADATA</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a7ee695d173c035d106ea7a9d078de3b9_cgraph.svg" width="986" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aecac8b38cd35267b1af57e2443a55ea0" name="aecac8b38cd35267b1af57e2443a55ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecac8b38cd35267b1af57e2443a55ea0">&#9670;&nbsp;</a></span>async_connect_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_connect_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">Handler_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation core of <code>async_connect*()</code> that gets rid of templated or missing arguments thereof. </p>
<p >E.g., the API would wrap this and supply a Fine_duration instead of generic <code>duration</code>; and supply <code>Fine_duration::max()</code> if user omitted the timeout argument; and convert a generic function object into a concrete <code><a class="el" href="classflow_1_1Function.html">Function</a>&lt;&gt;</code> object. Code bloat and possible circular definition issues are among the reasons for this "de-templating" pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>See the public <code>async_connect(timeout)</code>. <code>"duration&lt;Rep, Period&gt;::max()"</code> maps to the value <code>Fine_duration::max()</code> for this argument. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">on_result</td><td><code>handler_func(on_result)</code>, where <code>on_result</code> is the user's <code>async_*()</code> method arg. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">171</a> of file <a class="el" href="asio_2peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8cpp_source.html#l00040">async_task_engine()</a>, <a class="el" href="asio_2peer__socket_8cpp_source.html#l00152">flow::net_flow::asio::Peer_socket::cast()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03907">flow::net_flow::Node::connect_with_metadata()</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">flow::net_flow::Peer_socket::S_CLOSED</a>, and <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c">flow::net_flow::error::S_WAIT_USER_TIMEOUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8hpp_source.html#l00916">async_connect()</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00943">async_connect_with_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_aecac8b38cd35267b1af57e2443a55ea0_cgraph.svg" width="790" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_aecac8b38cd35267b1af57e2443a55ea0_icgraph.svg" width="383" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5352db9d04c9d1e87b0cae848d0a5a90" name="a5352db9d04c9d1e87b0cae848d0a5a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5352db9d04c9d1e87b0cae848d0a5a90">&#9670;&nbsp;</a></span>async_connect_with_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Handler &amp;&#160;</td>
          <td class="paramname"><em>on_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>async_connect_with_metadata(to, on_result, duration::max(),
serialized_metadata, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a> with no user timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">on_result</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#af8ae97d499f6de21140b89218e52fc4c" title="A combination of async_connect() and connect_with_metadata() (asynchronously blocking connect,...">async_connect_with_metadata()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00955">955</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">async_connect_impl()</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00966">handler_func()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a5352db9d04c9d1e87b0cae848d0a5a90_cgraph.svg" width="986" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af8ae97d499f6de21140b89218e52fc4c" name="af8ae97d499f6de21140b89218e52fc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ae97d499f6de21140b89218e52fc4c">&#9670;&nbsp;</a></span>async_connect_with_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Handler &amp;&#160;</td>
          <td class="paramname"><em>on_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (asynchronously blocking connect, with supplied metadata). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">Period</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">Handler</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">on_result</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00943">943</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">async_connect_impl()</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00966">handler_func()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_af8ae97d499f6de21140b89218e52fc4c_cgraph.svg" width="986" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0cf22e56b3c091645154719eeb49ff4a" name="a0cf22e56b3c091645154719eeb49ff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf22e56b3c091645154719eeb49ff4a">&#9670;&nbsp;</a></span>async_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket , typename Base_socket , typename Non_blocking_func_ret_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::async_op </td>
          <td>(</td>
          <td class="paramtype">typename Socket::Ptr&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1Function.html">Function</a>&lt; Non_blocking_func_ret_type(<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>non_blocking_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Non_blocking_func_ret_type&#160;</td>
          <td class="paramname"><em>would_block_ret_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a>&#160;</td>
          <td class="paramname"><em>ev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;, Non_blocking_func_ret_type)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of core asynchronous transfer methods, namely <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a33adc635f29071b10ea59802405d9b6c" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a98186f8257f1f7b49dbbbc13c0dda7fe" title="boost.asio-style asynchronous version that essentially performs non-nullptr_t net_flow::Peer_socket::...">asio::Peer_socket::async_receive()</a>, and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a8f374618b5d754321ac288cd6f1f50ea" title="boost.asio-style asynchronous version that essentially performs net_flow::Server_socket::sync_accept(...">asio::Server_socket::async_accept()</a>, once the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> has been obtain from socket in any one of those methods. </p>
<p >It is inspired by design of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae" title="Implementation of core blocking transfer methods, namely Peer_socket::sync_send(),...">net_flow::Node::sync_op()</a>.</p>
<p >Note the precise nature of <code>on_result</code> (see below).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Socket</td><td>Underlying object of the transfer operation (<a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">asio::Server_socket</a>). </td></tr>
    <tr><td class="paramname">Base_socket</td><td>Superclass of <code>Socket</code>. </td></tr>
    <tr><td class="paramname">Non_blocking_func_ret_type</td><td>The return type of the calling transfer operation (<code>size_t</code> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a3ee868ebd8acd1788a5bed8cf66a349e" title="Short-hand for shared_ptr to Peer_socket.">asio::Peer_socket::Ptr</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket on which user called <code>async_*()</code>. </td></tr>
    <tr><td class="paramname">non_blocking_func</td><td>When this method believes it should attempt a non-blocking transfer op, it will execute <code>non_blocking_func(&amp;err_code)</code> with some <code>Error_code err_code</code> existing. If <code>non_blocking_func.empty()</code>, do not call <code>non_blocking_func()</code> &ndash; invoke <code>on_result()</code> indicating no error so far, and let them do actual operation, if they want; we just tell them it should be ready for them. This is known as reactor pattern mode. Otherwise, do the operation and then invoke <code>on_result()</code> with the resulting error code, possibly success. This is the proactor pattern mode and arguably more typical. </td></tr>
    <tr><td class="paramname">would_block_ret_val</td><td>The value that <code>non_blocking_func()</code> returns to indicate it was unable to perform the non-blocking operation (i.e., no data/sockets available). </td></tr>
    <tr><td class="paramname">ev_type</td><td>Event type applicable to the type of operation this is. See <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71" title="Type of event or condition of interest supported by class Event_set.">Event_set::Event_type</a> doc header. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <code>max_wait</code> argument on the originating <code>async_*()</code> method. This is absolute timeout time point derived from it; zero-valued if no timeout. </td></tr>
    <tr><td class="paramname">on_result</td><td>A function that will properly <code>post()</code> the original <code>on_result()</code> from the originating <code>async_*()</code> method onto <code>*async_task_engine()</code>. This must be done carefully, preserving any associated executor of that original <code>on_result</code> handler. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00581">581</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8hpp_source.html#l00581">async_op()</a>, <a class="el" href="event__set_8cpp_source.html#l00879">flow::net_flow::Node::event_set_create()</a>, <a class="el" href="error_2error_8hpp_source.html#l00202">FLOW_ERROR_EMIT_ERROR</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="log_8cpp_source.html#l00217">flow::log::Log_context::get_logger()</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5">flow::net_flow::error::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c">flow::net_flow::error::S_WAIT_USER_TIMEOUT</a>, <a class="el" href="sched__task_8hpp_source.html#l00245">flow::util::schedule_task_at()</a>, and <a class="el" href="sched__task_8cpp_source.html#l00026">flow::util::scheduled_task_cancel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8hpp_source.html#l00581">async_op()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a0cf22e56b3c091645154719eeb49ff4a_cgraph.svg" width="696" height="303"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a0cf22e56b3c091645154719eeb49ff4a_icgraph.svg" width="139" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a778ffa52a73f455142da9497ca10734d" name="a778ffa52a73f455142da9497ca10734d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778ffa52a73f455142da9497ca10734d">&#9670;&nbsp;</a></span>async_task_engine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> * flow::net_flow::asio::Node::async_task_engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer (possibly null) for the <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a> used by any coming async I/O calls and inherited by any subsequently generated <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> objects. </p>
<p >One, this is used by <code>Node::async_*()</code> I/O calls, namely <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">Node::async_connect()</a> and all its variants, both synchronously and during the async phases of such calls, whenever placing a user-supplied handler routine onto an <code>Task_engine</code>. Whatever <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> returns at that time is the <code>Task_engine</code> used.</p>
<p >Two, when <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> creates <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a>, or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> creates <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a>, at that moment this is used. (Recall: <code>[a]<a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a></code> and variants will all call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> internally.) Hence, the initial value returned by <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#a1c63aaece6a9b056688a35405f064c70" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async_*() I/O calls.">Peer_socket::async_task_engine()</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html#a88c5b9b8fee3429f28d9f1dfbe1359c2" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">Server_socket::async_task_engine()</a> is thus inherited from the factory <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>'s <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> result.</p>
<h3>Thread safety (operating on a given <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a>)</h3>
<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> is the only way to change the returned value, upon <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> construction.</li>
<li>It is not safe to call <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> at the same time as <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>.</li>
<li>Define "any Node async op" as <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">Node::async_connect()</a> and all its variants, including actions it takes in the background (asynchronously).<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> must return the same value &ndash; and <em>not</em> null &ndash; throughout "any Node async op."</li>
</ul>
</li>
<li>Define "any Node async inheriting op" as any non-blocking <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">Node</a> method that creates a <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> (namely, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a>, and any variants).<ul>
<li>Note that <code>[a]<a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a></code> (and variants) each invokes this non-blocking <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> at the start.</li>
<li><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> must return the same value &ndash; possibly null &ndash; throughout "any Node async inheriting
      op."</li>
</ul>
</li>
<li>Put simply, a null <code>Task_engine</code> can be inherited by a generated socket, but a null cannot be used when performing an async op. Furthermore, <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> is unsafe through any of those and through <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> itself.</li>
</ul>
<p >Informal tip: Typically you'd never call <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a>, hence there is no problem. If you DO need to call it, even then normally it's easy to ensure one does this before any actual async calls are made. Trouble only begins if one calls <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0e6b29f0ae35a832b0c3c75cf0b577ae" title="Overwrites the value to be returned by next async_task_engine().">set_async_task_engine()</a> "in the middle" of operating the socket. There is no way to add outside locking to make that work, either, due to async "tails" of some calls.</p>
<dl class="section return"><dt>Returns</dt><dd>Null or non-null pointer to <a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8cpp_source.html#l00040">40</a> of file <a class="el" href="asio_2node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8hpp_source.html#l00575">m_target_task_engine</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2peer__socket_8cpp_source.html#l00171">async_connect_impl()</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00966">handler_func()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a778ffa52a73f455142da9497ca10734d_icgraph.svg" width="602" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad0b99ea857df0cbbf2b26f6c84e8863a" name="ad0b99ea857df0cbbf2b26f6c84e8863a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b99ea857df0cbbf2b26f6c84e8863a">&#9670;&nbsp;</a></span>handler_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a62307823b2aa4db4f6de5c0245461652">Node::Handler_func</a> flow::net_flow::asio::Node::handler_func </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a functor that essentially performs <code>post()</code> <code>on_result</code> onto <code>*async_task_engine()</code> in a way suitable for a boost.asio-compatible async-op. </p>
<h3>Rationale</h3>
<p >See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html#aa727c33c3eeeb217d50fcd451096ded8" title="Returns a functor that essentially performs post() on_result onto *async_task_engine() in a way suita...">asio::Peer_socket::handler_func()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_result</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a97d21b9a18651cd234589f3b0b6d2971" title="The boost.asio asynchronous version of sync_connect(), performing any necessary wait and connection i...">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classflow_1_1Function.html">Function</a> to call from any context that will properly <code>post()</code> <code>on_result();</code> onto <code>*async_task_engine()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00966">966</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8cpp_source.html#l00040">async_task_engine()</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8hpp_source.html#l00916">async_connect()</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00943">async_connect_with_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_ad0b99ea857df0cbbf2b26f6c84e8863a_cgraph.svg" width="368" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_ad0b99ea857df0cbbf2b26f6c84e8863a_icgraph.svg" width="346" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a63171653725513e198b8baf60c3c1427" name="a63171653725513e198b8baf60c3c1427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63171653725513e198b8baf60c3c1427">&#9670;&nbsp;</a></span>serv_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">net_flow::Server_socket</a> * flow::net_flow::asio::Node::serv_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements superclass API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_sock_opts</td><td>See superclass API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See superclass API. </dd></dl>

<p>Reimplemented from <a class="el" href="classflow_1_1net__flow_1_1Node.html#a0a91542fce634cf6a749c71f225b105a">flow::net_flow::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="asio_2server__socket_8cpp_source.html#l00115">115</a> of file <a class="el" href="asio_2server__socket_8cpp_source.html">server_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8hpp_source.html#l00575">m_target_task_engine</a>, and <a class="el" href="asio_2server__socket_8cpp_source.html#l00052">flow::net_flow::asio::Server_socket::set_async_task_engine()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a63171653725513e198b8baf60c3c1427_cgraph.svg" width="320" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0e6b29f0ae35a832b0c3c75cf0b577ae" name="a0e6b29f0ae35a832b0c3c75cf0b577ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6b29f0ae35a832b0c3c75cf0b577ae">&#9670;&nbsp;</a></span>set_async_task_engine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::asio::Node::set_async_task_engine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a> *&#160;</td>
          <td class="paramname"><em>target_async_task_engine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites the value to be returned by next <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>. </p>
<p >See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a> doc header before using this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_async_task_engine</td><td>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asio_2node_8cpp_source.html#l00046">46</a> of file <a class="el" href="asio_2node_8cpp_source.html">node.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="asio_2node_8hpp_source.html#l00575">m_target_task_engine</a>.</p>

</div>
</div>
<a id="a13e8070f5a4e4300e0138b63694884fc" name="a13e8070f5a4e4300e0138b63694884fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e8070f5a4e4300e0138b63694884fc">&#9670;&nbsp;</a></span>sock_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">net_flow::Peer_socket</a> * flow::net_flow::asio::Node::sock_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements superclass API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>See superclass API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See superclass API. </dd></dl>

<p>Reimplemented from <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">flow::net_flow::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="asio_2peer__socket_8cpp_source.html#l00160">160</a> of file <a class="el" href="asio_2peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio_2node_8hpp_source.html#l00575">m_target_task_engine</a>, and <a class="el" href="asio_2peer__socket_8cpp_source.html#l00053">flow::net_flow::asio::Peer_socket::set_async_task_engine()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1asio_1_1Node_a13e8070f5a4e4300e0138b63694884fc_cgraph.svg" width="348" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a62cd43d29137c6c9abc7d9dd731555f9" name="a62cd43d29137c6c9abc7d9dd731555f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd43d29137c6c9abc7d9dd731555f9">&#9670;&nbsp;</a></span>Peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html">Peer_socket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">Peer_socket</a> must be able to forward to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a" title="Implementation of core asynchronous transfer methods, namely asio::Peer_socket::async_send(),...">async_op()</a>, etc. </p>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00455">455</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<a id="a2165381af6166d76afba06862c762367" name="a2165381af6166d76afba06862c762367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2165381af6166d76afba06862c762367">&#9670;&nbsp;</a></span>Server_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html">Server_socket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">Server_socket</a> must be able to forward to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a0cf22e56b3c091645154719eeb49ff4a" title="Implementation of core asynchronous transfer methods, namely asio::Peer_socket::async_send(),...">async_op()</a>, etc. </p>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00457">457</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5b688a4071b8ad58a776de8d3816b757" name="a5b688a4071b8ad58a776de8d3816b757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b688a4071b8ad58a776de8d3816b757">&#9670;&nbsp;</a></span>m_target_task_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#ac3e89a8a271b0ddc76ac2a0ce488dea4">util::Task_engine</a>* flow::net_flow::asio::Node::m_target_task_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html#a778ffa52a73f455142da9497ca10734d" title="Pointer (possibly null) for the flow::util::Task_engine used by any coming async I/O calls and inheri...">async_task_engine()</a>. </p>

<p class="definition">Definition at line <a class="el" href="asio_2node_8hpp_source.html#l00575">575</a> of file <a class="el" href="asio_2node_8hpp_source.html">node.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2node_8cpp_source.html#l00040">async_task_engine()</a>, <a class="el" href="asio_2server__socket_8cpp_source.html#l00115">serv_create()</a>, <a class="el" href="asio_2node_8cpp_source.html#l00046">set_async_task_engine()</a>, and <a class="el" href="asio_2peer__socket_8cpp_source.html#l00160">sock_create()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/asio/<a class="el" href="asio_2node_8hpp_source.html">node.hpp</a></li>
<li>net_flow/asio/<a class="el" href="asio_2node_8cpp_source.html">node.cpp</a></li>
<li>net_flow/asio/<a class="el" href="asio_2peer__socket_8cpp_source.html">peer_socket.cpp</a></li>
<li>net_flow/asio/<a class="el" href="asio_2server__socket_8cpp_source.html">server_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 20 2025 06:08:48 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
