<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: cfg/option_set.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cfb2ffb2869bbb27b7281952022eb856.html">cfg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">option_set.hpp</div></div>
</div><!--header-->
<div class="contents">
<a href="option__set_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/* Flow</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * Copyright 2023 Akamai Technologies, Inc.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> *</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> * Licensed under the Apache License, Version 2.0 (the</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> * &quot;License&quot;); you may not use this file except in</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> * compliance with the License.  You may obtain a copy</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment"> * of the License at</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"> *</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"> *</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment"> * Unless required by applicable law or agreed to in</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment"> * writing, software distributed under the License is</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment"> * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment"> * CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment"> * See the License for the specific language governing</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment"> * permissions and limitations under the License. */</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment"></span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment">/// @file</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment"></span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="preprocessor">#include &quot;<a class="code" href="cfg__fwd_8hpp.html">flow/cfg/cfg_fwd.hpp</a>&quot;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &quot;<a class="code" href="log_8hpp.html">flow/log/log.hpp</a>&quot;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &quot;flow/error/error.hpp&quot;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="preprocessor">#include &quot;<a class="code" href="detail_2cfg__fwd_8hpp.html">flow/cfg/detail/cfg_fwd.hpp</a>&quot;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &lt;boost/algorithm/string.hpp&gt;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="preprocessor">#include &lt;boost/unordered_set.hpp&gt;</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span> </div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceflow_1_1cfg.html">flow::cfg</a></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>{</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="comment">// Types.</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="comment"></span> </div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="comment">/// Un-templated base for Option_set.</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html">   33</a></span><span class="comment"></span><span class="keyword">class </span><a class="code hl_class" href="classflow_1_1cfg_1_1Option__set__base.html">Option_set_base</a></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>{</div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="comment"></span> </div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="comment">   * Internal-use type to use with Option_set::Declare_options_func callback.</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span><span class="comment">   * The user of the class need not understand this nor use it directly.</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="comment">   *</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment">   *</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment">   * The reason for the Option_set::Declare_options_func call, originally from FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="comment">   */</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">   46</a></span>  <span class="keyword">enum class</span> <a class="code hl_enumeration" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">Declare_options_func_call_type</a></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>  {<span class="comment"></span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="comment">     *</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment">     * Add option entries into Option_set::m_opts_for_parsing using Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment">     */</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>    S_FILL_PARSING_ROLE_OPT_TABLE,</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"></span> </div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment">     *</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment">     * Add option entries into Option_set::m_opts_for_help using Option_set::declare_option_for_help().</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment">     */</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>    S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE,</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment"></span> </div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment">     *</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment">     * Add option entries into an Option_set::Opt_table that shall be output to an `ostream` to print a `Value_set`&#39;s</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment">     * payload, using declare_option_for_output().</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment">     */</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>    S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE,</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span><span class="comment"></span> </div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span><span class="comment">     *</span></div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="comment">     * Compare recently parsed values in Option_set::m_iterable_values_candidate to the canonical</span></div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span><span class="comment">     * Option_set::m_values values, using Option_set::scan_parsed_option().</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment">     */</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span>    S_COMPARE_PARSED_VALS,</div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment"></span> </div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="comment">     *</span></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="comment">     * Load values in Option_set::m_values_candidate and Option_set::m_iterable_values_candidate from a</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="comment">     * ready-made `Value_set` -- as if the latter was parsed from some config source --</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment">     * using load_option_value_as_if_parsed().</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="comment">     */</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    S_LOAD_VALS_AS_IF_PARSED,</div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment"></span> </div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment">     * Internal use only through macro.  Do not use directly.</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment">     *</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment">     * Validate values stored -- perhaps manually in code, not through parsing -- in a `Value_set` structure</span></div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment">     * using the same per-individual-option validator checks as configured into Option_set::m_opts_for_parsing</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment">     * via Declare_options_func_call_type::S_FILL_PARSING_ROLE_OPT_TABLE, using validate_parsed_option().</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment">     */</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span>    S_VALIDATE_STORED_VALS</div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span>  }; <span class="comment">// enum class Declare_options_func_call_type</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span> </div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment"></span> </div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment">   *</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment">   * Loads an entry into `target_opts` which will enable the proper text to appear for that option</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment">   * in Option_set::values_to_ostream() or Option_set::log_values(): including its name, default value, current values,</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment">   * and description.</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment">   *</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span><span class="comment">   *         Type of the value inside a `Value_set` object.  It must be reasonably copyable; and it must be supported by</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment">   *         some version (including specialization(s) and overload(s)) of value_to_ostream().</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment">   *        See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment">   * @param target_opts</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment">   *        The `Opt_table` that shall be filled out for output to `ostream`.</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment">   * @param value_default</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment">   *        See Option_set::declare_option_for_help().</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment">   * @param current_value</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment">   *        Current value to show to the user.</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment">   * @param description</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment">   *        See Option_set::declare_option_for_help().</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment">   */</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b">declare_option_for_output</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, opts::options_description* target_opts,</div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>                                        <span class="keyword">const</span> Value&amp; value_default, <span class="keyword">const</span> Value&amp; current_value,</div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>                                        <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description);</div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment"></span> </div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment">   *</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment">   * Runs the validator function, with the same semantics as in declare_option_for_parsing(), for the given</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment">   * option.  If the validation passes, no-op.  If the validation fails throws exception containing (in its message)</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment">   * a user-friendly description of what failed.</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment">   *</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment">   *         Type of the value inside a `Value_set` object.  It must be reasonably copyable.</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span><span class="comment">   *        See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment">   * @param value</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment">   *        Value to validate.</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="comment">   * @param validator_func_moved</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="comment">   *        See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span><span class="comment">   * @param validator_cond_str</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="comment">   *        See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="comment">   */</span></div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43">validate_parsed_option</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, <span class="keyword">const</span> Value&amp; value,</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>                                     <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>                                     <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str);</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span> </div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="keyword">protected</span>:</div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="comment"></span> </div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment">   * Short-hand for boost.program_options config options description, each of which is used for parsing and/or</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment">   * describing (to humans) one or more config option/its value.  boost.program_options allows for a wide variety</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment">   * of features and capacities for this object type, but our goal is to use it for our specific and more</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment">   * constrained config context, and hence we use this type in more specific/constrained ways which we describe</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment">   * here.</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment">   *</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="comment">   * We use it in our context in two primary roles; and since storage space and processor cycle are not</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span><span class="comment">   * practically affected, we tend to store separate copies of an `Opt_table` in *each* role (possibly</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span><span class="comment">   * even more than 1, as there can be sub-roles of each).</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span><span class="comment">   * The roles are:</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="comment">   *   - Parsing: Used during a parsing pass from a given config source (like a config file) solely to parse</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment">   *     values and store the resulting bits into a target `Values` and a mirroring</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">   *     `Iterable_values`.  `opts::{parse_*|store}()` and other such functions take</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment">   *     this `Opt_table` and a config source as input.  Such an `Opt_table`</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment">   *     stores a table of options; for each option storing:</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment">   *     - Name: A string to be found in a config source like a config file.</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment">   *     - C++ type: Essentially a size in bytes plus a `&gt;&gt;` stream input operator for reading values</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="comment">   *       into the target location from the config source.</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="comment">   *     - Target location: Pointer to the actual value, within a `Values`, which to load with the parsed bits</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span><span class="comment">   *       obtained from the config source.</span></div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="comment">   *     - NOTE: There is *no* default value stores in this *parsing-role* `Opt_table`.</span></div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment">   *       We expect each target value to already contain the default before parsing begins; if the option</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="comment">   *       is not present in the particular config source, then that value remains untouched.  Moreover note that</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="comment">   *       the pre-parse value is not necessarily the user-specified default per se; it might be, for example,</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="comment">   *       the value set by the previous config source&#39;s parsing phase; or even (in the case of dynamic option</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span><span class="comment">   *       sets) in a much earlier config application.</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span><span class="comment">   *     - Note: There&#39;s no reason to store a textual description for this role, as the computer doesn&#39;t care</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span><span class="comment">   *       about human explanations when parsing.</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="comment">   *   - Output: Used in various settings to print out -- to humans -- both the semantic info and actual values of</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="comment">   *     the options maintained by an Option_set.  To use this capability of boost.program_options -- which</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span><span class="comment">   *     it intends as help text, but we can leverage it in slightly different roles also -- simply</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment">   *     output this *output-role* `Opt_table` via a stream `&lt;&lt;`.  For each option:</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span><span class="comment">   *     - Name: Same as for the *parsing-role*.</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment">   *     - Description: Textual description of the meaning/semantics of the option.</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="comment">   *       - If it&#39;s not output of help text/similar, then description might be omitted, depending on usefulness.</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span><span class="comment">   *     - C++ type: Essentially a size in bytes plus a `&lt;&lt;` stream output operator for writing values</span></div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span><span class="comment">   *       via standard stream output.</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span><span class="comment">   *     - Value: A pointer to a value to print out along with the previous name and description.</span></div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span><span class="comment">   *       boost.program_options supports printing in one 2 ways:</span></div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="comment">   *       - Via `&lt;&lt;` stream output operator.  In this case that operator needs to be (conceptually) stored too.</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment">   *       - As an explicit string.  Sometimes, for human readability, we might want to provide custom output</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="comment">   *         for certain types beyond what `&lt;&lt;` would do; for example if we store a `Fine_duration` (typically</span></div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span><span class="comment">   *         outputting which would be in nanoseconds, because it usually stores nanoseconds), it&#39;s often more</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="comment">   *         convenient to round down (if precision would not be lost) and output using coarser units like sec or</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment">   *         even minutes, etc.  In this case we would prepare this value as an `std::string` and store that;</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span><span class="comment">   *         instead of storing a value in the original type as in *parsing-role* `Opt_table`.</span></div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span><span class="comment">   *       At least these reasons exist to print this value:</span></div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment">   *       - As the *default* in a help message.  The user would glean that not specifying a value in any config</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="comment">   *         source will lead to this value being taken.</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span><span class="comment">   *       - As the *current* stored value after the last round of parsing.  If it is also desired to output</span></div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="comment">   *         a default at the same time, it can be added into the description.</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span><span class="comment">   */</span></div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">  216</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a> = opts::options_description;</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span> </div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment"></span> </div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span><span class="comment">   * Returns a function that wraps a `Value`-&gt;Boolean validator function, as passed to</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span><span class="comment">   * declare_option_for_parsing() and others, in code that will throw an exception with a human-useful message</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span><span class="comment">   * if that validator function indicates the `Value` passed to it is invalid; else will no-op.</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span><span class="comment">   *</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="comment">   *         See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment">   *        See Option_set::declare_option_for_parsing().  For nice human-readable message formation.</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment">   * @param validator_func_moved</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment">   *        See Option_set::declare_option_for_parsing().</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment">   * @param validator_cond_str</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment">   *        See Option_set::declare_option_for_parsing().  For nice human-readable message formation.</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span><span class="comment">   */</span></div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>  <span class="keyword">static</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;void (<span class="keyword">const</span> Value&amp; val)&gt; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">throw_on_invalid_func</a></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>                                             (<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name,</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>                                              <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>                                              <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str);</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>  <span class="comment">/* @return Function that acts as described above.</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="comment">   * @todo @return just above breaks Doxygen for some reason (bug).  Work around it or something. */</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>}; <span class="comment">// class Option_set_base</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="comment"></span> </div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span><span class="comment">/**</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span><span class="comment"> * The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a given</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="comment"> * simple config-holding object, of the type `Value_set`, a template argument to this class template.</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="comment"> *</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="comment"> * ### General use pattern ###</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment"> * - First, create your `Value_set` (named however you want, of course) `struct`.  The values stored therein must</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment"> *   be reasonably deep-copyable; must have standard-stream `&lt;&lt;` and `&gt;&gt;` operators; and must reasonably implement</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="comment"> *   `==` comparison.  `Value_set` itself must be copy-constructible and copy-assignable in a reasonable way.</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span><span class="comment"> *   Lastly, and very importantly, the no-arg ctor `Value_set()` must initialize all configured</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span><span class="comment"> *   members to reasonable defaults: it is not possible to declare options as &quot;required.&quot;</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span><span class="comment"> *   - If you use the optional features mutable_values_copy(), #Mutable_values_ptr, and/or #Values_ptr, then, also,</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span><span class="comment"> *     `Value_set` shall derive from util::Shared_ptr_alias_holder.  (Don&#39;t worry: it&#39;s easy.)</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span><span class="comment"> * - Next, write a function fitting Option_set::Declare_options_func, which shall be used (when passed into</span></div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span><span class="comment"> *   Option_set ctor) by Option_set to enable parsing (and human-readable help/other output to streams) of various</span></div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="comment"> *   members of `Value_set`, which officially turns them into *options*.</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span><span class="comment"> *   - This is documented more fully in the `Option_set()` ctor doc header; but essentially this function</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span><span class="comment"> *     shall use FLOW_CFG_OPTION_SET_DECLARE_OPTION() macro to enumerate every parseable member, turning it into</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment"> *     an option *managed by* the containing Option_set.</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="comment"> *   - (The data members that thus become options need not be direct members of `Value_set`.  Composition via directly</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment"> *     nested, and nested via pointer, `struct`s is supported.  See FLOW_CFG_OPTION_SET_DECLARE_OPTION() doc header for</span></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment"> *     details.)</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment"> * - Finally, create an instance of `Option_set&lt;Value_set&gt;`, and use parse_config_file() (or any other `parse_*()`</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span><span class="comment"> *   methods that might exist) to parse things at will.</span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="comment"> *   - &quot;At rest,&quot; Option_set is in CANONICAL state.  values_candidate() returns null, and values() is the *canonical*</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span><span class="comment"> *     (official, current) set of parsed config; originally it equals `Value_set()`.</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span><span class="comment"> *     It returns a reference to immutable internally stored `Value_set`.</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span><span class="comment"> *   - Invoking parse_config_file() (or any other `parse_*()`) either enters or continues PARSING state.</span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span><span class="comment"> *     In this state `*values_candidate()` starts equal to values(); and is then potentially modified by each</span></div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment"> *     `parse_*()` operation.</span></div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment"> *   - Call `canonicalize_candidate()` to set values() to `*values_candidate()`, thus canonicalizing the parsed</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span><span class="comment"> *     values, and return to CANONICAL state.</span></div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment"> *     - Alternatively, if a `parse_*()` or `validate_values*()` fails, or any manual check of values_candidate() fails,</span></div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment"> *       one might want to instead call reject_candidate() to discard any parse attempts and return to CANONICAL state.</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment"> *     - See notes in Validation below.</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment"> *   - If one desires to model multiple dynamic updates, meaning calling canonicalize_candidate() multiple times --</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment"> *     once for each update -- it may be desirable to use parse_direct_values() to load a baseline state at entry</span></div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment"> *     into PARSING state, and only then `parse_*()` from actual config source(s).</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment"> *     (It would be trivial to save a previous state using values() to be that baseline state.)</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="comment"> *</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="comment"> * A typical expected scenario -- although more complex ones can be devised -- and one assumed by</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span><span class="comment"> * Config_manager -- is to have 2 `struct`s of config; one for static and one for dynamic config, the latter being</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span><span class="comment"> * something that can be parsed-into repeatedly over time, as new config is delivered to the process.</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span><span class="comment"> * In that case one would use one `Option_set&lt;Static_value_set&gt;` and one `Option_set&lt;Dynamic_value_set&gt;` and invoke</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment"> * their parsing at appropriate times (1+ times for the latter, once for the former).  It is also possible to</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="comment"> * allow, on startup, to read both sets from the same config source(s) (e.g., a static config file); then read</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment"> * the dynamic `Option_set&lt;&gt;` from the dynamic config source(s) once (for any initial dynamic values overriding</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment"> * the initial baseline static ones); and after that accept any further updates of the latter config source(s), as</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment"> * they come in (e.g., if the dynamic config file is modified externally).  The `allow_unregistered` argument</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="comment"> * to `parse_*()` allows 2+ `Option_set&lt;&gt;`s to share one config file.</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"> *</span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment"> * ### Validation ###</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="comment"> * Option validation *mandatorily* occurs in the following places.</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment"> *   - When `parse_*()` is invoked, the config source (e.g., config file in case of parse_config_file()) may have</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment"> *     plainly illegal contents, such as an option expecting a number but receiving alphanumerics, or a syntax</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment"> *     error.  This will cause `parse_*()` to indicate error.</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span><span class="comment"> *   - If that passes, the individual-option-validator checks are performed *on values in fact read+parsed*.</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span><span class="comment"> *     For example, a duration option may need to be non-negative, or a</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span><span class="comment"> *     value in bytes must be a multiple of 4KiB.  To provide any such additional</span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span><span class="comment"> *     *per-option*, *independent-of-other-options* conditions, use the `ARG_bool_validate_expr` argument to</span></div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment"> *     FLOW_CFG_OPTION_SET_DECLARE_OPTION() when declaring the options (see above).  This is somewhat reminiscent</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment"> *     of writing `assert()` conditions.  If a validator fails, `parse*()` will transparently fail, not dissimilarly</span></div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span><span class="comment"> *     to what happens if some line is straight-up illegal (previous bullet point).</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment"> *</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="comment"> * However this is likely insufficient validation in at least some use cases.  You should also concern yourself with</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span><span class="comment"> * the following.</span></div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span><span class="comment"> *   - Note that parse_config_file() (and any similar `parse_*()` that scans+parses strings) will *only* validate</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="comment"> *     (via individual-option-validator checks) values actually present in the config source.</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span><span class="comment"> *     Defaults (from `Value_set()`) or baseline values (from parse_direct_values()) are not *mandatorily* checked.</span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span><span class="comment"> *     If one performs no additional validation calls, it will not be possible to know of bad defaults or baseline</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment"> *     values, and one can canonicalize_candidate() invalid values.  This is allowed, for flexibility, but in most cases</span></div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment"> *     one will want to reject_candidate() instead.  The following abilities are provided to resolve this.</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment"> *     For flexibility we do not here enforce any particular approach.  It is your reponsibility to trace the</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment"> *     possibilities.  (For example Config_manager chooses certain conventions as it marshals various `Option_set`s.)</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment"> *     - To validate defaults (default-constructed `Value_set`) themselves, call `validate_values(bool*)` overload --</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment"> *       just after construction.</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment"> *       (Informally: This is a stringent convention.  It is possible to instead establish the convention wherein</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="comment"> *       intentionally invalid defaults are allowed, to force that a config source must specify such values explicitly.</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span><span class="comment"> *       In that case: one would not call validate_values() this way but rather... see next bullet point.)</span></div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment"> *     - To validate any defaults and/or baseline values that &quot;got through&quot; in PARSING mode, by virtue of not being</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="comment"> *       present in a parsed config source (e.g., file) so far, call validate_values_candidate().</span></div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span><span class="comment"> *       (Informally: Typically you will not want to canonicalize_candidate() when the values_candidate() might have</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span><span class="comment"> *       invalid values.  So, just ahead of the decision to canonicalize_candidate()</span></div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span><span class="comment"> *       or reject_candidate(), call validate_values_candidate().  If it indicates failure, probably you&#39;ll want</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="comment"> *       to reject_candidate().)</span></div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span><span class="comment"> *     - Lastly: parse_direct_values() intentionally does not validate the supplied `Value_set`.</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment"> *       You are free to call validate_values_candidate() right after it to detect problems, if it suits your needs.</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="comment"> *       (Informally: Whether this is necessary really depends on your setup, including the source of the values</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span><span class="comment"> *       applied -- which may have already been validated -- and whether you&#39;re going to be calling</span></div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span><span class="comment"> *       validate_values_candidate() before canonicalizing anyway.)</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment"> *   - You may also need a validation for inner consistency; e.g., if one setting must not exceed another setting.</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="comment"> *     Do this yourself: Before calling canonicalize_candidate() check whatever is necessary in `*values_candidate()`.</span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment"> *     If you find problems call reject_candidate() instead.</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment"> *     - Informal recommendation: It is better to not leave individual-option checking to this step; make use</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span><span class="comment"> *       of FLOW_CFG_OPTION_SET_DECLARE_OPTION() to its fullest.  This will result in more maintainable, reusable code</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span><span class="comment"> *       and likely improve the experience (e.g., the individual validator machinery will always print the value of</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment"> *       the offending option and, `assert()`-style, a string representation of the condition that failed).</span></div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span><span class="comment"> *</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span><span class="comment"> * Lastly, and optionally, you may validate a given `Value_set` object &quot;offline,&quot; meaning outside of any</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="comment"> * `Option_set&lt;Value_set&gt;` -- which need not even exist or ever parse anything; only the function fitting</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="comment"> * Option_set::Declare_options_func must exist, as-if for `Option_set` ctor.  Simply call a validate_values()</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span><span class="comment"> * API on your object; it will yield failure given at least 1 invalid value.  This can be useful, at least, when</span></div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment"> * setting values manually through assignment (perhaps in a simpler program not requiring external config; or when</span></div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span><span class="comment"> * unit-testing); just because you aren&#39;t parsing it through Option_set does not mean you don&#39;t want to sanity-check it</span></div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment"> * for validity.</span></div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment"> *</span></div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span><span class="comment"> * ### Change detection ###</span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment"> * For dynamic options, it may be necessary to detect whether the set of option values has changed or even individual</span></div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment"> * changes (and then, in many cases, invoke config-changed hooks).  Option_set is designed with this in mind, as it</span></div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span><span class="comment"> * is able to provide such checks *without* forcing the user to write an `operator==(Value_set, Value_set)` (a laborious</span></div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment"> * and error-prone procedure).</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment"> *</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span><span class="comment"> * Change detection occurs at the canonicalize_candidate() stage.  That is, once you&#39;ve parsed all the different config</span></div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="comment"> * sources in a parse pass, canonicalize_candidate() will scan for changes.  As of this writing that method will</span></div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span><span class="comment"> * optionally return a Boolean indicating whether at least one value changed vs. the canonical values().  It is possible</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment"> * to add an API for detecting individual option changes.  As I write this, it doesn&#39;t exist, but it may be added after</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment"> * I write this.  Option_set is eminently capable of it; and in fact it at least logs an INFO message for each</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span><span class="comment"> * option that has changed, at canonicalize_candidate() time.</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span><span class="comment"> *</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="comment"> * ### Input/output ###</span></div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment"> * Input of configurable values in `Value_set` is required to be able to parse the corresponding options (parse_*()).</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment"> * Output thereof is required in:</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment"> *   - help_to_ostream(), log_help(): A usage/help message describing all options, and their default values,</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment"> *     in human-friendly form.</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span><span class="comment"> *   - values_to_ostream(), log_values(): A message describing all options, their default values, and their *current*</span></div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment"> *     (presumably parsed at some point) values, is printed (in human-friendly form).  You can use this to output</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment"> *     any `Value_set`, but if none is specified, it will log the canonical one (values()).</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="comment"> *</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment"> * For input (parsing), every configurable value in `Value_set` must have an `istream&gt;&gt;` operator.</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment"> *</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span><span class="comment"> * For output (in help and current-values output), every such value must have an `ostream&lt;&lt;` operator.</span></div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span><span class="comment"> * In addition, it is sometimes desirable to further massage output in config help/current-values output but not</span></div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span><span class="comment"> * in a general `ostream&lt;&lt;` operator for that type.  (E.g., you would not want to, or be able to usually, override</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="comment"> * stream output for `std::string` or `chrono::duration`.)  To do this, provide a specialization or overload of</span></div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="comment"> * the free function `cfg::value_to_ostream&lt;Value_set&gt;()`.  Its generic implementation simply forwards to</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment"> * `ostream&lt;&lt;`, but you can do something different.  As of this writing we already provide an overload for</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment"> * `cfg::value_to_ostream&lt;chrono::duration&lt;...&gt;&gt;`, which will automatically print the duration (which is typically</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment"> * stored in nanoseconds) in the coarsest possible units that would lose no precision (e.g., 60billion nanoseconds =&gt;</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment"> * &quot;1 minute&quot;).</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment"> *</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment"> * ### Recommended conventions ###</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment"> * Firstly, it is recommended to store all durations in your `Value_set` as util::Fine_duration instead of using</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment"> * coarser units like `chrono::seconds()` or even `chrono::milliseconds()`.  This tends to lead to more consistent</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment"> * and maintainable code, in the author&#39;s (ygoldfel) opinion, as util::Fine_duration *can* store durations expressed</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment"> * in essentially any units, without losing precision; *does* use the same underlying storage type -- `int64_t` --</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment"> * and hence presents no performance or overflow difficulties (usually); and changing the desired units of a duration</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment"> * config value is fairly common.  Simply put `Fine_duration` supports 99.99999999% of units and use cases without</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment"> * perf overhead.  *In addition*, `value_to_ostream&lt;&gt;` is overloaded in such a way as to output `Fine_duration`</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment"> * members of `Value_set` in the most convenient possible units -- automagically.  So you&#39;re in no way forcing humans</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment"> * to work with nanoseconds: you can use any units in input and in code.</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment"> *</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment"> * @note For all duration values, config sources can specify *any* units (convertible without loss of precision to</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment"> *       the specific `chrono` type); and indeed *should* specify units.  E.g., &quot;5 ms&quot; and &quot;5 milliseconds&quot; will both</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment"> *       work.  Since util::Fine_duration is in nanoseconds internally, almost any conceivable units (from &quot;hours&quot; to</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment"> *       &quot;nanoseconds&quot;) are accepted equally well as inputs in config sources.</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment"> *</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment"> * Secondly, when working with non-durations, specify units as a suffix in the member name.</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment"> *   - Exception: if it&#39;s in bytes, `_bytes` or `_b` shall be omitted.</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment"> *   - If it&#39;s in multiples of bytes, use `_kb`, `_mb`, etc., knowing that this stands for KiB (1024), MiB (1024^2),</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="comment"> *     etc.  In the rare case that actual KILObytes, etc., are needed, spell it out: `_kilob`, `_megab`, etc.</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment"> *     - I (ygoldfel) am not recommending `_kib`, etc., only because the convention in the relevant organization(s) is</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment"> *       quite strong to say KB for KiB, etc.</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="comment"> *   - If, for some reason, you must use a duration with a max resolution lower than ns, then use these suffixes:</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment"> *     `_hr`, `_min`, `_sec`, `_msec`, `_usec`, `_nsec`.  Please still use `chrono::duration`, though, even if you</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment"> *     chose something other than `Fine_duration`.  (Do not use an integer type.)</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment"> *</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment"> * @todo Add individual-option-changed detection API(s) in addition to the existing Option_set overall-value-set-changed</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment"> * detection API.  This is contingent on a use case needing it.  The existing code already detects this internally</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment"> * and logs a message for each changed option (in canonicalize_candidate()).</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment"> *</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment"> * @tparam Value_set</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment"> *         The value type stored inside `*this`, and returned by values().  Requirements on this type are at least</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment"> *         informally explained above.</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment"> */</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html">  418</a></span><span class="keyword">class </span><a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a> :</div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span>  <span class="keyword">public</span> <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set__base.html">Option_set_base</a>,</div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span>  <span class="keyword">public</span> <a class="code hl_class" href="classflow_1_1log_1_1Log__context.html">log::Log_context</a>,</div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span>  <span class="keyword">private</span> boost::noncopyable</div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span>{</div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="comment"></span> </div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="comment">   * Short-hand for the template parameter type `Value_set`.  E.g.: `Cool_option_set::Values`, where one aliased</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="comment">   * `Cool_option_set` to `Option_set&lt;Cool_value_set&gt;`.</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="comment">   */</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">  430</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> = Value_set;</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment"></span> </div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="comment">   * Short-hand for ref-counted pointer to an immutable `Value_set` (config payload storable in an Option_set).</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="comment">   *</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment">   * The name is not, say, `Const_values_ptr`, because we would expect such objects to be passed around in `const`</span></div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment">   * form most of the time, including when made accessible from within a config-holding API.</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment">   * When a mutable #Values is desired, one would typically create it from an Option_set by using mutable_values_copy().</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment">   */</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d">  439</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d">Values_ptr</a> = <span class="keyword">typename</span> Values::Const_ptr;</div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="comment"></span> </div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="comment">  /// Short-hand for ref-counted pointer to a mutable #Values (config payload storable in an Option_set).</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">  442</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">Mutable_values_ptr</a> = <span class="keyword">typename</span> Values::Ptr;</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="comment"></span> </div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="comment">   * Internal-use structure to use with #Declare_options_func callback.  The user of the class need not understand this</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="comment">   * nor use it directly.</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment">   *</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment">   *</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment">   * This `union`-y `struct` is used to pass values into `declare_option_*()`, `scan_parsed_option()`, or</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment">   * `validate_parsed_option()`.</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment">   * The `enum` specifies which part of the `union` is in effect; then each `struct` inside the `union` corresponds</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment">   * to that #Declare_options_func call purpose.</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment">   */</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">  455</a></span>  <span class="keyword">struct </span><a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a></div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span>  {</div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span>    <span class="comment">// Types.</span></div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span><span class="comment"></span> </div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="comment">    /// Short-hand for type of #m_call_type.</span></div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ad652ec52b981c9e0b571cf1463bd2e55">  460</a></span><span class="comment"></span>    <span class="keyword">using </span><a class="code hl_enumeration" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">Call_type</a> = <a class="code hl_enumeration" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">Option_set_base::Declare_options_func_call_type</a>;</div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span> </div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span>    <span class="comment">// Data.</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment"></span> </div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment">    /// Why #Declare_options_func is being called.</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">  465</a></span><span class="comment"></span>    <a class="code hl_enumeration" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">Call_type</a> <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a>;</div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment"></span> </div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment">    /**</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment">     * The args to pass in depending on #m_call_type.</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="comment">     * @internal</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span><span class="comment">     * @todo `union` used inside Option_set implementation should be replaced with the type-safe, equally-fast,</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="comment">     * more-expressive `std::variant`.  The author was not aware of the latter&#39;s existence when originally writing</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span><span class="comment">     * this.</span></div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span><span class="comment">     */</span></div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span>    <span class="keyword">union</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span>    {<span class="comment"></span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment">      /// Corresponds to Call_type::S_FILL_PARSING_ROLE_OPT_TABLE.</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment">        /// `m_option_set-&gt;m_opts_for_parsing` shall be filled out.</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">  480</a></span><span class="comment"></span>        <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a>;<span class="comment"></span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment">         * `m_option_set-&gt;m_values_candidate`, the parsing-in-progress `Value_set` filled out whenever parsing using</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment">         * the completed Option_set::m_opts_for_parsing.</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment">         */</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#acbaeb3dd021040e15bff6e85b8da5253">  485</a></span>        <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#acbaeb3dd021040e15bff6e85b8da5253">m_values_candidate</a>;<span class="comment"></span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="comment">         * `m_option_set-&gt;m_values_default`: the defaults loaded into #m_values_candidate at the top of each</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment">         * parse, for any option specified as non-accumulating.  (Any members whose corresponding option is a regular</span></div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment">         * accumulating one is, in this context, ignored; instead the preceding parse&#39;s final value is kept unchanged.)</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="comment">         */</span></div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#adc8e05f6d6528755712280a812a6ad4d">  491</a></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#adc8e05f6d6528755712280a812a6ad4d">m_values_default_no_acc</a>;</div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a1a35f61a3ebedfdd443e6f050e674aa9">  492</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a1a35f61a3ebedfdd443e6f050e674aa9">m_fill_parsing_role_opt_table_args</a>;</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment"></span> </div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment">      /// Corresponds to Call_type::S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE.</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment">        /// `m_option_set-&gt;m_opts_for_help` shall be filled out.</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment"></span>        <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a>;<span class="comment"></span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="comment">        /// `m_option_set-&gt;m_values_default`: defaults loaded into `Option_set::m_opts_for_help` will originate here.</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a7c91f3db7161cf30816e0fe1fccc39c0">  500</a></span><span class="comment"></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a7c91f3db7161cf30816e0fe1fccc39c0">m_values_default</a>;</div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a32c9e1f9d46f3379bbb95a4aada644ba">  501</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a32c9e1f9d46f3379bbb95a4aada644ba">m_fill_output_help_role_opt_table_args</a>;</div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="comment"></span> </div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span><span class="comment">      /// Corresponds to Call_type::S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE.</span></div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment">         * #m_target_opts shall be filled out based on the defaults earlier saved into #m_values_default and</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">         * current values in #m_values_current.</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment">         */</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a94df262d2c85c677916cb5f57f9c1559">  510</a></span>        opts::options_description* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a94df262d2c85c677916cb5f57f9c1559">m_target_opts</a>;<span class="comment"></span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment">        /// `m_option_set-&gt;m_values_default`: the defaults loaded into `*m_target_opts` will originate here.</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment"></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a7c91f3db7161cf30816e0fe1fccc39c0">m_values_default</a>;<span class="comment"></span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span><span class="comment">        /// The current values loaded into `*m_target_opts` (e.g., via description text) will originate here.</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a19683d3ea7c64e3abf96f85b60e9e610">  514</a></span><span class="comment"></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a19683d3ea7c64e3abf96f85b60e9e610">m_values_current</a>;</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a391e72f142afe97b89e4e106bf443801">  515</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a391e72f142afe97b89e4e106bf443801">m_fill_output_current_role_opt_table_args</a>;</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span><span class="comment"></span> </div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="comment">      /// Corresponds to Call_type::S_COMPARE_PARSED_VALS.</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment">         * Canonical values in `m_option_set-&gt;values()` shall be compared with parsed values in</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment">         * `m_option_set-&gt;m_iterable_values_candidate`.</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment">         */</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span>        <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a>;</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a4d18a90df12e3c632a2fd25fdc23224e">  525</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a4d18a90df12e3c632a2fd25fdc23224e">m_compare_parsed_vals_args</a>;</div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment"></span> </div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment">      /// Corresponds to Call_type::S_LOAD_VALS_AS_IF_PARSED.</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment">         * Values in `*(m_option_set-&gt;values_candidate())` (and related) shall be loaded from #m_values_to_load, as-if</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span><span class="comment">         * parsed from some config source.</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="comment">         */</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span>        <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a>;</div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="comment"></span> </div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span><span class="comment">        /**</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="comment">         * `m_option_set-&gt;m_values_candidate`, the structure to load from #m_values_to_load.</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="comment">         */</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span>        <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#acbaeb3dd021040e15bff6e85b8da5253">m_values_candidate</a>;</div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="comment"></span> </div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span><span class="comment">        /// Values shall be copied from this external `Value_set`.</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a838e0b0c1f25e167a102e11de272de4e">  542</a></span><span class="comment"></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a838e0b0c1f25e167a102e11de272de4e">m_values_to_load</a>;</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a47faf7f6307ae1bcea3e55577b102b41">  543</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a47faf7f6307ae1bcea3e55577b102b41">m_load_val_as_if_parsed_args</a>;</div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span><span class="comment"></span> </div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment">      /// Corresponds to Call_type::S_VALIDATE_STORED_VALS.</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment"></span>      <span class="keyword">struct</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span>      {<span class="comment"></span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="comment">        /// Each validator-enabled (via a #Declare_options_func) member in this structure shall be validated.</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a75ab66920b874488bed052a90bc716d5">  549</a></span><span class="comment"></span>        <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a75ab66920b874488bed052a90bc716d5">m_values_to_validate</a>;</div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae780a398078db2299e8a5c3714bcb987">  550</a></span>      } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae780a398078db2299e8a5c3714bcb987">m_validate_stored_vals_args</a>;</div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno"><a class="line" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">  551</a></span>    } <a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>;</div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span>  }; <span class="comment">// struct Declare_options_func_args</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment"></span> </div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="comment">   * Short-hand for the ever-important callback passed to the main Option_set constructor.  The user of the class</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="comment">   * need not understand the meanings of the args, because the FLOW_CFG_OPTION_SET_DECLARE_OPTION() macro will</span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="comment">   * take care of using them properly.</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span><span class="comment">   *</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment">   *</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment">   * The idea is that the body of a user-provided callback of this type will consist of invoking</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() for each parseable option, in some consistent order, and that macro (which</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="comment">   * we control) will invoke handling of that particular option -- whose stored type can be anything and different from</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span><span class="comment">   * the other options&#39;, meaning we cannot iterate through them at runtime (nor is it possible at compile time without</span></div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment">   * some kind of insane meta-programming).  So, depending on what arguments we pass to this callback, the macro will --</span></div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment">   * upon performing an operation only a macro can do (namely `#ARG_whatever` and the like) -- forward those args</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span><span class="comment">   * to a function templated on the type of the option&#39;s stored value, namely one of `declare_option_*()`,</span></div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment">   * scan_parsed_option(), load_option_value_as_if_parsed(), or validate_parsed_option().  That function will then</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment">   * perform the needed handling for that particular option.</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="comment">   *</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="comment">   * See Declare_options_func_args for the possible args&#39; meanings.</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="comment">   */</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">  573</a></span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a> = <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;void (<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a>&amp; args)&gt;;</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span> </div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span>  <span class="comment">// Constructors/destructor.</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment"></span> </div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment">   * Constructs an option set in CANONICAL state with a default-valued values() payload and options declared</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment">   * by synchronously invoking the callback `declare_opts_func()`.  See below for details on the latter.</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment">   *</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment">   * Post-condition: `values()` is equal to `Values()`; values_candidate() is null (so the state is initially</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment">   * CANONICAL).  (Therefore `Value_set` no-args ctor must by definition be written so as to initialize all its</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment">   * relevant members to their defaults.  Recall `Value_set` is a template parameter type with certain requirements.)</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment">   *</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span><span class="comment">   * Use `parse_*()` (once per config source) and `canonicalize_candidate()` (once) to move to PARSING state and back</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span><span class="comment">   * to CANONICAL state respectively.</span></div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span><span class="comment">   *</span></div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment">   * ### Declaring options via `declare_opts_func()` callback ###</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment">   * `declare_opts_func` above denotes an internally saved callback `move()`d from the corresponding arg</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment">   * `declare_opts_func_moved`.  `declare_opts_func()` is also invoked synchronously</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment">   * from within various relevant output APIs; their doc headers</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment">   * mention it.  (E.g., invoking stream output `os &lt;&lt; *this` will call `declare_opts_func()`.)</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment">   *</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment">   * Informally, the callback must declare every parseable (and therefore stream-printable-semantic-description-having)</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment">   * option, linking it to some data member within a target `Values` whose address is passed to the callback as an</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="comment">   * arg; in a consistent order; and as many times through the lifetime of `*this` (including during this ctor) as</span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span><span class="comment">   * `*this` deems necessary.  Use FLOW_CFG_OPTION_SET_DECLARE_OPTION() to describe all the options.</span></div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="comment">   * Formally, it must follow the following exact rules:</span></div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment">   *   - Its signature right above the `{ body }` must name its args *exactly* as shown in the value of the</span></div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span><span class="comment">   *     #Declare_options_func alias.</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span><span class="comment">   *   - Its body must execute N&gt;=1 invocations of the macro</span></div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span><span class="comment">   *     FLOW_CFG_OPTION_SET_DECLARE_OPTION() -- see its doc header -- each corresponding to a distinct</span></div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span><span class="comment">   *     data member of `Values`, always in the same order and the same N.  Clues as to how this works:</span></div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span><span class="comment">   *     - The naming of the args is so specific in order to make the macro minimally concise to use.</span></div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span><span class="comment">   *     - Macro machinery will auto-determine the main name of the option (as seen in config sources like files)</span></div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span><span class="comment">   *       based on the naming of the `m_` member.</span></div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment">   *     - The macro will call a public API that is not to be called directly, passing in various</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment">   *       data just mentioned, plus the text description passed to it (if relevant) and the option name passed to it.</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span><span class="comment">   *</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment">   *        Logger to use for subsequently logging.</span></div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment">   * @param nickname</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment">   *        Brief string used for logging subsequently.</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span><span class="comment">   * @param declare_opts_func_moved</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span><span class="comment">   */</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2">Option_set</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr, <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> nickname,</div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span>                      <a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a>&amp;&amp; declare_opts_func_moved);</div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span> </div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span><span class="comment"></span> </div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="comment">   * Externally immutable internally stored canonical (current) config values as last constructed or parsed,</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="comment">   * whichever happened more recently.</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span><span class="comment">   *</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="comment">   * @see mutable_values_copy() to get a copy.</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><span class="comment">   *</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span><span class="comment">   */</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a">values</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span><span class="comment"></span> </div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment">   * Convenience method that heap-allocates a copy of the internally stored `values()` and wraps in a ref-counted</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment">   * handle suitable for speedy passing around the rest of the application.</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="comment">   *</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span><span class="comment">   */</span></div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">Mutable_values_ptr</a> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f">mutable_values_copy</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span><span class="comment"></span> </div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span><span class="comment">   * Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after the last</span></div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span><span class="comment">   * successful `parse_*()` API call.</span></div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span><span class="comment">   *</span></div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span><span class="comment">   * Rationale: It is supplied publicly in case the caller wans to log it or something; or perhaps to check</span></div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span><span class="comment">   * for current state (CANONICAL if and only it returns null).</span></div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span><span class="comment">   *</span></div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span><span class="comment">   */</span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215">values_candidate</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span><span class="comment"></span> </div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span><span class="comment">   * Validates the current contents of values() using the validators `*this` `Option_set&lt;Value_set&gt;` is configured</span></div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span><span class="comment">   * to use via constructor.  If at least one option</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span><span class="comment">   * is invalid according to a validator declared by a FLOW_CFG_OPTION_SET_DECLARE_OPTION() invocation in</span></div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span><span class="comment">   * `declare_opts_func()`, then this function shall indicate failure; else success.</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span><span class="comment">   *</span></div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span><span class="comment">   * On failure throws an exception, if `success_or_null` is null; otherwise set `*success_or_null` to `false`.</span></div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span><span class="comment">   * On success simply returns or sets `*success_or_null` to `true` respectively.  In the exception case the message</span></div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span><span class="comment">   * will indicate every reasonable detail about the option value that went wrong.  This info is logged regardless.</span></div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span><span class="comment">   *</span></div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span><span class="comment">   * Informally, the use case driving the presence of this overload is discussed in the Validation section of our</span></div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span><span class="comment">   * class doc header; see that.  To restate: If you want to stringently ensure the defaults are themselves valid,</span></div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment">   * simply invoke this right after construction, at which point values() are by definition at their defaults.</span></div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment">   *</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span><span class="comment">   * @param success_or_null</span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment">   *        If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure.</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment">   */</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">validate_values</a>(<span class="keywordtype">bool</span>* success_or_null = 0) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment"></span> </div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment">   * Validates an arbitrary `Value_set`, as parseable by *an* `Option_set&lt;Value_set&gt;`, according to the</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span><span class="comment">   * given option-registering function suitable for `Option_set&lt;Value_set&gt;` constructor.  If at least one option</span></div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span><span class="comment">   * is invalid according to a validator declared by a FLOW_CFG_OPTION_SET_DECLARE_OPTION() invocation in</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span><span class="comment">   * `declare_opts_func()`, then this function shall indicate failure; else success.</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span><span class="comment">   *</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span><span class="comment">   * On failure throws an exception, if `success_or_null` is null; otherwise set `*success_or_null` to `false`.</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span><span class="comment">   * On success simply returns or sets `*success_or_null` to `true` respectively.  In the exception case the message</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span><span class="comment">   * will indicate every reasonable detail about the option value that went wrong.  This info is logged regardless.</span></div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span><span class="comment">   *</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span><span class="comment">   * Use this, at least, if you&#39;ve filled out a `Value_set` through manual assignment or some other source, rather</span></div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span><span class="comment">   * than parsing through an Option_set -- and don&#39;t even *use* an Option_set, as you don&#39;t parse from config --</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="comment">   * but still want to check it for validity.</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span><span class="comment">   *</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span><span class="comment">   * You can also use the non-`static` overload to reuse the #Declare_options_func passed to an existing</span></div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span><span class="comment">   * parsing-capable `Option_set&lt;Value_set&gt;`.</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span><span class="comment">   *</span></div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span><span class="comment">   *        Logger to use for subsequently logging.</span></div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span><span class="comment">   * @param values_to_validate</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span><span class="comment">   *        The values in this structure shall be validated in the same way as they are upon parsing</span></div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span><span class="comment">   *        by a hypothetical `Option_set&lt;Value_set&gt;` into whose ctor the same `declare_opts_func` were passed.</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span><span class="comment">   * @param declare_opts_func</span></div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span><span class="comment">   *        See Option_set constructor.</span></div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span><span class="comment">   * @param success_or_null</span></div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span><span class="comment">   *        If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure.</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span><span class="comment">   */</span></div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">validate_values</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr,</div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span>                              <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; values_to_validate, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a>&amp; declare_opts_func,</div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span>                              <span class="keywordtype">bool</span>* success_or_null = 0);</div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span><span class="comment"></span> </div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span><span class="comment">   * Validates an arbitrary `Value_set`, using the same validators `*this` `Option_set&lt;Value_set&gt;` is configured to use</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span><span class="comment">   * when parsing config sources.  This essentially means using the `static` overload and passing to it</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span><span class="comment">   * `declare_opts_func` equal to the one earlier passed by the user to `*this` constructor.  The success/failure</span></div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span><span class="comment">   * semantics are identical to the other overload&#39;s (see that doc header).</span></div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span><span class="comment">   *</span></div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span><span class="comment">   * You can also use the `static` overload, if you aren&#39;t at all parsing from config sources but still want to</span></div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span><span class="comment">   * validate.</span></div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span><span class="comment">   *</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span><span class="comment">   * @param values_to_validate</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span><span class="comment">   *        The values in this structure shall be validated in the same way as they are upon `this-&gt;parse_*()`ing from</span></div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span><span class="comment">   *        a config source.</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span><span class="comment">   * @param success_or_null</span></div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span><span class="comment">   *        If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure.</span></div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span><span class="comment">   */</span></div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">validate_values</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; values_to_validate, <span class="keywordtype">bool</span>* success_or_null = 0) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span><span class="comment"></span> </div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span><span class="comment">   * Equivalent to `validate_values(success_or_null)` but validates `*values_candidate()` instead of values().</span></div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span><span class="comment">   * Behavior is undefined (assertion may trip) if not in PARSING mode currently (i.e., values_candidate() is null).</span></div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span><span class="comment">   *</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span><span class="comment">   * Informally, the use case driving the presence of this overload is discussed in the Validation section of our</span></div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span><span class="comment">   * class doc header; see that.  To restate: If you want to ensure no invalid defaults or baseline values have</span></div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span><span class="comment">   * &quot;gotten through&quot; in the current PARSING state, then invoke this -- particularly just ahead of the decision to</span></div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span><span class="comment">   * either canonicalize_candidate() or reject_candidate().</span></div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span><span class="comment">   *</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span><span class="comment">   * @param success_or_null</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span><span class="comment">   *        If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure.</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span><span class="comment">   */</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2">validate_values_candidate</a>(<span class="keywordtype">bool</span>* success_or_null = 0) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span><span class="comment"></span> </div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span><span class="comment">   * Writes a multi-line user-suitable representation of the current values in a #Values object, at some point</span></div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span><span class="comment">   * perhaps initialized or parsed by `*this`, to the given stream.  This should typically be preceded by</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment">   * a newline but not followed by one, unless one desires a blank line there.</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment">   *</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span><span class="comment">   * @param os</span></div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span><span class="comment">   *        Stream to which to serialize.</span></div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span><span class="comment">   * @param values_or_null</span></div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span><span class="comment">   *        Values to serialize; if null then we act as-if it&#39;s `&amp;(values())`.</span></div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span><span class="comment">   */</span></div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633">values_to_ostream</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* values_or_null = 0) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span><span class="comment"></span> </div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span><span class="comment">   * Logs the given values payload using values_to_ostream().</span></div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span><span class="comment">   *</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="comment">   * @param values_or_null</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span><span class="comment">   *        See values_to_ostream().</span></div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="comment">   * @param summary</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span><span class="comment">   *        Brief summary of what this payload represents.</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span><span class="comment">   * @param sev</span></div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span><span class="comment">   *        Severity to use for the log message.</span></div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span><span class="comment">   */</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214">log_values</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* values_or_null = 0, <a class="code hl_enumeration" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev = <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span><span class="comment"></span> </div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span><span class="comment">   * Prints a multi-line help message about the set of options that `*this` can parse.  This should typically</span></div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="comment">   * be preceded by a newline but not followed by one, unless one desires a blank line there.</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="comment">   *</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span><span class="comment">   * @param os</span></div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span><span class="comment">   *        Stream to which to serialize.</span></div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span><span class="comment">   */</span></div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3">help_to_ostream</a>(std::ostream&amp; os) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span><span class="comment"></span> </div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span><span class="comment">   * Logs a multi-line help message using help_to_ostream().</span></div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span><span class="comment">   *</span></div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span><span class="comment">   * @param summary</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment">   *        Brief summary of the help message.</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment">   * @param sev</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span><span class="comment">   *        Severity to use for the log message.</span></div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span><span class="comment">   */</span></div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4">log_help</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, <a class="code hl_enumeration" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev = <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span><span class="comment"></span> </div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span><span class="comment">   * Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the form of</span></div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span><span class="comment">   * the given file in the file-system.  On success values_candidate() is updated; on failure it is untouched.</span></div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span><span class="comment">   *</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment">   * On failure throws an exception, if `success_or_null` is null; otherwise set `*success_or_null` to `false`.</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment">   * On success simply returns or sets `*success_or_null` to `true` respectively.  Information is logged regardless.</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">   *</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span><span class="comment">   * A failure may occur due to invalid contents in the config source.  A failure may occur due to a validator</span></div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment">   * condition failed (see FLOW_CFG_OPTION_SET_DECLARE_OPTION()).</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span><span class="comment">   *</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment">   * However: the latter applies only to settings actually specified in `cfg_path` file.  Any default or baseline or</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment">   * otherwise-previously-set, but not overridden in `cfg_path`, values are not validated -- neither before nor after</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span><span class="comment">   * scanning `cfg_path`.  You are, however, free to do so by next (or previously, or both) invoking</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span><span class="comment">   * validate_values_candidate().  (If &quot;previously,&quot; and not yet in PARSING state, then use validate_values().)</span></div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span><span class="comment">   * See Validation in class doc header for discussion.</span></div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span><span class="comment">   *</span></div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span><span class="comment">   * @see canonicalize_candidate() which will finalize the values_candidate() constructed so far.</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span><span class="comment">   * @see reject_candidate() which will snap back to CANONICAL state rejecting any successful parsing done.</span></div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span><span class="comment">   *      In particular it would make sense in many cases to do this if parse_config_file() indicates failure.</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span><span class="comment">   * @param cfg_path</span></div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span><span class="comment">   *        Path to parse.</span></div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span><span class="comment">   * @param allow_unregistered</span></div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span><span class="comment">   *        If `true`, if an unknown option is encountered it may be allowed (not considered a failure),</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span><span class="comment">   *        subject to `allowed_unregistered_opts_or_empty`, though an INFO</span></div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span><span class="comment">   *        message is still logged for each; if `false` it is an error like any other illegal config setting.</span></div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span><span class="comment">   *        One reason for `true` is if another `Option_set&lt;&gt;` will be parsed from the same config source.</span></div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span><span class="comment">   *        Another is if there could be forward- or backward-compatibility concerns.</span></div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span><span class="comment">   * @param allowed_unregistered_opts_or_empty</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span><span class="comment">   *        Meaningful only if `allow_unregistered == true`, this is the list of all option names (compared</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span><span class="comment">   *        case-sensitively) that will not cause a validation error; or empty to allow *all* unknown options.</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span><span class="comment">   * @param success_or_null</span></div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span><span class="comment">   *        If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure.</span></div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span><span class="comment">   */</span></div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128">parse_config_file</a>(<span class="keyword">const</span> fs::path&amp; cfg_path, <span class="keywordtype">bool</span> allow_unregistered,</div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span>                         <span class="keywordtype">bool</span>* success_or_null = 0,</div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span>                         <span class="keyword">const</span> boost::unordered_set&lt;std::string&gt;&amp; allowed_unregistered_opts_or_empty = {});</div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span><span class="comment"></span> </div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span><span class="comment">   * Enters into (from CANONICAL state) or continues in PARSING state by simply setting `*values_candidate()`</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span><span class="comment">   * to equal the #Values payload given as an argument.  Typically precedes other `parse_*()` calls such as</span></div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span><span class="comment">   * parse_config_file().  If already in PARSING state, note that any changes accumulated in `*values_candidate()`</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span><span class="comment">   * so far will be overwritten entirely.</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span><span class="comment">   *</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span><span class="comment">   * The values in `src_values` are not checked for validity according to the validators configured</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment">   * in the FLOW_CFG_OPTION_SET_DECLARE_OPTION() invocations in `declare_opts_func()` passed to ctor.</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span><span class="comment">   * You are, however, free to do so by next invoking validate_values_candidate().</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span><span class="comment">   * See Validation in class doc header for discussion.</span></div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span><span class="comment">   *</span></div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span><span class="comment">   * ### Rationale ###</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span><span class="comment">   * This is useful, particularly, when one plans to repeatedly apply updates to one `*this`, but a certain *baseline*</span></div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span><span class="comment">   * state is desired before each update.  Consider the example of an Option_set that stores dynamically changeable</span></div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span><span class="comment">   * values.  Suppose each update consists only of a single `parse_config_file(F)` call, where `F` is some file that</span></div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span><span class="comment">   * might get changed at various times to deliver dynamic updates.  Then consider this series:</span></div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span><span class="comment">   *   -# Initial Option_set construction.  End state: `values() == Values()` (default).</span></div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span><span class="comment">   *   -# First update occurs: `parse_config_file(F)`, followed by canonicalize_candidate().</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span><span class="comment">   *      End state: `values()` == defaults + changes in file `F` at time 1.</span></div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span><span class="comment">   *   -# Second update occurs: `parse_config_file(F)`, followed by canonicalize_candidate().</span></div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span><span class="comment">   *      End state: `values()` == defaults + changes in file `F` at time 1 +</span></div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span><span class="comment">   *      changes in file `F` at time 2.</span></div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span><span class="comment">   *   -# (etc.)</span></div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span><span class="comment">   *</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span><span class="comment">   * In this case values() is incrementally changed by each dynamic update, as the file `F` keeps changing.</span></div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span><span class="comment">   * E.g., if at time 1 it contained only option A, and at time 2 it contained only option B, then values()</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span><span class="comment">   * would contain both time-1 option A value and time-2 option B value -- even though the file `F` at</span></div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span><span class="comment">   * time 2 contains only the latter.  This *might* be what you want, but since it&#39;s fully incremental, there are</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span><span class="comment">   * some usability landmines.  Mainly: If one looks at `F` contents at any given time, they can&#39;t know what the</span></div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span><span class="comment">   * resulting state would be; it depends on what updates preceded it.</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span><span class="comment">   *</span></div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span><span class="comment">   * To resolve this, one can save a *baseline* state of values() by copy; and then apply it via this</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span><span class="comment">   * parse_direct_values() call before parsing the file in each dynamic update.  The baseline state could just be</span></div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span><span class="comment">   * defaults (`Values()`), or it could come from some special &quot;baseline&quot; config file that is not `F` which one knows</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span><span class="comment">   * to never change.  (Such a file could also typically store static config managed by a separate Option_set.)</span></div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment">   *</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span><span class="comment">   * So then the sequence might become not parse_config_file(), canonicalize_candidate(), parse_config_file(),</span></div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span><span class="comment">   * canonicalize_candidate(), ...; but rather:</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span><span class="comment">   *   -# Baseline parse: `parse_config_file(B)`, canonicalize_candidate().</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span><span class="comment">   *   -# Save values() copy into `Values baseline`.</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span><span class="comment">   *   -# Update 0: `parse_direct_values(baseline)`, `parse_config_file(F)`, canonicalize_candidate().</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span><span class="comment">   *   -# Update 1: `parse_direct_values(baseline)`, `parse_config_file(F)`, canonicalize_candidate().</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span><span class="comment">   *   -# Update 2: `parse_direct_values(baseline)`, `parse_config_file(F)`, canonicalize_candidate().</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span><span class="comment">   *   -# ...</span></div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span><span class="comment">   * (The first `parse_direct_values(baseline)` here is a no-op but included for clarity/symmetry, as usually one</span></div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span><span class="comment">   * would just do the same thing for each update.)</span></div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span><span class="comment">   *</span></div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span><span class="comment">   * It is also sometimes desirable to &quot;rewind&quot; the state of values_candidate() (by first memorizing it, then</span></div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span><span class="comment">   * parse_config_file() or similar, then if some value in the resulting value set indicates the file should not</span></div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span><span class="comment">   * apply after all, parse_direct_values() to &quot;undo.&quot;  Config_manager uses it when its multi-source feature is</span></div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span><span class="comment">   * engaged -- `commit = false`.)</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span><span class="comment">   *</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span><span class="comment">   * @param src_values</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span><span class="comment">   *        The values set loaded into `*values_candidate()`, as-if parsed from some config source.</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span><span class="comment">   */</span></div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc">parse_direct_values</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; src_values);</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span><span class="comment"></span> </div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span><span class="comment">   * In PARSING state enters CANONICAL state, finalizing values() from values_candidate().</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span><span class="comment">   * Any cumulative changes are INFO-logged on a per-changed-option basis; and if at least one option&#39;s value indeed</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span><span class="comment">   * changed then `*change_detected` is set to `true` (else `false`).  (Leave the arg null, if you do not care.)</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span><span class="comment">   *</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span><span class="comment">   * @note Individual option validation should be done via the validation condition argument to</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span><span class="comment">   *       FLOW_CFG_OPTION_SET_DECLARE_OPTION().  However, it may be necessary to perform a check for internal</span></div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span><span class="comment">   *       consistency among the final values.  The proper time to do this is just before calling</span></div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span><span class="comment">   *       canonicalize_candidate().  If the final check fails, typically one would instead call</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span><span class="comment">   *       reject_candidate().</span></div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span><span class="comment">   *</span></div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span><span class="comment">   * @param change_detected</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span><span class="comment">   *        If null, ignored; otherwise `*change_detected` is set to `true` if a setting changed; else `false`.</span></div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span><span class="comment">   */</span></div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49">canonicalize_candidate</a>(<span class="keywordtype">bool</span>* change_detected = 0);</div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span><span class="comment"></span> </div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span><span class="comment">   * In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.  In CANONICAL state, a no-op.</span></div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span><span class="comment">   * Calling this is typically a good idea when a `parse_*()` attempt indicates failure.</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span><span class="comment">   */</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587">reject_candidate</a>();</div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span><span class="comment"></span> </div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span><span class="comment">   *</span></div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span><span class="comment">   * Loads an entry into #m_opts_for_parsing which will enable the parsing into `*target_value` from config sources</span></div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span><span class="comment">   * such as config files.</span></div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="comment">   *</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span><span class="comment">   *         Type of the value inside a #Values object.  It must be reasonably copyable.</span></div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span><span class="comment">   *        Main option name: as specified by the user in a config source.</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span><span class="comment">   *        As of this writing FLOW_CFG_OPTION_SET_DECLARE_OPTION() uses macro magic to automatically form this</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span><span class="comment">   *        from the identifier name within a #Values object (e.g., `Value_set::m_cool_option` =&gt; &quot;cool-option&quot;).</span></div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span><span class="comment">   * @param target_value</span></div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span><span class="comment">   *        When deserializing a value from a config source, the bits shall be written there.</span></div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span><span class="comment">   *        This must point inside `m_values_candidate`.</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span><span class="comment">   * @param value_default_if_no_acc</span></div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span><span class="comment">   *        Usually -- with regular (accumulating) options -- null; otherwise pointer to the default value for</span></div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="comment">   *        `*target_value` (as from `Values()`), inside `m_values_default`.  In the latter case (non-null) this</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span><span class="comment">   *        indicates this is an option marked by the user as non-accumulating</span></div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span><span class="comment">   *        (see FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC() and similar), meaning each time a config source</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span><span class="comment">   *        (e.g., a file) is parsed `*target_value` is first reset to this default; then overwritten with the value in</span></div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span><span class="comment">   *        the config source if, else left at the default.  An accumulating option in the latter case would instead</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span><span class="comment">   *        keep its existing value already in `*target_value`.</span></div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span><span class="comment">   * @param validator_func_moved</span></div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span><span class="comment">   *        Function F, such that F(V) shall be called from `parse_*()` when this option&#39;s successfully parsed value V</span></div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span><span class="comment">   *        is being validated before final storage in `m_values_candidate`.  Return `false` if the validation</span></div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span><span class="comment">   *        shall fail; otherwise return `true`.</span></div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span><span class="comment">   * @param validator_cond_str</span></div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span><span class="comment">   *        String containing the Boolean code that `validator_func_moved()` would need to evaluate to `true` to pass</span></div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span><span class="comment">   *        validation.  As of this writing FLOW_CFG_OPTION_SET_DECLARE_OPTION() uses macro magic to automatically form</span></div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span><span class="comment">   *        this from a Boolean expression fragment.</span></div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span><span class="comment">   */</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa">declare_option_for_parsing</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, Value* target_value, <span class="keyword">const</span> Value* value_default_if_no_acc,</div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span>                                  <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span>                                  <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str);</div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span><span class="comment"></span> </div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span><span class="comment">   *</span></div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span><span class="comment">   * Loads an entry into #m_opts_for_help which will enable the proper help text to appear for that option</span></div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span><span class="comment">   * in help_to_ostream() or log_help().</span></div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span><span class="comment">   *</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span><span class="comment">   *         Type of the value inside a #Values object.  It must be reasonably copyable; and it must be supported by</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span><span class="comment">   *         some version (including specialization(s) and overload(s)) of value_to_ostream().</span></div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span><span class="comment">   *        See declare_option_for_parsing().</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span><span class="comment">   * @param value_default</span></div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span><span class="comment">   *        Default value to show to the user.</span></div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span><span class="comment">   * @param description</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span><span class="comment">   *        The description text to show to the user.</span></div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span><span class="comment">   */</span></div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce">declare_option_for_help</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, <span class="keyword">const</span> Value&amp; value_default, <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description);</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span><span class="comment"></span> </div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span><span class="comment">   *</span></div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span><span class="comment">   * Scans a canonical (current) value in #m_values, comparing it to the (possibly) parsed one in</span></div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span><span class="comment">   * #m_iterable_values_candidate, erasing it from the latter if and only if it is unchanged.</span></div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span><span class="comment">   *</span></div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span><span class="comment">   *         Type of the value inside a #Values object.  It must have a meaningful `==` operation.</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span><span class="comment">   *        See declare_option_for_parsing().</span></div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span><span class="comment">   * @param canonical_value</span></div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span><span class="comment">   *        Current value in `m_values`.</span></div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span><span class="comment">   */</span></div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8">scan_parsed_option</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, <span class="keyword">const</span> Value&amp; canonical_value);</div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span><span class="comment"></span> </div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span><span class="comment">   * Internal-through-macro helper function; the user shall not call this directly but only through</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span><span class="comment">   * FLOW_CFG_OPTION_SET_DECLARE_OPTION() (see Option_set main constructor doc header).</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span><span class="comment">   *</span></div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span><span class="comment">   * @internal</span></div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span><span class="comment">   * To be called only when #m_parsing is `true`, sets a value in #m_values_candidate to equal one</span></div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span><span class="comment">   * in an external #Values object; and mirrors this in #m_iterable_values_candidate to maintain its invariant.</span></div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span><span class="comment">   * As a result, it is as-if that value was parsed from some config source such as a file.</span></div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span><span class="comment">   * Note that, as with parsing from actual config sources like files, one must still scan_parsed_option()</span></div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span><span class="comment">   * at some point to slim down #m_iterable_values_candidate to store merely the changed options.</span></div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span><span class="comment">   * @endinternal</span></div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span><span class="comment">   *</span></div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span><span class="comment">   * @tparam Value</span></div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span><span class="comment">   *         Type of the value inside a #Values object.  It must have a meaningful `=` operation.</span></div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span><span class="comment">   * @param name</span></div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span><span class="comment">   *        See declare_option_for_parsing().</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span><span class="comment">   * @param target_value</span></div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span><span class="comment">   *        Target value inside `m_values_candidate`.</span></div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span><span class="comment">   * @param source_value</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span><span class="comment">   *        Value to load into `*target_value` (as-if it was parsed from a config source).</span></div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span><span class="comment">   */</span></div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae">load_option_value_as_if_parsed</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, Value* target_value, <span class="keyword">const</span> Value&amp; source_value);</div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span><span class="comment"></span> </div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span><span class="comment">   * Return `true` if and only if the option-declaring function passed to the constructor declared no options.</span></div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span><span class="comment">   * This value is always the same for a given `*this`.</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span><span class="comment">   *</span></div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span><span class="comment">   * ### Rationale ###</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span><span class="comment">   * While likely of little value when the user instantiates an Option_set directly, this can be useful in</span></div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span><span class="comment">   * generic meta-programming, wherein multiple `Option_set`s might be instantiated at compile time, but the</span></div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span><span class="comment">   * coder doesn&#39;t know how many while coding.  For example Config_manager uses null() to bypass confusingly-logging</span></div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span><span class="comment">   * parse_config_file() calls on empty Option_set objects, such as if a static config set has no dynamic config</span></div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span><span class="comment">   * counterpart.</span></div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span><span class="comment">   *</span></div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span><span class="comment">   */</span></div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">null</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span><span class="comment"></span> </div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span><span class="comment">   * Returns set of all option names declared by the option-declaring function passed to the constructor.</span></div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span><span class="comment">   * This can be useful to supply to parse_config_file(), for example, when parsing another Option_set from the</span></div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span><span class="comment">   * same file: then other options can be passed to that function as not causing a parse error if encountered;</span></div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span><span class="comment">   * hence 2 or more `Option_set`s can parse_config_file() the same file despite having disjoint option name sets --</span></div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span><span class="comment">   * yet totally extraneous options in none of the `Option_set`s would cause an error as desired.</span></div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span><span class="comment">   *</span></div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span><span class="comment">   * This returns the same value (and reference) each time it is called.</span></div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span><span class="comment">   *</span></div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span><span class="comment">   */</span></div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span>  <span class="keyword">const</span> boost::unordered_set&lt;std::string&gt;&amp; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1">option_names</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span> </div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span>  <span class="comment">// Data.</span></div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span><span class="comment"></span> </div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span><span class="comment">  /// See `nickname` ctor arg.</span></div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a5e5cf9a5efd81ba6d851171a109005f6"> 1027</a></span><span class="comment"></span>  <span class="keyword">const</span> std::string <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a5e5cf9a5efd81ba6d851171a109005f6">m_nickname</a>;</div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span> </div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span><span class="keyword">private</span>:</div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span><span class="comment"></span> </div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span><span class="comment">   * Similar to a boost.program_options parsing results `variables_map`, which conceptually mirrors the results of a</span></div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span><span class="comment">   * parsing operation in the target `Values` structure,</span></div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span><span class="comment">   * mapping `string` to variable-type values.  As explained in the doc header for</span></div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span><span class="comment">   * Option_set::Opt_table, a parsing operation takes in a config source (config file, etc.)</span></div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span><span class="comment">   * and a *parsing-role* `Opt_table`; and outputs a `Values` and an object of the present type.</span></div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span><span class="comment">   * `Values` is the main point Option_set exists; it&#39;s what the application accesses, via simple</span></div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span><span class="comment">   * `-&gt;m_*` access of various values, to observe the parsed config -- so why do we need `Iterable_values`?</span></div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span><span class="comment">   *</span></div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"> 1041</span><span class="comment">   * The reason we use this is: we need to be able to iterate through all the options that were found in a</span></div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"> 1042</span><span class="comment">   * parsing pass, at least to detect changes as needed at least for dynamic option features (triggering</span></div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"> 1043</span><span class="comment">   * on-changed hooks, etc.).  (Requiring a manual `operator==(Value_set, Value_set)` or similar is too onerous</span></div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"> 1044</span><span class="comment">   * and error-prone for the implementor of the `Value_set`, as every `-&gt;m_` would require manual mention.)</span></div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"> 1045</span><span class="comment">   *</span></div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span><span class="comment">   * A `variables_map` is classically filled via the aforementioned parsing operation `opts::store()`;</span></div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"> 1047</span><span class="comment">   * and is itself an `std::map`.  Hence one can copy all the pairs from that into an #Iterable_values; and</span></div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span><span class="comment">   * an #Iterable_values can be manually pre-filled with pre-parse values from `Values` for easy</span></div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span><span class="comment">   * comparison after the `store()` (and other such algorithms).  Note, also, it is deep-copyable, as long as</span></div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span><span class="comment">   * all types stored within are deep-copyable.</span></div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span><span class="comment">   *</span></div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span><span class="comment">   * ### Rationale ###</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span><span class="comment">   * - Why not simply use `opts::variables_map`?  It is after all very close to what this is.  Answer: I (ygoldfel)</span></div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span><span class="comment">   *   started that way, but its API is a bit hairy, and it&#39;s scary to have to depend on how boost.program_options</span></div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span><span class="comment">   *   will act when `variables_map` isn&#39;t empty before the parsing begins, for example (e.g., `store()` docs say</span></div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span><span class="comment">   *   it will NOT overwrite any &quot;non-defaulted&quot; value -- having to rely on such nuances doesn&#39;t seem great).</span></div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span><span class="comment">   *   It is safer, if slower (but we don&#39;t care), to treat a fresh `variables_map` that&#39;s `store()`d into as an</span></div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span><span class="comment">   *   intermediary.</span></div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span><span class="comment">   * - Why not `unordered_map`?  It&#39;s faster after all.  Answer: An alphabetical iteration order seems nice when</span></div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span><span class="comment">   *   (e.g.) iterating over the keys to show differences in values to humans.</span></div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span><span class="comment">   */</span></div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a30c5113f0e85c705fadc32076d83dca4"> 1062</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a30c5113f0e85c705fadc32076d83dca4">Iterable_values</a> = std::map&lt;std::string, boost::any&gt;;</div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"> 1063</span> </div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span>  <span class="comment">// Data.</span></div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span><span class="comment"></span> </div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span><span class="comment">  /// See null().</span></div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a18227d957ee16e50977dd4bb34d489ab"> 1067</a></span><span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a18227d957ee16e50977dd4bb34d489ab">m_null</a>;</div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span><span class="comment"></span> </div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span><span class="comment">  /// See option_names().</span></div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a650edbbffb9f75ed102f2bab5e355feb"> 1070</a></span><span class="comment"></span>  boost::unordered_set&lt;std::string&gt; <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a650edbbffb9f75ed102f2bab5e355feb">m_opt_names</a>;</div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span><span class="comment"></span> </div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span><span class="comment">   * The #Opt_table-filling, or #m_iterable_values_candidate-scanning, callback passed to the constructor and invoked</span></div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span><span class="comment">   * with various input args (see #Declare_options_func doc header).  Depending on those args it will either fill</span></div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span><span class="comment">   * `Opt_table` in various roles (see #Opt_table doc header), or it will scan the values just loaded into</span></div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"> 1076</span><span class="comment">   * #m_iterable_values_candidate (e.g., for equality to the values in canonical #m_values).</span></div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"> 1077</span><span class="comment">   */</span></div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a94ce83bb7ca160d551fa87daeb288493"> 1078</a></span>  <a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a94ce83bb7ca160d551fa87daeb288493">m_declare_opts_func</a>;</div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"> 1079</span><span class="comment"></span> </div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span><span class="comment">  /// See values().</span></div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a7bda9a32640f89d1c8a2306b8b368a13"> 1081</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a7bda9a32640f89d1c8a2306b8b368a13">m_values</a>;</div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span><span class="comment"></span> </div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span><span class="comment">  /// Copy of values() when it is first constructed; i.e., the defaults.</span></div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#aea72e19fce43c10c84f6445f1892de41"> 1084</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#aea72e19fce43c10c84f6445f1892de41">m_values_default</a>;</div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span><span class="comment"></span> </div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span><span class="comment">  /// See values_candidate() -- `true` if and only if that returns non-null (PARSING state; else CANONICAL state).</span></div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ac3f6c86292b4f6040c655f6bdcb05a3e"> 1087</a></span><span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#ac3f6c86292b4f6040c655f6bdcb05a3e">m_parsing</a>;</div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span><span class="comment"></span> </div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span><span class="comment">  /// See values_candidate().  When that returns null (`m_parsing == false`) this value is meaningless.</span></div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#adfd72b4b73913193252a02d35acdff09"> 1090</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#adfd72b4b73913193252a02d35acdff09">m_values_candidate</a>;</div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span><span class="comment"></span> </div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"> 1092</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span><span class="comment">   * Structure mirroring #m_values_candidate, where the values are the parsing-enabled members of #m_values_candidate,</span></div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span><span class="comment">   * and each value&#39;s key is it main config option name; if an option has not changed between #m_values and</span></div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span><span class="comment">   * #m_values_candidate (according to its `==` operator), then that option&#39;s key is omitted.  In particular</span></div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span><span class="comment">   * it is `.empty() == true` when in CANONICAL mode (`m_parsing == false`).</span></div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span><span class="comment">   */</span></div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a3de831b04134e0729a11a7e0a114a320"> 1098</a></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a30c5113f0e85c705fadc32076d83dca4">Iterable_values</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a3de831b04134e0729a11a7e0a114a320">m_iterable_values_candidate</a>;</div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span><span class="comment"></span> </div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span><span class="comment">   * The *parsing-role* #Opt_table (see extensive explanation in #Opt_table doc header).  Briefly: it&#39;s used</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span><span class="comment">   * to actually load `*m_values_candidate` -- and ultimately #m_values -- with values parsed from config sources such</span></div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span><span class="comment">   * as files.  This must not change after the first `parse_*()` API begins execution.</span></div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span><span class="comment">   */</span></div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a381ff2ba7989b90cec0040e3b833d238"> 1105</a></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a381ff2ba7989b90cec0040e3b833d238">m_opts_for_parsing</a>;</div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"> 1106</span><span class="comment"></span> </div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span><span class="comment">   * The *output-role* #Opt_table, help-text sub-role (see extensive explanation in #Opt_table doc header).</span></div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span><span class="comment">   * Briefly: it&#39;s used to output help text to output streams for user&#39;s convenience, in fact simply by piping it</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span><span class="comment">   * to an `ostream` via `&lt;&lt;`.  This should not change after the first `parse_*()` API begins execution (lest the</span></div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span><span class="comment">   * user become confused).</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span><span class="comment">   */</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#aaeb9b41e8ac4c9f5a2437cedb0f3472a"> 1113</a></span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a> <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#aaeb9b41e8ac4c9f5a2437cedb0f3472a">m_opts_for_help</a>;</div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span>}; <span class="comment">// class Option_set</span></div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span> </div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span><span class="comment">// Free functions: in *_fwd.hpp.</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span> </div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"> 1118</span><span class="comment">// Macros.</span></div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span><span class="comment"></span> </div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span><span class="comment">/**</span></div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span><span class="comment"> * Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing</span></div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span><span class="comment"> * `declare_opts_func` in their flow::cfg::Option_set::Declare_options_func callback, when declaring each individual</span></div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span><span class="comment"> * config option as linked to a given data member of their config-bearing `struct` used as the `Value_set` in</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span><span class="comment"> * `Option_set&lt;Value_set&gt;`.</span></div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span><span class="comment"> *</span></div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span><span class="comment"> * @note The resulting option name, as found in config sources such as config files, will be auto-computed from</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span><span class="comment"> *       the string `#ARG_m_value`.  So if `ARG_m_value` is `m_cool_thing.m_cool_guy`, then the option name</span></div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span><span class="comment"> *       might be computed to be, say, `&quot;cool-thing.cool-duration&quot;`, with a config file line:</span></div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span><span class="comment"> *       `&quot;cool-thing.cool-duration=2 milliseconds&quot;`.</span></div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span><span class="comment"> * @note It may be desirable to *not* auto-name a given option; a known use case for this is legacy option names,</span></div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span><span class="comment"> *       if renaming is difficult in the field.  Use FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED() if indeed</span></div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span><span class="comment"> *       you want to custom-name your option.</span></div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span><span class="comment"> *</span></div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span><span class="comment"> *        Supposing `Value_set` is the template arg to `Option_set`, and `Value_set V` is being registered,</span></div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span><span class="comment"> *        then `ARG_m_value` is such that `V.ARG_m_value` is the scalar into which the particular config option shall</span></div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span><span class="comment"> *        be deserialized.  It shall be a scalar data member name, optionally within a compound data member, which is</span></div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span><span class="comment"> *        itself optionally within a compound, and so forth, within `Value_set V`.  Each optional compounding may</span></div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span><span class="comment"> *        be via simple object composition (`.`) or pointer dereference (`-&gt;`).</span></div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="comment"> *        Examples: `m_direct_member`, `m_group_obj.m_indirect_member`,</span></div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span><span class="comment"> *        `m_group.m_group1-&gt;m_pointed_group-&gt;m_cool_scalar`.  Reminder: each of these must be accessible within</span></div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment"> *        a `Value_set` via `.` compounding.  E.g.: `V.m_direct_member` a/k/a `Value_set::m_direct_member`.</span></div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span><span class="comment"> *        Description of the option as shown to the user in help text.  Use 1+ sentence(s), starting with capital and</span></div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span><span class="comment"> *        ending with punctuator.  Indicate all key semantics, including special values, but (1) try to keep to one</span></div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span><span class="comment"> *        sentence and line if possible; and (2) save extended discussion for the comment on the data member declaration</span></div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span><span class="comment"> *        itself.  Omit discussion of defaults; the default will be auto-printed and might change in code later.</span></div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"> 1148</span><span class="comment"> *        Reminder: This is a brief summary -- not a `man` page equivalent... but a `man` page equivalent *should* be</span></div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"> 1149</span><span class="comment"> *        in the actual code.</span></div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"> 1150</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"> 1151</span><span class="comment"> *        In a fashion similar to `assert()` arg, an expression convertible to `bool` such that if and only if it</span></div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span><span class="comment"> *        evaluates to `false` at the time of parsing a value for `ARG_m_value` from a config source, then the value</span></div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span><span class="comment"> *        is considered invalid, causing parse failure for that config source.  The expression shall assume that</span></div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span><span class="comment"> *        the parsed value is in the variable of type `Value` named `val`.  (If no further validation is needed, you</span></div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span><span class="comment"> *        may simply pass in `true`.)</span></div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span><span class="comment"> */</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f"> 1157</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION(ARG_m_value, ARG_description, ARG_bool_validate_expr) \</span></div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span><span class="preprocessor">  FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS(ARG_m_value, ARG_description, ARG_bool_validate_expr, false)</span></div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span><span class="comment"></span> </div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span><span class="comment">/**</span></div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span><span class="comment"> * Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), except the option is marked as *non-accumulating*, which</span></div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span><span class="comment"> * means that each time a config source (such as file) is parsed, this option&#39;s value is reset to default and then</span></div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span><span class="comment"> * only overwritten with a potential non-default value if explicitly specified in the config source.  (Otherwise</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span><span class="comment"> * the option is accumulating, hence whatever value is already stored in the `Value_set` is left unchanged unless</span></div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span><span class="comment"> * specified in the config source.)</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span><span class="comment"> *</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span><span class="comment"> * @note This may be useful, in particular, when used in flow::cfg::Config_manager in multi-file updates for special</span></div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span><span class="comment"> *       options that implement conditionality.  It does not make sense to accumulate such options&#39; values from file to</span></div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment"> *       file in a given update, so this `_NO_ACC` variant macro makes sense to use.</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span><span class="comment"> *</span></div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span><span class="comment"> */</span></div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#a9187f169f3eaf596c0e7b0f9e7e34761"> 1178</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC(ARG_m_value, ARG_description, ARG_bool_validate_expr) \</span></div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span><span class="preprocessor">  FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS(ARG_m_value, ARG_description, ARG_bool_validate_expr, true)</span></div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span><span class="comment"></span> </div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span><span class="comment">/**</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span><span class="comment"> * Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), but with support for setting a value at a container subscript.</span></div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span><span class="comment"> *</span></div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span><span class="comment"> * It works as follows.  Normally `ARG_m_value`, when stringified via `#` preprocessor trick, looks like a sequence of</span></div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span><span class="comment"> * `m_...` of identifiers joined with `.` and/or `-&gt;`.  Call these *terms*.  In this case, however, exactly one of the</span></div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span><span class="comment"> * terms -- but not the trailing term -- must end with the postfix `[...]`, where `...` may be 1 or more characters</span></div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span><span class="comment"> * excluding `]`.  As in FLOW_CFG_OPTION_SET_DECLARE_OPTION(), the option name will be auto-computed based on</span></div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span><span class="comment"> * the stringification; but with one extra step at the end: `[...]` shall be replaced by the added macro</span></div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span><span class="comment"> * arg `ARG_key`, which must be `ostream&lt;&lt;`able.</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span><span class="comment"> *</span></div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span><span class="comment"> * This can be used to fill out fixed-key-set containers of `struct`s concisely.  Otherwise one would have to</span></div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span><span class="comment"> * tediously unroll the loop and manually provide the name via FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED().</span></div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span><span class="comment"> * Perhaps best shown by example:</span></div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span><span class="comment"> *</span></div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span><span class="comment"> *   // In Value_set:</span></div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span><span class="comment"> *     constexpr size_t S_N_GRAND_PARENTS = 4;</span></div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span><span class="comment"> *     struct Grand_parent { string m_name; bool m_male_else_female = false; };</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment"> *     array&lt;Grand_parent, S_N_GRAND_PARENTS&gt; m_grand_parents;</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><span class="comment"> *   // When declaring options for Option_set&lt;Value_set&gt;:</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span><span class="comment"> *     for (size_t idx = 0; idx != Value_set::S_N_GRAND_PARENTS; ++idx)</span></div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span><span class="comment"> *     {</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span><span class="comment"> *       FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED(m_grand_parents[idx].m_name, &quot;The grandparent&#39;s name.&quot;, true, idx);</span></div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span><span class="comment"> *       FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED(m_grand_parents[idx].m_male_else_female, &quot;Their gender.&quot;, true, idx);</span></div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span><span class="comment"> *     }</span></div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment"> *   // Resulting config options:</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment"> *     &quot;grand-parents.0.name&quot;</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span><span class="comment"> *     &quot;grand-parents.0.male-else-female&quot;</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span><span class="comment"> *     &quot;grand-parents.1.name&quot;</span></div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span><span class="comment"> *     &quot;grand-parents.1.male-else-female&quot;</span></div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment"> *     &quot;grand-parents.2.name&quot;</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span><span class="comment"> *     &quot;grand-parents.2.male-else-female&quot;</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span><span class="comment"> *     &quot;grand-parents.3.name&quot;</span></div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span><span class="comment"> *     &quot;grand-parents.3.male-else-female&quot;</span></div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span><span class="comment"> *   // Example file:</span></div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span><span class="comment"> *     [grand-parents.0]</span></div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span><span class="comment"> *     name=Alice Eve</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span><span class="comment"> *     male-else-female=false</span></div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span><span class="comment"> *     [grand-parents.1]</span></div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span><span class="comment"> *     name=Ray Liotta</span></div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span><span class="comment"> *     male-else-female=true</span></div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span><span class="comment"> *</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="comment"> * Tip: In this example `idx` is a number; and the container is an `array`.  However, it can be any container with</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span><span class="comment"> * both keys and values; it just needs to always have the same key set after `Value_set` construction: `map`, `vector`,</span></div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span><span class="comment"> * etc.  Accordingly the key can be anything `ostream&lt;&lt;`-able (e.g., `string` works).  However -- behavior is undefined</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span><span class="comment"> * if the value, when `ostream&lt;&lt;`ed, would not be accepted by boost.program_options as an option name postfix.</span></div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"> 1229</span><span class="comment"> * Informally: keep it to alphanumerics and underscores.</span></div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span><span class="comment"> *</span></div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span><span class="comment"> * @note Do not confuse this with the situation where *one* option is *itself* a `vector&lt;T&gt;`, where `T` is a scalar</span></div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span><span class="comment"> *       (from boost.program_options&#39; point of view).  E.g., a `vector&lt;int&gt;` can simply be a single option, and</span></div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span><span class="comment"> *       the user can supply as many or as few elements as they want, at runtime (in config file, one option per line).</span></div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span><span class="comment"> *       For example the above `Value_set` can *itself* contain a `vector&lt;&gt;` in *each* `struct` in the array:</span></div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span><span class="comment"> *</span></div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span><span class="comment"> *   // In Value_set:</span></div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span><span class="comment"> *     struct Grand_parent { ...; vector&lt;int&gt; m_kid_ages; };</span></div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span><span class="comment"> *   // When declaring options for Option_set&lt;Value_set&gt;:</span></div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span><span class="comment"> *     for (size_t idx = 0; idx != Value_set::S_N_GRAND_PARENTS; ++idx)</span></div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span><span class="comment"> *     {</span></div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span><span class="comment"> *       ...</span></div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span><span class="comment"> *       FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED(m_grand_parents[idx].m_kid_ages, &quot;Children&#39;s age list.&quot;, true, idx);</span></div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span><span class="comment"> *     }</span></div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span><span class="comment"> *   // Resulting config options:</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span><span class="comment"> *     &quot;grand-parents.0.kid-ages&quot;</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span><span class="comment"> *     &quot;grand-parents.1.kid-ages&quot;</span></div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span><span class="comment"> *     &quot;grand-parents.2.kid-ages&quot;</span></div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span><span class="comment"> *     &quot;grand-parents.3.kid-ages&quot;</span></div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="comment"> *   // Example file:</span></div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span><span class="comment"> *     [grand-parents.0]</span></div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span><span class="comment"> *     name=Alice Eve</span></div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span><span class="comment"> *     male-else-female=false</span></div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="comment"> *     kid-ages=5</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span><span class="comment"> *     kid-ages=7</span></div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span><span class="comment"> *     kid-ages=25</span></div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span><span class="comment"> *     [grand-parents.1]</span></div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span><span class="comment"> *     name=Ray Liotta</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span><span class="comment"> *     male-else-female=true</span></div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span><span class="comment"> *     kid-ages=32</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span><span class="comment"> *     ...</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span><span class="comment"> *</span></div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span><span class="comment"> * @param ARG_key</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span><span class="comment"> *        See above.</span></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span><span class="comment"> */</span></div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#a4fef7c1a28ef3510f71fae708c647590"> 1277</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED(ARG_m_value, ARG_description, ARG_bool_validate_expr, ARG_key) \</span></div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span><span class="preprocessor">  FLOW_UTIL_SEMICOLON_SAFE \</span></div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span><span class="preprocessor">    ( \</span></div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span><span class="preprocessor">      const ::std::string FLOW_CFG_SET_DECL_OPT_KEYED_name \</span></div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span><span class="preprocessor">        = ::flow::cfg::value_set_member_id_to_opt_name_keyed(#ARG_m_value, ARG_key); \</span></div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span><span class="preprocessor">      FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED \</span></div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span><span class="preprocessor">        (ARG_m_value, FLOW_CFG_SET_DECL_OPT_KEYED_name.c_str(), ARG_description, ARG_bool_validate_expr, false); \</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span><span class="preprocessor">    )</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span><span class="comment"></span> </div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span><span class="comment">/**</span></div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span><span class="comment"> * Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED_NO_ACC(), except the option is marked as *non-accumulating*</span></div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span><span class="comment"> * in the same sense as for FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC().</span></div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span><span class="comment"> *</span></div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span><span class="comment"> * @see FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC() for a brief explanation of how non-accumulating options work.</span></div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span><span class="comment"> *</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span><span class="comment"> * @param ARG_key</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED().</span></div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span><span class="comment"> */</span></div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#acebdea54dd008e15d8e3b36a1c3fbb67"> 1301</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED_NO_ACC(ARG_m_value, ARG_description, ARG_bool_validate_expr, ARG_key) \</span></div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span><span class="preprocessor">  FLOW_UTIL_SEMICOLON_SAFE \</span></div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span><span class="preprocessor">    ( \</span></div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span><span class="preprocessor">      const ::std::string FLOW_CFG_SET_DECL_OPT_KEYED_name \</span></div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span><span class="preprocessor">        = ::flow::cfg::value_set_member_id_to_opt_name_keyed(#ARG_m_value, ARG_key); \</span></div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span><span class="preprocessor">      FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED \</span></div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span><span class="preprocessor">        (ARG_m_value, FLOW_CFG_SET_DECL_OPT_KEYED_name.c_str(), ARG_description, ARG_bool_validate_expr, true); \</span></div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span><span class="preprocessor">    )</span></div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span><span class="comment"></span> </div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span><span class="comment">/**</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span><span class="comment"> * As of this writing is identical to either FLOW_CFG_OPTION_SET_DECLARE_OPTION() or</span></div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span><span class="comment"> * FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC(), depending on the value of `ARG_no_accumulation` argument.</span></div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span><span class="comment"> *</span></div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span><span class="comment"> * Rationale: Currently we don&#39;t necessarily expect this to be widely used directly in place of the aforementioned two</span></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span><span class="comment"> * macros, but it seems reasonable to have a single macro with all various knobs given as parameters with certain</span></div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span><span class="comment"> * knob combinations potentially invoked via macro(s) based on this one.  As of this</span></div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span><span class="comment"> * writing there is just the one extra knob, `ARG_no_accumulation`, but in the future we might expand to more</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span><span class="comment"> * variations in which case more args would be added here.</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span><span class="comment"> * </span></div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span><span class="comment"> * @param ARG_no_accumulation</span></div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span><span class="comment"> *        `bool` such that `false` causes FLOW_CFG_OPTION_SET_DECLARE_OPTION() behavior, while `true`</span></div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment"> *        causes FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC() behavior.</span></div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="comment"> */</span></div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#ab4bbc1d89a4476cdce0d29fd7dc461e8"> 1330</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS(ARG_m_value, ARG_description, ARG_bool_validate_expr, \</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span><span class="preprocessor">                                                      ARG_no_accumulation) \</span></div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="preprocessor">  FLOW_UTIL_SEMICOLON_SAFE \</span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span><span class="preprocessor">    ( \</span></div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="preprocessor">      const ::std::string FLOW_CFG_SET_DECL_OPT_name = ::flow::cfg::value_set_member_id_to_opt_name(#ARG_m_value); \</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span><span class="preprocessor">      FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED \</span></div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="preprocessor">        (ARG_m_value, FLOW_CFG_SET_DECL_OPT_name.c_str(), ARG_description, ARG_bool_validate_expr, \</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span><span class="preprocessor">         ARG_no_accumulation); \</span></div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span><span class="preprocessor">    )</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span><span class="comment"></span> </div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span><span class="comment">/**</span></div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span><span class="comment"> * Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS(), except the user must specify the option&#39;s string name</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span><span class="comment"> * manually as an argument to the functional macro.  (FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS() itself</span></div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span><span class="comment"> * is basically FLOW_CFG_OPTION_SET_DECLARE_OPTION() plus certain knobs which the former sets to commonly-used values</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span><span class="comment"> * for concision.)</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span><span class="comment"> *</span></div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span><span class="comment"> * This macro, which can be used directly but normally is not, is internally invoked (potentially indirectly) by any</span></div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span><span class="comment"> * other `FLOW_CFG_OPTION_SET_DECLARE_OPTION*()` macro.  As such it is the essential core such macro.</span></div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span><span class="comment"> * </span></div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="comment"> * Informally: it is best to avoid its direct use, as it can break the auto-naming conventions maintained by</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span><span class="comment"> * FLOW_CFG_OPTION_SET_DECLARE_OPTION() and similar.  That said a couple of use cases might be:</span></div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span><span class="comment"> *   - FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED() uses it in its impl to add a convention for container subscripts.</span></div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span><span class="comment"> *   - One can specify a legacy option-name alias.  (E.g., one can FLOW_CFG_OPTION_SET_DECLARE_OPTION()</span></div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span><span class="comment"> *     an option and then FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED() a manually-named option targeting</span></div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span><span class="comment"> *     the same `Value_set` member.  Then either the auto-generated name or the legacy name can be used in a config</span></div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span><span class="comment"> *     source, until the latter is deprecated-out successfully in the field.)</span></div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span><span class="comment"> *</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span><span class="comment"> * @param ARG_opt_name_c_str</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span><span class="comment"> *        The option&#39;s manually specified string name.  Type: directly convertible to `const char*`; typically</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span><span class="comment"> *        a string literal.</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment"> * @param ARG_m_value</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span><span class="comment"> * @param ARG_description</span></div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span><span class="comment"> * @param ARG_bool_validate_expr</span></div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION().</span></div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span><span class="comment"> * @param ARG_no_accumulation</span></div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span><span class="comment"> *        See FLOW_CFG_OPTION_SET_DECLARE_OPTION_WITH_KNOBS().</span></div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span><span class="comment"> */</span></div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"><a class="line" href="option__set_8hpp.html#ab96b1325e31736438412e5125ae4fb26"> 1369</a></span><span class="preprocessor">#define FLOW_CFG_OPTION_SET_DECLARE_OPTION_MANUALLY_NAMED(ARG_m_value, ARG_opt_name_c_str, \</span></div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span><span class="preprocessor">                                                          ARG_description, ARG_bool_validate_expr, \</span></div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span><span class="preprocessor">                                                          ARG_no_accumulation) \</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span><span class="preprocessor">  FLOW_UTIL_SEMICOLON_SAFE \</span></div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span><span class="preprocessor">    ( \</span></div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span><span class="preprocessor">      char const * const FLOW_CFG_SET_DECL_OPT_MANUAL_name_c_str = ARG_opt_name_c_str; \</span></div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span><span class="preprocessor">      </span><span class="comment">/* Subtlety: This is only safe to use here synchronously. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span><span class="preprocessor">      const ::flow::util::String_view FLOW_CFG_SET_DECL_OPT_MANUAL_name_view(FLOW_CFG_SET_DECL_OPT_MANUAL_name_c_str); \</span></div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span><span class="preprocessor">      const bool FLOW_CFG_SET_DECL_OPT_MANUAL_no_acc = ARG_no_accumulation; \</span></div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span><span class="preprocessor">      switch (args.m_call_type) \</span></div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span><span class="preprocessor">      { \</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_FILL_PARSING_ROLE_OPT_TABLE: \</span></div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span><span class="preprocessor">      { \</span></div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span><span class="preprocessor">        using Value = decltype(args.m_args.m_fill_parsing_role_opt_table_args.m_values_candidate-&gt;ARG_m_value); \</span></div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span><span class="preprocessor">        </span><span class="comment">/* Subtlety: Copy input NUL-terminated char* into lambda string capture just in case they give us */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span><span class="preprocessor">        </span><span class="comment">/* not the usual `static` string literal as ARG_opt_name_c_str. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span><span class="preprocessor">        flow::Function&lt;bool (const Value&amp;)&gt; FLOW_CFG_SET_DECL_OPT_MANUAL_validator_func \</span></div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span><span class="preprocessor">          = [FLOW_CFG_SET_DECL_OPT_MANUAL_name_std_str = std::string(FLOW_CFG_SET_DECL_OPT_MANUAL_name_c_str)] \</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span><span class="preprocessor">              ([[maybe_unused]] const Value&amp; val) -&gt; bool { return ARG_bool_validate_expr; }; \</span></div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span><span class="preprocessor">        args.m_args.m_fill_parsing_role_opt_table_args.m_option_set \</span></div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span><span class="preprocessor">          -&gt;declare_option_for_parsing \</span></div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span><span class="preprocessor">              (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span><span class="preprocessor">               &amp;args.m_args.m_fill_parsing_role_opt_table_args.m_values_candidate-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span><span class="preprocessor">               </span><span class="comment">/* Default is irrelevant if option accumulates from parse to parse.  Pass null. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span><span class="preprocessor">               </span><span class="comment">/* Default from Value_set() shall be in effect at construction time, but that&#39;s it. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"> 1394</span><span class="preprocessor">               </span><span class="comment">/* However if it&#39;s set as a non-accumulating option via knob, then pass-through the default: */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span><span class="preprocessor">               </span><span class="comment">/* each parse via boost.program_options shall first reset option to that default; then if present */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span><span class="preprocessor">               </span><span class="comment">/* overwrite that default.  Hence the value from any preceding parse is always forgotten. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span><span class="preprocessor">               FLOW_CFG_SET_DECL_OPT_MANUAL_no_acc \</span></div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span><span class="preprocessor">                 ? &amp;args.m_args.m_fill_parsing_role_opt_table_args.m_values_default_no_acc-&gt;ARG_m_value \</span></div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span><span class="preprocessor">                 : nullptr, \</span></div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span><span class="preprocessor">               ::std::move(FLOW_CFG_SET_DECL_OPT_MANUAL_validator_func), \</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span><span class="preprocessor">               ::flow::util::String_view(#ARG_bool_validate_expr)); \</span></div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"> 1403</span><span class="preprocessor">      } \</span></div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE: \</span></div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span><span class="preprocessor">        args.m_args.m_fill_output_help_role_opt_table_args.m_option_set \</span></div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span><span class="preprocessor">          -&gt;declare_option_for_help \</span></div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span><span class="preprocessor">              (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span><span class="preprocessor">               args.m_args.m_fill_output_help_role_opt_table_args.m_values_default-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span><span class="preprocessor">               ARG_description); \</span></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE: \</span></div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span><span class="preprocessor">        ::flow::cfg::Option_set_base::declare_option_for_output \</span></div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span><span class="preprocessor">          (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span><span class="preprocessor">           args.m_args.m_fill_output_current_role_opt_table_args.m_target_opts, \</span></div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span><span class="preprocessor">           args.m_args.m_fill_output_current_role_opt_table_args.m_values_default-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span><span class="preprocessor">           args.m_args.m_fill_output_current_role_opt_table_args.m_values_current-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"> 1417</span><span class="preprocessor">           ARG_description); \</span></div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_COMPARE_PARSED_VALS: \</span></div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span><span class="preprocessor">        args.m_args.m_compare_parsed_vals_args.m_option_set \</span></div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span><span class="preprocessor">          -&gt;scan_parsed_option \</span></div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span><span class="preprocessor">              (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span><span class="preprocessor">               args.m_args.m_compare_parsed_vals_args.m_option_set-&gt;values().ARG_m_value); \</span></div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_LOAD_VALS_AS_IF_PARSED: \</span></div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span><span class="preprocessor">        args.m_args.m_load_val_as_if_parsed_args.m_option_set \</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span><span class="preprocessor">          -&gt;load_option_value_as_if_parsed \</span></div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span><span class="preprocessor">              (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span><span class="preprocessor">               &amp;args.m_args.m_load_val_as_if_parsed_args.m_values_candidate-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span><span class="preprocessor">               args.m_args.m_load_val_as_if_parsed_args.m_values_to_load-&gt;ARG_m_value); \</span></div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span><span class="preprocessor">      case ::flow::cfg::Option_set_base::Declare_options_func_call_type::S_VALIDATE_STORED_VALS: \</span></div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span><span class="preprocessor">      { \</span></div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span><span class="preprocessor">        </span><span class="comment">/* Set up validator func similarly to above; see those comments. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span><span class="preprocessor">        using Value = decltype(args.m_args.m_validate_stored_vals_args.m_values_to_validate-&gt;ARG_m_value); \</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"> 1436</span><span class="preprocessor">        flow::Function&lt;bool (const Value&amp;)&gt; FLOW_CFG_SET_DECL_OPT_MANUAL_validator_func \</span></div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span><span class="preprocessor">          = [FLOW_CFG_SET_DECL_OPT_MANUAL_name_std_str = std::string(FLOW_CFG_SET_DECL_OPT_MANUAL_name_c_str)] \</span></div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span><span class="preprocessor">              ([[maybe_unused]] const Value&amp; val) -&gt; bool { return ARG_bool_validate_expr; }; \</span></div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span><span class="preprocessor">        </span><span class="comment">/* Throw if invalid; else no-op. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span><span class="preprocessor">        ::flow::cfg::Option_set_base::validate_parsed_option \</span></div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span><span class="preprocessor">          (FLOW_CFG_SET_DECL_OPT_MANUAL_name_view, \</span></div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span><span class="preprocessor">           args.m_args.m_validate_stored_vals_args.m_values_to_validate-&gt;ARG_m_value, \</span></div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span><span class="preprocessor">           ::std::move(FLOW_CFG_SET_DECL_OPT_MANUAL_validator_func), \</span></div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span><span class="preprocessor">           ::flow::util::String_view(#ARG_bool_validate_expr)); \</span></div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span><span class="preprocessor">        break; \</span></div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span><span class="preprocessor">      } \</span></div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span><span class="preprocessor">      </span><span class="comment">/* No `default:` intentionally: most compilers should catch a missing enum value and warn. */</span><span class="preprocessor"> \</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span><span class="preprocessor">      } \</span></div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span><span class="preprocessor">    ) </span><span class="comment">// FLOW_UTIL_SEMICOLON_SAFE()</span></div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span> </div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span><span class="comment">// Template implementations.</span></div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span> </div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"> 1453</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2"> 1454</a></span><a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2">Option_set&lt;Value_set&gt;::Option_set</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr, <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> nickname,</div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span>                                  <a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a>&amp;&amp; declare_opts_func_moved) :</div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"> 1456</span>  log::Log_context(logger_ptr, <a class="code hl_enumeration" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">Flow_log_component</a>::S_CFG),</div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span>  m_nickname(nickname),</div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span>  m_null(true),</div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span>  m_declare_opts_func(std::move(declare_opts_func_moved)),</div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span>  m_parsing(false)</div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span>{</div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span>  <span class="comment">// Avoid INFO logging, in case they&#39;re only creating us to print some help and exit.  Not essential info here.</span></div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Created with default values payload.  Options table setup begins.&quot;</span>);</div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span> </div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span>  <span class="comment">// Refer to the doc headers for Opt_table and Declare_options_func to understand the next couple of calls.</span></div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span> </div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span>  <span class="comment">// Load the *parsing-role* Opt_table m_opts_for_parsing.  Its contents won&#39;t change after this.</span></div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span>  <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> args;</div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = <a class="code hl_enumvalue" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda4f70649bf85f31925dd145af4c67025c">Declare_options_func_args::Call_type::S_FILL_PARSING_ROLE_OPT_TABLE</a>;</div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a1a35f61a3ebedfdd443e6f050e674aa9">m_fill_parsing_role_opt_table_args</a> = { <span class="keyword">this</span>, &amp;<a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#adfd72b4b73913193252a02d35acdff09">m_values_candidate</a>, &amp;<a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#aea72e19fce43c10c84f6445f1892de41">m_values_default</a> };</div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span>  <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a94ce83bb7ca160d551fa87daeb288493">m_declare_opts_func</a>(args);</div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span>  <span class="comment">// m_null is now permanently true or false.</span></div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span> </div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span>  <span class="comment">/* Load the *output-role* (help text sub-role) Opt_table.  The defaults source is the current Value_set m_values</span></div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span><span class="comment">   * itself (since it was just loaded up with defaults by definition).  It again won&#39;t change after this. */</span></div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = <a class="code hl_enumvalue" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda2525895c3e467823cc3450761eaac825">Declare_options_func_args::Call_type::S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE</a>;</div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a32c9e1f9d46f3379bbb95a4aada644ba">m_fill_output_help_role_opt_table_args</a> = { <span class="keyword">this</span>, &amp;<a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#aea72e19fce43c10c84f6445f1892de41">m_values_default</a> };</div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span>  <a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a94ce83bb7ca160d551fa87daeb288493">m_declare_opts_func</a>(args);</div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span> </div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Options table setup finished.  Null set? = [&quot;</span> &lt;&lt; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">null</a>() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span>} <span class="comment">// Option_set::Option_set()</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span> </div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c"> 1484</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">Option_set&lt;Value_set&gt;::null</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span>  <span class="keywordflow">return</span> m_null;</div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span>}</div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span> </div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a"> 1490</a></span><span class="keyword">const</span> Value_set&amp; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a">Option_set&lt;Value_set&gt;::values</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"> 1492</span>  <span class="keywordflow">return</span> m_values;</div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"> 1493</span>}</div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"> 1494</span> </div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"> 1495</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f"> 1496</a></span><span class="keyword">typename</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">Option_set&lt;Value_set&gt;::Mutable_values_ptr</a> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f">Option_set&lt;Value_set&gt;::mutable_values_copy</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span>  <span class="keywordflow">return</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">Mutable_values_ptr</a>(<span class="keyword">new</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>(values()));</div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span>}</div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span> </div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215"> 1502</a></span><span class="keyword">const</span> Value_set* <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215">Option_set&lt;Value_set&gt;::values_candidate</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"> 1504</span>  <span class="keywordflow">return</span> m_parsing ? &amp;m_values_candidate : 0;</div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"> 1505</span>}</div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"> 1506</span> </div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"> 1507</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633"> 1508</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633">Option_set&lt;Value_set&gt;::values_to_ostream</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>* values_or_null)<span class="keyword"> const</span></div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span>  <span class="comment">/* Provide more real estate than the default 80, since this is chiefly for value output, probably in logs.</span></div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span><span class="comment">   * And just put the description on the next line always. */</span></div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span>  <span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> LINE_LENGTH = 1000;</div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span>  <span class="keyword">constexpr</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DESC_LENGTH = LINE_LENGTH - 1;</div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span> </div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span>  <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a> opts_for_output(LINE_LENGTH, DESC_LENGTH);</div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"> 1516</span> </div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"> 1517</span>  <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> args;</div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"> 1518</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = Declare_options_func_args::Call_type::S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE;</div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"> 1519</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a391e72f142afe97b89e4e106bf443801">m_fill_output_current_role_opt_table_args</a></div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span>    = { &amp;opts_for_output, &amp;m_values_default,</div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span>        values_or_null ? values_or_null : &amp;m_values };</div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span>  m_declare_opts_func(args);</div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span> </div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span>  os &lt;&lt; opts_for_output; <span class="comment">// Leverage boost.program_options to print the nicely formatted current+defaults+descriptions.</span></div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span>}</div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span> </div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214"> 1528</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214">Option_set&lt;Value_set&gt;::log_values</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, <span class="keyword">const</span> Value_set* values_or_null, <a class="code hl_enumeration" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev)<span class="keyword"> const</span></div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"> 1529</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"> 1530</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"> 1531</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span> </div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span>  String_ostream os;</div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span>  values_to_ostream(os.os(), values_or_null);</div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span>  os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span>  <a class="code hl_define" href="log_8hpp.html#a692bbadd8b5c3e9cef7a0bbea1915e66">FLOW_LOG_WITH_CHECKING</a>(sev, <span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Values payload [&quot;</span> &lt;&lt; summary &lt;&lt; <span class="stringliteral">&quot;]:\n&quot;</span> &lt;&lt; os.str());</div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span>}</div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span> </div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3"> 1540</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3">Option_set&lt;Value_set&gt;::help_to_ostream</a>(std::ostream&amp; os)<span class="keyword"> const</span></div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"> 1541</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"> 1542</span>  os &lt;&lt; m_opts_for_help; <span class="comment">// Leverage boost.program_options to print the nicely formatted defaults+descriptions.</span></div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"> 1543</span>}</div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"> 1544</span> </div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4"> 1546</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4">Option_set&lt;Value_set&gt;::log_help</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, <a class="code hl_enumeration" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev)<span class="keyword"> const</span></div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span> </div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span>  String_ostream os;</div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span>  help_to_ostream(os.os());</div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span>  os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"> 1554</span>  <a class="code hl_define" href="log_8hpp.html#a692bbadd8b5c3e9cef7a0bbea1915e66">FLOW_LOG_WITH_CHECKING</a>(sev, <span class="stringliteral">&quot;Config usage [&quot;</span> &lt;&lt; summary &lt;&lt; <span class="stringliteral">&quot;]:\n&quot;</span> &lt;&lt; os.str());</div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"> 1555</span>}</div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"> 1556</span> </div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"> 1557</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1"> 1558</a></span><span class="keyword">const</span> boost::unordered_set&lt;std::string&gt;&amp; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1">Option_set&lt;Value_set&gt;::option_names</a>()<span class="keyword"> const</span></div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span>  <span class="keywordflow">return</span> m_opt_names;</div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span>}</div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span> </div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa"> 1565</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa">Option_set&lt;Value_set&gt;::declare_option_for_parsing</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name_view,</div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"> 1566</span>                                                       Value* target_value, <span class="keyword">const</span> Value* value_default_if_no_acc,</div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"> 1567</span>                                                       <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"> 1568</span>                                                       <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str_view)</div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"> 1569</span>{</div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"> 1570</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span>  <span class="keyword">using </span>opts::value;</div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span> </div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span>  assert(target_value);</div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span>  <span class="keywordtype">string</span> name(name_view);</div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"> 1577</span> </div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span>  m_opt_names.insert(name);</div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"> 1579</span> </div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"> 1580</span>  <span class="comment">// Avoid INFO logging, in case they&#39;re only creating us to print some help and exit.  Not essential info here.</span></div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"> 1581</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Options table of parsing-role: &quot;</span></div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span>                 <span class="stringliteral">&quot;Declaring parsing-capable option [&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;]; raw shallow size [&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Value) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span> </div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span>  <span class="comment">/* *Parsing-role* target is within m_values_candidate.  No default: if not in config, it&#39;ll just be left untouched.</span></div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span><span class="comment">   * The validator function we create shall throw on validation failure, having been passed `const Value&amp; val` by the</span></div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span><span class="comment">   * options engine. */</span></div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span>  <span class="keyword">const</span> <span class="keyword">auto</span> val_spec = value&lt;Value&gt;(target_value)</div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span>                          -&gt;notifier(throw_on_invalid_func(name_view, std::move(validator_func_moved),</div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span>                                                           validator_cond_str_view));</div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"> 1590</span>  <span class="comment">/* However: if non-accumulating mode is enabled then, in fact, set the value from Value_set()</span></div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"> 1591</span><span class="comment">   * as default_value(); so that starting to parse a config source (e.g., config file) shall always reset to default</span></div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"> 1592</span><span class="comment">   * first instead of accumulating from a previous parse (if any).  This matters for a given parse only if this</span></div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span><span class="comment">   * option is not specified in that config source. */</span></div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span>  <span class="keywordflow">if</span> (value_default_if_no_acc)</div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span>  {</div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span>    <span class="comment">// Subtlety re. default_value(2 args): Same as in declare_option_for_help().</span></div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span>    String_ostream default_str_os;</div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span>    <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(default_str_os.os(), *value_default_if_no_acc);</div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span>    default_str_os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span> </div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"> 1601</span>    val_spec-&gt;default_value(*value_default_if_no_acc, default_str_os.str());</div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"> 1602</span>  }</div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"> 1603</span> </div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span>  m_opts_for_parsing.add_options()(name.c_str(), val_spec);</div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span> </div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span>  m_null = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span>} <span class="comment">// Option_set::declare_option_for_parsing()</span></div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span> </div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838"> 1610</a></span><a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;void (<span class="keyword">const</span> Value&amp; val)&gt; <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">Option_set_base::throw_on_invalid_func</a></div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span>                                    (<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name_view,</div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span>                                     <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"> 1613</span>                                     <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str_view) <span class="comment">// Static.</span></div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"> 1614</span>{</div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"> 1615</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1error_1_1Runtime__error.html">error::Runtime_error</a>;</div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"> 1616</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span> </div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span>  <span class="keywordflow">return</span> [validator_func = std::move(validator_func_moved),</div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span>          validator_cond_str = string(validator_cond_str_view),</div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span>          name = string(name_view)]</div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span>           (<span class="keyword">const</span> Value&amp; val)</div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span>  {</div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"> 1625</span>    <span class="keywordflow">if</span> (!(validator_func(val)))</div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"> 1626</span>    {</div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"> 1627</span>      String_ostream msg_os;</div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"> 1628</span>      msg_os.<a class="code hl_function" href="classflow_1_1util_1_1String__ostream.html#a7e64b069ae0e221952068c13fdc0f080">os</a>() &lt;&lt; <span class="stringliteral">&quot;Option [&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span></div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"> 1629</span>                     <span class="stringliteral">&quot;Validation failed; the following condition must hold: [&quot;</span> &lt;&lt; validator_cond_str &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span>                     <span class="stringliteral">&quot;Option value `val` = [&quot;</span>;</div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span>      <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(msg_os.os(), val);</div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span>      msg_os.os() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span> &lt;&lt; flush;</div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span>      <span class="keywordflow">throw</span> Runtime_error(msg_os.str());</div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span>    }</div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span>  };</div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span>} <span class="comment">// Option_set_base::throw_on_invalid_func()</span></div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"> 1637</span> </div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"> 1638</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"> 1639</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce"> 1640</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce">Option_set&lt;Value_set&gt;::declare_option_for_help</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name,</div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span>                                                    <span class="keyword">const</span> Value&amp; value_default, <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description)</div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span>{</div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span>  <span class="keyword">using </span>opts::value;</div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span> </div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span>  assert(!description.empty());</div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span> </div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span>  <span class="comment">/* Subtlety: The is also a -&gt;default_value(1 arg) overload, which always uses ostream&lt;&lt; for output, but (as</span></div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span><span class="comment">   * elsewhere) run it through our possible output massaging machinery by providing the string to output.  Hence use</span></div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span><span class="comment">   * the 2-arg version which takes an explicit string.  @todo Could also implement a proxy type with an operator&lt;&lt;</span></div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span><span class="comment">   * ostream overload to make these call sites more elegant/concise. */</span></div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span>  String_ostream default_str_os;</div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span>  <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(default_str_os.os(), value_default);</div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span>  default_str_os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"> 1657</span> </div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"> 1658</span>  m_opts_for_help.add_options()</div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"> 1659</span>    (string(name).c_str(),</div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"> 1660</span>     <span class="comment">// *Output-role* has no target; it does output, not input.</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"> 1661</span>     value&lt;Value&gt;()</div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span>       -&gt;default_value(value_default, default_str_os.str()),</div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span>     string(description).c_str());</div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span> </div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span>  <span class="comment">// No need to log: logs are only interesting when setting up the parsing table.  This&#39;d just be verbose/redundant.</span></div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span>} <span class="comment">// Option_set::declare_option_for_help()</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span> </div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b"> 1669</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b">Option_set_base::declare_option_for_output</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a>* target_opts,</div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"> 1670</span>                                                <span class="keyword">const</span> Value&amp; value_default, <span class="keyword">const</span> Value&amp; current_value,</div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"> 1671</span>                                                <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description) <span class="comment">// Static.</span></div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"> 1672</span>{</div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"> 1673</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1util_1_1String__ostream.html">util::String_ostream</a>;</div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span>  <span class="keyword">using </span>opts::value;</div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span>  <span class="keyword">using </span>std::flush;</div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span> </div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span>  assert(!description.empty());</div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span> </div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span>  <span class="comment">/* This is similar to declare_option_for_help() with 2 differences:</span></div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span><span class="comment">   *   - The target is passed to us, *target_opts, as they will be printing that, and it depends on a current value</span></div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span><span class="comment">   *     which changes over time, hence we can&#39;t just plant this in some data member the way we did with</span></div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span><span class="comment">   *     m_opts_for_help.</span></div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span><span class="comment">   *   - In addition to the default, add the current value into the output by massaging the description text.</span></div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span><span class="comment">   *     We are printing a current value which will go into the description text here, while the default will</span></div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"> 1686</span><span class="comment">   *     go into the default slot of the &quot;usage&quot; output to ostream. */</span></div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"> 1687</span>  String_ostream description_os;</div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"> 1688</span> </div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"> 1689</span>  <span class="comment">// Visually match how boost.program_options prints the default value above us.</span></div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span> </div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span>  description_os.os() &lt;&lt; <span class="stringliteral">&quot;    (&quot;</span>;</div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span>  <span class="comment">/* Always pass any user output of Value_set members through our possible specialization/overload around ostream&lt;&lt;,</span></div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span><span class="comment">   * as we may want to apply some us-specific massaging. */</span></div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span>  <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(description_os.os(), current_value);</div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span>  description_os.os() &lt;&lt; <span class="stringliteral">&quot;) &lt;==current | default==^\n&quot;</span></div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span>                         <span class="stringliteral">&quot;      &quot;</span> &lt;&lt; description &lt;&lt; flush;</div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span> </div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span>  <span class="comment">// Subtlety re. default_value(2 args): Same as in declare_option_for_help().</span></div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span>  String_ostream default_str_os;</div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span>  <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(default_str_os.os(), value_default);</div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span>  default_str_os.os() &lt;&lt; flush;</div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span> </div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span>  target_opts-&gt;add_options()</div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span>    (string(name).c_str(),</div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span>     <span class="comment">// *Output-role* has no target; it does output, not input.</span></div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span>     value&lt;Value&gt;()</div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"> 1707</span>       -&gt;default_value(value_default, default_str_os.str()),</div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"> 1708</span>     description_os.str().c_str());</div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"> 1709</span> </div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"> 1710</span>  <span class="comment">// No need to log: logs are only interesting when setting up the parsing table.  This&#39;d just be verbose/redundant.</span></div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span>} <span class="comment">// Option_set_base::declare_option_for_output()</span></div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span> </div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8"> 1715</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8">Option_set&lt;Value_set&gt;::scan_parsed_option</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name_view, <span class="keyword">const</span> Value&amp; canonical_value)</div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span>{</div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span>  <span class="keyword">using </span>boost::any_cast;</div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span>  <span class="keywordtype">string</span> name(name_view);</div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span> </div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span>  <span class="comment">/* In this mode we are basically to check whether the value just parsed for `name`, which is in</span></div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"> 1722</span><span class="comment">   * m_iterable_values_candidate[name], is actually *different* from the current canonical value, which is</span></div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"> 1723</span><span class="comment">   * in canonical_value.  If so we are to leave it there; if not, we are to remove it,</span></div>
<div class="line"><a id="l01724" name="l01724"></a><span class="lineno"> 1724</span><span class="comment">   * thus maintaining the invariant wherein m_iterable_values_candidate mirrors m_values_candidate, except for those</span></div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"> 1725</span><span class="comment">   * options whose values have not changed. */</span></div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span> </div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span>  <span class="keyword">const</span> <span class="keyword">auto</span> it = m_iterable_values_candidate.find(name);</div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span>  <span class="keywordflow">if</span> (it == m_iterable_values_candidate.end())</div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span>  {</div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span>    <span class="keywordflow">return</span>; <span class="comment">// Option was not parsed.</span></div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span>  }</div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span> </div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; new_val = any_cast&lt;const Value&amp;&gt;(it-&gt;second);</div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; old_val = canonical_value;</div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span> </div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span>  <span class="keywordflow">if</span> (old_val == new_val)</div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span>  {</div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span>    m_iterable_values_candidate.erase(name);</div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span>  }</div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span>  <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"> 1742</span>} <span class="comment">// Option_set::scan_parsed_option()</span></div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"> 1743</span> </div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"> 1744</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"> 1745</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae"> 1746</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae">Option_set&lt;Value_set&gt;::load_option_value_as_if_parsed</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name_view,</div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span>                                                           Value* target_value,</div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span>                                                           <span class="keyword">const</span> Value&amp; source_value)</div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span>{</div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span>  <span class="keywordtype">string</span> name(name_view);</div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span> </div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span>  assert(target_value);</div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span>  assert(m_parsing);</div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span> </div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span>  <span class="comment">/* Getting here is hairy to understand, but our task is simple: Modify *this as-if</span></div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span><span class="comment">   * *target_value -- which is a member of m_values_candidate -- was parsed from some config source, yielding</span></div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span><span class="comment">   * in valid value source_value.  We must update our state (given that m_parsing is true) accordingly. */</span></div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"> 1759</span> </div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"> 1760</span>  <span class="comment">// This is the obvious part: set the thing inside m_values_candidate.</span></div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"> 1761</span>  *target_value = source_value;</div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"> 1762</span> </div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span>  <span class="comment">// Now mirror it in m_iterable_values_candidate to maintain that invariant.</span></div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span>  m_iterable_values_candidate[name] = source_value;</div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span> </div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span>  <span class="comment">/* That&#39;s it.  Just picture it as if &lt;name_view contents&gt;=&lt;encoding of source_value&gt; was in a config file,</span></div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span><span class="comment">   * and parse_config_file() just did a store()/notify() of that line alone and hence updated</span></div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span><span class="comment">   * m_iterable_values_candidate accordingly.  What we did above equals that; it&#39;s just much simpler to do</span></div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span><span class="comment">   * than actual parsing, since we have the value given to us directly in source_value. */</span></div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span>}</div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span> </div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43"> 1773</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43">Option_set_base::validate_parsed_option</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name_view, <span class="keyword">const</span> Value&amp; value,</div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"> 1774</span>                                             <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">bool</span> (<span class="keyword">const</span> Value&amp; val)&gt;&amp;&amp; validator_func_moved,</div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"> 1775</span>                                             <a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str_view) <span class="comment">// Static.</span></div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"> 1776</span>{</div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"> 1777</span>  <span class="keyword">const</span> <span class="keyword">auto</span> validate_or_throw_func = <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">throw_on_invalid_func</a>(name_view, std::move(validator_func_moved),</div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span>                                                            validator_cond_str_view);</div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span>  validate_or_throw_func(value);</div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span>} <span class="comment">// Option_set_base::validate_parsed_option()</span></div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span> </div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128"> 1783</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128">Option_set&lt;Value_set&gt;::parse_config_file</a></div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span>       (<span class="keyword">const</span> fs::path&amp; cfg_path, <span class="keywordtype">bool</span> allow_unregistered, <span class="keywordtype">bool</span>* success_or_null,</div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span>        <span class="keyword">const</span> boost::unordered_set&lt;std::string&gt;&amp; allowed_unregistered_opts_or_empty)</div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span>{</div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span>  <span class="keyword">using </span><a class="code hl_class" href="classflow_1_1error_1_1Runtime__error.html">error::Runtime_error</a>;</div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"> 1788</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">util::ostream_op_string</a>;</div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"> 1789</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">util::key_exists</a>;</div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"> 1790</span>  <span class="keyword">using </span>opts::notify;</div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"> 1791</span>  <span class="keyword">using </span>opts::store;</div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span>  <span class="keyword">using </span>opts::variables_map;</div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span>  <span class="keyword">using </span>boost::system::system_category;</div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span>  <span class="keyword">using </span>fs::ifstream;</div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span>  <span class="keyword">using </span>std::exception;</div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span> </div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span>  <span class="comment">// If they invoked us in non-throwing mode, call selves recursively in throwing mode and catch it.</span></div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span>  <span class="keywordflow">if</span> (success_or_null)</div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span>  {</div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span>    <span class="keywordflow">try</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"> 1802</span>    {</div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span>      parse_config_file(cfg_path, allow_unregistered, 0, allowed_unregistered_opts_or_empty);</div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span>    }</div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span>    <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"> 1806</span>    {</div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"> 1807</span>      <span class="comment">// We already logged on exception; be quiet.</span></div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"> 1808</span>      *success_or_null = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span>    }</div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span>    *success_or_null = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span>  }</div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span>  <span class="comment">// else: Throw an exception on error.  Perf not a real concern.</span></div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span> </div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span>  <span class="keywordflow">if</span> (!m_parsing)</div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span>  {</div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span>    m_parsing = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State CANONICAL: Request to parse file [&quot;</span> &lt;&lt; cfg_path &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span>                  <span class="stringliteral">&quot;entering state PARSING.  Initial candidate values payload initialized from current canonical &quot;</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span>                  <span class="stringliteral">&quot;values payload.  Details follow (TRACE log level).&quot;</span>);</div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span> </div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span>    assert(m_iterable_values_candidate.empty());</div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"> 1824</span>  }</div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"> 1825</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"> 1826</span>  {</div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Request to parse file [&quot;</span> &lt;&lt; cfg_path &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span>                  <span class="stringliteral">&quot;continuing by parsing this next config source.  &quot;</span></div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span>                  <span class="stringliteral">&quot;The values payload going into it is as it was after the previous config source.  &quot;</span></div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span>                  <span class="stringliteral">&quot;Details follow (TRACE log level).&quot;</span>);</div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span>  }</div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span> </div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span>  log_values(<span class="stringliteral">&quot;pre-parsing candidate config&quot;</span>, &amp;m_values_candidate, <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>);</div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span> </div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span>  ifstream ifs(cfg_path);</div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span>  <span class="keywordflow">if</span> (!ifs)</div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"> 1837</span>  {</div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"> 1838</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> sys_err_code(errno, system_category());</div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"> 1839</span>    <a class="code hl_define" href="error_2error_8hpp.html#a019ee6e90802e444572dd78d312d6e23">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>();</div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"> 1840</span> </div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span>    <span class="keywordflow">throw</span> Runtime_error(sys_err_code, <a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">ostream_op_string</a>(<span class="stringliteral">&quot;Could not open file [&quot;</span>, cfg_path, <span class="stringliteral">&quot;].&quot;</span>));</div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span>  }</div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span> </div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span>  <span class="comment">/* parse_() can throw on invalid option values and so on!  In case it managed to touch m_values_candidate -- save it.</span></div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span><span class="comment">   * Our doc header(s) guarantee config payload is untouched unless parsing succeeds.</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span><span class="comment">   * @todo This may not be necessary.  boost.program_options is solid, but there&#39;s an uncommon (for Boost) looseness</span></div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"> 1848</span><span class="comment">   * to the documentation, including about error handling, so we don&#39;t find it trustworthy enough not to do this and</span></div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span><span class="comment">   * stay maintainable.  Still consider revisiting this and not catching the exception and not worrying about</span></div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span><span class="comment">   * backing this up -- if that&#39;s really how it works. */</span></div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span>  <span class="keyword">const</span> <span class="keyword">auto</span> values_candidate_backup = m_values_candidate;</div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"> 1852</span>  opts::parsed_options parsed_options(&amp;m_opts_for_parsing);</div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"> 1853</span>  <span class="keywordflow">try</span></div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"> 1854</span>  {</div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"> 1855</span>    parsed_options = opts::parse_config_file(ifs, m_opts_for_parsing, allow_unregistered);</div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span>  }</div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"> 1857</span>  <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span>  {</div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span>    m_values_candidate = values_candidate_backup;</div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"> 1860</span>    <span class="comment">// m_iterable_values_candidate is set below, so it hasn&#39;t been touched from this config source yet.</span></div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span> </div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: &quot;</span></div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"> 1863</span>                     <span class="stringliteral">&quot;Parsing file [&quot;</span> &lt;&lt; cfg_path &lt;&lt; <span class="stringliteral">&quot;]: Exception occurred; parse failed.  Values payload untouched.  &quot;</span></div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span>                     <span class="stringliteral">&quot;Message = [&quot;</span> &lt;&lt; exc.what() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span>  }</div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"> 1867</span>  <span class="comment">// Got here?  No problem parsing (but we haven&#39;t validated).  First a detour:</span></div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"> 1868</span> </div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"> 1869</span>  <span class="comment">/* If we were told to allow at least some (possibly all) unregistered options:</span></div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"> 1870</span><span class="comment">   * Log (at appropriate level) the unregistered options; log only the name part of the tokens for each (ignoring</span></div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span><span class="comment">   * any values); and fail if an un-approved unknown option shows up. */</span></div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span>  <span class="keywordflow">if</span> (allow_unregistered)</div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span>  {</div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; option : parsed_options.options)</div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span>    {</div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"> 1876</span>      <span class="keywordflow">if</span> (option.unregistered)</div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span>      {</div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span>        assert(!option.original_tokens.empty());</div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span>        <span class="keyword">const</span> <span class="keywordtype">string</span> opt_name = option.original_tokens.front();</div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span> </div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"> 1881</span>        <span class="keywordflow">if</span> (allowed_unregistered_opts_or_empty.empty())</div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"> 1882</span>        {</div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"> 1883</span>          <span class="comment">// Do not use INFO level; this can get verbose.</span></div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"> 1884</span>          <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Ignoring unregistered option named &quot;</span></div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; opt_name &lt;&lt; <span class="stringliteral">&quot;].  We were not given an approved-list.  Perhaps this file contains &quot;</span></div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span>                         <span class="stringliteral">&quot;other option sets, or it has to do with forward/backward-compatibility.&quot;</span>);</div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span>        }</div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span>        <span class="keywordflow">else</span></div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span>        {</div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span>          <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">key_exists</a>(allowed_unregistered_opts_or_empty, opt_name))</div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span>          {</div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span>            <span class="comment">// Same deal as above.</span></div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"> 1893</span>            m_values_candidate = values_candidate_backup;</div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span> </div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span>            <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Unregistered option named &quot;</span></div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"> 1896</span>                             <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; opt_name &lt;&lt; <span class="stringliteral">&quot;] is not approved; parse failed.  Values payload untouched.&quot;</span>);</div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"> 1897</span>            <span class="keywordflow">throw</span> Runtime_error(<a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">ostream_op_string</a>(<span class="stringliteral">&quot;Unregistered option named [&quot;</span>, opt_name,</div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"> 1898</span>                                                  <span class="stringliteral">&quot;] is not approved; parse failed.&quot;</span>));</div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"> 1899</span>          }</div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span>          <span class="comment">// else</span></div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"> 1901</span> </div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span>          <span class="comment">// Do not use INFO level; this can get verbose.</span></div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span>          <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Ignoring unregistered option named &quot;</span></div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; opt_name &lt;&lt; <span class="stringliteral">&quot;]; it is in the approved-list.  Perhaps this file contains &quot;</span></div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span>                         <span class="stringliteral">&quot;other option sets.&quot;</span>);</div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span>        } <span class="comment">// if (!allowed_unregistered_opts_or_empty.empty())</span></div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span>      } <span class="comment">// if (option.unregistered)</span></div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"> 1908</span>    } <span class="comment">// for (option : parsed_options.options)</span></div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span>    <span class="comment">// We don&#39;t care about them further.</span></div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span>  }</div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span>  <span class="comment">// else { Apparently there were no unknown options encountered, as it didn&#39;t throw when parsing. }</span></div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span> </div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span>  <span class="comment">// Store into a variables_map (a glorified map&lt;string, boost::any&gt;) and m_values_candidate.</span></div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"> 1914</span> </div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Parsed general format successfully.  &quot;</span></div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"> 1916</span>                 <span class="stringliteral">&quot;Will now parse each option&#39;s value.&quot;</span>);</div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"> 1917</span> </div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"> 1918</span>  <span class="comment">/* As explained in ###Rationale### in Iterable_values doc header, we use a fresh opts::variables_map as an</span></div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"> 1919</span><span class="comment">   * intermediary and load the results from that into our Iterable_values, overwriting any values already there</span></div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span><span class="comment">   * that were indeed set during this parse_*().  In other words, for every configured option N, it either does not</span></div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span><span class="comment">   * exist in m_iterable_values_candidate (in which case the value is still at its canonical m_values value), or it does</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"> 1922</span><span class="comment">   * as m_iterable_values_candidate[N] (in which case it has been parsed at least once in a previous config source&#39;s</span></div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span><span class="comment">   * parse step *and* is different from m_values).  Then after store() it will either be created or changed or remain</span></div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span><span class="comment">   * unchanged.  In the latter case we should remove it to maintain the invariant, wherein only keys for</span></div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"> 1925</span><span class="comment">   * changed-from-canonical options exist. */</span></div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span>  variables_map fresh_iterable_values;</div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span>  <span class="keywordflow">try</span></div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"> 1928</span>  {</div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span>    store(parsed_options, fresh_iterable_values);</div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"> 1930</span>  }</div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"> 1931</span>  <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"> 1932</span>  {</div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"> 1933</span>    <span class="comment">// Same deal as above.</span></div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span>    m_values_candidate = values_candidate_backup;</div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span> </div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: &quot;</span></div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span>                     <span class="stringliteral">&quot;Parsed file [&quot;</span> &lt;&lt; cfg_path &lt;&lt; <span class="stringliteral">&quot;]: Exception occurred; individual option parsing failed.  &quot;</span></div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span>                     <span class="stringliteral">&quot;Values payload untouched.  Message = [&quot;</span> &lt;&lt; exc.what() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span>  }</div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span> </div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Parsed each individual option successfully.  &quot;</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span>                 <span class="stringliteral">&quot;Will now further validate each option value logically and store on success.&quot;</span>);</div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"> 1944</span> </div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"> 1945</span>  <span class="comment">/* notify() will finish things by loading m_values_candidate members and validating them.</span></div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"> 1946</span><span class="comment">   * notify() can throw, particularly due to our own custom validating notifiers (see declare_option_for_parsing()). */</span></div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"> 1947</span>  <span class="keywordflow">try</span></div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"> 1948</span>  {</div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span>    notify(fresh_iterable_values);</div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span>  }</div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span>  <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span>  {</div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span>    <span class="comment">// Same deal as above.</span></div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span>    m_values_candidate = values_candidate_backup;</div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span> </div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: &quot;</span></div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span>                     <span class="stringliteral">&quot;Parsed file [&quot;</span> &lt;&lt; cfg_path &lt;&lt; <span class="stringliteral">&quot;]: Exception occurred; individual logical validation failed.  &quot;</span></div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span>                     <span class="stringliteral">&quot;Values payload untouched.  Message = [&quot;</span> &lt;&lt; exc.what() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"> 1959</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"> 1960</span>  }</div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"> 1961</span> </div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"> 1962</span>  <span class="comment">// As noted above transfer from the clean variables_map into our Iterable_values.</span></div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : fresh_iterable_values)</div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span>  {</div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; name = pair.first;</div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; var_value = pair.second.value(); <span class="comment">// boost.any.</span></div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span> </div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span>    assert((!<a class="code hl_function" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">key_exists</a>(m_iterable_values_candidate, name) ||</div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span>           (m_iterable_values_candidate[name].type() == var_value.type())));</div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span> </div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span>    m_iterable_values_candidate[name] = var_value; <span class="comment">// Copying boost.any copies the payload it holds.</span></div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span>  }</div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"> 1973</span> </div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span>  <span class="comment">// This is the part that removes each option such that it was just parsed, but the new value makes it == canonical.</span></div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span>  <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> args;</div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = Declare_options_func_args::Call_type::S_COMPARE_PARSED_VALS;</div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a4d18a90df12e3c632a2fd25fdc23224e">m_compare_parsed_vals_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a> = <span class="keyword">this</span>;</div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span>  m_declare_opts_func(args);</div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span> </div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"> 1980</span>  <span class="comment">/* m_values_candidate and its iterable mirror m_iterable_values_candidate have been filled in!</span></div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span><span class="comment">   * By definition the former contains the pre-parsing values, plus whatever was in the config source overwriting</span></div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span><span class="comment">   * zero or more of those.  m_iterable_values_candidate fully mirrors by including only those values different from</span></div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span><span class="comment">   * m_values_candidate.  This fact may be used in canonicalize_candidate().  (For now, though, we don&#39;t care about</span></div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"> 1984</span><span class="comment">   * m_iterable_values_candidate outside of keeping it updated after each parse.) */</span></div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"> 1985</span> </div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"> 1986</span>  <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Validate/store succeded.  &quot;</span></div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"> 1987</span>                 <span class="stringliteral">&quot;Further validation deferred until attempt to enter state CANONICAL.  &quot;</span></div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span>                 <span class="stringliteral">&quot;Updated values payload details follow.&quot;</span>);</div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span>  log_values(<span class="stringliteral">&quot;post-parsing candidate config&quot;</span>, &amp;m_values_candidate, <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>);</div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span>} <span class="comment">// Option_set::parse_config_file()</span></div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span> </div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc"> 1993</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc">Option_set&lt;Value_set&gt;::parse_direct_values</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; src_values)</div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"> 1994</span>{</div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"> 1995</span>  <span class="keywordflow">if</span> (!m_parsing)</div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"> 1996</span>  {</div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"> 1997</span>    m_parsing = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"> 1998</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State CANONICAL: Request to load values from source struct &quot;</span></div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span>                  <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; &amp;src_values &lt;&lt; <span class="stringliteral">&quot;]; entering state PARSING.  &quot;</span></div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span>                  <span class="stringliteral">&quot;Any preceding canonical state will be ignored.  Details follow (TRACE log level).&quot;</span>);</div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"> 2001</span> </div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span>    assert(m_iterable_values_candidate.empty());</div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"> 2003</span>  }</div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"> 2004</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"> 2005</span>  {</div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"> 2006</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Request to load values from source struct &quot;</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"> 2007</span>                  <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; &amp;src_values &lt;&lt; <span class="stringliteral">&quot;]; continuing by parsing this next config source.  &quot;</span></div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span>                  <span class="stringliteral">&quot;Any current candidate values payload will be overwritten entirely.  &quot;</span></div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span>                  <span class="stringliteral">&quot;Details follow (TRACE log level).&quot;</span>);</div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span>  }</div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span> </div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"> 2012</span>  <span class="comment">/* The best way to explain our task is... to me (ygoldfel), it&#39;s like parse_config_file() of an imaginary file</span></div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"> 2013</span><span class="comment">   * that would have contained every possible option, with values src_values.  We need to do the stuff to end up</span></div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"> 2014</span><span class="comment">   * in the same state.  (We already updated m_parsing if needed.)  Of course it&#39;s a lot easier to just load the values</span></div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"> 2015</span><span class="comment">   * as opposed to really parsing them (which can fail validation and other difficulties).  However we still need</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span><span class="comment">   * to update the same m_* state that the parsing would have.  Namely:</span></div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"> 2017</span><span class="comment">   *   - m_values_candidate should equal src_values (as far as each individual option goes).</span></div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span><span class="comment">   *   - m_iterable_values_candidate must be updated accordingly (see its doc header). */</span></div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span> </div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span>  <span class="comment">/* This work-horse will indeed update m_values_candidate as needed and mirror each value in</span></div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"> 2021</span><span class="comment">   * m_iterable_values_candidate[name].  In parse_config_file() that is what occurs through the step where</span></div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"> 2022</span><span class="comment">   * m_iterable_values_candidate is loaded from the variable_map generated by store()/notify(). */</span></div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"> 2023</span>  <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> args;</div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"> 2024</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = Declare_options_func_args::Call_type::S_LOAD_VALS_AS_IF_PARSED;</div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a47faf7f6307ae1bcea3e55577b102b41">m_load_val_as_if_parsed_args</a> = { <span class="keyword">this</span>, &amp;m_values_candidate, &amp;src_values };</div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span>  m_declare_opts_func(args);</div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span> </div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span>  <span class="comment">/* Now, m_iterable_values_candidate contains every (config-enabled) member of a Values struct.</span></div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span><span class="comment">   * Note, in particular, that this overwrites anything that may have been parsed from other config sources</span></div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"> 2030</span><span class="comment">   * until that point (as our log messages indicate) -- as all of src_values was copied over.</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"> 2031</span><span class="comment">   *</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"> 2032</span><span class="comment">   * All we need now is to ensure m_iterable_values_candidate stores *only* the values that were changed</span></div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"> 2033</span><span class="comment">   * compared to the canonical m_values.  For that we just do the same thing parse_config_file() would at this stage. */</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = Declare_options_func_args::Call_type::S_COMPARE_PARSED_VALS;</div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a4d18a90df12e3c632a2fd25fdc23224e">m_compare_parsed_vals_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">m_option_set</a> = <span class="keyword">this</span>;</div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"> 2036</span>  m_declare_opts_func(args);</div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span> </div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span>  log_values(<span class="stringliteral">&quot;post-loading (perhaps baseline or rewound) candidate config&quot;</span>, &amp;m_values_candidate, <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>);</div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span>} <span class="comment">// Option_set::parse_direct_values()</span></div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"> 2040</span> </div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"> 2041</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49"> 2042</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49">Option_set&lt;Value_set&gt;::canonicalize_candidate</a>(<span class="keywordtype">bool</span>* change_detected)</div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"> 2043</span>{</div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">util::key_exists</a>;</div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span> </div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span>  assert(m_parsing);</div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"> 2047</span> </div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span>  <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Entering state CANONICAL.  &quot;</span></div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span>                <span class="stringliteral">&quot;Values payload finalized.  Details follow (TRACE log level).&quot;</span>);</div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"> 2050</span>  log_values(<span class="stringliteral">&quot;entering-CANONICAL-state finalized config&quot;</span>, &amp;m_values_candidate, <a class="code hl_enumvalue" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">log::Sev::S_TRACE</a>);</div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"> 2051</span> </div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"> 2052</span>  <span class="comment">/* Before finalizing m_values from m_values_candidate let&#39;s examine changes.</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"> 2053</span><span class="comment">   * m_iterable_values_candidate maintains the invariant of only include those options whose values have changed</span></div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span><span class="comment">   * vs. m_values.  So this is trivial. */</span></div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span> </div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : m_iterable_values_candidate)</div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span>  {</div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; name = pair.first;</div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"> 2059</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Detected change in option named [&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"> 2060</span>  }</div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"> 2061</span> </div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"> 2062</span>  <span class="keywordflow">if</span> (change_detected)</div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span>  {</div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span>    *change_detected = (!m_iterable_values_candidate.empty());</div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span>  }</div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span> </div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span>  <span class="comment">// All is right with the world.</span></div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"> 2068</span> </div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"> 2069</span>  m_parsing = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"> 2070</span>  m_values = m_values_candidate;</div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"> 2071</span>  m_iterable_values_candidate.clear();</div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span>} <span class="comment">// Option_set::canonicalize_candidate()</span></div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span> </div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587"> 2075</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587">Option_set&lt;Value_set&gt;::reject_candidate</a>()</div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span>{</div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"> 2077</span>  <span class="keywordflow">if</span> (m_parsing)</div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"> 2078</span>  {</div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"> 2079</span>    <a class="code hl_define" href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a>(<span class="stringliteral">&quot;Option_set[&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: State PARSING: Rejecting candidate payload built; &quot;</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"> 2080</span>                  <span class="stringliteral">&quot;reverting to state CANONICAL.&quot;</span>);</div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span>    m_parsing = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span>    m_iterable_values_candidate.clear();</div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span>    <span class="comment">// m_values remains unchanged.  m_values_candidate becomes meaningless (see its doc header: m_parsing == false now).</span></div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span>  }</div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span>}</div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"> 2086</span> </div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"> 2087</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3"> 2088</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">Option_set&lt;Value_set&gt;::validate_values</a>(<span class="keywordtype">bool</span>* success_or_null)<span class="keyword"> const</span></div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"> 2089</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span>  validate_values(values(), success_or_null);</div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span>}</div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span> </div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2"> 2094</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2">Option_set&lt;Value_set&gt;::validate_values_candidate</a>(<span class="keywordtype">bool</span>* success_or_null)<span class="keyword"> const</span></div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"> 2096</span>  <span class="keyword">const</span> <span class="keyword">auto</span> candidate = values_candidate();</div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"> 2097</span>  assert(candidate &amp;&amp; <span class="stringliteral">&quot;Do not invoke validate_values_candidate() in CANONICAL state; only while PARSING.&quot;</span>);</div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"> 2098</span>  validate_values(*candidate, success_or_null);</div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"> 2099</span>}</div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span> </div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a7f3924bff19cae0beb9f06b6dffbd504"> 2102</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">Option_set&lt;Value_set&gt;::validate_values</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger_ptr, <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; values_to_validate,</div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Declare_options_func</a>&amp; declare_opts_func,</div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span>                                            <span class="keywordtype">bool</span>* success_or_null) <span class="comment">// Static.</span></div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span>{</div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"> 2106</span>  <span class="keyword">using </span>std::exception;</div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"> 2107</span> </div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"> 2108</span>  <span class="comment">// If they invoked us in non-throwing mode, call selves recursively in throwing mode and catch it.</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"> 2109</span>  <span class="keywordflow">if</span> (success_or_null)</div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span>  {</div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span>    <span class="keywordflow">try</span></div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span>    {</div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span>      validate_values(logger_ptr, values_to_validate, declare_opts_func);</div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span>    }</div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"> 2115</span>    <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"> 2116</span>    {</div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"> 2117</span>      <span class="comment">// We already logged on exception; be quiet.</span></div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"> 2118</span>      *success_or_null = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span>    }</div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span>    *success_or_null = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span>  }</div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"> 2124</span>  <span class="comment">// else: Throw an exception on error.  Perf not a real concern.</span></div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"> 2125</span> </div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"> 2126</span>  <a class="code hl_define" href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95">FLOW_LOG_SET_CONTEXT</a>(logger_ptr, Flow_log_component::S_CFG);</div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"> 2127</span> </div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span>  <a class="code hl_struct" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> args;</div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">m_call_type</a> = Declare_options_func_args::Call_type::S_VALIDATE_STORED_VALS;</div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span>  args.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">m_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae780a398078db2299e8a5c3714bcb987">m_validate_stored_vals_args</a>.<a class="code hl_variable" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a75ab66920b874488bed052a90bc716d5">m_values_to_validate</a> = &amp;values_to_validate;</div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span>  <span class="keywordflow">try</span></div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span>  {</div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"> 2133</span>    <span class="comment">/* Simple as that!  This will invoke FLOW_CFG_OPTION_SET_DECLARE_OPTION() for each option; and that will</span></div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"> 2134</span><span class="comment">     * simply call validate_parsed_option() with all the needed info like name, current value, validation condition</span></div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"> 2135</span><span class="comment">     * string, and most importantly the validator function created from the validation Boolean expression user</span></div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"> 2136</span><span class="comment">     * passed to FLOW_CFG_OPTION_SET_DECLARE_OPTION().  validate_parsed_option() will throw when invoked on an invalid</span></div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span><span class="comment">     * value.  Catch it to log it, as promised, but then re-throw it, as if it fell through. */</span></div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span>    declare_opts_func(args);</div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span>  }</div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span>  <span class="keywordflow">catch</span> (<span class="keyword">const</span> exception&amp; exc)</div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span>  {</div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Stand-alone validation check failed: Details: [&quot;</span> &lt;&lt; exc.what() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"> 2143</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"> 2144</span>  }</div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"> 2145</span>} <span class="comment">// void Option_set::validate_values()</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"> 2146</span> </div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#a601592ed6eacb42eb5296a2c79fb6ace"> 2148</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">Option_set&lt;Value_set&gt;::validate_values</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a>&amp; values_to_validate, <span class="keywordtype">bool</span>* success_or_null)<span class="keyword"> const</span></div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span>  validate_values(get_logger(), values_to_validate, m_declare_opts_func, success_or_null);</div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span>}</div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"> 2152</span> </div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"> 2153</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value_set&gt;</div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"><a class="line" href="classflow_1_1cfg_1_1Option__set.html#acd1ce6e7c258d7486388915d59019880"> 2154</a></span>std::ostream&amp; <a class="code hl_function" href="namespaceflow_1_1cfg.html#af310e567f2763a9736eda686030e6311">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1cfg_1_1Option__set.html">Option_set&lt;Value_set&gt;</a>&amp; val)</div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"> 2155</span>{</div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span>  <span class="keywordflow">return</span> os &lt;&lt; <span class="charliteral">&#39;[&#39;</span> &lt;&lt; val.<a class="code hl_variable" href="classflow_1_1cfg_1_1Option__set.html#a5e5cf9a5efd81ba6d851171a109005f6">m_nickname</a> &lt;&lt; <span class="stringliteral">&quot;]@&quot;</span> &lt;&lt; &amp;val;</div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span>}</div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span> </div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"><a class="line" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96"> 2160</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(std::ostream&amp; os, <span class="keyword">const</span> Value&amp; val)</div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"> 2161</span>{</div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"> 2162</span>  os &lt;&lt; val;</div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"> 2163</span>}</div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"> 2164</span> </div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"><a class="line" href="namespaceflow_1_1cfg.html#ac3782f31b7c020d7b08e250e89198ad4"> 2166</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(std::ostream&amp; os, <span class="keyword">const</span> boost::chrono::duration&lt;Rep, Period&gt;&amp; val)</div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span>{</div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">util::ostream_op_string</a>;</div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>;</div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"> 2170</span>  <span class="keyword">using </span>boost::chrono::ceil;</div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"> 2171</span>  <span class="keyword">using </span>boost::chrono::nanoseconds;</div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"> 2172</span>  <span class="keyword">using </span>boost::chrono::microseconds;</div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"> 2173</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span>  <span class="keyword">using </span>boost::chrono::seconds;</div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span>  <span class="keyword">using </span>boost::chrono::minutes;</div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span>  <span class="keyword">using </span>boost::chrono::hours;</div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span> </div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span>  <span class="keyword">using </span>raw_ticks_t = uint64_t; <span class="comment">// Should be big enough for anything.</span></div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"> 2180</span> </div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"> 2181</span>  <span class="comment">// Nanoseconds should be the highest precision we use anywhere.  It won&#39;t compile if this can lose precision.</span></div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"> 2182</span>  nanoseconds val_ns(val);</div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"> 2183</span> </div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span>  <span class="comment">// Deal with positives only... why not?</span></div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span>  raw_ticks_t raw_abs_ticks = (val_ns.count() &lt; 0) ? (-val_ns.count()) : val_ns.count();</div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"> 2186</span> </div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span>  <span class="comment">/* We can of course simply `os &lt;&lt; val_ns` -- and it&#39;ll print something like &quot;&lt;...&gt; ns&quot; which is correct.</span></div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span><span class="comment">   * Instead we&#39;d like to use more convenient units -- but without losing precision due to conversion; so convert</span></div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span><span class="comment">   * up to the most coarse units possible.  First, though, take care of the special case 0: */</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span>  <span class="keywordflow">if</span> (raw_abs_ticks == 0)</div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span>  {</div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"> 2192</span>    os &lt;&lt; seconds::zero(); <span class="comment">// Seconds are a nice default.  It&#39;s strange to say &quot;0 hours&quot; or what-not.</span></div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"> 2193</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"> 2194</span>  }</div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"> 2195</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span> </div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span>  <span class="comment">// Then keep trying this until can no longer try a coarser unit without losing precision.</span></div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"> 2198</span>  <span class="keyword">const</span> <span class="keyword">auto</span> try_next_unit = [&amp;](<span class="keyword">auto</span> pre_division_dur, raw_ticks_t divide_by) -&gt; <span class="keywordtype">bool</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span>  {</div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span>    <span class="keywordflow">if</span> ((raw_abs_ticks % divide_by) == 0)</div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span>    {</div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"> 2202</span>      <span class="comment">// Dividing current raw_abs_ticks by divide_by does not lose precision; so at worst can output post-division dur.</span></div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"> 2203</span>      raw_abs_ticks /= divide_by;</div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"> 2204</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"> 2205</span>    }</div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span>    <span class="comment">// else: It does lose precision, so we must stop here and print it in pre-division units.</span></div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span>    os &lt;&lt; <a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">ostream_op_string</a>(pre_division_dur);</div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span>  };</div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span> </div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span>  <span class="keywordflow">if</span> (!(try_next_unit(val_ns, 1000)</div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"> 2212</span>        || try_next_unit(ceil&lt;microseconds&gt;(val), 1000)</div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"> 2213</span>        || try_next_unit(ceil&lt;milliseconds&gt;(val), 1000)</div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"> 2214</span>        || try_next_unit(ceil&lt;seconds&gt;(val), 60)</div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"> 2215</span>        || try_next_unit(ceil&lt;minutes&gt;(val), 60)))</div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span>  {</div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span>    os &lt;&lt; ceil&lt;hours&gt;(val);</div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span>  }</div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span>} <span class="comment">// value_to_ostream()</span></div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span> </div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"> 2221</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Element&gt;</div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"><a class="line" href="namespaceflow_1_1cfg.html#a66d8d4f33601a06cb7bc109b22800387"> 2222</a></span><span class="keywordtype">void</span> <a class="code hl_function" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">value_to_ostream</a>(std::ostream&amp; os, <span class="keyword">const</span> std::vector&lt;Element&gt;&amp; val)</div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"> 2223</span>{</div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"> 2224</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx = 0; idx != val.size(); ++idx)</div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span>  {</div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span>    os &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;</div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span>    value_to_ostream&lt;Element&gt;(os, val[idx]);</div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span>    os &lt;&lt; <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span>    <span class="keywordflow">if</span> (idx != (val.size() - 1))</div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"> 2230</span>    {</div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"> 2231</span>      os &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"> 2232</span>    }</div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"> 2233</span>  }</div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span>} <span class="comment">// value_to_ostream()</span></div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span> </div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key&gt;</div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"><a class="line" href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960"> 2237</a></span>std::string <a class="code hl_function" href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960">value_set_member_id_to_opt_name_keyed</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> member_id, <span class="keyword">const</span> Key&amp; key)</div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span>{</div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"> 2239</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>;</div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"> 2240</span>  <span class="keyword">using </span><a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">util::ostream_op_string</a>;</div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"> 2241</span>  <span class="keyword">using </span>boost::regex;</div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"> 2242</span>  <span class="keyword">using </span>boost::regex_match;</div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span>  <span class="keyword">using </span>boost::smatch;</div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span> </div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span>  <span class="comment">// Keep in harmony with value_set_member_id_to_opt_name() of course,</span></div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span> </div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"> 2248</span>  <span class="comment">/* &lt;anything, long as possible&gt;[&lt;replaced stuff&gt;]&lt;.blah... or -&gt;blah... though we don&#39;t enforce it here&gt;</span></div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"> 2249</span><span class="comment">   *   =&gt;</span></div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"> 2250</span><span class="comment">   * &lt;anything, long as possible&gt;.&lt;`key`&gt;&lt;.blah... or -&gt;blah... though we don&#39;t enforce it here&gt; */</span></div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"> 2251</span> </div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span>  smatch matched_groups;</div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span>  <span class="comment">/* @todo Should I be imbuing the regex with std::locale::classic() or something?</span></div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span><span class="comment">   * @todo Can probably make it work directly on String_view member_id; seems to conflict with `smatch`; but</span></div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span><span class="comment">   * probably it can be figured out.  Perf at this level is hardly of high import so not worrying. */</span></div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span>  <span class="keyword">const</span> <span class="keywordtype">string</span> member_id_str(member_id);</div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"> 2257</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"> 2258</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> matched_ok =</div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"> 2259</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"> 2260</span>  regex_match(member_id_str, matched_groups, <a class="code hl_variable" href="namespaceflow_1_1cfg.html#ac2f99fdb8f743e12d8f92553292dc8d6">VALUE_SET_MEMBER_ID_TO_OPT_NAME_KEYED_REGEX</a>);</div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span>  assert(matched_ok &amp;&amp; <span class="stringliteral">&quot;Member identifier must look like: &lt;longest possible stuff&gt;[&lt;key to replace&gt;]&lt;the rest&gt;&quot;</span>);</div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span> </div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span>  <span class="keyword">constexpr</span> <span class="keywordtype">char</span> INDEX_SEP_BEFORE(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span> </div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"> 2265</span>  <span class="comment">/* Don&#39;t post-process or pre-process a single value_set_member_id_to_opt_name() result.</span></div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"> 2266</span><span class="comment">   * The replacer in that function shouldn&#39;t run across the substituted-in `key` (which could contain, e.g., &quot;m_...&quot; --</span></div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"> 2267</span><span class="comment">   * which would get incorrectly replaced by just &quot;...&quot;); and running the replacer followed by making the</span></div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"> 2268</span><span class="comment">   * [...]-by-dot-key substution is at least aesthetically perf-wasteful (those characters get replaced anyway later).</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"> 2269</span><span class="comment">   * Anyway, all that aside, the following is easily defensible as clearly not having any such issues. */</span></div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"> 2270</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">ostream_op_string</a></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"> 2271</span>           (<a class="code hl_function" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0">value_set_member_id_to_opt_name</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">String_view</a>(&amp;*matched_groups[1].first, matched_groups[1].length())),</div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"> 2272</span>            INDEX_SEP_BEFORE,</div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"> 2273</span>            key, <span class="comment">// ostream&lt;&lt; it.</span></div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"> 2274</span>            <a class="code hl_function" href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0">value_set_member_id_to_opt_name</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">String_view</a>(&amp;*matched_groups[2].first, matched_groups[2].length())));</div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"> 2275</span>} <span class="comment">// value_set_member_id_to_opt_name_keyed()</span></div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"> 2276</span> </div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"> 2277</span>} <span class="comment">// namespace flow::cfg</span></div>
<div class="ttc" id="acfg__fwd_8hpp_html"><div class="ttname"><a href="cfg__fwd_8hpp.html">cfg_fwd.hpp</a></div></div>
<div class="ttc" id="aclassflow_1_1Function_html"><div class="ttname"><a href="classflow_1_1Function.html">flow::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00506">common.hpp:506</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html">flow::cfg::Option_set_base</a></div><div class="ttdoc">Un-templated base for Option_set.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00033">option_set.hpp:34</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_a1d2f46a93337cf83f1e7b5c3f805725b"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b">flow::cfg::Option_set_base::declare_option_for_output</a></div><div class="ttdeci">static void declare_option_for_output(util::String_view name, opts::options_description *target_opts, const Value &amp;value_default, const Value &amp;current_value, util::String_view description)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01669">option_set.hpp:1669</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_a74619d5264f549f99b8187f38be3c838"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">flow::cfg::Option_set_base::throw_on_invalid_func</a></div><div class="ttdeci">static Function&lt; void(const Value &amp;val)&gt; throw_on_invalid_func(util::String_view name, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, util::String_view validator_cond_str)</div><div class="ttdoc">Returns a function that wraps a Value-&gt;Boolean validator function, as passed to declare_option_for_pa...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01610">option_set.hpp:1611</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_a812f2164fb689d4cbcaa04f482ecf4cd"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">flow::cfg::Option_set_base::Declare_options_func_call_type</a></div><div class="ttdeci">Declare_options_func_call_type</div><div class="ttdoc">Internal-use type to use with Option_set::Declare_options_func callback.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00046">option_set.hpp:47</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_a812f2164fb689d4cbcaa04f482ecf4cda2525895c3e467823cc3450761eaac825"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda2525895c3e467823cc3450761eaac825">flow::cfg::Option_set_base::Declare_options_func_call_type::S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE</a></div><div class="ttdeci">@ S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE</div><div class="ttdoc">Internal use only through macro.</div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_a812f2164fb689d4cbcaa04f482ecf4cda4f70649bf85f31925dd145af4c67025c"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda4f70649bf85f31925dd145af4c67025c">flow::cfg::Option_set_base::Declare_options_func_call_type::S_FILL_PARSING_ROLE_OPT_TABLE</a></div><div class="ttdeci">@ S_FILL_PARSING_ROLE_OPT_TABLE</div><div class="ttdoc">Internal use only through macro.</div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_ab79c61f62032b238cb25e132ce1e1d43"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43">flow::cfg::Option_set_base::validate_parsed_option</a></div><div class="ttdeci">static void validate_parsed_option(util::String_view name, const Value &amp;value, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, util::String_view validator_cond_str)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01773">option_set.hpp:1773</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set__base_html_ae2f1d04cb457f4845d636e93aa156f46"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">flow::cfg::Option_set_base::Opt_table</a></div><div class="ttdeci">opts::options_description Opt_table</div><div class="ttdoc">Short-hand for boost.program_options config options description, each of which is used for parsing an...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00216">option_set.hpp:216</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a></div><div class="ttdoc">The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00418">option_set.hpp:422</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a03ec172ee1f15c091ca78102faa55987"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">flow::cfg::Option_set::Mutable_values_ptr</a></div><div class="ttdeci">typename Values::Ptr Mutable_values_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to a mutable Values (config payload storable in an Option_set).</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00442">option_set.hpp:442</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a18227d957ee16e50977dd4bb34d489ab"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a18227d957ee16e50977dd4bb34d489ab">flow::cfg::Option_set::m_null</a></div><div class="ttdeci">bool m_null</div><div class="ttdoc">See null().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01067">option_set.hpp:1067</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a2c5b105705745a5369a35cedbff326d1"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1">flow::cfg::Option_set::option_names</a></div><div class="ttdeci">const boost::unordered_set&lt; std::string &gt; &amp; option_names() const</div><div class="ttdoc">Returns set of all option names declared by the option-declaring function passed to the constructor.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01558">option_set.hpp:1558</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a30c5113f0e85c705fadc32076d83dca4"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a30c5113f0e85c705fadc32076d83dca4">flow::cfg::Option_set::Iterable_values</a></div><div class="ttdeci">std::map&lt; std::string, boost::any &gt; Iterable_values</div><div class="ttdoc">Similar to a boost.program_options parsing results variables_map, which conceptually mirrors the resu...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01062">option_set.hpp:1062</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a381ff2ba7989b90cec0040e3b833d238"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a381ff2ba7989b90cec0040e3b833d238">flow::cfg::Option_set::m_opts_for_parsing</a></div><div class="ttdeci">Opt_table m_opts_for_parsing</div><div class="ttdoc">The parsing-role Opt_table (see extensive explanation in Opt_table doc header).</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01105">option_set.hpp:1105</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a3de831b04134e0729a11a7e0a114a320"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a3de831b04134e0729a11a7e0a114a320">flow::cfg::Option_set::m_iterable_values_candidate</a></div><div class="ttdeci">Iterable_values m_iterable_values_candidate</div><div class="ttdoc">Structure mirroring m_values_candidate, where the values are the parsing-enabled members of m_values_...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01098">option_set.hpp:1098</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a45eebf6c9d7384bcc95c10ff7c934e1f"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f">flow::cfg::Option_set::mutable_values_copy</a></div><div class="ttdeci">Mutable_values_ptr mutable_values_copy() const</div><div class="ttdoc">Convenience method that heap-allocates a copy of the internally stored values() and wraps in a ref-co...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01496">option_set.hpp:1496</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a4a3d6a15332fd7e2da1b852adc81aec3"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">flow::cfg::Option_set::validate_values</a></div><div class="ttdeci">void validate_values(bool *success_or_null=0) const</div><div class="ttdoc">Validates the current contents of values() using the validators *this Option_set&lt;Value_set&gt; is config...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02088">option_set.hpp:2088</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a4ca1b50ec692a98865e4afde76d04128"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128">flow::cfg::Option_set::parse_config_file</a></div><div class="ttdeci">void parse_config_file(const fs::path &amp;cfg_path, bool allow_unregistered, bool *success_or_null=0, const boost::unordered_set&lt; std::string &gt; &amp;allowed_unregistered_opts_or_empty={})</div><div class="ttdoc">Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01783">option_set.hpp:1784</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a5e5cf9a5efd81ba6d851171a109005f6"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a5e5cf9a5efd81ba6d851171a109005f6">flow::cfg::Option_set::m_nickname</a></div><div class="ttdeci">const std::string m_nickname</div><div class="ttdoc">See nickname ctor arg.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01027">option_set.hpp:1027</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a650edbbffb9f75ed102f2bab5e355feb"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a650edbbffb9f75ed102f2bab5e355feb">flow::cfg::Option_set::m_opt_names</a></div><div class="ttdeci">boost::unordered_set&lt; std::string &gt; m_opt_names</div><div class="ttdoc">See option_names().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01070">option_set.hpp:1070</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a6e4542b206e60f310db02bc98706aac4"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4">flow::cfg::Option_set::log_help</a></div><div class="ttdeci">void log_help(util::String_view summary, log::Sev sev=log::Sev::S_INFO) const</div><div class="ttdoc">Logs a multi-line help message using help_to_ostream().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01546">option_set.hpp:1546</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a7bda9a32640f89d1c8a2306b8b368a13"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a7bda9a32640f89d1c8a2306b8b368a13">flow::cfg::Option_set::m_values</a></div><div class="ttdeci">Values m_values</div><div class="ttdoc">See values().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01081">option_set.hpp:1081</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a8435631dfa49db887d2fc56638378aae"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae">flow::cfg::Option_set::load_option_value_as_if_parsed</a></div><div class="ttdeci">void load_option_value_as_if_parsed(util::String_view name, Value *target_value, const Value &amp;source_value)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01746">option_set.hpp:1746</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a93ab889bf230d21961c22bd4bf21e06a"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a">flow::cfg::Option_set::values</a></div><div class="ttdeci">const Values &amp; values() const</div><div class="ttdoc">Externally immutable internally stored canonical (current) config values as last constructed or parse...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01490">option_set.hpp:1490</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_a94ce83bb7ca160d551fa87daeb288493"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#a94ce83bb7ca160d551fa87daeb288493">flow::cfg::Option_set::m_declare_opts_func</a></div><div class="ttdeci">Declare_options_func m_declare_opts_func</div><div class="ttdoc">The Opt_table-filling, or m_iterable_values_candidate-scanning, callback passed to the constructor an...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01078">option_set.hpp:1078</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_aa1aec14275948fe5b66ca75ba5f3b43d"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d">flow::cfg::Option_set::Values_ptr</a></div><div class="ttdeci">typename Values::Const_ptr Values_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to an immutable Value_set (config payload storable in an Option_se...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00439">option_set.hpp:439</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_aa1f780bfd3a5ff07ade1e36785e28f49"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49">flow::cfg::Option_set::canonicalize_candidate</a></div><div class="ttdeci">void canonicalize_candidate(bool *change_detected=0)</div><div class="ttdoc">In PARSING state enters CANONICAL state, finalizing values() from values_candidate().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02042">option_set.hpp:2042</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_aa5ecbc1b1da6efb81002f1431bdbbeaa"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa">flow::cfg::Option_set::declare_option_for_parsing</a></div><div class="ttdeci">void declare_option_for_parsing(util::String_view name, Value *target_value, const Value *value_default_if_no_acc, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, util::String_view validator_cond_str)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01565">option_set.hpp:1565</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_aaeb9b41e8ac4c9f5a2437cedb0f3472a"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#aaeb9b41e8ac4c9f5a2437cedb0f3472a">flow::cfg::Option_set::m_opts_for_help</a></div><div class="ttdeci">Opt_table m_opts_for_help</div><div class="ttdoc">The output-role Opt_table, help-text sub-role (see extensive explanation in Opt_table doc header).</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01113">option_set.hpp:1113</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ab12751047ec45932c26364e533a96e7c"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">flow::cfg::Option_set::Values</a></div><div class="ttdeci">Value_set Values</div><div class="ttdoc">Short-hand for the template parameter type Value_set.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00430">option_set.hpp:430</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_abbbc9648c8c4bac0c456ed176106a0d2"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2">flow::cfg::Option_set::Option_set</a></div><div class="ttdeci">Option_set(log::Logger *logger_ptr, util::String_view nickname, Declare_options_func &amp;&amp;declare_opts_func_moved)</div><div class="ttdoc">Constructs an option set in CANONICAL state with a default-valued values() payload and options declar...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01454">option_set.hpp:1454</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ac3f6c86292b4f6040c655f6bdcb05a3e"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ac3f6c86292b4f6040c655f6bdcb05a3e">flow::cfg::Option_set::m_parsing</a></div><div class="ttdeci">bool m_parsing</div><div class="ttdoc">See values_candidate() – true if and only if that returns non-null (PARSING state; else CANONICAL sta...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01087">option_set.hpp:1087</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ac5452a6e866c911df46d948f02b6a587"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587">flow::cfg::Option_set::reject_candidate</a></div><div class="ttdeci">void reject_candidate()</div><div class="ttdoc">In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02075">option_set.hpp:2075</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_acb1c681c600d989cd3ae4fe834501214"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214">flow::cfg::Option_set::log_values</a></div><div class="ttdeci">void log_values(util::String_view summary, const Values *values_or_null=0, log::Sev sev=log::Sev::S_INFO) const</div><div class="ttdoc">Logs the given values payload using values_to_ostream().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01528">option_set.hpp:1528</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_accd086867406387070ac766b03e7998c"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">flow::cfg::Option_set::null</a></div><div class="ttdeci">bool null() const</div><div class="ttdoc">Return true if and only if the option-declaring function passed to the constructor declared no option...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01484">option_set.hpp:1484</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ad57de4947f2c8fd5e4663ab982e8dbce"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce">flow::cfg::Option_set::declare_option_for_help</a></div><div class="ttdeci">void declare_option_for_help(util::String_view name, const Value &amp;value_default, util::String_view description)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01640">option_set.hpp:1640</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_adbbf2ec0dd43cb8372f33a3f4cc23633"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633">flow::cfg::Option_set::values_to_ostream</a></div><div class="ttdeci">void values_to_ostream(std::ostream &amp;os, const Values *values_or_null=0) const</div><div class="ttdoc">Writes a multi-line user-suitable representation of the current values in a Values object,...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01508">option_set.hpp:1508</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_adce212853383183bd1b60505157f7215"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215">flow::cfg::Option_set::values_candidate</a></div><div class="ttdeci">const Values * values_candidate() const</div><div class="ttdoc">Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01502">option_set.hpp:1502</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ade06b27cbbf36393e81da4713c20a6d3"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3">flow::cfg::Option_set::help_to_ostream</a></div><div class="ttdeci">void help_to_ostream(std::ostream &amp;os) const</div><div class="ttdoc">Prints a multi-line help message about the set of options that *this can parse.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01540">option_set.hpp:1540</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_adfd72b4b73913193252a02d35acdff09"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#adfd72b4b73913193252a02d35acdff09">flow::cfg::Option_set::m_values_candidate</a></div><div class="ttdeci">Values m_values_candidate</div><div class="ttdoc">See values_candidate(). When that returns null (m_parsing == false) this value is meaningless.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01090">option_set.hpp:1090</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_ae6b85e12065536214e78266d086be3b2"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2">flow::cfg::Option_set::validate_values_candidate</a></div><div class="ttdeci">void validate_values_candidate(bool *success_or_null=0) const</div><div class="ttdoc">Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02094">option_set.hpp:2094</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_aea72e19fce43c10c84f6445f1892de41"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#aea72e19fce43c10c84f6445f1892de41">flow::cfg::Option_set::m_values_default</a></div><div class="ttdeci">Values m_values_default</div><div class="ttdoc">Copy of values() when it is first constructed; i.e., the defaults.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01084">option_set.hpp:1084</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_afcd900a94beabe8e9964efc3bc1b91bc"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc">flow::cfg::Option_set::parse_direct_values</a></div><div class="ttdeci">void parse_direct_values(const Values &amp;src_values)</div><div class="ttdoc">Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01993">option_set.hpp:1993</a></div></div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Option__set_html_afe4b08b3a98b57d3b6caa2057e5e59e8"><div class="ttname"><a href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8">flow::cfg::Option_set::scan_parsed_option</a></div><div class="ttdeci">void scan_parsed_option(util::String_view name, const Value &amp;canonical_value)</div><div class="ttdoc">Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l01715">option_set.hpp:1715</a></div></div>
<div class="ttc" id="aclassflow_1_1error_1_1Runtime__error_html"><div class="ttname"><a href="classflow_1_1error_1_1Runtime__error.html">flow::error::Runtime_error</a></div><div class="ttdoc">An std::runtime_error (which is an std::exception) that stores an Error_code.</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00047">error.hpp:49</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></div><div class="ttdoc">Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l01618">log.hpp:1619</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Logger_html"><div class="ttname"><a href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a></div><div class="ttdoc">Interface that the user should implement, passing the implementing Logger into logging classes (Flow'...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l01287">log.hpp:1291</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1String__ostream_html"><div class="ttname"><a href="classflow_1_1util_1_1String__ostream.html">flow::util::String_ostream</a></div><div class="ttdoc">Similar to ostringstream but allows fast read-only access directly into the std::string being written...</div><div class="ttdef"><b>Definition:</b> <a href="string__ostream_8hpp_source.html#l00045">string_ostream.hpp:47</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1String__ostream_html_a7e64b069ae0e221952068c13fdc0f080"><div class="ttname"><a href="classflow_1_1util_1_1String__ostream.html#a7e64b069ae0e221952068c13fdc0f080">flow::util::String_ostream::os</a></div><div class="ttdeci">std::ostream &amp; os()</div><div class="ttdoc">Access to stream that will write to owned string.</div><div class="ttdef"><b>Definition:</b> <a href="string__ostream_8cpp_source.html#l00033">string_ostream.cpp:33</a></div></div>
<div class="ttc" id="adetail_2cfg__fwd_8hpp_html"><div class="ttname"><a href="detail_2cfg__fwd_8hpp.html">cfg_fwd.hpp</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_a019ee6e90802e444572dd78d312d6e23"><div class="ttname"><a href="error_2error_8hpp.html#a019ee6e90802e444572dd78d312d6e23">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a></div><div class="ttdeci">#define FLOW_ERROR_SYS_ERROR_LOG_WARNING()</div><div class="ttdoc">Logs a warning about the (often errno-based or from a library) error code in sys_err_code.</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00269">error.hpp:269</a></div></div>
<div class="ttc" id="alog_8hpp_html"><div class="ttname"><a href="log_8hpp.html">log.hpp</a></div></div>
<div class="ttc" id="alog_8hpp_html_a325fdd4b5cf0be49b37d3b7b7c29070d"><div class="ttname"><a href="log_8hpp.html#a325fdd4b5cf0be49b37d3b7b7c29070d">FLOW_LOG_INFO</a></div><div class="ttdeci">#define FLOW_LOG_INFO(ARG_stream_fragment)</div><div class="ttdoc">Logs an INFO message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00197">log.hpp:197</a></div></div>
<div class="ttc" id="alog_8hpp_html_a626c7dc4d3b4dc0b32a8aac8624d66bc"><div class="ttname"><a href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a></div><div class="ttdeci">#define FLOW_LOG_WARNING(ARG_stream_fragment)</div><div class="ttdoc">Logs a WARNING message into flow::log::Logger *get_logger() with flow::log::Component get_log_compone...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00152">log.hpp:152</a></div></div>
<div class="ttc" id="alog_8hpp_html_a692bbadd8b5c3e9cef7a0bbea1915e66"><div class="ttname"><a href="log_8hpp.html#a692bbadd8b5c3e9cef7a0bbea1915e66">FLOW_LOG_WITH_CHECKING</a></div><div class="ttdeci">#define FLOW_LOG_WITH_CHECKING(ARG_sev, ARG_stream_fragment)</div><div class="ttdoc">Logs a message of the specified severity into flow::log::Logger *get_logger() with flow::log::Compone...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00489">log.hpp:489</a></div></div>
<div class="ttc" id="alog_8hpp_html_ae4b5d4fdd2eb052615620879dd74af95"><div class="ttname"><a href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95">FLOW_LOG_SET_CONTEXT</a></div><div class="ttdeci">#define FLOW_LOG_SET_CONTEXT(ARG_logger_ptr, ARG_component_payload)</div><div class="ttdoc">For the rest of the block within which this macro is instantiated, causes all FLOW_LOG_....</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00405">log.hpp:405</a></div></div>
<div class="ttc" id="alog_8hpp_html_affcf2e4c496ce3f42adf981669c623b8"><div class="ttname"><a href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div><div class="ttdeci">#define FLOW_LOG_TRACE(ARG_stream_fragment)</div><div class="ttdoc">Logs a TRACE message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00227">log.hpp:227</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html"><div class="ttname"><a href="namespaceflow_1_1cfg.html">flow::cfg</a></div><div class="ttdoc">Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...</div><div class="ttdef"><b>Definition:</b> <a href="cfg__fwd_8hpp_source.html#l00111">cfg_fwd.hpp:112</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_a1f5ff766e52aae24e6d5c876b3b26e96"><div class="ttname"><a href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96">flow::cfg::value_to_ostream</a></div><div class="ttdeci">void value_to_ostream(std::ostream &amp;os, const Value &amp;val)</div><div class="ttdoc">Serializes a value of type Value to the given ostream suitably for output in Option_set-related outpu...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02160">option_set.hpp:2160</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_a696eee859b6e3f0fc0b6473a1d2836b0"><div class="ttname"><a href="namespaceflow_1_1cfg.html#a696eee859b6e3f0fc0b6473a1d2836b0">flow::cfg::value_set_member_id_to_opt_name</a></div><div class="ttdeci">std::string value_set_member_id_to_opt_name(util::String_view member_id)</div><div class="ttdoc">Utility, used by FLOW_CFG_OPTION_SET_DECLARE_OPTION() internally but made available as a public API i...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8cpp_source.html#l00038">option_set.cpp:38</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_aafaf432a612183beab72175831aaa960"><div class="ttname"><a href="namespaceflow_1_1cfg.html#aafaf432a612183beab72175831aaa960">flow::cfg::value_set_member_id_to_opt_name_keyed</a></div><div class="ttdeci">std::string value_set_member_id_to_opt_name_keyed(util::String_view member_id, const Key &amp;key)</div><div class="ttdoc">Similar to value_set_member_id_to_opt_name() but used by FLOW_CFG_OPTION_SET_DECLARE_OPTION_KEYED() i...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02237">option_set.hpp:2237</a></div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_ac2f99fdb8f743e12d8f92553292dc8d6"><div class="ttname"><a href="namespaceflow_1_1cfg.html#ac2f99fdb8f743e12d8f92553292dc8d6">flow::cfg::VALUE_SET_MEMBER_ID_TO_OPT_NAME_KEYED_REGEX</a></div><div class="ttdeci">const boost::regex VALUE_SET_MEMBER_ID_TO_OPT_NAME_KEYED_REGEX</div><div class="ttdoc">An internal constant for value_set_member_id_to_opt_name_keyed().</div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_af310e567f2763a9736eda686030e6311"><div class="ttname"><a href="namespaceflow_1_1cfg.html#af310e567f2763a9736eda686030e6311">flow::cfg::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Option_set&lt; Value_set &gt; &amp;val)</div><div class="ttdoc">Serializes (briefly) an Option_set to a standard output stream.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l02154">option_set.hpp:2154</a></div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">flow::log::Sev</a></div><div class="ttdeci">Sev</div><div class="ttdoc">Enumeration containing one of several message severity levels, ordered from highest to lowest.</div><div class="ttdef"><b>Definition:</b> <a href="log__fwd_8hpp_source.html#l00223">log_fwd.hpp:224</a></div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b">flow::log::Sev::S_TRACE</a></div><div class="ttdeci">@ S_TRACE</div><div class="ttdoc">Message indicates any condition that may occur with great frequency (thus verbose if logged).</div></div>
<div class="ttc" id="anamespaceflow_1_1log_html_a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7"><div class="ttname"><a href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">flow::log::Sev::S_INFO</a></div><div class="ttdeci">@ S_INFO</div><div class="ttdoc">Message indicates a not-&quot;bad&quot; condition that is not frequent enough to be of severity Sev::S_TRACE.</div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a03984e29450abf9cf287c501d6c8f866"><div class="ttname"><a href="namespaceflow_1_1util.html#a03984e29450abf9cf287c501d6c8f866">flow::util::key_exists</a></div><div class="ttdeci">bool key_exists(const Container &amp;container, const typename Container::key_type &amp;key)</div><div class="ttdoc">Returns true if and only if the given key is present at least once in the given associative container...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00276">util.hpp:276</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a685b86585da2fa5186f51854e7ae1561"><div class="ttname"><a href="namespaceflow_1_1util.html#a685b86585da2fa5186f51854e7ae1561">flow::util::ostream_op_string</a></div><div class="ttdeci">std::string ostream_op_string(T const &amp;... ostream_args)</div><div class="ttdoc">Equivalent to ostream_op_to_string() but returns a new string by value instead of writing to the call...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00356">util.hpp:356</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ae4dc52186797094b3040379ff19124c9"><div class="ttname"><a href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">flow::util::String_view</a></div><div class="ttdeci">Basic_string_view&lt; char &gt; String_view</div><div class="ttdoc">Commonly used char-based Basic_string_view. See its doc header.</div><div class="ttdef"><b>Definition:</b> <a href="string__view_8hpp_source.html#l00191">string_view.hpp:191</a></div></div>
<div class="ttc" id="anamespaceflow_html_a29eaaa9d0fac4ce87d8b969222dbed09"><div class="ttname"><a href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">flow::Error_code</a></div><div class="ttdeci">boost::system::error_code Error_code</div><div class="ttdoc">Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00502">common.hpp:502</a></div></div>
<div class="ttc" id="anamespaceflow_html_a3938730ab4b89daf13d027a5f620e7ce"><div class="ttname"><a href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">flow::Flow_log_component</a></div><div class="ttdeci">Flow_log_component</div><div class="ttdoc">The flow::log::Component payload enumeration comprising various log components used by Flow's own int...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00631">common.hpp:632</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">flow::cfg::Option_set::Declare_options_func_args</a></div><div class="ttdoc">Internal-use structure to use with Declare_options_func callback.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00455">option_set.hpp:456</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a0ed8c54022a5d7c61abc03efaae17f88"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a0ed8c54022a5d7c61abc03efaae17f88">flow::cfg::Option_set::Declare_options_func_args::m_option_set</a></div><div class="ttdeci">Option_set * m_option_set</div><div class="ttdoc">m_option_set-&gt;m_opts_for_parsing shall be filled out.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00480">option_set.hpp:480</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a19683d3ea7c64e3abf96f85b60e9e610"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a19683d3ea7c64e3abf96f85b60e9e610">flow::cfg::Option_set::Declare_options_func_args::m_values_current</a></div><div class="ttdeci">const Values * m_values_current</div><div class="ttdoc">The current values loaded into *m_target_opts (e.g., via description text) will originate here.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00514">option_set.hpp:514</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a1a35f61a3ebedfdd443e6f050e674aa9"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a1a35f61a3ebedfdd443e6f050e674aa9">flow::cfg::Option_set::Declare_options_func_args::m_fill_parsing_role_opt_table_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@1 m_fill_parsing_role_opt_table_args</div><div class="ttdoc">Corresponds to Call_type::S_FILL_PARSING_ROLE_OPT_TABLE.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a32c9e1f9d46f3379bbb95a4aada644ba"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a32c9e1f9d46f3379bbb95a4aada644ba">flow::cfg::Option_set::Declare_options_func_args::m_fill_output_help_role_opt_table_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@2 m_fill_output_help_role_opt_table_args</div><div class="ttdoc">Corresponds to Call_type::S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a391e72f142afe97b89e4e106bf443801"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a391e72f142afe97b89e4e106bf443801">flow::cfg::Option_set::Declare_options_func_args::m_fill_output_current_role_opt_table_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@3 m_fill_output_current_role_opt_table_args</div><div class="ttdoc">Corresponds to Call_type::S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a47faf7f6307ae1bcea3e55577b102b41"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a47faf7f6307ae1bcea3e55577b102b41">flow::cfg::Option_set::Declare_options_func_args::m_load_val_as_if_parsed_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@5 m_load_val_as_if_parsed_args</div><div class="ttdoc">Corresponds to Call_type::S_LOAD_VALS_AS_IF_PARSED.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a4d18a90df12e3c632a2fd25fdc23224e"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a4d18a90df12e3c632a2fd25fdc23224e">flow::cfg::Option_set::Declare_options_func_args::m_compare_parsed_vals_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@4 m_compare_parsed_vals_args</div><div class="ttdoc">Corresponds to Call_type::S_COMPARE_PARSED_VALS.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a75ab66920b874488bed052a90bc716d5"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a75ab66920b874488bed052a90bc716d5">flow::cfg::Option_set::Declare_options_func_args::m_values_to_validate</a></div><div class="ttdeci">const Values * m_values_to_validate</div><div class="ttdoc">Each validator-enabled (via a Declare_options_func) member in this structure shall be validated.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00549">option_set.hpp:549</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a7c91f3db7161cf30816e0fe1fccc39c0"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a7c91f3db7161cf30816e0fe1fccc39c0">flow::cfg::Option_set::Declare_options_func_args::m_values_default</a></div><div class="ttdeci">const Values * m_values_default</div><div class="ttdoc">m_option_set-&gt;m_values_default: defaults loaded into Option_set::m_opts_for_help will originate here.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00500">option_set.hpp:500</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a838e0b0c1f25e167a102e11de272de4e"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a838e0b0c1f25e167a102e11de272de4e">flow::cfg::Option_set::Declare_options_func_args::m_values_to_load</a></div><div class="ttdeci">const Values * m_values_to_load</div><div class="ttdoc">Values shall be copied from this external Value_set.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00542">option_set.hpp:542</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_a94df262d2c85c677916cb5f57f9c1559"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#a94df262d2c85c677916cb5f57f9c1559">flow::cfg::Option_set::Declare_options_func_args::m_target_opts</a></div><div class="ttdeci">opts::options_description * m_target_opts</div><div class="ttdoc">m_target_opts shall be filled out based on the defaults earlier saved into m_values_default and curre...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00510">option_set.hpp:510</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_ab563381b890c42be9e02c23acb9af0f5"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ab563381b890c42be9e02c23acb9af0f5">flow::cfg::Option_set::Declare_options_func_args::m_call_type</a></div><div class="ttdeci">Call_type m_call_type</div><div class="ttdoc">Why Declare_options_func is being called.</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00465">option_set.hpp:465</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_acbaeb3dd021040e15bff6e85b8da5253"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#acbaeb3dd021040e15bff6e85b8da5253">flow::cfg::Option_set::Declare_options_func_args::m_values_candidate</a></div><div class="ttdeci">Values * m_values_candidate</div><div class="ttdoc">m_option_set-&gt;m_values_candidate, the parsing-in-progress Value_set filled out whenever parsing using...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00485">option_set.hpp:485</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_adc8e05f6d6528755712280a812a6ad4d"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#adc8e05f6d6528755712280a812a6ad4d">flow::cfg::Option_set::Declare_options_func_args::m_values_default_no_acc</a></div><div class="ttdeci">const Values * m_values_default_no_acc</div><div class="ttdoc">m_option_set-&gt;m_values_default: the defaults loaded into m_values_candidate at the top of each parse,...</div><div class="ttdef"><b>Definition:</b> <a href="option__set_8hpp_source.html#l00491">option_set.hpp:491</a></div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_ae0e0d11ce1bf4ce971f5e2d75ed6e18d"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae0e0d11ce1bf4ce971f5e2d75ed6e18d">flow::cfg::Option_set::Declare_options_func_args::m_args</a></div><div class="ttdeci">union flow::cfg::Option_set::Declare_options_func_args::@0 m_args</div><div class="ttdoc">The args to pass in depending on m_call_type.</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args_html_ae780a398078db2299e8a5c3714bcb987"><div class="ttname"><a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#ae780a398078db2299e8a5c3714bcb987">flow::cfg::Option_set::Declare_options_func_args::m_validate_stored_vals_args</a></div><div class="ttdeci">struct flow::cfg::Option_set::Declare_options_func_args::@0::@6 m_validate_stored_vals_args</div><div class="ttdoc">Corresponds to Call_type::S_VALIDATE_STORED_VALS.</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 5 2024 04:45:42 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
