<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Peer_socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1net__flow_1_1Peer__socket-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Peer_socket Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes and reliability support.  
 <a href="classflow_1_1net__flow_1_1Peer__socket.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Peer_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket__inherit__graph.svg" width="554" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Peer_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket__coll__graph.svg" width="2220" height="4056"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html">Individual_ack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata describing the data sent in the acknowledgment of an individual received packet.  <a href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Received_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata (and data, if retransmission is on) for a packet that has been received (and, if retransmission is off, copied to Receive buffer).  <a href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Sent_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission is off) or possibly more (if on) times.  <a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6a9bb727c8982f24bcf978c10c2c7345"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a> { <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">S_OPEN</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>
 }</td></tr>
<tr class="memdesc:a6a9bb727c8982f24bcf978c10c2c7345"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">More...</a><br /></td></tr>
<tr class="separator:a6a9bb727c8982f24bcf978c10c2c7345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f48d01d1269c9d4260d972baa40e548"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> { <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">S_CONNECTING</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">S_CONNECTED</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">S_DISCONNECTING</a>
 }</td></tr>
<tr class="memdesc:a6f48d01d1269c9d4260d972baa40e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sub-state of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">More...</a><br /></td></tr>
<tr class="separator:a6f48d01d1269c9d4260d972baa40e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;</a></td></tr>
<tr class="memitem:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a> = boost::shared_ptr&lt; Peer_socket &gt;</td></tr>
<tr class="memdesc:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to mutable values of type <code>Target_type::element_type</code> (a-la <code>T*</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">More...</a><br /></td></tr>
<tr class="separator:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a> = Const_target_ptr</td></tr>
<tr class="memdesc:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to immutable values of type <code>Target_type::element_type</code> (a-la <code>T const *</code>).  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">More...</a><br /></td></tr>
<tr class="separator:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a729af2cb3465b67b811d8e9438b5af5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a729af2cb3465b67b811d8e9438b5af5d">~Peer_socket</a> () override</td></tr>
<tr class="memdesc:a729af2cb3465b67b811d8e9438b5af5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a729af2cb3465b67b811d8e9438b5af5d">More...</a><br /></td></tr>
<tr class="separator:a729af2cb3465b67b811d8e9438b5af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982953b5136c1df488066eacc293a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">state</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> *open_sub_state=0) const</td></tr>
<tr class="memdesc:af982953b5136c1df488066eacc293a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current State of the socket.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">More...</a><br /></td></tr>
<tr class="separator:af982953b5136c1df488066eacc293a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e7e1be830c901bc7348742e79ba2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">node</a> () const</td></tr>
<tr class="memdesc:aa9e7e1be830c901bc7348742e79ba2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">More...</a><br /></td></tr>
<tr class="separator:aa9e7e1be830c901bc7348742e79ba2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended other side of the connection (regardless of success, failure, or current State).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">More...</a><br /></td></tr>
<tr class="separator:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af387476aa0bdc6b3906c153d824acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">local_port</a> () const</td></tr>
<tr class="memdesc:a7af387476aa0bdc6b3906c153d824acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local Flow-protocol port chosen by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (if active or passive open) or user (if passive open) for this side of the connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">More...</a><br /></td></tr>
<tr class="separator:a7af387476aa0bdc6b3906c153d824acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">get_connect_metadata</a> (const boost::asio::mutable_buffer &amp;buffer, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the serialized connect metadata, as supplied by the user during the connection handshake.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">More...</a><br /></td></tr>
<tr class="separator:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90b656d7e0b7e746b8beb4e24717cec"><td class="memTemplParams" colspan="2">template&lt;typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:af90b656d7e0b7e746b8beb4e24717cec"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec">send</a> (const Const_buffer_sequence &amp;data, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af90b656d7e0b7e746b8beb4e24717cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asynchronously sends them to the other side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec">More...</a><br /></td></tr>
<tr class="separator:af90b656d7e0b7e746b8beb4e24717cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70629642551f18e474b87c128d2d77e2"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:a70629642551f18e474b87c128d2d77e2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">sync_send</a> (const Const_buffer_sequence &amp;data, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a70629642551f18e474b87c128d2d77e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">More...</a><br /></td></tr>
<tr class="separator:a70629642551f18e474b87c128d2d77e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a28cb6fc51585c9fa2bf2f152675615a1">sync_send</a> (const boost::asio::null_buffers &amp;, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a28cb6fc51585c9fa2bf2f152675615a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Writable state is reached &ndash; the actual data are not moved out of any buffer, leaving that to the caller to do if desired.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a28cb6fc51585c9fa2bf2f152675615a1">More...</a><br /></td></tr>
<tr class="separator:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memTemplParams" colspan="2">template&lt;typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6b9fa02a7c41b52fde9e05e862a9d20f">sync_send</a> (const Const_buffer_sequence &amp;data, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_send(data, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6b9fa02a7c41b52fde9e05e862a9d20f">More...</a><br /></td></tr>
<tr class="separator:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f3d07ec71e46ff8f4c4d1bbc44079">sync_send</a> (const boost::asio::null_buffers &amp;, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_send(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_send(null_buffers)</code> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f3d07ec71e46ff8f4c4d1bbc44079">More...</a><br /></td></tr>
<tr class="separator:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memTemplParams" colspan="2">template&lt;typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0">receive</a> (const Mutable_buffer_sequence &amp;target, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of bytes as inferred from size of provided target buffer sequence.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0">More...</a><br /></td></tr>
<tr class="separator:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b77e546fff9394ef8d509e2ae771b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:a256b77e546fff9394ef8d509e2ae771b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">sync_receive</a> (const Mutable_buffer_sequence &amp;target, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a256b77e546fff9394ef8d509e2ae771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">More...</a><br /></td></tr>
<tr class="separator:a256b77e546fff9394ef8d509e2ae771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d796625339aa1aae09326091509d18"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a45d796625339aa1aae09326091509d18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a45d796625339aa1aae09326091509d18">sync_receive</a> (const boost::asio::null_buffers &amp;, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a45d796625339aa1aae09326091509d18"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Readable state is reached &ndash; the actual data are not moved into any buffer, leaving that to the caller to do if desired.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a45d796625339aa1aae09326091509d18">More...</a><br /></td></tr>
<tr class="separator:a45d796625339aa1aae09326091509d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memTemplParams" colspan="2">template&lt;typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af5143886b33b4f16e4fbfbe3a4e91e44">sync_receive</a> (const Mutable_buffer_sequence &amp;target, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_receive(target, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af5143886b33b4f16e4fbfbe3a4e91e44">More...</a><br /></td></tr>
<tr class="separator:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4429aead81514f99e3120a0b96667cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4429aead81514f99e3120a0b96667cb5">sync_receive</a> (const boost::asio::null_buffers &amp;, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a4429aead81514f99e3120a0b96667cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_receive(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_receive(null_buffers)</code> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a4429aead81514f99e3120a0b96667cb5">More...</a><br /></td></tr>
<tr class="separator:a4429aead81514f99e3120a0b96667cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab710704237f912eb219f9b8d574afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">close_abruptly</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9ab710704237f912eb219f9b8d574afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as if fatal error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8" title="User code on this side abruptly closed connection; other side may be informed of this.">error::Code::S_USER_CLOSED_ABRUPTLY</a> has been discovered on the connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">More...</a><br /></td></tr>
<tr class="separator:a9ab710704237f912eb219f9b8d574afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31cf18a3c075873de1c46c0176e41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">set_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7d31cf18a3c075873de1c46c0176e41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>) with the given options set.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">More...</a><br /></td></tr>
<tr class="separator:a7d31cf18a3c075873de1c46c0176e41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">options</a> () const</td></tr>
<tr class="memdesc:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this socket's option set and returns that copy.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">More...</a><br /></td></tr>
<tr class="separator:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">info</a> () const</td></tr>
<tr class="memdesc:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a structure containing the most up-to-date stats about this connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">More...</a><br /></td></tr>
<tr class="separator:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f821dde38a7aa572651730744edbd8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a> () const</td></tr>
<tr class="memdesc:aa1f821dde38a7aa572651730744edbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes of user data per received or sent packet on this connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">More...</a><br /></td></tr>
<tr class="separator:aa1f821dde38a7aa572651730744edbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6fd527766fdeb05a96c5c03729a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">disconnect_cause</a> () const</td></tr>
<tr class="memdesc:a74f6fd527766fdeb05a96c5c03729a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">More...</a><br /></td></tr>
<tr class="separator:a74f6fd527766fdeb05a96c5c03729a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5003c554807f5b5b58989ad58be48d42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">Peer_socket</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> *task_engine, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a5003c554807f5b5b58989ad58be48d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">More...</a><br /></td></tr>
<tr class="separator:a5003c554807f5b5b58989ad58be48d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9537860c2c2a7380a45a525e5121880f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a> { <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87">S_SYN_SENT</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2">S_SYN_RCVD</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202">S_ESTABLISHED</a>
 }</td></tr>
<tr class="memdesc:a9537860c2c2a7380a45a525e5121880f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the socket (and the connection from this end's point of view) for the internal state machine governing the operation of the socket.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">More...</a><br /></td></tr>
<tr class="separator:a9537860c2c2a7380a45a525e5121880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae804be57cf09b9bf76eafa8ffff73de6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae804be57cf09b9bf76eafa8ffff73de6">Drop_timer_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html">Drop_timer</a> &gt;</td></tr>
<tr class="memdesc:ae804be57cf09b9bf76eafa8ffff73de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>shared_ptr</code> to immutable <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> (can't use <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Drop_timer::Ptr</a> due to C++ and circular reference).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ae804be57cf09b9bf76eafa8ffff73de6">More...</a><br /></td></tr>
<tr class="separator:ae804be57cf09b9bf76eafa8ffff73de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1379f9a0269d6990f26bf1da045657"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Options_mutex</a> = <a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">util::Mutex_non_recursive</a></td></tr>
<tr class="memdesc:a1e1379f9a0269d6990f26bf1da045657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for high-performance, non-reentrant, exclusive mutex used to lock <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773" title="This socket&#39;s per-socket set of options.">m_opts</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">More...</a><br /></td></tr>
<tr class="separator:a1e1379f9a0269d6990f26bf1da045657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c6729b318f28b61e144f8a9b1f4dfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Options_lock</a> = <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Options_mutex</a> &gt;</td></tr>
<tr class="memdesc:a98c6729b318f28b61e144f8a9b1f4dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for lock that acquires exclusive access to an <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657" title="Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.">Options_mutex</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">More...</a><br /></td></tr>
<tr class="separator:a98c6729b318f28b61e144f8a9b1f4dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e36619c78b15f46576a18678a4ee67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">Mutex</a> = <a class="el" href="namespaceflow_1_1util.html#a9c7a5df07c2e86c788de9e6bbaee77d5">util::Mutex_recursive</a></td></tr>
<tr class="memdesc:ad1e36619c78b15f46576a18678a4ee67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for reentrant mutex type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">More...</a><br /></td></tr>
<tr class="separator:ad1e36619c78b15f46576a18678a4ee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90abde8badaf451ba6ca615e9936d5df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">Lock_guard</a> = <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">Mutex</a> &gt;</td></tr>
<tr class="memdesc:a90abde8badaf451ba6ca615e9936d5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for RAII lock guard of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67" title="Short-hand for reentrant mutex type.">Mutex</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">More...</a><br /></td></tr>
<tr class="separator:a90abde8badaf451ba6ca615e9936d5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59db68ed0c77a9f6e1a7aeeb3df2a6b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">security_token_t</a> = uint64_t</td></tr>
<tr class="memdesc:a59db68ed0c77a9f6e1a7aeeb3df2a6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a33a90b123612cc2e6a119cfa95ba4f6d" title="Random security token used during SYN_ACK-SYN_ACK_ACK.">m_security_token</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">More...</a><br /></td></tr>
<tr class="separator:a59db68ed0c77a9f6e1a7aeeb3df2a6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797a524b73e2626fcfefe1be64f4d481"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">order_num_t</a> = <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html#ab307e12c0cf8cefbe7fb1ec8588af2a8">Sequence_number::seq_num_t</a></td></tr>
<tr class="memdesc:a797a524b73e2626fcfefe1be64f4d481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for order number type. 0 is reserved. Caution: Keep in sync with <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html#a0930c4da4484ffc1f8bcfbc496e5ecd0" title="Type to uniquely identify a packet sent over the wire in the socket to which this Drop_timer applies.">Drop_timer::packet_id_t</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">More...</a><br /></td></tr>
<tr class="separator:a797a524b73e2626fcfefe1be64f4d481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10b3cd1d32b48cab8146ba4d07cb814"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814">Sent_pkt_by_sent_when_map</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">util::Linked_hash_map</a>&lt; <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Sent_packet</a> &gt; &gt;</td></tr>
<tr class="memdesc:ad10b3cd1d32b48cab8146ba4d07cb814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> type; see that data member.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814">More...</a><br /></td></tr>
<tr class="separator:ad10b3cd1d32b48cab8146ba4d07cb814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac974bdce3d2035d2af69078837f59482"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Sent_pkt_ordered_by_when_const_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2b5383264c89ac63cc8827b18063f2ca">Sent_pkt_by_sent_when_map::const_iterator</a></td></tr>
<tr class="memdesc:ac974bdce3d2035d2af69078837f59482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> <code>const</code> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">More...</a><br /></td></tr>
<tr class="separator:ac974bdce3d2035d2af69078837f59482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc3b752b67295c82919c2f87aed60b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Sent_pkt_ordered_by_when_iter</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1f09f98b4089a8c3ffd0b7f732923b44">Sent_pkt_by_sent_when_map::iterator</a></td></tr>
<tr class="memdesc:ab7dc3b752b67295c82919c2f87aed60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">More...</a><br /></td></tr>
<tr class="separator:ab7dc3b752b67295c82919c2f87aed60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958264af0c40f3c9c5769ddff4c9ade"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">Sent_pkt_by_seq_num_map</a> = std::map&lt; <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Sent_pkt_ordered_by_when_iter</a> &gt;</td></tr>
<tr class="memdesc:a1958264af0c40f3c9c5769ddff4c9ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> type; see that data member.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">More...</a><br /></td></tr>
<tr class="separator:a1958264af0c40f3c9c5769ddff4c9ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6f3174914c3ec559954b4125f2f9dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">Sent_pkt_ordered_by_seq_const_iter</a> = Sent_pkt_by_seq_num_map::const_iterator</td></tr>
<tr class="memdesc:abd6f3174914c3ec559954b4125f2f9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> <code>const</code> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">More...</a><br /></td></tr>
<tr class="separator:abd6f3174914c3ec559954b4125f2f9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9320421e96ab89e6528da6a28b008709"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9320421e96ab89e6528da6a28b008709">Sent_pkt_ordered_by_seq_iter</a> = Sent_pkt_by_seq_num_map::iterator</td></tr>
<tr class="memdesc:a9320421e96ab89e6528da6a28b008709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a9320421e96ab89e6528da6a28b008709">More...</a><br /></td></tr>
<tr class="separator:a9320421e96ab89e6528da6a28b008709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfc181f4d43ab816b2ede9216bf9331"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Recvd_pkt_map</a> = std::map&lt; <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Received_packet</a> &gt; &gt;</td></tr>
<tr class="memdesc:addfc181f4d43ab816b2ede9216bf9331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> type; see that data member.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">More...</a><br /></td></tr>
<tr class="separator:addfc181f4d43ab816b2ede9216bf9331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade41e13eb5176d833c7b1ea144612353"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">Recvd_pkt_const_iter</a> = Recvd_pkt_map::const_iterator</td></tr>
<tr class="memdesc:ade41e13eb5176d833c7b1ea144612353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> <code>const</code> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">More...</a><br /></td></tr>
<tr class="separator:ade41e13eb5176d833c7b1ea144612353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec992a7a14368623cc03c4382d71107"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">Recvd_pkt_iter</a> = Recvd_pkt_map::iterator</td></tr>
<tr class="memdesc:aaec992a7a14368623cc03c4382d71107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> iterator type.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">More...</a><br /></td></tr>
<tr class="separator:aaec992a7a14368623cc03c4382d71107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1869760d5cfc5c0d22665e5db88710e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1869760d5cfc5c0d22665e5db88710e4">Rcv_syn_rcvd_data_q</a> = std::vector&lt; boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a> &gt; &gt;</td></tr>
<tr class="memdesc:a1869760d5cfc5c0d22665e5db88710e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed" title="The queue of DATA packets received while in Int_state::S_SYN_RCVD state before the Syn_ack_ack_packet...">m_rcv_syn_rcvd_data_q</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1869760d5cfc5c0d22665e5db88710e4">More...</a><br /></td></tr>
<tr class="separator:a1869760d5cfc5c0d22665e5db88710e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a83ba2b4c39555afad67932ea6ed39bbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe">node_send</a> (const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a83ba2b4c39555afad67932ea6ed39bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template helper for template <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> that forwards the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> logic to <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe">More...</a><br /></td></tr>
<tr class="separator:a83ba2b4c39555afad67932ea6ed39bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a802024549a59978a53343b09a86d"><td class="memTemplParams" colspan="2">template&lt;typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:a3f1a802024549a59978a53343b09a86d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d">sync_send_impl</a> (const Const_buffer_sequence &amp;data, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a3f1a802024549a59978a53343b09a86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> but uses a <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>-based <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79" title="A high-res time duration as computed from two Fine_time_pts.">Fine_duration</a> non-template type for implementation convenience and to avoid code bloat to specify timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d">More...</a><br /></td></tr>
<tr class="separator:a3f1a802024549a59978a53343b09a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ba1d4af6d4e3fcab9534a307c00595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">sync_send_reactor_pattern_impl</a> (const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a15ba1d4af6d4e3fcab9534a307c00595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper similar to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d" title="Same as sync_send() but uses a Fine_clock-based Fine_duration non-template type for implementation co...">sync_send_impl()</a> but for the <code>null_buffers</code> versions of <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a15ba1d4af6d4e3fcab9534a307c00595">More...</a><br /></td></tr>
<tr class="separator:a15ba1d4af6d4e3fcab9534a307c00595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2c7dfb5596269a6f86a716015f1a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">node_sync_send</a> (const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func_or_empty, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a34e2c7dfb5596269a6f86a716015f1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe" title="Non-template helper for template send() that forwards the send() logic to Node::send().">node_send()</a> is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a34e2c7dfb5596269a6f86a716015f1a6">More...</a><br /></td></tr>
<tr class="separator:a34e2c7dfb5596269a6f86a716015f1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac1b0b3c9b1c3a5ec246148595c657"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657">node_receive</a> (const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;rcv_buf_consume_func, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:af3ac1b0b3c9b1c3a5ec246148595c657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template helper for template <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> that forwards the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> logic to <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657">More...</a><br /></td></tr>
<tr class="separator:af3ac1b0b3c9b1c3a5ec246148595c657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29f61b9885b10ddc3846cdae0560518"><td class="memTemplParams" colspan="2">template&lt;typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:ad29f61b9885b10ddc3846cdae0560518"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518">sync_receive_impl</a> (const Mutable_buffer_sequence &amp;target, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:ad29f61b9885b10ddc3846cdae0560518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> but uses a <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>-based <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79" title="A high-res time duration as computed from two Fine_time_pts.">Fine_duration</a> non-template type for implementation convenience and to avoid code bloat to specify timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518">More...</a><br /></td></tr>
<tr class="separator:ad29f61b9885b10ddc3846cdae0560518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2eccfa314a397c12259f414ef6798c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">sync_receive_reactor_pattern_impl</a> (const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a1a2eccfa314a397c12259f414ef6798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper similar to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518" title="Same as sync_receive() but uses a Fine_clock-based Fine_duration non-template type for implementation...">sync_receive_impl()</a> but for the <code>null_buffers</code> versions of <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1a2eccfa314a397c12259f414ef6798c">More...</a><br /></td></tr>
<tr class="separator:a1a2eccfa314a397c12259f414ef6798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abde92d5189bf2a058fe8741789f814"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">node_sync_receive</a> (const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;rcv_buf_consume_func_or_empty, const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;wait_until, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a8abde92d5189bf2a058fe8741789f814"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657" title="Non-template helper for template receive() that forwards the receive() logic to Node::receive().">node_receive()</a> is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a8abde92d5189bf2a058fe8741789f814">More...</a><br /></td></tr>
<tr class="separator:a8abde92d5189bf2a058fe8741789f814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf6d724ed1f145716ae3d4567f582f3"><td class="memTemplParams" colspan="2">template&lt;typename Opt_type &gt; </td></tr>
<tr class="memitem:accf6d724ed1f145716ae3d4567f582f3"><td class="memTemplItemLeft" align="right" valign="top">Opt_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">opt</a> (const Opt_type &amp;opt_val_ref) const</td></tr>
<tr class="memdesc:accf6d724ed1f145716ae3d4567f582f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595" title="Obtain a copy of the value of a given option in a thread-safe manner.">Node::opt()</a> but for per-socket options.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3">More...</a><br /></td></tr>
<tr class="separator:accf6d724ed1f145716ae3d4567f582f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102b78eaac9c8add512238ec5f26fcfc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a102b78eaac9c8add512238ec5f26fcfc">max_block_size_multiple</a> (const size_t &amp;opt_val_ref, const unsigned int *inflate_pct_val_ptr=0) const</td></tr>
<tr class="memdesc:a102b78eaac9c8add512238ec5f26fcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest multiple of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a> that is &gt;= the given option value, optionally first inflated by a certain %.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a102b78eaac9c8add512238ec5f26fcfc">More...</a><br /></td></tr>
<tr class="separator:a102b78eaac9c8add512238ec5f26fcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d852e3722532d75006b024714a5cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">rexmit_on</a> () const</td></tr>
<tr class="memdesc:a89d852e3722532d75006b024714a5cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether retransmission is enabled on this connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a89d852e3722532d75006b024714a5cef">More...</a><br /></td></tr>
<tr class="separator:a89d852e3722532d75006b024714a5cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cbefb99ae173bd5f355f5d082564ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">ensure_open</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:ac7cbefb99ae173bd5f355f5d082564ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that is equivalent to Node::ensure_sock_open(this, err_code).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ac7cbefb99ae173bd5f355f5d082564ce">More...</a><br /></td></tr>
<tr class="separator:ac7cbefb99ae173bd5f355f5d082564ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd100a3c02fad5d9e00fcbc1f645f116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#acd100a3c02fad5d9e00fcbc1f645f116">bytes_blocks_str</a> (size_t bytes) const</td></tr>
<tr class="memdesc:acd100a3c02fad5d9e00fcbc1f645f116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that, given a byte count, returns a string with that byte count and the number of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a>-size blocks that can fit within it (rounded down).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#acd100a3c02fad5d9e00fcbc1f645f116">More...</a><br /></td></tr>
<tr class="separator:acd100a3c02fad5d9e00fcbc1f645f116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad59c09f34003873a3c207cc590236773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">m_opts</a></td></tr>
<tr class="memdesc:ad59c09f34003873a3c207cc590236773"><td class="mdescLeft">&#160;</td><td class="mdescRight">This socket's per-socket set of options.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773">More...</a><br /></td></tr>
<tr class="separator:ad59c09f34003873a3c207cc590236773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfbe1487c621d4a9c464aec61bc108a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Options_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a">m_opts_mutex</a></td></tr>
<tr class="memdesc:addfbe1487c621d4a9c464aec61bc108a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex protecting <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773" title="This socket&#39;s per-socket set of options.">m_opts</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a">More...</a><br /></td></tr>
<tr class="separator:addfbe1487c621d4a9c464aec61bc108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288ccfc742d6982c4059d82500397874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a288ccfc742d6982c4059d82500397874">m_active_connect</a></td></tr>
<tr class="memdesc:a288ccfc742d6982c4059d82500397874"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if we connect() to server; <code>false</code> if we are to be/are <code>accept()</code>ed. Should be set once and not modified.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a288ccfc742d6982c4059d82500397874">More...</a><br /></td></tr>
<tr class="separator:a288ccfc742d6982c4059d82500397874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a765055fd54412c63e57e43697f1bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc">m_state</a></td></tr>
<tr class="memdesc:a05a765055fd54412c63e57e43697f1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc">More...</a><br /></td></tr>
<tr class="separator:a05a765055fd54412c63e57e43697f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d47460784cc20c9e44237edffaac95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95">m_open_sub_state</a></td></tr>
<tr class="memdesc:ae5d47460784cc20c9e44237edffaac95"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95">More...</a><br /></td></tr>
<tr class="separator:ae5d47460784cc20c9e44237edffaac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab27af6886c7699f9965a5eb296cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">m_node</a></td></tr>
<tr class="memdesc:a36ab27af6886c7699f9965a5eb296cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7" title="Node that produced this Peer_socket.">node()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6">More...</a><br /></td></tr>
<tr class="separator:a36ab27af6886c7699f9965a5eb296cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5629d810d2c7252eaa2243e076dde83f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5629d810d2c7252eaa2243e076dde83f">m_originating_serv</a></td></tr>
<tr class="memdesc:a5629d810d2c7252eaa2243e076dde83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For sockets that come a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, this is the inverse of <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a16bcbf9951c24d13d5b84d9aa163288e" title="Set of passively opening sockets in pre-ESTABLISHED (so SYN_RCVD?) internal state (and thus are not y...">Server_socket::m_connecting_socks</a>: it is the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> from which this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> will be <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>ed (if that succeeds); or null if this is an actively-connecting <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or has already been <code>accept()</code>ed.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5629d810d2c7252eaa2243e076dde83f">More...</a><br /></td></tr>
<tr class="separator:a5629d810d2c7252eaa2243e076dde83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9cb8f2dbd50ddaa0265d940b149ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3">m_rcv_buf</a></td></tr>
<tr class="memdesc:aae9cb8f2dbd50ddaa0265d940b149ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Receive buffer; <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> feeds data at the back; user consumes data at the front.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3">More...</a><br /></td></tr>
<tr class="separator:aae9cb8f2dbd50ddaa0265d940b149ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993edf95f6bce2e57e7111e42533dc74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74">m_snd_buf</a></td></tr>
<tr class="memdesc:a993edf95f6bce2e57e7111e42533dc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Send buffer; user feeds data at the back; <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> consumes data at the front.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74">More...</a><br /></td></tr>
<tr class="separator:a993edf95f6bce2e57e7111e42533dc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8e8df98efa023e8bd4bd825475a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18">m_disconnect_cause</a></td></tr>
<tr class="memdesc:a4fb8e8df98efa023e8bd4bd825475a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> causing disconnection (if one has occurred or is occurring) on this socket; otherwise a clear (success) <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18">More...</a><br /></td></tr>
<tr class="separator:a4fb8e8df98efa023e8bd4bd825475a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322dddf34a06bb199dab02c993bad686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686">m_serialized_metadata</a></td></tr>
<tr class="memdesc:a322dddf34a06bb199dab02c993bad686"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>!m_active_connect</code>, this contains the serialized metadata that the user supplied on the other side when initiating the connect; otherwise this is the serialized metadata that the user supplied on this side when initiating the connect.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686">More...</a><br /></td></tr>
<tr class="separator:a322dddf34a06bb199dab02c993bad686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b19ed4e62cb14fcd7dac81e4a8f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">m_mutex</a></td></tr>
<tr class="memdesc:ab41b19ed4e62cb14fcd7dac81e4a8f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object's mutex.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41">More...</a><br /></td></tr>
<tr class="separator:ab41b19ed4e62cb14fcd7dac81e4a8f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218ec098984b754b43940001f59ab787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a218ec098984b754b43940001f59ab787">m_remote_endpoint</a></td></tr>
<tr class="memdesc:a218ec098984b754b43940001f59ab787"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e" title="Intended other side of the connection (regardless of success, failure, or current State).">remote_endpoint()</a>. Should be set before user gets access to <code>*this</code> and not changed afterwards.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a218ec098984b754b43940001f59ab787">More...</a><br /></td></tr>
<tr class="separator:a218ec098984b754b43940001f59ab787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b65c1b26e38a2ae614d9a12edfa57dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd">m_local_port</a></td></tr>
<tr class="memdesc:a7b65c1b26e38a2ae614d9a12edfa57dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb" title="The local Flow-protocol port chosen by the Node (if active or passive open) or user (if passive open)...">local_port()</a>. Should be set before user gets access to <code>*this</code> and not changed afterwards.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7b65c1b26e38a2ae614d9a12edfa57dd">More...</a><br /></td></tr>
<tr class="separator:a7b65c1b26e38a2ae614d9a12edfa57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5de5df50268168cbbad82eaf90fa93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2c5de5df50268168cbbad82eaf90fa93">m_int_state</a></td></tr>
<tr class="memdesc:a2c5de5df50268168cbbad82eaf90fa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current internal state of the socket.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a2c5de5df50268168cbbad82eaf90fa93">More...</a><br /></td></tr>
<tr class="separator:a2c5de5df50268168cbbad82eaf90fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48320d96118a37626f1852626965e6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1869760d5cfc5c0d22665e5db88710e4">Rcv_syn_rcvd_data_q</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed">m_rcv_syn_rcvd_data_q</a></td></tr>
<tr class="memdesc:a48320d96118a37626f1852626965e6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queue of DATA packets received while in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Int_state::S_SYN_RCVD</a> state before the <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN_ACK_ACK packet.">Syn_ack_ack_packet</a> arrives to move us to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Int_state::S_ESTABLISHED</a> state, at which point these packets can be processed normally.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed">More...</a><br /></td></tr>
<tr class="separator:a48320d96118a37626f1852626965e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1553bbefc3407cf84eaa8e256c6cffff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1553bbefc3407cf84eaa8e256c6cffff">m_rcv_syn_rcvd_data_cumulative_size</a></td></tr>
<tr class="memdesc:a1553bbefc3407cf84eaa8e256c6cffff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The running total count of bytes in the <code>m_data</code> fields of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed" title="The queue of DATA packets received while in Int_state::S_SYN_RCVD state before the Syn_ack_ack_packet...">m_rcv_syn_rcvd_data_q</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1553bbefc3407cf84eaa8e256c6cffff">More...</a><br /></td></tr>
<tr class="separator:a1553bbefc3407cf84eaa8e256c6cffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc05d1f5deb71e1259c5d5aad1fcf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5dc05d1f5deb71e1259c5d5aad1fcf84">m_rcv_init_seq_num</a></td></tr>
<tr class="memdesc:a5dc05d1f5deb71e1259c5d5aad1fcf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Initial Sequence Number (ISN) contained in the original <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN packet.">Syn_packet</a> or <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN_ACK packet.">Syn_ack_packet</a> we received.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5dc05d1f5deb71e1259c5d5aad1fcf84">More...</a><br /></td></tr>
<tr class="separator:a5dc05d1f5deb71e1259c5d5aad1fcf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c640ebd14a75df3894e7d885d16f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f">m_rcv_next_seq_num</a></td></tr>
<tr class="memdesc:a13c640ebd14a75df3894e7d885d16f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximal sequence number R from the remote side such that all data with sequence numbers strictly less than R in this connection have been received by us and placed into the Receive buffer.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f">More...</a><br /></td></tr>
<tr class="separator:a13c640ebd14a75df3894e7d885d16f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82958ed6d71be46b96eceaca6214143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Recvd_pkt_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143">m_rcv_packets_with_gaps</a></td></tr>
<tr class="memdesc:ae82958ed6d71be46b96eceaca6214143"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets such that at least one unreceived-or-otherwise-unknown datum precedes all sequence numbers in this collection; a/k/a the reassembly queue if retransmission is enabled.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143">More...</a><br /></td></tr>
<tr class="separator:ae82958ed6d71be46b96eceaca6214143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7398394052c8e634365fb979c294644"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa7398394052c8e634365fb979c294644">m_rcv_reassembly_q_data_size</a></td></tr>
<tr class="memdesc:aa7398394052c8e634365fb979c294644"><td class="mdescLeft">&#160;</td><td class="mdescRight">With retransmission enabled, the sum of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a7d0760b1dead081bdcf775fbca7f708b" title="Number of bytes in the Data_packet::m_data field of that packet.">Received_packet::m_size</a> over all packets stored in the reassembly queue, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa7398394052c8e634365fb979c294644">More...</a><br /></td></tr>
<tr class="separator:aa7398394052c8e634365fb979c294644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46ed439a3d118eb2b540e9f99a7b0ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html">Individual_ack</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca">m_rcv_pending_acks</a></td></tr>
<tr class="memdesc:ad46ed439a3d118eb2b540e9f99a7b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side, ordered in the chronological order they were received.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca">More...</a><br /></td></tr>
<tr class="separator:ad46ed439a3d118eb2b540e9f99a7b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780f86759f861a3a84de8c5c768736b7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a780f86759f861a3a84de8c5c768736b7">m_rcv_pending_acks_size_at_recv_handler_start</a></td></tr>
<tr class="memdesc:a780f86759f861a3a84de8c5c768736b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper state, to be used while inside either <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a>, set only at the beginning of either and equal to <code>m_rcv_pending_acks.size()</code> at that time.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a780f86759f861a3a84de8c5c768736b7">More...</a><br /></td></tr>
<tr class="separator:a780f86759f861a3a84de8c5c768736b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229396adfd306d15e8a05dac3fe8c29"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#abbd41e30089125f67667b39f5756c275">Ack_packet::Individual_ack::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8229396adfd306d15e8a05dac3fe8c29">m_rcv_acked_packets</a></td></tr>
<tr class="memdesc:a8229396adfd306d15e8a05dac3fe8c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">While <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a> is running, accumulates the individual acknowledgments contained in all incoming ACK low-level packets received in those methods.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a8229396adfd306d15e8a05dac3fe8c29">More...</a><br /></td></tr>
<tr class="separator:a8229396adfd306d15e8a05dac3fe8c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d885e5c8ec85e7ef8718dc0468ffe9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a07d885e5c8ec85e7ef8718dc0468ffe9">m_snd_pending_rcv_wnd</a></td></tr>
<tr class="memdesc:a07d885e5c8ec85e7ef8718dc0468ffe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">While <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a> is running, contains the rcv_wnd (eventual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a12611e0ac9e8b86b8304b855050a8c8c" title="The receive window: the maximum number of bytes the other side has advertised it would be willing to ...">m_snd_remote_rcv_wnd</a>) value in the last observed ACK low-level packet received in those methods.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a07d885e5c8ec85e7ef8718dc0468ffe9">More...</a><br /></td></tr>
<tr class="separator:a07d885e5c8ec85e7ef8718dc0468ffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa76b609ef0aa5962d8de77338cf9ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7fa76b609ef0aa5962d8de77338cf9ee">m_rcv_last_sent_rcv_wnd</a></td></tr>
<tr class="memdesc:a7fa76b609ef0aa5962d8de77338cf9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last rcv_wnd value sent to the other side (in an ACK).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7fa76b609ef0aa5962d8de77338cf9ee">More...</a><br /></td></tr>
<tr class="separator:a7fa76b609ef0aa5962d8de77338cf9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7414dfca4b869dd3a4e0de39195c69e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e">m_rcv_in_rcv_wnd_recovery</a></td></tr>
<tr class="memdesc:ad7414dfca4b869dd3a4e0de39195c69e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> indicates we are in a state where we've decided other side needs to be informed that our receive window has increased substantially, so that it can resume sending data (probably after a zero window being advertised).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e">More...</a><br /></td></tr>
<tr class="separator:ad7414dfca4b869dd3a4e0de39195c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5476d9206f997fc9119b2a80b078ee87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5476d9206f997fc9119b2a80b078ee87">m_rcv_wnd_recovery_start_time</a></td></tr>
<tr class="memdesc:a5476d9206f997fc9119b2a80b078ee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time point at which <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e" title="true indicates we are in a state where we&#39;ve decided other side needs to be informed that our receive...">m_rcv_in_rcv_wnd_recovery</a> was last set to true.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5476d9206f997fc9119b2a80b078ee87">More...</a><br /></td></tr>
<tr class="separator:a5476d9206f997fc9119b2a80b078ee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd590cc70d06b8e903027e4924fd095a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#afd590cc70d06b8e903027e4924fd095a">m_rcv_wnd_recovery_scheduled_task</a></td></tr>
<tr class="memdesc:afd590cc70d06b8e903027e4924fd095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e" title="true indicates we are in a state where we&#39;ve decided other side needs to be informed that our receive...">m_rcv_in_rcv_wnd_recovery</a> is <code>true</code>, this is the scheduled task to possibly send another unsolicited rcv_wnd-advertising ACK to the other side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#afd590cc70d06b8e903027e4924fd095a">More...</a><br /></td></tr>
<tr class="separator:afd590cc70d06b8e903027e4924fd095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f967e74f8618c94088113e918ab52f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">util::Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a88f967e74f8618c94088113e918ab52f">m_rcv_delayed_ack_timer</a></td></tr>
<tr class="memdesc:a88f967e74f8618c94088113e918ab52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer started, assuming delayed ACKs are enabled, when the first <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html" title="Metadata describing the data sent in the acknowledgment of an individual received packet.">Individual_ack</a> is placed onto an empty <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">m_rcv_pending_acks</a>; when it triggers, the pending individual acknowledgments are packed into as few as possible ACKs and sent to the other side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a88f967e74f8618c94088113e918ab52f">More...</a><br /></td></tr>
<tr class="separator:a88f967e74f8618c94088113e918ab52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f1d381749473f7a2471b8be20d6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f1d381749473f7a2471b8be20d6a8">m_rcv_stats</a></td></tr>
<tr class="memdesc:a7d1f1d381749473f7a2471b8be20d6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats regarding incoming traffic (and resulting outgoing ACKs) for this connection so far.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f1d381749473f7a2471b8be20d6a8">More...</a><br /></td></tr>
<tr class="separator:a7d1f1d381749473f7a2471b8be20d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66d1cb582ca027745d1ef847266cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aca66d1cb582ca027745d1ef847266cc4">m_snd_init_seq_num</a></td></tr>
<tr class="memdesc:aca66d1cb582ca027745d1ef847266cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Initial Sequence Number (ISN) used in our original SYN or SYN_ACK.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aca66d1cb582ca027745d1ef847266cc4">More...</a><br /></td></tr>
<tr class="separator:aca66d1cb582ca027745d1ef847266cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8bebf649551131e6ed6e75c6f98d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1f8bebf649551131e6ed6e75c6f98d54">m_snd_next_seq_num</a></td></tr>
<tr class="memdesc:a1f8bebf649551131e6ed6e75c6f98d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence number for the start of the data in the next new DATA packet to be sent out.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1f8bebf649551131e6ed6e75c6f98d54">More...</a><br /></td></tr>
<tr class="separator:a1f8bebf649551131e6ed6e75c6f98d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea56c54a98289211fef4a672432a2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814">Sent_pkt_by_sent_when_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad">m_snd_flying_pkts_by_sent_when</a></td></tr>
<tr class="memdesc:a5ea56c54a98289211fef4a672432a2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of all In-flight packets, indexed by sequence number and ordered from most to least recently sent (including those queued up to wire-send in pacing module).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad">More...</a><br /></td></tr>
<tr class="separator:a5ea56c54a98289211fef4a672432a2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db7d11ece920d4adcacd00eaa2253fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">Sent_pkt_by_seq_num_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd">m_snd_flying_pkts_by_seq_num</a></td></tr>
<tr class="memdesc:a2db7d11ece920d4adcacd00eaa2253fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of all In-flight packets (including those queued up to send in pacing module), indexed AND ordered by sequence number.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd">More...</a><br /></td></tr>
<tr class="separator:a2db7d11ece920d4adcacd00eaa2253fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae870847f024fca7109c15557bb165480"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480">m_snd_flying_bytes</a></td></tr>
<tr class="memdesc:ae870847f024fca7109c15557bb165480"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes contained in all In-flight packets, used at least for comparison against the congestion window (CWND).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480">More...</a><br /></td></tr>
<tr class="separator:ae870847f024fca7109c15557bb165480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea98297d775f2085c21daf41c6582200"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">order_num_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aea98297d775f2085c21daf41c6582200">m_snd_temp_pkts_marked_to_drop</a></td></tr>
<tr class="memdesc:aea98297d775f2085c21daf41c6582200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper data structure to store the packet IDs of packets that are marked Dropped during a single run through accumulated ACKs; it is a data member instead of local variable for performance only.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aea98297d775f2085c21daf41c6582200">More...</a><br /></td></tr>
<tr class="separator:aea98297d775f2085c21daf41c6582200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec79951579d595bb790be87189d6e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">order_num_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1ec79951579d595bb790be87189d6e6c">m_snd_last_order_num</a></td></tr>
<tr class="memdesc:a1ec79951579d595bb790be87189d6e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> representing the next packet to be sent, this is the value to assign to <code>m_sent_when.back().first</code>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a1ec79951579d595bb790be87189d6e6c">More...</a><br /></td></tr>
<tr class="separator:a1ec79951579d595bb790be87189d6e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f21b754ef641b65b1fe44727fb429"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Sent_packet</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a845f21b754ef641b65b1fe44727fb429">m_snd_rexmit_q</a></td></tr>
<tr class="memdesc:a845f21b754ef641b65b1fe44727fb429"><td class="mdescLeft">&#160;</td><td class="mdescRight">If retransmission is on, this is the retransmission queue.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a845f21b754ef641b65b1fe44727fb429">More...</a><br /></td></tr>
<tr class="separator:a845f21b754ef641b65b1fe44727fb429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5063c85a2070822cf69a530f0af1f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9f5063c85a2070822cf69a530f0af1f5">m_snd_rexmit_q_size</a></td></tr>
<tr class="memdesc:a9f5063c85a2070822cf69a530f0af1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <code>m_snd_rexmit_q.size().</code> Kept since <code>m_snd_rexmit_q.size()</code> may be <em>O(n)</em> depending on implementation.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a9f5063c85a2070822cf69a530f0af1f5">More...</a><br /></td></tr>
<tr class="separator:a9f5063c85a2070822cf69a530f0af1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eb43f2b5d7dd46a941def4523f673c"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html">Congestion_control_strategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c">m_snd_cong_ctl</a></td></tr>
<tr class="memdesc:a35eb43f2b5d7dd46a941def4523f673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The congestion control strategy in use for this connection on this side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c">More...</a><br /></td></tr>
<tr class="separator:a35eb43f2b5d7dd46a941def4523f673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12611e0ac9e8b86b8304b855050a8c8c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a12611e0ac9e8b86b8304b855050a8c8c">m_snd_remote_rcv_wnd</a></td></tr>
<tr class="memdesc:a12611e0ac9e8b86b8304b855050a8c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The receive window: the maximum number of bytes the other side has advertised it would be willing to accept into its Receive buffer if they'd arrived at the moment that advertisement was generated by the other side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a12611e0ac9e8b86b8304b855050a8c8c">More...</a><br /></td></tr>
<tr class="separator:a12611e0ac9e8b86b8304b855050a8c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd08c5fed4d179e4fde3a632c084751"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html">Send_bandwidth_estimator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2dd08c5fed4d179e4fde3a632c084751">m_snd_bandwidth_estimator</a></td></tr>
<tr class="memdesc:a2dd08c5fed4d179e4fde3a632c084751"><td class="mdescLeft">&#160;</td><td class="mdescRight">The outgoing available bandwidth estimator for this connection on this side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a2dd08c5fed4d179e4fde3a632c084751">More...</a><br /></td></tr>
<tr class="separator:a2dd08c5fed4d179e4fde3a632c084751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b53052e7eedfa7a925258f5ef1cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba">m_snd_smoothed_round_trip_time</a></td></tr>
<tr class="memdesc:ad08b53052e7eedfa7a925258f5ef1cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated current round trip time of packets, computed as a smooth value over the past individual RTT measurements.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba">More...</a><br /></td></tr>
<tr class="separator:ad08b53052e7eedfa7a925258f5ef1cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ce5b19ab4abcf61aa07153c46b2be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a27ce5b19ab4abcf61aa07153c46b2be3">m_round_trip_time_variance</a></td></tr>
<tr class="memdesc:a27ce5b19ab4abcf61aa07153c46b2be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTTVAR used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a> calculation.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a27ce5b19ab4abcf61aa07153c46b2be3">More...</a><br /></td></tr>
<tr class="separator:a27ce5b19ab4abcf61aa07153c46b2be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037459e6f1345cedf45e490d544c8567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae804be57cf09b9bf76eafa8ffff73de6">Drop_timer_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567">m_snd_drop_timer</a></td></tr>
<tr class="memdesc:a037459e6f1345cedf45e490d544c8567"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Drop Timer engine, which controls how In-flight (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>) packets are considered Dropped due to being unacknowledged for too long.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567">More...</a><br /></td></tr>
<tr class="separator:a037459e6f1345cedf45e490d544c8567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8aded3761028967fd3abb464e64936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2d8aded3761028967fd3abb464e64936">m_snd_drop_timeout</a></td></tr>
<tr class="memdesc:a2d8aded3761028967fd3abb464e64936"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Drop Timeout: Time period between the next time <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">m_snd_drop_timer</a> schedules a Drop Timer and that timer expiring.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a2d8aded3761028967fd3abb464e64936">More...</a><br /></td></tr>
<tr class="separator:a2d8aded3761028967fd3abb464e64936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b44104a2c305b9679434ba623a7357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html">Send_pacing_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a55b44104a2c305b9679434ba623a7357">m_snd_pacing_data</a></td></tr>
<tr class="memdesc:a55b44104a2c305b9679434ba623a7357"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of outgoing packet pacing for this socket; segregated into a simple <code>struct</code> to keep <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> shorter and easier to understand.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a55b44104a2c305b9679434ba623a7357">More...</a><br /></td></tr>
<tr class="separator:a55b44104a2c305b9679434ba623a7357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f77167af54cfe2921fab5fd143eff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9f77167af54cfe2921fab5fd143eff4">m_snd_last_loss_event_when</a></td></tr>
<tr class="memdesc:aa9f77167af54cfe2921fab5fd143eff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last time that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has detected a packet loss event and so informed <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> by calling the appropriate method of class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa9f77167af54cfe2921fab5fd143eff4">More...</a><br /></td></tr>
<tr class="separator:aa9f77167af54cfe2921fab5fd143eff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af392484f79ffcead4f74ca351672d8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af392484f79ffcead4f74ca351672d8d4">m_snd_last_data_sent_when</a></td></tr>
<tr class="memdesc:af392484f79ffcead4f74ca351672d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time at which the last <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level DATA packet.">Data_packet</a> low-level packet for this connection was sent.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af392484f79ffcead4f74ca351672d8d4">More...</a><br /></td></tr>
<tr class="separator:af392484f79ffcead4f74ca351672d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4aff3e65ef9551b6c5ab890173b741e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats__accumulator.html">Peer_socket_send_stats_accumulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab4aff3e65ef9551b6c5ab890173b741e">m_snd_stats</a></td></tr>
<tr class="memdesc:ab4aff3e65ef9551b6c5ab890173b741e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats regarding outgoing traffic (and resulting incoming ACKs) for this connection so far.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ab4aff3e65ef9551b6c5ab890173b741e">More...</a><br /></td></tr>
<tr class="separator:ab4aff3e65ef9551b6c5ab890173b741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a90b123612cc2e6a119cfa95ba4f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">security_token_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a33a90b123612cc2e6a119cfa95ba4f6d">m_security_token</a></td></tr>
<tr class="memdesc:a33a90b123612cc2e6a119cfa95ba4f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random security token used during SYN_ACK-SYN_ACK_ACK.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a33a90b123612cc2e6a119cfa95ba4f6d">More...</a><br /></td></tr>
<tr class="separator:a33a90b123612cc2e6a119cfa95ba4f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b3d271527dbaa04b1d9f751631fd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a85b3d271527dbaa04b1d9f751631fd71">m_init_rexmit_scheduled_task</a></td></tr>
<tr class="memdesc:a85b3d271527dbaa04b1d9f751631fd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection attempt scheduled task; fires if an individual connection request packet is not answered with a reply packet in time.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a85b3d271527dbaa04b1d9f751631fd71">More...</a><br /></td></tr>
<tr class="separator:a85b3d271527dbaa04b1d9f751631fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1eecb59c62912b5630359df774dc62"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0d1eecb59c62912b5630359df774dc62">m_init_rexmit_count</a></td></tr>
<tr class="memdesc:a0d1eecb59c62912b5630359df774dc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">If currently using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a85b3d271527dbaa04b1d9f751631fd71" title="Connection attempt scheduled task; fires if an individual connection request packet is not answered w...">m_init_rexmit_scheduled_task</a>, this is the number of times the timer has already fired in this session.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a0d1eecb59c62912b5630359df774dc62">More...</a><br /></td></tr>
<tr class="separator:a0d1eecb59c62912b5630359df774dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad772e56de286567c4b7a681907b5f285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad772e56de286567c4b7a681907b5f285">m_connection_timeout_scheduled_task</a></td></tr>
<tr class="memdesc:ad772e56de286567c4b7a681907b5f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection timeout scheduled task; fires if the entire initial connection process does not complete within a certain amount of time.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad772e56de286567c4b7a681907b5f285">More...</a><br /></td></tr>
<tr class="separator:ad772e56de286567c4b7a681907b5f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c942e1bb6c4dc4b24251f294a2f92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac4c942e1bb6c4dc4b24251f294a2f92d">m_info_on_close</a></td></tr>
<tr class="memdesc:ac4c942e1bb6c4dc4b24251f294a2f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the final set of stats collected at the time the socket was moved to S_CLOSED <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">m_state</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ac4c942e1bb6c4dc4b24251f294a2f92d">More...</a><br /></td></tr>
<tr class="separator:ac4c942e1bb6c4dc4b24251f294a2f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6db9d28bd448a131448276ee03de1e6d">Node</a></td></tr>
<tr class="memdesc:a6db9d28bd448a131448276ee03de1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> documentation header.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6db9d28bd448a131448276ee03de1e6d">More...</a><br /></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165381af6166d76afba06862c762367"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2165381af6166d76afba06862c762367">Server_socket</a></td></tr>
<tr class="memdesc:a2165381af6166d76afba06862c762367"><td class="mdescLeft">&#160;</td><td class="mdescRight">See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> in class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> documentation header.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a2165381af6166d76afba06862c762367">More...</a><br /></td></tr>
<tr class="separator:a2165381af6166d76afba06862c762367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1259416e25ed2bd94bce3192c682e5d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1259416e25ed2bd94bce3192c682e5d">Drop_timer</a></td></tr>
<tr class="memdesc:ad1259416e25ed2bd94bce3192c682e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For access to <code>Sent_pkt_by_sent_when_map</code> and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> types, at least.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad1259416e25ed2bd94bce3192c682e5d">More...</a><br /></td></tr>
<tr class="separator:ad1259416e25ed2bd94bce3192c682e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0f36768414ae35afeb525636a41290"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7c0f36768414ae35afeb525636a41290">Send_bandwidth_estimator</a></td></tr>
<tr class="memdesc:a7c0f36768414ae35afeb525636a41290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats modules have const access to all socket internals.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7c0f36768414ae35afeb525636a41290">More...</a><br /></td></tr>
<tr class="separator:a7c0f36768414ae35afeb525636a41290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cd234409fb43c27e1f46f2303ca55d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a73cd234409fb43c27e1f46f2303ca55d">Congestion_control_classic_data</a></td></tr>
<tr class="memdesc:a73cd234409fb43c27e1f46f2303ca55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congestion control modules have const access to all socket internals.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a73cd234409fb43c27e1f46f2303ca55d">More...</a><br /></td></tr>
<tr class="separator:a73cd234409fb43c27e1f46f2303ca55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b055f28b89531ad98368286babfdb1"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1b055f28b89531ad98368286babfdb1">Congestion_control_classic</a></td></tr>
<tr class="memdesc:ad1b055f28b89531ad98368286babfdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congestion control modules have const access to all socket internals.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad1b055f28b89531ad98368286babfdb1">More...</a><br /></td></tr>
<tr class="separator:ad1b055f28b89531ad98368286babfdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7020b02ef7daffcfd9004e41240f51b8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7020b02ef7daffcfd9004e41240f51b8">Congestion_control_classic_with_bandwidth_est</a></td></tr>
<tr class="memdesc:a7020b02ef7daffcfd9004e41240f51b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congestion control modules have const access to all socket internals.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7020b02ef7daffcfd9004e41240f51b8">More...</a><br /></td></tr>
<tr class="separator:a7020b02ef7daffcfd9004e41240f51b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ea7069aa4779abaf274989bd4c2fb6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a03ea7069aa4779abaf274989bd4c2fb6">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a> <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">state</a>)</td></tr>
<tr class="separator:a03ea7069aa4779abaf274989bd4c2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8497776b61df32a79707c264f8f2422b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8497776b61df32a79707c264f8f2422b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *sock)</td></tr>
<tr class="memdesc:a8497776b61df32a79707c264f8f2422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a8497776b61df32a79707c264f8f2422b">More...</a><br /></td></tr>
<tr class="separator:a8497776b61df32a79707c264f8f2422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;</a></td></tr>
<tr class="memitem:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides syntactic-sugary way to perform a <code>static_pointer_cast&lt;&gt;</code> from a compatible smart pointer type <code>From_ptr</code>, typically <code>From_ptr::element_type</code> being in the same class hierarchy as <code>Target_ptr::element_type</code>.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">More...</a><br /></td></tr>
<tr class="separator:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but adds <code>const</code>-ness (immutability) to the pointed-to type.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">More...</a><br /></td></tr>
<tr class="separator:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">dynamic_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">More...</a><br /></td></tr>
<tr class="separator:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">dynamic_const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8" title="Identical to ptr_cast() but adds const-ness (immutability) to the pointed-to type.">const_ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">More...</a><br /></td></tr>
<tr class="separator:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes and reliability support. </p>
<p >Reliability is enabled or disabled via a socket option, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360" title="Whether to enable reliability via retransmission.">Peer_socket_options::m_st_rexmit_on</a>, at socket creation. Use unreliable mode with care &ndash; see <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> method doc header for details.</p>
<h3>Life cycle of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a></h3>
<p >A given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> can arise either by connecting to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> on a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a>), or by listening on a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> and accepting such a connection (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>). In all cases, <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> generates a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and returns it (factory pattern). <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is not instantiable otherwise. A <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> cannot be deleted explicitly by the user and will only be returned via <code>boost::shared_ptr&lt;&gt;</code>; when both the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and all user code no longer refers to it, the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> will be destroyed.</p>
<p >Once a <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> user has a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> object, that object represents a socket in one of the following basic states:</p>
<ul>
<li>Open.<ul>
<li>Sub-states:<ul>
<li>Connecting. (Never Writable, never Readable.)</li>
<li>Connected. (May be Writable, may be Readable.)</li>
<li>Disconnecting. (May be Readable, never Writable.)</li>
</ul>
</li>
</ul>
</li>
<li>Closed.<ul>
<li>Socket can neither read nor write.</li>
</ul>
</li>
</ul>
<p >Open.Connecting means means <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> initiated a connect to the given server, and this is in progress. Open.Connected means the connection to the other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is fully functional. Open.Disconnecting means either our side or the other side has initiated a clean or abrupt disconnect, but it is not yet entirely finished (background handshaking is happening, you have not read all available data or sent all queued data, etc.).</p>
<p >In either case, reading and writing may or may not be possible at a given time, depending on the state of the internal buffers and the data having arrived on the logical connection. Thus all Open sub-states can and often should be treated the same way in a typical Flow-protocol-using algorithm: simply determine when the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is Readable, and read; and similarly for Writable and write. Thus the sub-states are distinguished for informational/diagnostic purposes only, as user reading/writing logic in these states should usually be identical.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000123">Todo:</a></b></dt><dd>Closing connection considerations. May implement closing only via timeouts at first (as opposed to explicit closing). Below text refers to <code>close_final()</code> and <code>close_start()</code>, but those are just ideas and may be replaced with timeout, or nothing. At this time, the only closing supported is abrupt close due to error or abrupt close via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a>.</dd></dl>
<p >Closed means that the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> has become disconnected, and no data can possibly be received or sent, AND that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has no more background internal operations to perform and has disowned the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. In other words, a Closed <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is entirely dead.</p>
<p >Exactly the following state transitions are possible for a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>:</p>
<ul>
<li>start =&gt; Closed</li>
<li>start =&gt; Open</li>
<li>Open =&gt; Closed</li>
</ul>
<p >Note, in particular, that Closed is final; socket cannot move from Closed to Open. If after an error or valid disconnection you want to reestablish a connection, obtain a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s factories. Rationale (subject to change): this cuts down on state having to be tracked inside a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, while the interface becomes simpler without much impact on usability. Anti-rationale: contradicts BSD socket and boost.asio established practices; potentially more resource-intensive/slower in the event of errors and disconnects. Why IMO rationale &gt; anti-rationale: it's simpler, and the potential problems do not appear immediately serious; added statefulness can be added later if found desirable.</p>
<p >Receving, sending, and buffers: <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, like a TCP socket, has a Receive buffer (a/k/a FIFO queue of bytes) of some maximum size and a Send buffer (a/k/a FIFO queue of bytes) of some maximum size. They are typically not directly exposed via the interface, but their existence affects documented behavior. I formally describe them here, but generally they work similarly to TCP socket Send/Receive buffers.</p>
<p >The Receive buffer: Contains bytes asynchronously received on the connection that have not yet been removed with a <code>*receive()</code> method. Any bytes that asynchronously arrive on the connection are asynchronously stored to the buffer on the other side of the buffer in a queued fashion.</p>
<p >The Send buffer: Contains bytes intended to be asynchronously sent on the connection that have been placed there by a <code>*send()</code> method but not yet sent on the connection. Any bytes that are asynchronously sent on the connection are asynchronously removed from the buffer on the other side of the buffer in a queued fashion.</p>
<p >With that in mind, here are the definitions of Readable and Writable while state is Open:</p>
<ul>
<li>Readable &lt;=&gt; Data available in internal Receive buffer, and user has not explicitly announced via <code>close_final()</code> they're not interested in reading further.</li>
<li>Writable &lt;=&gt; Space for data available in internal Send buffer, and the state is Open.Connected.</li>
</ul>
<p >Note that neither definition really cares about the state of the network connection (e.g., could bytes actually be sent over the network at the moment?). There is one caveat: A socket is not Writable until Open.Connecting state is transitioned away from; this prevents user from buffering up send data before the connection is ready. (Allowing that would not necessarily be wrong, but I'm taking a cue from BSD socket semantics on this, as they seem to be convenient.)</p>
<p >In Open, the following archetypal operations are provided. (In Closed all immediately fail; in Open.Disconnecting some immediately fail if <code>close*()</code> has been called.) Let R be the current size of data in the Receive buffer, and S be the available space for data in the Send buffer.</p>
<ul>
<li><code>receive(N)</code>. If Readable, return to caller <code>min(N, R)</code> oldest data to have been received from the other side, and remove them from Receive buffer. Otherwise do nothing.</li>
<li><code>send(N)</code>. If Writable, take from caller <code>min(N, S)</code> data to be appended to the Send buffer and, when possible, sent to the other side. Otherwise do nothing.</li>
<li><code>sync_receive(N)</code>. If Readable, <code>receive(N)</code>. Otherwise sleep until Readable, then <code>receive(N)</code>.</li>
<li><code>sync_send(N)</code>. If Writable, <code>send(N)</code>. Otherwise sleep until Writable, then <code>send(N)</code>.</li>
</ul>
<p >These are similar to TCP Receive and Send APIs in non-blocking mode, and TCP Receive and Send APIs in blocking mode, respectively. There may be other similarly themed methods, but all use these as semantic building blocks.</p>
<p >To understand the order of events, one can think of a disconnect-causing event (like a graceful close initiation from the remote socket) as a piece of data itself. Thus, for example, if 5 bytes are received and placed into the Receive buffer without being read by the user, and then a connection close is detected, the socket will be Readable until the 5 bytes have been <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>ed, and the next <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> (or <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>) would yield the error, since that's the order things happened. Similarly, suppose you've sent 5 bytes, but they haven't been yet sent over the wire and are sitting in the Send buffer. Then you trigger a graceful connection close. First the 5 bytes will be sent if possible, and then the closing procedure will actually begin.</p>
<p >Abrupt closes such as connection resets may force both buffers to be immediately emptied without giving to the user or writing to the other side, so that the above rule does not have to apply. Typically a connection reset means the socket is immediately unusable no matter what was in the buffers at the time, per BSD socket semantics.</p>
<h3>Efficiently reading/writing</h3>
<p >The <code>sync_*</code>() methods are efficient, in that they use no processor cycles until Readable or Writable is achieved (i.e., they sleep until that point). The non-blocking versions don't sleep/block, however. For a program using them to be efficient it should sleep until Readable or Writable and only then call <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>/send(), when data are certainly available for immediate reading or writing. Moreover, a complex program is likely to want to perform this sleep-and-conditional-wake on a set of several <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects simultaneously (similarly to <code>select()</code>, <code>epoll*()</code>, etc.). Use class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> for this purpose.</p>
<h3>Thread safety</h3>
<p >Same as for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (Briefly: all operations safe for simultaneous execution on separate or the same object.)</p>
<h2>Implementation notes </h2>
<p >While to a user a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> appears as a nearly self-sufficient object (i.e., you can do things like <code>s-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a></code>, which means 'socket <code>s</code>, send some data!''), the most reasonable way to internally implement this is to have <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> contain the logic behind a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> (and how it works together with other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects and other internal infrastructure). Thus <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is the class with all of the logic behind (for example) <code>s-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a></code>. <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> then, privately, is not too much more than a collection of data (like a <code>struct</code> almost) to help <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.</p>
<p >Therefore <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> provides a clean object-oriented public interface to the user but, on the implementation side, is basically a data store (with <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> as <code>friend</code>) and forwards the logic to the originating <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. One idea to make this dichotomy more cleanly expressed (e.g., without <code>friend</code>) was to make <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> a pure interface and have <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> produce <code>Peer_socket_impl</code> objects, where <code>Peer_socket_impl</code> implements <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and is itself private to the user (a classic factory pattern). Unfortunately defining function templates such as <code>send&lt;Buffers&gt;()</code> (where <code>Buffers</code> is an arbitrary <code>Buffers</code> concept model) as pure <code>virtual</code> functions is not really possible in C++. Since such a templated interface can be highly convenient (see boost.asio with its seamless support for buffers and buffer sequences of most types, including scatter-gather), the usefulness of the interface trumps implementation beauty.</p>
<p >To prevent node.cpp from being unmanageably large (and also because it makes sense), implementations for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> methods that deal only with an individual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> reside in peer_socket.cpp (even though they are members of <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, since, again, the logic is all forwarded to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000124">Todo:</a></b></dt><dd>Rename <code>State</code> and <code>Open_sub_state</code> to <code>Phase</code> and <code>Open_sub_phase</code> respectively; and <code>Int_state</code> to <code>State</code>. Explain difference between phases (application-layer, user-visible and used close to application layer) and states (transport layer, internal).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000125">Todo:</a></b></dt><dd>Look into a way to defeat the need for boiler-plate trickery &ndash; with low but non-zero perf cost &ndash; involving <code>*_socket</code>-vs-<code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code> circular references in method templates, such as the way <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> internally make <code><a class="el" href="classflow_1_1Function.html">Function</a>&lt;&gt;</code>s before forwarding to the core in <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. Can this be done with <code>.inl</code> files? Look into how Boost internally uses <code>.inl</code> files; this could inspire a solution... or not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00215">215</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae804be57cf09b9bf76eafa8ffff73de6" name="ae804be57cf09b9bf76eafa8ffff73de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae804be57cf09b9bf76eafa8ffff73de6">&#9670;&nbsp;</a></span>Drop_timer_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae804be57cf09b9bf76eafa8ffff73de6">flow::net_flow::Peer_socket::Drop_timer_ptr</a> =  boost::shared_ptr&lt;<a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html">Drop_timer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <code>shared_ptr</code> to immutable <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> (can't use <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Drop_timer::Ptr</a> due to C++ and circular reference). </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00856">856</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a90abde8badaf451ba6ca615e9936d5df" name="a90abde8badaf451ba6ca615e9936d5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90abde8badaf451ba6ca615e9936d5df">&#9670;&nbsp;</a></span>Lock_guard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a90abde8badaf451ba6ca615e9936d5df">flow::net_flow::Peer_socket::Lock_guard</a> =  <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">Mutex</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for RAII lock guard of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67" title="Short-hand for reentrant mutex type.">Mutex</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00899">899</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad1e36619c78b15f46576a18678a4ee67" name="ad1e36619c78b15f46576a18678a4ee67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e36619c78b15f46576a18678a4ee67">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">flow::net_flow::Peer_socket::Mutex</a> =  <a class="el" href="namespaceflow_1_1util.html#a9c7a5df07c2e86c788de9e6bbaee77d5">util::Mutex_recursive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for reentrant mutex type. </p>
<p >We explicitly rely on reentrant behavior, so this isn't "just in case."</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000131">Todo:</a></b></dt><dd>This doc header for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67" title="Short-hand for reentrant mutex type.">Peer_socket::Mutex</a> should specify what specific behavior requires mutex reentrance, so that for example one could reevaluate whether there's a sleeker code pattern that would avoid it. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00896">896</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a98c6729b318f28b61e144f8a9b1f4dfc" name="a98c6729b318f28b61e144f8a9b1f4dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c6729b318f28b61e144f8a9b1f4dfc">&#9670;&nbsp;</a></span>Options_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">flow::net_flow::Peer_socket::Options_lock</a> =  <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">util::Lock_guard</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Options_mutex</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for lock that acquires exclusive access to an <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657" title="Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.">Options_mutex</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00888">888</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1e1379f9a0269d6990f26bf1da045657" name="a1e1379f9a0269d6990f26bf1da045657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1379f9a0269d6990f26bf1da045657">&#9670;&nbsp;</a></span>Options_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">flow::net_flow::Peer_socket::Options_mutex</a> =  <a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">util::Mutex_non_recursive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for high-performance, non-reentrant, exclusive mutex used to lock <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773" title="This socket&#39;s per-socket set of options.">m_opts</a>. </p>
<h3>Rationale</h3>
<p >You might notice this seems tailor-made for shared/exclusive (a/k/a multiple-readers-single-writer) mutex. Why a 2-level mutex instead of a normal exclusive mutex? Because options can be accessed by thread W and various user threads, in the vast majority of the time to read option values. On the other hand, rarely, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773" title="This socket&#39;s per-socket set of options.">m_opts</a> may be modified via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. To avoid thread contention when no one is writing (which is usual), we could use that 2-level type of mutex and apply the appropriate (shared or unique) lock depending on the situation. So why not? Answer: While a shared/exclusive mutex sounds lovely in theory &ndash; and perhaps if its implementation were closer to the hardware it would be lovely indeed &ndash; in practice it seems its implementation just causes performance problems rather than solving them. Apparently that's why it was rejected by C++11 standards people w/r/t inclusion in that standard. The people involved explained their decision here: <a href="http://permalink.gmane.org/gmane.comp.lib.boost.devel/211180">http://permalink.gmane.org/gmane.comp.lib.boost.devel/211180</a>. So until that is improved, just do this. I'm not even adding a to-do for fixing this, as that seems unlikely anytime soon. Update: C++17 added <code>std::shared_mutex</code>, and C++14 added a similar thing named something else. Seems like a good time to revisit this &ndash; if not to materially improve <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657" title="Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.">Options_mutex</a> performance then to gain up-to-date knowledge on the topic, specifically whether <code>shared_mutex</code> is fast now. Update: Apparently as of Boost-1.80 the Boost.thread impl of <code>shared_mutex</code> is lacking in perf, and there is a ticket filed for many years for this. Perhaps gcc <code>std::shared_mutex</code> is fine. However research suggests it's less about this nitty-gritty of various impls and more the following bottom line: A simple mutex is <em>very</em> fast to lock/unlock, and perf problems occur only if one must wait for a lock. Experts say that it is possible but quite rare that there is enough lock contention to make it "worth it": a shared mutex is <em>much</em> slower to lock/unlock sans contention. Only when the read critical sections are long and very frequently accessed does it become "worth it." </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00885">885</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a797a524b73e2626fcfefe1be64f4d481" name="a797a524b73e2626fcfefe1be64f4d481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797a524b73e2626fcfefe1be64f4d481">&#9670;&nbsp;</a></span>order_num_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">flow::net_flow::Peer_socket::order_num_t</a> =  <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html#ab307e12c0cf8cefbe7fb1ec8588af2a8">Sequence_number::seq_num_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for order number type. 0 is reserved. Caution: Keep in sync with <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html#a0930c4da4484ffc1f8bcfbc496e5ecd0" title="Type to uniquely identify a packet sent over the wire in the socket to which this Drop_timer applies.">Drop_timer::packet_id_t</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00905">905</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1869760d5cfc5c0d22665e5db88710e4" name="a1869760d5cfc5c0d22665e5db88710e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1869760d5cfc5c0d22665e5db88710e4">&#9670;&nbsp;</a></span>Rcv_syn_rcvd_data_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1869760d5cfc5c0d22665e5db88710e4">flow::net_flow::Peer_socket::Rcv_syn_rcvd_data_q</a> =  std::vector&lt;boost::shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Data__packet.html">Data_packet</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed" title="The queue of DATA packets received while in Int_state::S_SYN_RCVD state before the Syn_ack_ack_packet...">m_rcv_syn_rcvd_data_q</a>. </p>
<p >Using <code>vector</code> because we only need <code>push_back()</code> and iteration at the moment. Using pointer to non-<code>const</code> instead of <code>const</code> because when we actually handle the packet as received we will need to be able to modify the packet for performance (see <a class="el" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">Node::handle_data_to_established()</a>, when it transfers data to Receive buffer). </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00981">981</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ade41e13eb5176d833c7b1ea144612353" name="ade41e13eb5176d833c7b1ea144612353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade41e13eb5176d833c7b1ea144612353">&#9670;&nbsp;</a></span>Recvd_pkt_const_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ade41e13eb5176d833c7b1ea144612353">flow::net_flow::Peer_socket::Recvd_pkt_const_iter</a> =  Recvd_pkt_map::const_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> <code>const</code> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00968">968</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aaec992a7a14368623cc03c4382d71107" name="aaec992a7a14368623cc03c4382d71107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec992a7a14368623cc03c4382d71107">&#9670;&nbsp;</a></span>Recvd_pkt_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aaec992a7a14368623cc03c4382d71107">flow::net_flow::Peer_socket::Recvd_pkt_iter</a> =  Recvd_pkt_map::iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00971">971</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="addfc181f4d43ab816b2ede9216bf9331" name="addfc181f4d43ab816b2ede9216bf9331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfc181f4d43ab816b2ede9216bf9331">&#9670;&nbsp;</a></span>Recvd_pkt_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">flow::net_flow::Peer_socket::Recvd_pkt_map</a> =  std::map&lt;<a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, boost::shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html">Received_packet</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> type; see that data member. </p>
<p ><code>struct</code>s are stored via shared pointers instead of as direct objects to minimize copying of potentially heavy-weight data. They are stored as shared pointers instead of as raw pointers to avoid having to worry about <code>delete</code>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00965">965</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a59db68ed0c77a9f6e1a7aeeb3df2a6b9" name="a59db68ed0c77a9f6e1a7aeeb3df2a6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">&#9670;&nbsp;</a></span>security_token_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">flow::net_flow::Peer_socket::security_token_t</a> =  uint64_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a33a90b123612cc2e6a119cfa95ba4f6d" title="Random security token used during SYN_ACK-SYN_ACK_ACK.">m_security_token</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00902">902</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad10b3cd1d32b48cab8146ba4d07cb814" name="ad10b3cd1d32b48cab8146ba4d07cb814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10b3cd1d32b48cab8146ba4d07cb814">&#9670;&nbsp;</a></span>Sent_pkt_by_sent_when_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814">flow::net_flow::Peer_socket::Sent_pkt_by_sent_when_map</a> =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">util::Linked_hash_map</a>&lt;<a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, boost::shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Sent_packet</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> type; see that data member. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00940">940</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1958264af0c40f3c9c5769ddff4c9ade" name="a1958264af0c40f3c9c5769ddff4c9ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1958264af0c40f3c9c5769ddff4c9ade">&#9670;&nbsp;</a></span>Sent_pkt_by_seq_num_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">flow::net_flow::Peer_socket::Sent_pkt_by_seq_num_map</a> =  std::map&lt;<a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Sent_pkt_ordered_by_when_iter</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> type; see that data member. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00949">949</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="abd6f3174914c3ec559954b4125f2f9dd" name="abd6f3174914c3ec559954b4125f2f9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6f3174914c3ec559954b4125f2f9dd">&#9670;&nbsp;</a></span>Sent_pkt_ordered_by_seq_const_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#abd6f3174914c3ec559954b4125f2f9dd">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_seq_const_iter</a> =  Sent_pkt_by_seq_num_map::const_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> <code>const</code> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00952">952</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a9320421e96ab89e6528da6a28b008709" name="a9320421e96ab89e6528da6a28b008709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9320421e96ab89e6528da6a28b008709">&#9670;&nbsp;</a></span>Sent_pkt_ordered_by_seq_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9320421e96ab89e6528da6a28b008709">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_seq_iter</a> =  Sent_pkt_by_seq_num_map::iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00955">955</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ac974bdce3d2035d2af69078837f59482" name="ac974bdce3d2035d2af69078837f59482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac974bdce3d2035d2af69078837f59482">&#9670;&nbsp;</a></span>Sent_pkt_ordered_by_when_const_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2b5383264c89ac63cc8827b18063f2ca">Sent_pkt_by_sent_when_map::const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> <code>const</code> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00943">943</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ab7dc3b752b67295c82919c2f87aed60b" name="ab7dc3b752b67295c82919c2f87aed60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dc3b752b67295c82919c2f87aed60b">&#9670;&nbsp;</a></span>Sent_pkt_ordered_by_when_iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_iter</a> =  <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1f09f98b4089a8c3ffd0b7f732923b44">Sent_pkt_by_sent_when_map::iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> iterator type. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00946">946</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a9537860c2c2a7380a45a525e5121880f" name="a9537860c2c2a7380a45a525e5121880f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9537860c2c2a7380a45a525e5121880f">&#9670;&nbsp;</a></span>Int_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">flow::net_flow::Peer_socket::Int_state</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The state of the socket (and the connection from this end's point of view) for the internal state machine governing the operation of the socket. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000132">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f" title="The state of the socket (and the connection from this end&#39;s point of view) for the internal state mac...">Peer_socket::Int_state</a> will also include various states on way to a graceful close, once we implement that. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f" name="a9537860c2c2a7380a45a525e5121880fa6abcbd1be8478aa03e76aec9c540e14f"></a>S_CLOSED&#160;</td><td class="fielddoc"><p >Closed (dead or new) socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87" name="a9537860c2c2a7380a45a525e5121880fa20112c63421f4aa5d77b5d5ba5b10c87"></a>S_SYN_SENT&#160;</td><td class="fielddoc"><p >Public state is OPEN+CONNECTING; user requested active connect; we sent SYN and are awaiting response. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" name="a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2"></a>S_SYN_RCVD&#160;</td><td class="fielddoc"><p >Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and are awaiting response. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" name="a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202"></a>S_ESTABLISHED&#160;</td><td class="fielddoc"><p >Public state is OPEN+CONNECTED; in our opinion the connection is established. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00913">913</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a6f48d01d1269c9d4260d972baa40e548" name="a6f48d01d1269c9d4260d972baa40e548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f48d01d1269c9d4260d972baa40e548">&#9670;&nbsp;</a></span>Open_sub_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">flow::net_flow::Peer_socket::Open_sub_state</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sub-state of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb" name="a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb"></a>S_CONNECTING&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), and the connection to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently being negotiated by this socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >A socket in this state may be Writable but cannot be Readable. However, except for diagnostic purposes, this state should generally be treated the same as S_CONNECTED. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe" name="a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe"></a>S_CONNECTED&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through a passive connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">Node::accept()</a> and the like) or an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), and the connection is (as far this socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> knows) set up and functioning. </p>
<p >A socket in this state may be Writable or Readable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9" name="a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9"></a>S_DISCONNECTING&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through a passive connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567" title="Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...">Node::accept()</a> and the like) or an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), but since then either an active close, passive close, or an error has begun to close the connection, but data may still possibly arrive and be Readable; also data may have been "sent" but still sitting in the Send buffer and needs to be sent over the network. </p>
<p >A socket in this state may be Readable but cannot be Writable.</p>
<p >This implies that a non-S_CLOSED socket may be, at a lower level, disconnected. For example, say there are 5 bytes in the Receive buffer, and the other side sends a graceful disconnect packet to this socket. This means the connection is finished, but the user can still <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> the 5 bytes (without blocking). Then state will remain S_OPEN.S_DISCONNECTING until the last of the 5 bytes is received (gone from the buffer); at this point state may change to S_CLOSED (pending any other work <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> must do to be able to disown the socket). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00237">237</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a6a9bb727c8982f24bcf978c10c2c7345" name="a6a9bb727c8982f24bcf978c10c2c7345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9bb727c8982f24bcf978c10c2c7345">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">flow::net_flow::Peer_socket::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" name="a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189"></a>S_OPEN&#160;</td><td class="fielddoc"><p >Future reads or writes may be possible. A socket in this state may be Writable or Readable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" name="a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f"></a>S_CLOSED&#160;</td><td class="fielddoc"><p >Neither future reads nor writes are possible, AND <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has disowned the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00228">228</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a729af2cb3465b67b811d8e9438b5af5d" name="a729af2cb3465b67b811d8e9438b5af5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729af2cb3465b67b811d8e9438b5af5d">&#9670;&nbsp;</a></span>~Peer_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Peer_socket::~Peer_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boring <code>virtual</code> destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00077">77</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>.</p>

</div>
</div>
<a id="a5003c554807f5b5b58989ad58be48d42" name="a5003c554807f5b5b58989ad58be48d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5003c554807f5b5b58989ad58be48d42">&#9670;&nbsp;</a></span>Peer_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Peer_socket::Peer_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> *&#160;</td>
          <td class="paramname"><em>task_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use subsequently. </td></tr>
    <tr><td class="paramname">task_engine</td><td>IO service for the timer(s) stored as data member(s). </td></tr>
    <tr><td class="paramname">opts</td><td>The options set to copy into this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and use subsequently. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00037">37</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00318">options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00234">node_sync_receive()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00149">node_sync_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a5003c554807f5b5b58989ad58be48d42_cgraph.svg" width="502" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a5003c554807f5b5b58989ad58be48d42_icgraph.svg" width="779" height="302"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd100a3c02fad5d9e00fcbc1f645f116" name="acd100a3c02fad5d9e00fcbc1f645f116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd100a3c02fad5d9e00fcbc1f645f116">&#9670;&nbsp;</a></span>bytes_blocks_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::net_flow::Peer_socket::bytes_blocks_str </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that, given a byte count, returns a string with that byte count and the number of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a>-size blocks that can fit within it (rounded down). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00424">424</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l00352">max_block_size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_acd100a3c02fad5d9e00fcbc1f645f116_cgraph.svg" width="551" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9ab710704237f912eb219f9b8d574afc" name="a9ab710704237f912eb219f9b8d574afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab710704237f912eb219f9b8d574afc">&#9670;&nbsp;</a></span>close_abruptly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket::close_abruptly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acts as if fatal error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8" title="User code on this side abruptly closed connection; other side may be informed of this.">error::Code::S_USER_CLOSED_ABRUPTLY</a> has been discovered on the connection. </p>
<p >Does not block.</p>
<p >Post-condition: <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a></code>. Additionally, assuming no loss on the network, the other side will close the connection with error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4" title="Other side reset an established connection.">error::Code::S_CONN_RESET_BY_OTHER_SIDE</a>.</p>
<p >Note: Discovering a fatal error on the connection would trigger all event waits on this socket (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>) to execute on-event behavior (return, return, return, invoke handler, respectively). Therefore this method will cause just that, if applicable.</p>
<p >Note: As a corollary, a socket closing this way (or any other way) does NOT cause that socket's events (if any) to be removed from any <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects. Clearing an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> of all or some sockets is the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> user's responsibility (the classic way being <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>The moment the other side is informed we have abruptly closed the connection, they will no longer be able to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> any of it (even if data had been queued up in their Receive buffer).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000127">Todo:</a></b></dt><dd>Currently this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> is the only way for the user to explicitly close one specified socket. All other ways are due to error (or other side starting graceful shutdown, once we implement that). Once we implement graceful close, via <code>close_start()</code> and <code>close_final()</code>, use of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> should be discouraged, or it may even be deprecated (e.g., <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s lack a way to initiate an abrupt close for a specific socket).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000128">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> return <code>bool</code> (<code>false</code> on failure)?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, or &ndash; if socket already closed (<code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a></code>) &ndash; then the error that caused the closure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00269">269</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l00269">close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05621">flow::net_flow::Node::close_abruptly()</a>, <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="error_2error_8hpp_source.html#l00168">flow::error::exec_void_and_throw_on_error()</a>, <a class="el" href="util__fwd_8hpp_source.html#l00965">FLOW_UTIL_WHERE_AM_I_STR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, and <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00269">close_abruptly()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a9ab710704237f912eb219f9b8d574afc_cgraph.svg" width="1238" height="923"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a9ab710704237f912eb219f9b8d574afc_icgraph.svg" width="162" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a74f6fd527766fdeb05a96c5c03729a00" name="a74f6fd527766fdeb05a96c5c03729a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f6fd527766fdeb05a96c5c03729a00">&#9670;&nbsp;</a></span>disconnect_cause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> flow::net_flow::Peer_socket::disconnect_cause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED. </p>
<p >For example, error::code::S_CONN_RESET_BY_OTHER_SIDE (if was connected) or <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090" title="Other side did not complete connection handshake within the allowed time; perhaps no one is listening...">error::Code::S_CONN_TIMEOUT</a> (if was connecting)</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00101">101</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01312">m_disconnect_cause</a>, and <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2peer__socket_8cpp_source.html#l00132">flow::net_flow::asio::Peer_socket::node_or_post_error()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a74f6fd527766fdeb05a96c5c03729a00_icgraph.svg" width="772" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac7cbefb99ae173bd5f355f5d082564ce" name="ac7cbefb99ae173bd5f355f5d082564ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cbefb99ae173bd5f355f5d082564ce">&#9670;&nbsp;</a></span>ensure_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::ensure_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that is equivalent to Node::ensure_sock_open(this, err_code). </p>
<p >Used by templated methods which must be defined in this header file, which means they cannot access <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> members directly, as <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is an incomplete type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0" title="Helper method that checks whether the given Peer_socket or Server_socket is CLOSED; if so,...">Node::ensure_sock_open()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0" title="Helper method that checks whether the given Peer_socket or Server_socket is CLOSED; if so,...">Node::ensure_sock_open()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00419">419</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00390">get_connect_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ac7cbefb99ae173bd5f355f5d082564ce_cgraph.svg" width="336" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ac7cbefb99ae173bd5f355f5d082564ce_icgraph.svg" width="340" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0c99637726b3c2b2ff1dbf14c6c92752" name="a0c99637726b3c2b2ff1dbf14c6c92752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c99637726b3c2b2ff1dbf14c6c92752">&#9670;&nbsp;</a></span>get_connect_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::get_connect_metadata </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::mutable_buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the serialized connect metadata, as supplied by the user during the connection handshake. </p>
<p >If this side initiated the connection (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and friends), then this will equal what was passed to the connect_with_metadata() (or similar) method. More likely, if this side accepted the connection (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> and friends), then this will equal what the user on the OTHER side passed to connect_with_metadata() or similar.</p>
<dl class="section note"><dt>Note</dt><dd>It is up to the user to deserialize the metadata portably. One recommended convention is to use <code>boost::endian::native_to_little()</code> (and similar) before connecting; and on the other side use the reverse (<code>boost::endian::little_to_native()</code>) before using the value. Packet dumps will show a flipped (little-endian) representation, while with most platforms the conversion will be a no-op at compile time. Alternatively use <code>native_to_big()</code> and vice-versa. </dd>
<dd>
If a connect() variant without <code>_with_metadata</code> in the name was used, then the metadata are composed of a single byte with the zero value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to copy the metadata into. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the copied metadata. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00390">390</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l00419">ensure_open()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8cpp_source.html#l00390">get_connect_metadata()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, and <a class="el" href="peer__socket_8hpp_source.html#l01328">m_serialized_metadata</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00390">get_connect_metadata()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a0c99637726b3c2b2ff1dbf14c6c92752_cgraph.svg" width="523" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a0c99637726b3c2b2ff1dbf14c6c92752_icgraph.svg" width="150" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad81cc16fc6f0d353fdc1379e1dd4712" name="aad81cc16fc6f0d353fdc1379e1dd4712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad81cc16fc6f0d353fdc1379e1dd4712">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> flow::net_flow::Peer_socket::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a structure containing the most up-to-date stats about this connection. </p>
<dl class="section note"><dt>Note</dt><dd>At the cost of reducing locking overhead in 99.999999% of the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>'s operation, this method may take a bit of time to run. It's still probably only 10 times or so slower than a simple lock, work, unlock &ndash; there is a condition variable and stuff involved &ndash; but this may matter if done very frequently. So you probably should not. (Hmmm... where did I get these estimates, namely "10 times or so"?)</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000130">Todo:</a></b></dt><dd>Provide a similar <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">info()</a> method that loads an existing structure (for structure reuse).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00323">323</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02166">m_info_on_close</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06344">flow::net_flow::Node::sock_info()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_aad81cc16fc6f0d353fdc1379e1dd4712_cgraph.svg" width="726" height="275"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7af387476aa0bdc6b3906c153d824acb" name="a7af387476aa0bdc6b3906c153d824acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af387476aa0bdc6b3906c153d824acb">&#9670;&nbsp;</a></span>local_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Peer_socket::local_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The local Flow-protocol port chosen by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (if active or passive open) or user (if passive open) for this side of the connection. </p>
<p >For a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, this will always return the same value, even if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>. However, when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, the port may be unused or taken by another socket.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00384">384</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01347">m_local_port</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06514">operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a7af387476aa0bdc6b3906c153d824acb_icgraph.svg" width="324" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa1f821dde38a7aa572651730744edbd8" name="aa1f821dde38a7aa572651730744edbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f821dde38a7aa572651730744edbd8">&#9670;&nbsp;</a></span>max_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::max_block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes of user data per received or sent packet on this connection. </p>
<p >See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7" title="The size of block that we will strive to (and will, assuming at least that many bytes are available i...">Peer_socket_options::m_st_max_block_size</a>. Note that this method is ESSENTIAL when using the socket in unreliable mode (assuming you want to implement reliability outside of <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>).</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00352">352</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01178">m_opts</a>, <a class="el" href="options_8hpp_source.html#l00114">flow::net_flow::Peer_socket_options::m_st_max_block_size</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02644">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00424">bytes_blocks_str()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03957">flow::net_flow::Node::connect_with_metadata()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00357">max_block_size_multiple()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_aa1f821dde38a7aa572651730744edbd8_cgraph.svg" width="343" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_aa1f821dde38a7aa572651730744edbd8_icgraph.svg" width="794" height="204"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a102b78eaac9c8add512238ec5f26fcfc" name="a102b78eaac9c8add512238ec5f26fcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102b78eaac9c8add512238ec5f26fcfc">&#9670;&nbsp;</a></span>max_block_size_multiple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::max_block_size_multiple </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>opt_val_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inflate_pct_val_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest multiple of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a> that is &gt;= the given option value, optionally first inflated by a certain %. </p>
<p >The intended use case is to obtain a Send of Receive buffer max size that is about equal to the user-specified (or otherwise obtained) value, in bytes, but is a multiple of max-block-size &ndash; to prevent fragmenting max-block-size-sized chunks of data unnecessarily &ndash; and to possibly inflate that value by a certain percentage for subtle flow control reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_val_ref</td><td>A reference to a <code>size_t</code>-sized socket option, as would be passed to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>. This is the starting value. </td></tr>
    <tr><td class="paramname">inflate_pct_val_ptr</td><td>A pointer to an <code>unsigned int</code>-sized socket option, as would be passed to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>. This is the % by which to inflate opt_val_ref before rounding up to nearest <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a> multiple. If null, the % is assumed to be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00357">357</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="util_2util_8hpp_source.html#l00233">flow::util::ceil_div()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01178">m_opts</a>, <a class="el" href="peer__socket_8hpp_source.html#l01181">m_opts_mutex</a>, <a class="el" href="options_8hpp_source.html#l00114">flow::net_flow::Peer_socket_options::m_st_max_block_size</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00352">max_block_size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a102b78eaac9c8add512238ec5f26fcfc_cgraph.svg" width="546" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa9e7e1be830c901bc7348742e79ba2e7" name="aa9e7e1be830c901bc7348742e79ba2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e7e1be830c901bc7348742e79ba2e7">&#9670;&nbsp;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> * flow::net_flow::Peer_socket::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to (guaranteed valid) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>; null if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00095">95</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, and <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio_2peer__socket_8cpp_source.html#l00132">flow::net_flow::asio::Peer_socket::node_or_post_error()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_aa9e7e1be830c901bc7348742e79ba2e7_icgraph.svg" width="732" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af3ac1b0b3c9b1c3a5ec246148595c657" name="af3ac1b0b3c9b1c3a5ec246148595c657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ac1b0b3c9b1c3a5ec246148595c657">&#9670;&nbsp;</a></span>node_receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::node_receive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;&#160;</td>
          <td class="paramname"><em>rcv_buf_consume_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-template helper for template <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> that forwards the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> logic to <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a>. </p>
<p >Would be pointless to try to explain more here; see code and how it's used. Anyway, this has to be in this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rcv_buf_consume_func</td><td><a class="el" href="classflow_1_1Function.html">Function</a> that will perform and return <code>m_rcv_buf-&gt;consume(...)</code>. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value to be returned by calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c" title="Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...">Node::receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00219">219</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, and <a class="el" href="peer__socket_8cpp_source.html#l05089">flow::net_flow::Node::receive()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02552">receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_af3ac1b0b3c9b1c3a5ec246148595c657_cgraph.svg" width="1828" height="779"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_af3ac1b0b3c9b1c3a5ec246148595c657_icgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a83ba2b4c39555afad67932ea6ed39bbe" name="a83ba2b4c39555afad67932ea6ed39bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ba2b4c39555afad67932ea6ed39bbe">&#9670;&nbsp;</a></span>node_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::node_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;&#160;</td>
          <td class="paramname"><em>snd_buf_feed_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-template helper for template <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> that forwards the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> logic to <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a>. </p>
<p >Would be pointless to try to explain more here; see code and how it's used. Anyway, this has to be in this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd_buf_feed_func</td><td><a class="el" href="classflow_1_1Function.html">Function</a> that will perform and return <code>m_snd_buf-&gt;feed(...)</code>. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value to be returned by calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc" title="Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...">Node::send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00134">134</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, and <a class="el" href="peer__socket_8cpp_source.html#l04526">flow::net_flow::Node::send()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02448">send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a83ba2b4c39555afad67932ea6ed39bbe_cgraph.svg" width="1158" height="844"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a83ba2b4c39555afad67932ea6ed39bbe_icgraph.svg" width="319" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8abde92d5189bf2a058fe8741789f814" name="a8abde92d5189bf2a058fe8741789f814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abde92d5189bf2a058fe8741789f814">&#9670;&nbsp;</a></span>node_sync_receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::node_sync_receive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t()&gt; &amp;&#160;</td>
          <td class="paramname"><em>rcv_buf_consume_func_or_empty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657" title="Non-template helper for template receive() that forwards the receive() logic to Node::receive().">node_receive()</a> is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rcv_buf_consume_func_or_empty</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af3ac1b0b3c9b1c3a5ec246148595c657" title="Non-template helper for template receive() that forwards the receive() logic to Node::receive().">node_receive()</a>. Additionally, if this is <code>.empty()</code> then <code>null_buffers</code> a/k/a "reactor pattern" mode is engaged. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518" title="Same as sync_receive() but uses a Fine_clock-based Fine_duration non-template type for implementation...">sync_receive_impl()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00234">234</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, <a class="el" href="peer__socket_8cpp_source.html#l00037">Peer_socket()</a>, <a class="el" href="peer__socket_8cpp_source.html#l05089">flow::net_flow::Node::receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a7cedcbdde2b86daeb1268c63c6cb6b88">flow::net_flow::Event_set::S_PEER_SOCKET_READABLE</a>, and <a class="el" href="node_8hpp_source.html#l03977">flow::net_flow::Node::sync_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02610">sync_receive_impl()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00197">sync_receive_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a8abde92d5189bf2a058fe8741789f814_cgraph.svg" width="1860" height="1099"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a8abde92d5189bf2a058fe8741789f814_icgraph.svg" width="592" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a34e2c7dfb5596269a6f86a716015f1a6" name="a34e2c7dfb5596269a6f86a716015f1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2c7dfb5596269a6f86a716015f1a6">&#9670;&nbsp;</a></span>node_sync_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::node_sync_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1Function.html">Function</a>&lt; size_t(size_t max_data_size)&gt; &amp;&#160;</td>
          <td class="paramname"><em>snd_buf_feed_func_or_empty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe" title="Non-template helper for template send() that forwards the send() logic to Node::send().">node_send()</a> is to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd_buf_feed_func_or_empty</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a83ba2b4c39555afad67932ea6ed39bbe" title="Non-template helper for template send() that forwards the send() logic to Node::send().">node_send()</a>. Additionally, if this is <code>.empty()</code> then <code>null_buffers</code> a/k/a "reactor pattern" mode is engaged. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d" title="Same as sync_send() but uses a Fine_clock-based Fine_duration non-template type for implementation co...">sync_send_impl()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00149">149</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, <a class="el" href="peer__socket_8cpp_source.html#l00037">Peer_socket()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71a5efb94617bcb00507a087224ce7a7d02">flow::net_flow::Event_set::S_PEER_SOCKET_WRITABLE</a>, <a class="el" href="peer__socket_8cpp_source.html#l04526">flow::net_flow::Node::send()</a>, and <a class="el" href="node_8hpp_source.html#l03977">flow::net_flow::Node::sync_op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02518">sync_send_impl()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00112">sync_send_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a34e2c7dfb5596269a6f86a716015f1a6_cgraph.svg" width="1200" height="1016"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a34e2c7dfb5596269a6f86a716015f1a6_icgraph.svg" width="570" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="accf6d724ed1f145716ae3d4567f582f3" name="accf6d724ed1f145716ae3d4567f582f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf6d724ed1f145716ae3d4567f582f3">&#9670;&nbsp;</a></span>opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Opt_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Opt_type flow::net_flow::Peer_socket::opt </td>
          <td>(</td>
          <td class="paramtype">const Opt_type &amp;&#160;</td>
          <td class="paramname"><em>opt_val_ref</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595" title="Obtain a copy of the value of a given option in a thread-safe manner.">Node::opt()</a> but for per-socket options. </p>
<p >See that method.</p>
<p >Do NOT read option values without <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Opt_type</td><td>The type of the option data member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_val_ref</td><td>A reference (important!) to the value you want; this may be either a data member of this-&gt;m_opts or the entire this-&gt;m_opts itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the value at the given reference. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02644">2644</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01181">m_opts_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00352">max_block_size()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00318">options()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00373">rexmit_on()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_accf6d724ed1f145716ae3d4567f582f3_icgraph.svg" width="1439" height="844"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad94e37c8cca01f801f13e9e0e0bc857d" name="ad94e37c8cca01f801f13e9e0e0bc857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e37c8cca01f801f13e9e0e0bc857d">&#9670;&nbsp;</a></span>options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> flow::net_flow::Peer_socket::options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this socket's option set and returns that copy. </p>
<p >If you intend to use <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> to modify a socket's options, we recommend you make the modifications on the copy returned by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000129">Todo:</a></b></dt><dd>Provide a similar <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a> method that loads an existing structure (for structure reuse).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00318">318</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01178">m_opts</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02644">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00037">Peer_socket()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ad94e37c8cca01f801f13e9e0e0bc857d_cgraph.svg" width="318" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ad94e37c8cca01f801f13e9e0e0bc857d_icgraph.svg" width="956" height="302"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aeb88e9253cc3f52269cb762c8e57e6d0" name="aeb88e9253cc3f52269cb762c8e57e6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb88e9253cc3f52269cb762c8e57e6d0">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of bytes as inferred from size of provided target buffer sequence. </p>
<p >The data are copied into the user's structure and then removed from the Receive buffer.</p>
<p >The method does not block. In particular if there are no data already received from the other side, we return no data.</p>
<p >If the provided buffer has size zero, the method is a NOOP other than possibly logging.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes.</p><ol type="1">
<li>There are no data in the Receive buffer. Socket not Readable. 0 is returned; <code>*err_code</code> is set to success unless null; no data returned.</li>
<li>The socket is not yet fully connected (<code>S_OPEN+S_CONNECTING</code>). Socket not Readable. 0 is returned; <code>*err_code</code> is set to success unless null; no data returned.</li>
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. &gt;= 1 is returned; *err_code is set to success; data returned.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.)</li>
</ol>
<p >The semantics of -3- (the success case) are as follows. N bytes will be copied from Receive buffer beginning at the start of the <code>Mutable_buffer_sequence target</code>. These N bytes may be spread across 1 or more buffers in that sequence; the subdivision structure of the sequence of bytes into buffers has no effect on the bytes, or order thereof, that will be moved from the Receive buffer (e.g., <code>target</code> could be N+ 1-byte buffers, or one N+-byte buffer &ndash; the popped Receive buffer would be the same, as would be the extracted bytes). N equals the smaller of: the available bytes in the Receive buffer; and <code>buffer_size(target)</code>. We return N.</p>
<h3>Reliability and ordering guarantees</h3>
<p >See the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>Type that models the boost.asio <code>MutableBufferSequence</code> concept (see Boost docs). Basically, it's any container with elements convertible to <code>boost::asio::mutable_buffer</code>; and bidirectional iterator support. Examples: <code>vector&lt;mutable_buffer&gt;</code>, <code>list&lt;mutable_buffer&gt;</code>. Why allow <code>mutable_buffer</code> instead of, say, <code>Sequence</code> of bytes? Same reason as boost.asio's receive functions: it allows a great amount of flexibility without sacrificing performance, since <code>boost::asio::buffer()</code> function can adapt lots of different objects (arrays, <code>vector</code>s, <code>string</code>s, and more of bytes, integers, and more). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Buffer sequence to which a stream of bytes to consume from Receive buffer will be written. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes consumed (placed into <code>target</code>). Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02552">2552</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="socket__buffer_8hpp_source.html#l00543">flow::net_flow::Socket_buffer::consume_bufs_copy()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01260">m_rcv_buf</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00219">node_receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_aeb88e9253cc3f52269cb762c8e57e6d0_cgraph.svg" width="1186" height="307"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5e423a9fd18a45cc7cc5fc34af29161e" name="a5e423a9fd18a45cc7cc5fc34af29161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e423a9fd18a45cc7cc5fc34af29161e">&#9670;&nbsp;</a></span>remote_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp; flow::net_flow::Peer_socket::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended other side of the connection (regardless of success, failure, or current State). </p>
<p >For a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, this will always return the same value, even if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00378">378</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01344">m_remote_endpoint</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l06514">operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a5e423a9fd18a45cc7cc5fc34af29161e_icgraph.svg" width="359" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a89d852e3722532d75006b024714a5cef" name="a89d852e3722532d75006b024714a5cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d852e3722532d75006b024714a5cef">&#9670;&nbsp;</a></span>rexmit_on()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::rexmit_on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether retransmission is enabled on this connection. </p>
<p >Short-hand for appropriate <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a> call. Note this always returns the same value for a given object.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00373">373</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01178">m_opts</a>, <a class="el" href="options_8hpp_source.html#l00214">flow::net_flow::Peer_socket_options::m_st_rexmit_on</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02644">opt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l02551">flow::net_flow::Node::categorize_individual_ack()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03108">flow::net_flow::Node::drop_pkts_on_acks()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03323">flow::net_flow::Node::drop_timer_action()</a>, <a class="el" href="peer__socket_8cpp_source.html#l02061">flow::net_flow::Node::handle_accumulated_acks()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00560">flow::net_flow::Node::handle_data_to_established()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l03641">flow::net_flow::Node::log_snd_window()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a89d852e3722532d75006b024714a5cef_cgraph.svg" width="318" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a89d852e3722532d75006b024714a5cef_icgraph.svg" width="1840" height="588"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af90b656d7e0b7e746b8beb4e24717cec" name="af90b656d7e0b7e746b8beb4e24717cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90b656d7e0b7e746b8beb4e24717cec">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asynchronously sends them to the other side. </p>
<p >The data given is copied into <code>*this</code>, in the order given. Only as many bytes as possible without the Send buffer size exceeding a certain max are copied.</p>
<p >The method does not block. Data are then sent asynchronously (in the background).</p>
<p >Method does nothing except possibly logging if there are no bytes in data.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes.</p><ol type="1">
<li>There is no space in the Send buffer (usually due to network congestion). Socket not Writable. 0 is returned; <code>*err_code</code> is set to success unless null; no data buffered.</li>
<li>The socket is not yet fully connected (<code>S_OPEN+S_CONNECTING</code> state). Socket not Writable. 0 is returned; <code>*err_code</code> is set to success unless null; no data buffered.</li>
<li>There is space in the Send buffer, and socket connection is open (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. &gt;= 1 is returned; <code>*err_code</code> is set to success; data buffered.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.)</li>
</ol>
<p >The semantics of -3- (the success case) are as follows. N bytes will be copied into Send buffer from the start of the Const_buffer_sequence data. These N bytes may be spread across 1 or more buffers in that sequence; the subdivision structure of the sequence of bytes into buffers has no effect on what will be buffered in Send buffer (e.g., "data" could be N+ 1-byte buffers, or one N+-byte buffer &ndash; the result would be the same). N equals the smaller of: the available space in the Send buffer; and <code>buffer_size(data)</code>. We return N.</p>
<h3>Reliability and ordering guarantees: if the socket option rexmit-on is enabled</h3>
<p >Reliability and ordering are guaranteed, and there is no notion of message boundaries. There is no possibility of data duplication. In other words full stream-of-bytes functionality is provided, as in TCP.</p>
<h3>Reliability and ordering guarantees: if the socket option rexmit-on is NOT enabled</h3>
<p >NO reliability guarantees are given, UNLESS <em>ALL</em> calls to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> (and other <code>*send</code>() methods) satisfy the condition: '<code>buffer_size(data)</code> is a multiple of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a></code>'; AND all calls to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> (and other <code>*receive()</code> methods) on the OTHER side satisfy the condition: '<code>buffer_size(target)</code> is a multiple of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a></code>.' If and only if these guidelines are followed, and there is no connection closure, the following reliability guarantee is made:</p>
<p >Let a "block" be a contiguous chunk of bytes in a "data" buffer sequence immediately following another "block," except the first "block" in a connection, which begins with the first byte of the "data" buffer sequence passed to the first <code>*send()</code> call on that connection. Then: Each given block will either be available to <code>*receive()</code> on the other side exactly once and without corruption; or not available to <code>*receive()</code> at all. Blocks may arrive in a different order than specified here, including with respect to other <code>*send()</code> calls performed before or after this one. In other words, these are guaranteed: block boundary preservation, protection against corruption, protection again duplication. These are not guaranteed: order preservation, delivery. Informally, the latter factors are more likely to be present on higher quality network paths.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Const_buffer_sequence</td><td>Type that models the boost.asio <code>ConstBufferSequence</code> concept (see Boost docs). Basically, it's any container with elements convertible to <code>boost::asio::const_buffer</code>; and bidirectional iterator support. Examples: <code>vector&lt;const_buffer&gt;</code>, <code>list&lt;const_buffer&gt;</code>. Why allow <code>const_buffer</code> instead of, say, <code>Sequence</code> of bytes? Same reason as boost.asio's send functions: it allows a great amount of flexibility without sacrificing performance, since <code>boost::asio::buffer()</code> function can adapt lots of different objects (arrays, <code>vector</code>s, <code>string</code>s, and more &ndash; composed of bytes, integers, and more). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer sequence from which a stream of bytes to add to Send buffer will be obtained. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> nor any subsequent <code>*send()</code> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to buffer. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02448">2448</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="socket__buffer_8hpp_source.html#l00391">flow::net_flow::Socket_buffer::feed_bufs_copy()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01278">m_snd_buf</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00134">node_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_af90b656d7e0b7e746b8beb4e24717cec_cgraph.svg" width="1114" height="307"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7d31cf18a3c075873de1c46c0176e41f" name="a7d31cf18a3c075873de1c46c0176e41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d31cf18a3c075873de1c46c0176e41f">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>) with the given options set. </p>
<p >Only those members of <code>opts</code> designated as dynamic (as opposed to static) may be different between <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a> and <code>opts</code>. If this is violated, it is an error, and no options are changed.</p>
<p >Typically one would acquire a copy of the existing options set via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>, modify the desired dynamic data members of that copy, and then apply that copy back by calling <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The new options to apply to this socket. It is copied; no reference is saved. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58" title="When setting options, tried to set an unchangeable (static) option.">error::Code::S_STATIC_OPTION_CHANGED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00297">297</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="node_8hpp_source.html#l04141">flow::net_flow::Node::ensure_sock_open()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01217">m_node</a>, <a class="el" href="peer__socket_8cpp_source.html#l00297">set_options()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06197">flow::net_flow::Node::sock_set_options()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00297">set_options()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a7d31cf18a3c075873de1c46c0176e41f_cgraph.svg" width="703" height="166"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a7d31cf18a3c075873de1c46c0176e41f_icgraph.svg" width="146" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af982953b5136c1df488066eacc293a78" name="af982953b5136c1df488066eacc293a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982953b5136c1df488066eacc293a78">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> flow::net_flow::Peer_socket::state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> *&#160;</td>
          <td class="paramname"><em>open_sub_state</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current State of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_sub_state</td><td>Ignored if null. Otherwise, if and only if <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a> is returned, <code>*open_sub_state</code> is set to the current sub-state of <code>S_OPEN</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current main state of the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00085">85</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01201">m_open_sub_state</a>, <a class="el" href="peer__socket_8hpp_source.html#l01192">m_state</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">S_OPEN</a>.</p>

</div>
</div>
<a id="a45d796625339aa1aae09326091509d18" name="a45d796625339aa1aae09326091509d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d796625339aa1aae09326091509d18">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Readable state is reached &ndash; the actual data are not moved into any buffer, leaving that to the caller to do if desired. </p>
<p >Hence, this is a way of waiting for Readable state that could be more concise in some situations than <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. <code>true</code> is returned; <code>*err_code</code> is set to success unless null.</li>
<li>The operation cannot proceed due to an error. <code>false</code> is returned; <code>*err_code</code> is set to the specific error unless null. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >Note that it is NOT possible to return <code>false</code> and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">Period</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are 1+ bytes ready to read; <code>false</code> if either a timeout has occurred (no bytes ready), or another error has occurred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02601">2601</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00042">flow::util::chrono_duration_from_now_to_fine_time_pt()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00197">sync_receive_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a45d796625339aa1aae09326091509d18_cgraph.svg" width="963" height="384"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4429aead81514f99e3120a0b96667cb5" name="a4429aead81514f99e3120a0b96667cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429aead81514f99e3120a0b96667cb5">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_receive(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_receive(null_buffers)</code> with no timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00192">192</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l02591">sync_receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a4429aead81514f99e3120a0b96667cb5_cgraph.svg" width="968" height="287"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a256b77e546fff9394ef8d509e2ae771b" name="a256b77e546fff9394ef8d509e2ae771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256b77e546fff9394ef8d509e2ae771b">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>, except that if socket is not immediately Readable (i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> would return 0 and no error), waits until it is Readable (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> would return either &gt;0, or 0 and an error) and returns <code>receive(target, err_code)</code>. If a timeout is specified, and this timeout expires before socket is Readable, it acts as if <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> produced <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. &gt;= 1 is returned; <code>*err_code</code> is set to success unless null; data returned.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >The semantics of -1- (the success case) equal those of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>.</p>
<p >Note that it is NOT possible to return 0 and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="section see"><dt>See also</dt><dd>The version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait (i.e., no timeout). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to target. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02591">2591</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00042">flow::util::chrono_duration_from_now_to_fine_time_pt()</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02610">sync_receive_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00192">sync_receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a256b77e546fff9394ef8d509e2ae771b_cgraph.svg" width="988" height="504"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a256b77e546fff9394ef8d509e2ae771b_icgraph.svg" width="342" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af5143886b33b4f16e4fbfbe3a4e91e44" name="af5143886b33b4f16e4fbfbe3a4e91e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5143886b33b4f16e4fbfbe3a4e91e44">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_receive(target, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02585">2585</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l02610">sync_receive_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_af5143886b33b4f16e4fbfbe3a4e91e44_cgraph.svg" width="988" height="504"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad29f61b9885b10ddc3846cdae0560518" name="ad29f61b9885b10ddc3846cdae0560518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29f61b9885b10ddc3846cdae0560518">&#9670;&nbsp;</a></span>sync_receive_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_buffer_sequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_receive_impl </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> but uses a <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>-based <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79" title="A high-res time duration as computed from two Fine_time_pts.">Fine_duration</a> non-template type for implementation convenience and to avoid code bloat to specify timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <code>sync_receive(timeout)</code>. This is the absolute time point corresponding to that. <code>"duration&lt;Rep, Period&gt;::max()"</code> maps to the value <code><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8" title="A high-res time point as returned by Fine_clock::now() and suitable for precise time math in general.">Fine_time_pt()</a></code> (Epoch) for this argument. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02610">2610</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="socket__buffer_8hpp_source.html#l00543">flow::net_flow::Socket_buffer::consume_bufs_copy()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01260">m_rcv_buf</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00234">node_sync_receive()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02585">sync_receive()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ad29f61b9885b10ddc3846cdae0560518_cgraph.svg" width="1235" height="544"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_ad29f61b9885b10ddc3846cdae0560518_icgraph.svg" width="370" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1a2eccfa314a397c12259f414ef6798c" name="a1a2eccfa314a397c12259f414ef6798c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2eccfa314a397c12259f414ef6798c">&#9670;&nbsp;</a></span>sync_receive_reactor_pattern_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_receive_reactor_pattern_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper similar to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518" title="Same as sync_receive() but uses a Fine_clock-based Fine_duration non-template type for implementation...">sync_receive_impl()</a> but for the <code>null_buffers</code> versions of <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_until</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518" title="Same as sync_receive() but uses a Fine_clock-based Fine_duration non-template type for implementation...">sync_receive_impl()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad29f61b9885b10ddc3846cdae0560518" title="Same as sync_receive() but uses a Fine_clock-based Fine_duration non-template type for implementation...">sync_receive_impl()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <code>sync_receive(null_buffers)</code>. <code>true</code> if and only if Readable status successfuly reached in time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00197">197</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8cpp_source.html#l00234">node_sync_receive()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00197">sync_receive_reactor_pattern_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02601">sync_receive()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00197">sync_receive_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a1a2eccfa314a397c12259f414ef6798c_cgraph.svg" width="1204" height="466"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a1a2eccfa314a397c12259f414ef6798c_icgraph.svg" width="342" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a28cb6fc51585c9fa2bf2f152675615a1" name="a28cb6fc51585c9fa2bf2f152675615a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cb6fc51585c9fa2bf2f152675615a1">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Writable state is reached &ndash; the actual data are not moved out of any buffer, leaving that to the caller to do if desired. </p>
<p >Hence, this is a way of waiting for Writable state that could be more concise in some situations than <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold – or the wait is interr...">Event_set::sync_wait()</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There is space in the Send buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. <code>true</code> is returned; <code>*err_code</code> is set to success unless null.</li>
<li>The operation cannot proceed due to an error. <code>false</code> is returned; <code>*err_code</code> is set to the specific error unless null. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >Note that it is NOT possible to return <code>false</code> and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
    <tr><td class="paramname">Period</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 1+ bytes are possible to add to Send buffer; <code>false</code> if either a timeout has occurred (bytes not writable), or another error has occurred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02508">2508</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00042">flow::util::chrono_duration_from_now_to_fine_time_pt()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00112">sync_send_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a28cb6fc51585c9fa2bf2f152675615a1_cgraph.svg" width="971" height="383"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7d1f3d07ec71e46ff8f4c4d1bbc44079" name="a7d1f3d07ec71e46ff8f4c4d1bbc44079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1f3d07ec71e46ff8f4c4d1bbc44079">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_send(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_send(null_buffers)</code> with no timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00107">107</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l02497">sync_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a7d1f3d07ec71e46ff8f4c4d1bbc44079_cgraph.svg" width="922" height="347"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a70629642551f18e474b87c128d2d77e2" name="a70629642551f18e474b87c128d2d77e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70629642551f18e474b87c128d2d77e2">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>, except that if Socket is not immediately Writable (i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> would return 0 and no error), waits until it is Writable (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> would return either &gt;0, or 0 and an error) and returns <code>send(data, err_code)</code>. If a timeout is specified, and this timeout expires before socket is Writable, acts like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> executed on an un-Writable socket.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes (assuming there are data in the argument <code>data</code>).</p><ol type="1">
<li>There is space in the Send buffer, and socket connection is open (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. &gt;= 1 is returned; <code>*err_code</code> is set to success unless null; data buffered.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.) The code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >The semantics of -1- (the success case) equal those of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>.</p>
<p >Note that it is NOT possible to return 0 and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="section see"><dt>See also</dt><dd>The version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Const_buffer_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait (i.e., no timeout). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to Send buffer. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02497">2497</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_2detail_2util_8hpp_source.html#l00042">flow::util::chrono_duration_from_now_to_fine_time_pt()</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02518">sync_send_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00107">sync_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a70629642551f18e474b87c128d2d77e2_cgraph.svg" width="1146" height="543"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a70629642551f18e474b87c128d2d77e2_icgraph.svg" width="318" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6b9fa02a7c41b52fde9e05e862a9d20f" name="a6b9fa02a7c41b52fde9e05e862a9d20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9fa02a7c41b52fde9e05e862a9d20f">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_send(data, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Const_buffer_sequence</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02491">2491</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8hpp_source.html#l02518">sync_send_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a6b9fa02a7c41b52fde9e05e862a9d20f_cgraph.svg" width="1146" height="543"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3f1a802024549a59978a53343b09a86d" name="a3f1a802024549a59978a53343b09a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1a802024549a59978a53343b09a86d">&#9670;&nbsp;</a></span>sync_send_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_buffer_sequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_send_impl </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> but uses a <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>-based <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79" title="A high-res time duration as computed from two Fine_time_pts.">Fine_duration</a> non-template type for implementation convenience and to avoid code bloat to specify timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Const_buffer_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
    <tr><td class="paramname">wait_until</td><td>See <code>sync_send(timeout)</code>. This is the absolute time point corresponding to that. <code>"duration&lt;Rep, Period&gt;::max()"</code> maps to the value <code><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8" title="A high-res time point as returned by Fine_clock::now() and suitable for precise time math in general.">Fine_time_pt()</a></code> (Epoch) for this argument. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02518">2518</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">References <a class="el" href="socket__buffer_8hpp_source.html#l00391">flow::net_flow::Socket_buffer::feed_bufs_copy()</a>, <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8hpp_source.html#l01278">m_snd_buf</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00149">node_sync_send()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02491">sync_send()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a3f1a802024549a59978a53343b09a86d_cgraph.svg" width="1162" height="564"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a3f1a802024549a59978a53343b09a86d_icgraph.svg" width="344" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a15ba1d4af6d4e3fcab9534a307c00595" name="a15ba1d4af6d4e3fcab9534a307c00595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ba1d4af6d4e3fcab9534a307c00595">&#9670;&nbsp;</a></span>sync_send_reactor_pattern_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::sync_send_reactor_pattern_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> &amp;&#160;</td>
          <td class="paramname"><em>wait_until</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper similar to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d" title="Same as sync_send() but uses a Fine_clock-based Fine_duration non-template type for implementation co...">sync_send_impl()</a> but for the <code>null_buffers</code> versions of <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_until</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d" title="Same as sync_send() but uses a Fine_clock-based Fine_duration non-template type for implementation co...">sync_send_impl()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a3f1a802024549a59978a53343b09a86d" title="Same as sync_send() but uses a Fine_clock-based Fine_duration non-template type for implementation co...">sync_send_impl()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <code>sync_send(null_buffers)</code>. <code>true</code> if and only if Writable status successfuly reached in time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l00112">112</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00357">FLOW_ERROR_EXEC_AND_THROW_ON_ERROR</a>, <a class="el" href="peer__socket_8hpp_source.html#l01341">m_mutex</a>, <a class="el" href="peer__socket_8cpp_source.html#l00149">node_sync_send()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00112">sync_send_reactor_pattern_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02508">sync_send()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00112">sync_send_reactor_pattern_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a15ba1d4af6d4e3fcab9534a307c00595_cgraph.svg" width="1178" height="371"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a15ba1d4af6d4e3fcab9534a307c00595_icgraph.svg" width="360" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad1b055f28b89531ad98368286babfdb1" name="ad1b055f28b89531ad98368286babfdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b055f28b89531ad98368286babfdb1">&#9670;&nbsp;</a></span>Congestion_control_classic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic.html">Congestion_control_classic</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congestion control modules have const access to all socket internals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic.html" title="Classic congestion control, based on Reno (TCP RFC 5681), with congestion avoidance,...">Congestion_control_classic</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00846">846</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a73cd234409fb43c27e1f46f2303ca55d" name="a73cd234409fb43c27e1f46f2303ca55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cd234409fb43c27e1f46f2303ca55d">&#9670;&nbsp;</a></span>Congestion_control_classic_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html">Congestion_control_classic_data</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congestion control modules have const access to all socket internals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__data.html" title="Utility class for use by Congestion_control_strategy implementations that implements congestion windo...">Congestion_control_classic_data</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00841">841</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a7020b02ef7daffcfd9004e41240f51b8" name="a7020b02ef7daffcfd9004e41240f51b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7020b02ef7daffcfd9004e41240f51b8">&#9670;&nbsp;</a></span>Congestion_control_classic_with_bandwidth_est</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__with__bandwidth__est.html">Congestion_control_classic_with_bandwidth_est</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congestion control modules have const access to all socket internals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Congestion__control__classic__with__bandwidth__est.html" title="Classic congestion control but with backoff to bandwidth estimate-based pipe size.">Congestion_control_classic_with_bandwidth_est</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00851">851</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad1259416e25ed2bd94bce3192c682e5d" name="ad1259416e25ed2bd94bce3192c682e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1259416e25ed2bd94bce3192c682e5d">&#9670;&nbsp;</a></span>Drop_timer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html">Drop_timer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For access to <code>Sent_pkt_by_sent_when_map</code> and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> types, at least. </p>
<p >(<a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> has no actual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> instance to mess with.) </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00831">831</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a6db9d28bd448a131448276ee03de1e6d" name="a6db9d28bd448a131448276ee03de1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9d28bd448a131448276ee03de1e6d">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> documentation header. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00821">821</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a8497776b61df32a79707c264f8f2422b" name="a8497776b61df32a79707c264f8f2422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8497776b61df32a79707c264f8f2422b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given socket to given standard <code>ostream</code> and returns the latter. </p>
<p >The representation includes the local and remote endpoints and the hex pointer value.</p>
<dl class="section note"><dt>Note</dt><dd><code>shared_ptr</code> forwards <code>ostream</code> output to the underlying pointer type, so this will affect <code>Ptr</code> output as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">sock</td><td>Object to serialize. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06514">6514</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

<p class="reference">References <a class="el" href="peer__socket_8cpp_source.html#l00384">local_port()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00378">remote_endpoint()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket_a8497776b61df32a79707c264f8f2422b_cgraph.svg" width="359" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a03ea7069aa4779abaf274989bd4c2fb6" name="a03ea7069aa4779abaf274989bd4c2fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ea7069aa4779abaf274989bd4c2fb6">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000126">Todo:</a></b></dt><dd>There are a few guys like this which are marked <code>@internal</code> (Doxygen command) to hide from generated public documentation, and that works, but really they should not be visible in the publicly-exported (not in detail/) header source code; so this should be reorganized for cleanliness. The prototypes like this one can be moved to a detail/ header or maybe directly into .cpp that uses them (for those where it's only one).</dd></dl>
<p >Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8cpp_source.html#l06537">6537</a> of file <a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a>.</p>

</div>
</div>
<a id="a7c0f36768414ae35afeb525636a41290" name="a7c0f36768414ae35afeb525636a41290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0f36768414ae35afeb525636a41290">&#9670;&nbsp;</a></span>Send_bandwidth_estimator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html">Send_bandwidth_estimator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stats modules have const access to all socket internals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html" title="A per-Peer_socket module that tries to estimate the bandwidth available to the outgoing flow.">Send_bandwidth_estimator</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00836">836</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04011">flow::net_flow::Node::connect_worker()</a>.</p>

</div>
</div>
<a id="a2165381af6166d76afba06862c762367" name="a2165381af6166d76afba06862c762367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2165381af6166d76afba06862c762367">&#9670;&nbsp;</a></span>Server_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See rationale for <code>friend</code>ing <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> in class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> documentation header. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l00826">826</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a288ccfc742d6982c4059d82500397874" name="a288ccfc742d6982c4059d82500397874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288ccfc742d6982c4059d82500397874">&#9670;&nbsp;</a></span>m_active_connect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::m_active_connect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if we connect() to server; <code>false</code> if we are to be/are <code>accept()</code>ed. Should be set once and not modified. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01184">1184</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad772e56de286567c4b7a681907b5f285" name="ad772e56de286567c4b7a681907b5f285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad772e56de286567c4b7a681907b5f285">&#9670;&nbsp;</a></span>m_connection_timeout_scheduled_task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a> flow::net_flow::Peer_socket::m_connection_timeout_scheduled_task</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connection timeout scheduled task; fires if the entire initial connection process does not complete within a certain amount of time. </p>
<p >It is started when the SYN or SYN_ACK is sent the very first time (NOT counting resends), canceled when SYN_ACK or SYN_ACK_ACK (respectively) is received in response to ANY SYN or SYN_ACK (respevtively), and fired if the the latter does not occur in time.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a85b3d271527dbaa04b1d9f751631fd71" title="Connection attempt scheduled task; fires if an individual connection request packet is not answered w...">m_init_rexmit_scheduled_task</a> which keeps track of <em>individual</em> attempts timing out, as opposed to the entire process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02158">2158</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a4fb8e8df98efa023e8bd4bd825475a18" name="a4fb8e8df98efa023e8bd4bd825475a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb8e8df98efa023e8bd4bd825475a18">&#9670;&nbsp;</a></span>m_disconnect_cause</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> flow::net_flow::Peer_socket::m_disconnect_cause</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> causing disconnection (if one has occurred or is occurring) on this socket; otherwise a clear (success) <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a>. </p>
<p >This starts as success and may move to one non-success value and then never change after that. Graceful connection termination is (unlike in BSD sockets, where this is indicated with <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> returning 0, not an error) indeed counted as a non-success value for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a>.</p>
<p >Exception: if, during graceful close, the connection must be closed abruptly (due to error, including <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8" title="User code on this side abruptly closed connection; other side may be informed of this.">error::Code::S_USER_CLOSED_ABRUPTLY</a>), <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a> may change a second time (from "graceful close" to "abrupt closure").</p>
<p >As in TCP net-stacks, one cannot recover from a transmission error or termination on the socket (fake "error" <code>EWOULDBLOCK</code>/<code>EAGAIN</code> excepted), which is why this can only go success -&gt; non-success and never change after that.</p>
<p >How to report this to the user: attempting to <code>*receive()</code> when not Readable while <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a> is not success =&gt; <code>*receive()</code> returns this <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> to the user; and similarly for <code>*send()</code> and Writable.</p>
<p >I emphasize that this should happen only after Receive buffer has been emptied; otherwise user will not be able to read queued up received data after the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> internally detects connection termination. By the same token, if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can still reasonably send data to the other side, and Send buffer is not empty, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a> is not success, the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> should only halt the packet sending once Send buffer has been emptied.</p>
<p >This should be success in all states except <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a> + <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9" title="This Peer_socket was created through a passive connect (Node::accept() and the like) or an active con...">Open_sub_state::S_DISCONNECTING</a>.</p>
<h3>Thread safety</h3>
<p >Since user threads will access this at least via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>, while thread W may set it having detected disconnection, this must be protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01312">1312</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00101">disconnect_cause()</a>.</p>

</div>
</div>
<a id="ac4c942e1bb6c4dc4b24251f294a2f92d" name="ac4c942e1bb6c4dc4b24251f294a2f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c942e1bb6c4dc4b24251f294a2f92d">&#9670;&nbsp;</a></span>m_info_on_close</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> flow::net_flow::Peer_socket::m_info_on_close</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the final set of stats collected at the time the socket was moved to S_CLOSED <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">m_state</a>. </p>
<p >If it has not yet moved to that state, this is not applicable (but equals Peer_socket_info()). It's used by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">info()</a> to get at the final set of stats, before the source info is purged by the resource cleanup in sock_free_memory(). </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02166">2166</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00323">info()</a>.</p>

</div>
</div>
<a id="a0d1eecb59c62912b5630359df774dc62" name="a0d1eecb59c62912b5630359df774dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1eecb59c62912b5630359df774dc62">&#9670;&nbsp;</a></span>m_init_rexmit_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Peer_socket::m_init_rexmit_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If currently using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a85b3d271527dbaa04b1d9f751631fd71" title="Connection attempt scheduled task; fires if an individual connection request packet is not answered w...">m_init_rexmit_scheduled_task</a>, this is the number of times the timer has already fired in this session. </p>
<p >So when the timer is readied the first time it's zero; if it fires and is thus readied again it's one; again =&gt; two; etc., until timer is canceled or connection is aborted due to too many retries.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02144">2144</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a85b3d271527dbaa04b1d9f751631fd71" name="a85b3d271527dbaa04b1d9f751631fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b3d271527dbaa04b1d9f751631fd71">&#9670;&nbsp;</a></span>m_init_rexmit_scheduled_task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a> flow::net_flow::Peer_socket::m_init_rexmit_scheduled_task</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connection attempt scheduled task; fires if an individual connection request packet is not answered with a reply packet in time. </p>
<p >It is readied when <em>any</em> SYN or SYN_ACK packet is sent, and fired if that packet has gone unacknowledged with a SYN_ACK or SYN_ACK_ACK (respectively), long enough to be retransmitted.</p>
<p >Connection establishment is aborted if it fires too many times, but <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad772e56de286567c4b7a681907b5f285" title="Connection timeout scheduled task; fires if the entire initial connection process does not complete w...">m_connection_timeout_scheduled_task</a> is how "too many times" is determined.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad772e56de286567c4b7a681907b5f285" title="Connection timeout scheduled task; fires if the entire initial connection process does not complete w...">m_connection_timeout_scheduled_task</a> which keeps track of the entire process timing out, as opposed to the individual attempts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02133">2133</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a2c5de5df50268168cbbad82eaf90fa93" name="a2c5de5df50268168cbbad82eaf90fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5de5df50268168cbbad82eaf90fa93">&#9670;&nbsp;</a></span>m_int_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Int_state</a> flow::net_flow::Peer_socket::m_int_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current internal state of the socket. </p>
<p >Note this is a very central piece of information and is analogous to TCP's "state" (ESTABLISHED, etc. etc.).</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01356">1356</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a7b65c1b26e38a2ae614d9a12edfa57dd" name="a7b65c1b26e38a2ae614d9a12edfa57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b65c1b26e38a2ae614d9a12edfa57dd">&#9670;&nbsp;</a></span>m_local_port</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Peer_socket::m_local_port</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb" title="The local Flow-protocol port chosen by the Node (if active or passive open) or user (if passive open)...">local_port()</a>. Should be set before user gets access to <code>*this</code> and not changed afterwards. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01347">1347</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00384">local_port()</a>.</p>

</div>
</div>
<a id="ab41b19ed4e62cb14fcd7dac81e4a8f41" name="ab41b19ed4e62cb14fcd7dac81e4a8f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41b19ed4e62cb14fcd7dac81e4a8f41">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad1e36619c78b15f46576a18678a4ee67">Mutex</a> flow::net_flow::Peer_socket::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This object's mutex. </p>
<p >The protected items are <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a05a765055fd54412c63e57e43697f1bc" title="See state().">m_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae5d47460784cc20c9e44237edffaac95" title="See state().">m_open_sub_state</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a36ab27af6886c7699f9965a5eb296cd6" title="See node().">m_node</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">m_snd_buf</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a322dddf34a06bb199dab02c993bad686" title="If !m_active_connect, this contains the serialized metadata that the user supplied on the other side ...">m_serialized_metadata</a>.</p>
<p >Generally speaking, if 2 or more of the protected variables must be changed in the same non-blocking "operation" (for some reasonable definition of "operation"), they should probably be changed within the same <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41" title="This object&#39;s mutex.">m_mutex</a>-locking critical section. For example, if closing the socket in thread W due to an incoming RST, one should lock <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41" title="This object&#39;s mutex.">m_mutex</a>, clear both buffers, set <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4fb8e8df98efa023e8bd4bd825475a18" title="The Error_code causing disconnection (if one has occurred or is occurring) on this socket; otherwise ...">m_disconnect_cause</a>, change <code>m_state = <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a></code>, and then unlock <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41" title="This object&#39;s mutex.">m_mutex</a>. Then thread U != W will observe all this state changed at the "same time," which is desirable. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01341">1341</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00269">close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00101">disconnect_cause()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00390">get_connect_metadata()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00323">info()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00095">node()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00234">node_sync_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00149">node_sync_send()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02552">receive()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02448">send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00297">set_options()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00085">state()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02610">sync_receive_impl()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00197">sync_receive_reactor_pattern_impl()</a>, <a class="el" href="peer__socket_8hpp_source.html#l02518">sync_send_impl()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00112">sync_send_reactor_pattern_impl()</a>.</p>

</div>
</div>
<a id="a36ab27af6886c7699f9965a5eb296cd6" name="a36ab27af6886c7699f9965a5eb296cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab27af6886c7699f9965a5eb296cd6">&#9670;&nbsp;</a></span>m_node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a>* flow::net_flow::Peer_socket::m_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7" title="Node that produced this Peer_socket.">node()</a>. </p>
<p >Should be set before user gets access to <code>*this</code> and not changed, except to null when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>. Must not be modified by non-W threads.</p>
<p >Invariant: <code>x-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7" title="Node that produced this Peer_socket.">node()</a> == y</code> if and only if <code>y-&gt;m_socks</code> contains <code>x</code>; otherwise <code>!x-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7" title="Node that produced this Peer_socket.">node()</a></code>. The invariant must hold by the end of the execution of any thread W boost.asio handler (but not necessarily at all points within that handler, or generally).</p>
<p >Accessed from thread W and user threads U != W (in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7" title="Node that produced this Peer_socket.">node()</a> and others). Must be protected by mutex.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000133">Todo:</a></b></dt><dd><code>boost::weak_ptr&lt;<a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>&gt;</code> would be ideal for this, but of course then <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> would have to (only?) be available via shared_ptr&lt;&gt;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01217">1217</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00269">close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00323">info()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00095">node()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00219">node_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00134">node_send()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00234">node_sync_receive()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00149">node_sync_send()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00297">set_options()</a>.</p>

</div>
</div>
<a id="ae5d47460784cc20c9e44237edffaac95" name="ae5d47460784cc20c9e44237edffaac95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d47460784cc20c9e44237edffaac95">&#9670;&nbsp;</a></span>m_open_sub_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> flow::net_flow::Peer_socket::m_open_sub_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a>. </p>
<p >Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that.</p>
<p >Accessed from thread W and user threads U != W (in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> and others). Must be protected by mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01201">1201</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00085">state()</a>.</p>

</div>
</div>
<a id="ad59c09f34003873a3c207cc590236773" name="ad59c09f34003873a3c207cc590236773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59c09f34003873a3c207cc590236773">&#9670;&nbsp;</a></span>m_opts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> flow::net_flow::Peer_socket::m_opts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This socket's per-socket set of options. </p>
<p >Initialized at construction; can be subsequently modified by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>, although only the dynamic members of this may be modified.</p>
<p >Accessed from thread W and user thread U != W. Protected by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfbe1487c621d4a9c464aec61bc108a" title="The mutex protecting m_opts.">m_opts_mutex</a>. When reading, do NOT access without locking (which is encapsulated in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#accf6d724ed1f145716ae3d4567f582f3" title="Analogous to Node::opt() but for per-socket options.">opt()</a>). </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01178">1178</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04011">flow::net_flow::Node::connect_worker()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00352">max_block_size()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00357">max_block_size_multiple()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00318">options()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l00373">rexmit_on()</a>.</p>

</div>
</div>
<a id="addfbe1487c621d4a9c464aec61bc108a" name="addfbe1487c621d4a9c464aec61bc108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfbe1487c621d4a9c464aec61bc108a">&#9670;&nbsp;</a></span>m_opts_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Options_mutex</a> flow::net_flow::Peer_socket::m_opts_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex protecting <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad59c09f34003873a3c207cc590236773" title="This socket&#39;s per-socket set of options.">m_opts</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01181">1181</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l04011">flow::net_flow::Node::connect_worker()</a>, <a class="el" href="peer__socket_8cpp_source.html#l00357">max_block_size_multiple()</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02644">opt()</a>.</p>

</div>
</div>
<a id="a5629d810d2c7252eaa2243e076dde83f" name="a5629d810d2c7252eaa2243e076dde83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5629d810d2c7252eaa2243e076dde83f">&#9670;&nbsp;</a></span>m_originating_serv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> flow::net_flow::Peer_socket::m_originating_serv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For sockets that come a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, this is the inverse of <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a16bcbf9951c24d13d5b84d9aa163288e" title="Set of passively opening sockets in pre-ESTABLISHED (so SYN_RCVD?) internal state (and thus are not y...">Server_socket::m_connecting_socks</a>: it is the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> from which this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> will be <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>ed (if that succeeds); or null if this is an actively-connecting <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or has already been <code>accept()</code>ed. </p>
<p >More formally, this is null if <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a288ccfc742d6982c4059d82500397874" title="true if we connect() to server; false if we are to be/are accept()ed. Should be set once and not modi...">m_active_connect</a>; null if not the case but already accept()ed; and otherwise: <code>((y-&gt;m_connecting_socks contains x) || (y-&gt;m_unaccepted_socks contains x))</code> if and only if <code>x-&gt;m_originating_serv == y</code>. That is, for a socket in state <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Int_state::S_SYN_RCVD</a>, or in state <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Int_state::S_ESTABLISHED</a>, but before being accept()ed by the user, this is the server socket that spawned this peer socket.</p>
<h3>Thread safety</h3>
<p >This can be write-accessed simultaneously by thread W (e.g., when closing a socket before it is accepted) and a user thread U != W (in <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a>). It is thus protected by a mutex &ndash; but it's <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a40967c1981ffde4f7b75c6bb5e5b279b" title="This object&#39;s mutex.">Server_socket::m_mutex</a>, not <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41" title="This object&#39;s mutex.">Peer_socket::m_mutex</a>. I know it's weird, but it makes sense. Basically <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a7ba32040008ffe0637d3a1847deb76c5" title="Queue of passively opened sockets in Peer_socket::Int_state::S_ESTABLISHED internal state that have n...">Server_socket::m_unaccepted_socks</a> and Server_socket::m_originating_serv &ndash; for each element of <code>m_unaccepted_socks</code> &ndash; are modified together in a synchronized way.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a16bcbf9951c24d13d5b84d9aa163288e" title="Set of passively opening sockets in pre-ESTABLISHED (so SYN_RCVD?) internal state (and thus are not y...">Server_socket::m_connecting_socks</a> and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a7ba32040008ffe0637d3a1847deb76c5" title="Queue of passively opened sockets in Peer_socket::Int_state::S_ESTABLISHED internal state that have n...">Server_socket::m_unaccepted_socks</a> for the closely related inverse. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01241">1241</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a8229396adfd306d15e8a05dac3fe8c29" name="a8229396adfd306d15e8a05dac3fe8c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8229396adfd306d15e8a05dac3fe8c29">&#9670;&nbsp;</a></span>m_rcv_acked_packets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#abbd41e30089125f67667b39f5756c275">Ack_packet::Individual_ack::Ptr</a>&gt; flow::net_flow::Peer_socket::m_rcv_acked_packets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a> is running, accumulates the individual acknowledgments contained in all incoming ACK low-level packets received in those methods. </p>
<p >More precisely, this accumulates the elements of <code>packet.m_rcv_acked_packets</code> for all packets such that <code>packet</code> is an <a class="el" href="structflow_1_1net__flow_1_1Ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level ACK packet.">Ack_packet</a>. They are accumulated in this data structure for a similar reason that outgoing acknowledgments are accumulated in <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">Peer_socket::m_rcv_pending_acks</a></code>. The situation here is simpler, however, since the present structure is always scanned and cleared at the end of the current handler and never carried over to the next, as we always want to scan all individual acks received within a non-blocking amount of time from receipt. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94" title="Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer soc...">Node::handle_ack_to_established()</a> for details.</p>
<p >This structure is empty, accumulated over the course of those methods, is used to finally scan all individual acknowledgments (in the exact order received), and then cleared for the next run.</p>
<p >Storing shared pointers to avoid copying of structs (however small) during internal reshuffling; shared instead of raw pointers to not worry about delete.</p>
<p >This gains meaning only in thread W and only within <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a>/etc. and loses meaning after either method exits. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01604">1604</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aae9cb8f2dbd50ddaa0265d940b149ef3" name="aae9cb8f2dbd50ddaa0265d940b149ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9cb8f2dbd50ddaa0265d940b149ef3">&#9670;&nbsp;</a></span>m_rcv_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a> flow::net_flow::Peer_socket::m_rcv_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Receive buffer; <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> feeds data at the back; user consumes data at the front. </p>
<p >Contains application-layer data received from the other side, to be read by user via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> and similar.</p>
<p >A maximum cumulative byte count is maintained. If data are received that would exceed this max (i.e., the user is not retrieving the data fast enough to keep up), these data are dropped (and if we use ACKs would be eventually treated as dropped by the other side).</p>
<p >Note that this is a high-level structure, near the application layer. This does not store any metadata, like sequence numbers, or data not ready to be consumed by the user (such as out-of-order packets, if we implement that). Such packets and data should be stored elsewhere.</p>
<h3>Thread safety</h3>
<p >This can be write-accessed simultaneously by thread W (when receiving by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>) and a user thread U != W (in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>, etc.). It is thus protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01260">1260</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02552">receive()</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02610">sync_receive_impl()</a>.</p>

</div>
</div>
<a id="a88f967e74f8618c94088113e918ab52f" name="a88f967e74f8618c94088113e918ab52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f967e74f8618c94088113e918ab52f">&#9670;&nbsp;</a></span>m_rcv_delayed_ack_timer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6">util::Timer</a> flow::net_flow::Peer_socket::m_rcv_delayed_ack_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer started, assuming delayed ACKs are enabled, when the first <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html" title="Metadata describing the data sent in the acknowledgment of an individual received packet.">Individual_ack</a> is placed onto an empty <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">m_rcv_pending_acks</a>; when it triggers, the pending individual acknowledgments are packed into as few as possible ACKs and sent to the other side. </p>
<p >After the handler exits <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad46ed439a3d118eb2b540e9f99a7b0ca" title="The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side...">m_rcv_pending_acks</a> is again empty and the process can repeat starting with the next received valid packet.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<h3>Implementation notes</h3>
<p >In other places we have tended to replace a <code>Timer</code> with the far simpler <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">util::schedule_task_from_now()</a> (etc.) facility (which internally uses a <code>Timer</code> but hides its various annoyances and caveats). Why not here? Answer: This timer is scheduled and fires often (could be on the order of every 1-500 milliseconds) and throughout a given socket's existence; hence the potential performance effects aren't worth the risk (or at least mental energy spent on evaluating that risk, originally and over time). The conservative thing to do is reuse a single <code>Timer</code> repeatedly, as we do here. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01674">1674</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad7414dfca4b869dd3a4e0de39195c69e" name="ad7414dfca4b869dd3a4e0de39195c69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7414dfca4b869dd3a4e0de39195c69e">&#9670;&nbsp;</a></span>m_rcv_in_rcv_wnd_recovery</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> flow::net_flow::Peer_socket::m_rcv_in_rcv_wnd_recovery</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> indicates we are in a state where we've decided other side needs to be informed that our receive window has increased substantially, so that it can resume sending data (probably after a zero window being advertised). </p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01636">1636</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a5dc05d1f5deb71e1259c5d5aad1fcf84" name="a5dc05d1f5deb71e1259c5d5aad1fcf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc05d1f5deb71e1259c5d5aad1fcf84">&#9670;&nbsp;</a></span>m_rcv_init_seq_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> flow::net_flow::Peer_socket::m_rcv_init_seq_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Initial Sequence Number (ISN) contained in the original <a class="el" href="structflow_1_1net__flow_1_1Syn__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN packet.">Syn_packet</a> or <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN_ACK packet.">Syn_ack_packet</a> we received. </p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. Useful at least in verifying the validity of duplicate SYNs and SYN_ACKs. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01386">1386</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00825">flow::net_flow::Node::sock_categorize_data_to_established()</a>.</p>

</div>
</div>
<a id="a7fa76b609ef0aa5962d8de77338cf9ee" name="a7fa76b609ef0aa5962d8de77338cf9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa76b609ef0aa5962d8de77338cf9ee">&#9670;&nbsp;</a></span>m_rcv_last_sent_rcv_wnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_rcv_last_sent_rcv_wnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last rcv_wnd value sent to the other side (in an ACK). </p>
<p >This is used to gauge how much the true rcv_wnd has increased since the value that the sender probably (assuming ACK was not lost) knows.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01626">1626</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a13c640ebd14a75df3894e7d885d16f5f" name="a13c640ebd14a75df3894e7d885d16f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c640ebd14a75df3894e7d885d16f5f">&#9670;&nbsp;</a></span>m_rcv_next_seq_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> flow::net_flow::Peer_socket::m_rcv_next_seq_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximal sequence number R from the remote side such that all data with sequence numbers strictly less than R in this connection have been received by us and placed into the Receive buffer. </p>
<p >This first gains meaning upon receiving SYN and is the sequence number of that SYN, plus one (as in TCP); or upon receiving SYN_ACK (similarly). Note that received packets past this sequence number may exist, but if so there is at least one missing packet (the one at <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a>) preceding all of them.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>.</dd></dl>
<p>This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01401">1401</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ae82958ed6d71be46b96eceaca6214143" name="ae82958ed6d71be46b96eceaca6214143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82958ed6d71be46b96eceaca6214143">&#9670;&nbsp;</a></span>m_rcv_packets_with_gaps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#addfc181f4d43ab816b2ede9216bf9331">Recvd_pkt_map</a> flow::net_flow::Peer_socket::m_rcv_packets_with_gaps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets such that at least one unreceived-or-otherwise-unknown datum precedes all sequence numbers in this collection; a/k/a the reassembly queue if retransmission is enabled. </p>
<p >With retransmission off, the only purpose of keeping this structure at all is to detect any already-received-and-given-to-Receive-buffer packet coming in again; such a packet should be ACKed but NOT given to the Receive buffer again (avoid data duplication). With retransmission on, this is additionally used as the reassembly queue (storing the non-contiguous data until the gaps are filled in).</p>
<p >The structure is best explained by breaking down the sequence number space. I list the sequence number ranges in increasing order starting with the ISN. Let <code>last_rcv_seq_num</code> be the sequence number of the last datum to have been received (and not dropped due to insufficient Receive buffer space), for exposition purposes.</p>
<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5dc05d1f5deb71e1259c5d5aad1fcf84" title="The Initial Sequence Number (ISN) contained in the original Syn_packet or Syn_ack_packet we received.">m_rcv_init_seq_num</a> =<ul>
<li>SYN or SYN_ACK</li>
</ul>
</li>
<li>[<code>m_rcv_init_seq_num + 1</code>, <code>m_rcv_next_seq_num - 1</code>] =<ul>
<li>Largest possible range of sequence numbers such that each datum represented by this range has been received (and not dropped due to insufficient Receive buffer space) and copied to the Receive buffer for user retrieval.</li>
</ul>
</li>
<li>[<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a>, <code>m_rcv_next_seq_num + N - 1</code>] =<ul>
<li>The first packet after the ISN that has not yet been received (or has been received but has been dropped due to insufficient Receive buffer space). <code>N</code> is the (unknown to us) length of that packet. <code>N</code> &gt; 0. This can be seen as the first "gap" in the received sequence number space.</li>
</ul>
</li>
<li>[<code>m_rcv_next_seq_num + N</code>, <code>last_rcv_seq_num</code>] =<ul>
<li>The remaining packets up to and including the last byte that has been received (and not dropped due to insufficient Receive buffer space). Each packet in this range is one of the following:<ul>
<li>received (and not dropped due to insufficient Receive buffer space);</li>
<li>not received (or received and dropped due to insufficient Receive buffer space).</li>
</ul>
</li>
</ul>
</li>
<li>[<code>last_rcv_seq_num + 1</code>, ...] =<ul>
<li>All remaining not-yet-received (or received but dropped due to insufficient Receive buffer space) packets.</li>
</ul>
</li>
</ul>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> contains all Received_packets in the range [<code>m_rcv_next_seq_num + N</code>, <code>last_rcv_seq_num</code>], with each particular <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been received (and,...">Received_packet</a>'s first sequence number as its key. If there are no gaps &ndash; all received sequence numbers are followed by unreceived sequence numbers &ndash; then that range is empty and so is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>. All the other ranges can be null (empty) as well. If there are no received-and-undropped packets, then <code>m_rcv_init_seq_num == m_rcv_next_seq_num</code>, which is the initial situation.</p>
<p >The above is an invariant, to be true at the end of each boost.asio handler in thread W, at least.</p>
<p >Each received-and-undropped packet therefore is placed into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>, anywhere in the middle. If retransmission is off, the data in the packet is added to Receive buffer. If retransmission is on, the data in the packet is NOT added to Receive buffer but instead saved within the structure for later reassembly (see next paragraph).</p>
<p >If the [<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a>, ...] (first gap) packet is received-and-not-dropped, then <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a> is incremented by N (the length of that packet), filling the gap. Moreover, any contiguous packets at the front of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>, assuming the first packet's sequence number equals <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a>, must be removed from <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>, and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a> should be incremented accordingly. All of this maintains the invariant. If retransmission is on, the data in the byte sequence formed by this operation is to be placed (in sequence number order) into the Receive buffer (a/k/a reassembly).</p>
<p >Conceptually, this is the action of receiving a gap packet which links up following already-received packets to previous already-received packets, which means all of these can go away, as the window slides forward beyond them.</p>
<p >If a packet arrives and is already in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>, then it is a duplicate and is NOT placed on the Receive buffer. The same holds for any packet with sequence numbers preceding <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a13c640ebd14a75df3894e7d885d16f5f" title="The maximal sequence number R from the remote side such that all data with sequence numbers strictly ...">m_rcv_next_seq_num</a>.</p>
<p >The type used is a map sorted by starting sequence number of each packet. Why? We need pretty fast middle operations, inserting and checking for existence of arriving packet. We need fast access to the earliest (smallest sequence number) packet, for when the first gap is filled. <code>std::map</code> satisfies these needs: <code>insert()</code> and <code>lower_bound()</code> are <em>O(log n)</em>; <code>begin()</code> gives the smallest element and is <em>O(1)</em>. Iteration is <em>O(1)</em> as well. (All amortized.)</p>
<h3>Memory use</h3>
<p >The above scheme allows for unbounded memory use given certain behavior from the other side, when retransmission is off. Suppose packets 1, 2, 3 are received; then packets 5, 6, ..., 1000 are received. Retransmission is off, so eventually the sender may give up on packet 4 and consider it Dropped. So the gap will forever exist; hence <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> will always hold per-packet data for 5, 6, ..., 1000 (and any subsequent packets). With retransmission, packet 4 would eventually arrive, or the connection would get RSTed, but without retransmission that doesn't happen. Thus memory use will just grow and grow. Solution: come up with some heuristic that would quite conservatively declare that packet 4 has been "received," even though it hasn't. This will plug the hole (packet 4) and clear <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> in this example. Then if packet 4 does somehow come in, it will get ACKed (like any valid received packet) but will NOT be saved into the Receive buffer, since it will be considered "duplicate" due to already being "received." Of course, the heuristic must be such that few if any packets considered "received" this way will actually get delivered eventually, otherwise we may lose a lot of data. Here is one such heuristic, that is both simple and conservative: let N be some constant (e.g., N = 100). If <code>m_rcv_packets_with_gaps.size()</code> exceeds N (i.e., equals (N + 1)), consider all gap packets preceding <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>'s first sequence number as "received." This will, through gap filling logic described above, reduce <code>m_rcv_packets_with_gaps.size()</code> to N or less. Thus it puts a simple upper bound on <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>'s memory; if N = 100 the memory used by the structure is not much (since we don't store the actual packet data there [but this can get non-trivial with 100,000 sockets all filled up]). Is it conservative? Yes. 100 packets arriving after a gap are a near-guarantee those gap packets will never arrive (especially without retransmission, which is the predicate for this entire problem). Besides, the Drop heuristics on the Sender side almost certainly will consider gap packets with 100 or near 100 Acknowledged packets after them as Dropped a long time ago; if the receiving side's heuristics are far more conservative, then that is good enough.</p>
<p >If retransmission is on, then (as noted) the sender's CWND and retransmission logic will ensure that gaps are filled before more future data are sent, so the above situation will not occur. However if the sender is a bad boy and for some reason sends new data and ignores gaps (possibly malicious behavior), then it would still be a problem. Since in retransmission mode it's not OK to just ignore lost packets, we have no choice but to drop received packets when the above situation occurs (similarly to when Receive buffer is exceeded). This is basically a security measure and should not matter assuming well-behaved operation from the other side. Update: With retransmission on, this structure is now subject to overflow protection with a tighter limit than with rexmit-off; namely, the limit controlling <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a> overflow actually applies to the sum of data being stored in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a> and this structure, together. I.e., a packet is dropped if the total data stored in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a> equal or exceed the configured limit. Accordingly, rcv-wnd advertised to other side is based on this sum also.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa7398394052c8e634365fb979c294644" title="With retransmission enabled, the sum of Received_packet::m_size over all packets stored in the reasse...">m_rcv_reassembly_q_data_size</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000134">Todo:</a></b></dt><dd>The memory use of this structure could be greatly optimized if, instead of storing each individual received packet's metadata separately, we always merged contiguous sequence number ranges. So for example if packet P1, P2, P3 (contiguous) all arrived in sequence, after missing packet P0, then we'd store P1's first sequence number and the total data size of P1+P2+P3, in a single <code>struct</code> instance. Since a typical pattern might include 1 lost packet followed by 100 received packets, we'd be able to cut down memory use by a factor of about 100 in that case (and thus worry much less about the limit). Of course the code would get more complex and potentially slower (but not necessarily significantly). </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01536">1536</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad46ed439a3d118eb2b540e9f99a7b0ca" name="ad46ed439a3d118eb2b540e9f99a7b0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46ed439a3d118eb2b540e9f99a7b0ca">&#9670;&nbsp;</a></span>m_rcv_pending_acks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html">Individual_ack</a>&gt; &gt; flow::net_flow::Peer_socket::m_rcv_pending_acks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The received packets to be acknowledged in the next low-level ACK packet to be sent to the other side, ordered in the chronological order they were received. </p>
<p >They are accumulated in a data structure because we may not send each desired acknowledgment right away, combining several together, thus reducing overhead at the cost of short delays (or even nearly non-existent delays, as in the case of several DATA packets handled in one NodeLLlow_lvl_recv_and_handle() invocation, i.e., having arrived at nearly at the same time).</p>
<p >Any two packets represented by these <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html" title="Metadata describing the data sent in the acknowledgment of an individual received packet.">Individual_ack</a> objects may be duplicates of each other (same <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html" title="An internal net_flow sequence number identifying a piece of data.">Sequence_number</a>, possibly different <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Individual__ack.html#ad6e1407a2a3fc95e568b00f31e423b25" title="When was it received? Used for supplying delay before acknowledging (for other side&#39;s RTT calculation...">Individual_ack::m_received_when</a> values). It's up to the sender (receiver of ACK) to sort it out. However, again, they MUST be ordered chronologicaly based on the time when they were received; from earliest to latest.</p>
<p >Storing shared pointers to avoid copying of structs (however small) during internal reshuffling; shared instead of raw pointers to not worry about delete.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01566">1566</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a780f86759f861a3a84de8c5c768736b7" name="a780f86759f861a3a84de8c5c768736b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780f86759f861a3a84de8c5c768736b7">&#9670;&nbsp;</a></span>m_rcv_pending_acks_size_at_recv_handler_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_rcv_pending_acks_size_at_recv_handler_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper state, to be used while inside either <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a>, set only at the beginning of either and equal to <code>m_rcv_pending_acks.size()</code> at that time. </p>
<p >Because, for efficiency, individual acknowledgements are accumulated over the course of those two methods, and an ACK with those acknowledgments is sent at the end of that method (in perform_accumulated_on_recv_tasks()) at the earliest, this member is used to determine whether we should start a delayed ACK timer at that point.</p>
<p >This gains meaning only in thread W and only within <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a>/etc. and loses meaning after either method exits. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01580">1580</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aa7398394052c8e634365fb979c294644" name="aa7398394052c8e634365fb979c294644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7398394052c8e634365fb979c294644">&#9670;&nbsp;</a></span>m_rcv_reassembly_q_data_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_rcv_reassembly_q_data_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>With retransmission enabled, the sum of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Received__packet.html#a7d0760b1dead081bdcf775fbca7f708b" title="Number of bytes in the Data_packet::m_data field of that packet.">Received_packet::m_size</a> over all packets stored in the reassembly queue, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae82958ed6d71be46b96eceaca6214143" title="The sequence-number-ordered collection of all received-and-not-dropped-due-to-buffer-overflow packets...">m_rcv_packets_with_gaps</a>. </p>
<p >Stored for performance.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01545">1545</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a7d1f1d381749473f7a2471b8be20d6a8" name="a7d1f1d381749473f7a2471b8be20d6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1f1d381749473f7a2471b8be20d6a8">&#9670;&nbsp;</a></span>m_rcv_stats</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__receive__stats__accumulator.html">Peer_socket_receive_stats_accumulator</a> flow::net_flow::Peer_socket::m_rcv_stats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stats regarding incoming traffic (and resulting outgoing ACKs) for this connection so far. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01677">1677</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1553bbefc3407cf84eaa8e256c6cffff" name="a1553bbefc3407cf84eaa8e256c6cffff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1553bbefc3407cf84eaa8e256c6cffff">&#9670;&nbsp;</a></span>m_rcv_syn_rcvd_data_cumulative_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_rcv_syn_rcvd_data_cumulative_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The running total count of bytes in the <code>m_data</code> fields of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a48320d96118a37626f1852626965e6ed" title="The queue of DATA packets received while in Int_state::S_SYN_RCVD state before the Syn_ack_ack_packet...">m_rcv_syn_rcvd_data_q</a>. </p>
<p >Undefined when the latter is empty. Used to limit its size. This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01376">1376</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a48320d96118a37626f1852626965e6ed" name="a48320d96118a37626f1852626965e6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48320d96118a37626f1852626965e6ed">&#9670;&nbsp;</a></span>m_rcv_syn_rcvd_data_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1869760d5cfc5c0d22665e5db88710e4">Rcv_syn_rcvd_data_q</a> flow::net_flow::Peer_socket::m_rcv_syn_rcvd_data_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The queue of DATA packets received while in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa9838c717b26793d3b5360e4d718dc2d2" title="Public state is OPEN+CONNECTING; other side requested passive connect via SYN; we sent SYN_ACK and ar...">Int_state::S_SYN_RCVD</a> state before the <a class="el" href="structflow_1_1net__flow_1_1Syn__ack__ack__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level SYN_ACK_ACK packet.">Syn_ack_ack_packet</a> arrives to move us to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Int_state::S_ESTABLISHED</a> state, at which point these packets can be processed normally. </p>
<p >Such DATA packets would not normally exist, but they can exist if the SYN_ACK_ACK is lost or DATA packets are re-ordered to go ahead of it. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c" title="Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...">Node::handle_data_to_syn_rcvd()</a> for more detail.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01369">1369</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="afd590cc70d06b8e903027e4924fd095a" name="afd590cc70d06b8e903027e4924fd095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd590cc70d06b8e903027e4924fd095a">&#9670;&nbsp;</a></span>m_rcv_wnd_recovery_scheduled_task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#aa0d10f5a906b3229f48979aa43e9ff7e">util::Scheduled_task_handle</a> flow::net_flow::Peer_socket::m_rcv_wnd_recovery_scheduled_task</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e" title="true indicates we are in a state where we&#39;ve decided other side needs to be informed that our receive...">m_rcv_in_rcv_wnd_recovery</a> is <code>true</code>, this is the scheduled task to possibly send another unsolicited rcv_wnd-advertising ACK to the other side. </p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01654">1654</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a5476d9206f997fc9119b2a80b078ee87" name="a5476d9206f997fc9119b2a80b078ee87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5476d9206f997fc9119b2a80b078ee87">&#9670;&nbsp;</a></span>m_rcv_wnd_recovery_start_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> flow::net_flow::Peer_socket::m_rcv_wnd_recovery_start_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time point at which <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad7414dfca4b869dd3a4e0de39195c69e" title="true indicates we are in a state where we&#39;ve decided other side needs to be informed that our receive...">m_rcv_in_rcv_wnd_recovery</a> was last set to true. </p>
<p >It is only used when the latter is indeed true.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01645">1645</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a218ec098984b754b43940001f59ab787" name="a218ec098984b754b43940001f59ab787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218ec098984b754b43940001f59ab787">&#9670;&nbsp;</a></span>m_remote_endpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> flow::net_flow::Peer_socket::m_remote_endpoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e" title="Intended other side of the connection (regardless of success, failure, or current State).">remote_endpoint()</a>. Should be set before user gets access to <code>*this</code> and not changed afterwards. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01344">1344</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00378">remote_endpoint()</a>.</p>

</div>
</div>
<a id="a27ce5b19ab4abcf61aa07153c46b2be3" name="a27ce5b19ab4abcf61aa07153c46b2be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ce5b19ab4abcf61aa07153c46b2be3">&#9670;&nbsp;</a></span>m_round_trip_time_variance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> flow::net_flow::Peer_socket::m_round_trip_time_variance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RTTVAR used for <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a> calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02041">2041</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a33a90b123612cc2e6a119cfa95ba4f6d" name="a33a90b123612cc2e6a119cfa95ba4f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a90b123612cc2e6a119cfa95ba4f6d">&#9670;&nbsp;</a></span>m_security_token</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a59db68ed0c77a9f6e1a7aeeb3df2a6b9">security_token_t</a> flow::net_flow::Peer_socket::m_security_token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random security token used during SYN_ACK-SYN_ACK_ACK. </p>
<p >For a given connection handshake, the SYN_ACK_ACK receiver ensures that <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a33a90b123612cc2e6a119cfa95ba4f6d" title="Random security token used during SYN_ACK-SYN_ACK_ACK.">m_security_token</a> it received is equal to the original one it had sent in SYN_ACK. This first gains meaning upong sending SYN_ACK and it does not change afterwards. It is not used unless <code>!m_active_connect</code>. See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a288ccfc742d6982c4059d82500397874" title="true if we connect() to server; false if we are to be/are accept()ed. Should be set once and not modi...">m_active_connect</a>.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02117">2117</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a322dddf34a06bb199dab02c993bad686" name="a322dddf34a06bb199dab02c993bad686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322dddf34a06bb199dab02c993bad686">&#9670;&nbsp;</a></span>m_serialized_metadata</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> flow::net_flow::Peer_socket::m_serialized_metadata</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>!m_active_connect</code>, this contains the serialized metadata that the user supplied on the other side when initiating the connect; otherwise this is the serialized metadata that the user supplied on this side when initiating the connect. </p>
<p >In either case (though obviously more useful in the <code>!m_active_connect</code> case) it can be obtained via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">get_connect_metadata()</a>. In the <code>m_active_connect</code> case, this is also needed if we must re-send the original SYN (retransmission).</p>
<h3>Thread safety</h3>
<p >Same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">m_snd_buf</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a> (protected by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ab41b19ed4e62cb14fcd7dac81e4a8f41" title="This object&#39;s mutex.">m_mutex</a>). This would not be necessary, since this value is immutable once user gets access to <code>*this</code>, and threads other than W can access it, but sock_free_memory() does clear it while the user may be accessing it. Due to that caveat, we have to lock it. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01328">1328</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00390">get_connect_metadata()</a>.</p>

</div>
</div>
<a id="a2dd08c5fed4d179e4fde3a632c084751" name="a2dd08c5fed4d179e4fde3a632c084751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd08c5fed4d179e4fde3a632c084751">&#9670;&nbsp;</a></span>m_snd_bandwidth_estimator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html">Send_bandwidth_estimator</a>&gt; flow::net_flow::Peer_socket::m_snd_bandwidth_estimator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The outgoing available bandwidth estimator for this connection on this side. </p>
<p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> informs this object of events, namely as acknowedgments; conversely this object informs (or can inform if asked) the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> what it thinks is the current available bandwidth for user data in DATA packets. This can be useful at least for some forms of congestion control but possibly as information for the user, which is why it's an independent object and not part of a specific congestion control strategy (I only mention this because the mechanics of such a bandwidth estimator typically originate in service of a congestion control algorithm like Westwood+).</p>
<h3>Life cycle</h3>
<p >It must be initialized to an instance before user gains access to this socket; the pointer must never change subsequently except back to null (permanently). The <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> destructor, at the latest, will delete the underlying object, as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2dd08c5fed4d179e4fde3a632c084751" title="The outgoing available bandwidth estimator for this connection on this side.">m_snd_bandwidth_estimator</a> is destroyed along with <code>*this</code>. The only reason it's a pointer is that it takes a Const_ptr in the constructor, and that's not available during <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> construction yet. (Note <code>unique_ptr</code> has no copy operator or constructor.) There is a 1-to-1 relationship between <code>*this</code> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2dd08c5fed4d179e4fde3a632c084751" title="The outgoing available bandwidth estimator for this connection on this side.">m_snd_bandwidth_estimator</a>.</p>
<h3>Visibility between <a class="el" href="classflow_1_1net__flow_1_1Send__bandwidth__estimator.html" title="A per-Peer_socket module that tries to estimate the bandwidth available to the outgoing flow.">Send_bandwidth_estimator</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a></h3>
<p >The former gets read-only (<code>const</code>!) but otherwise complete private access (via <code>friend</code>) to the contents of <code>*this</code> <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. For example, it can read <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a> (the SRTT) and use it for computations if needed. <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> get only strict public API access to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2dd08c5fed4d179e4fde3a632c084751" title="The outgoing available bandwidth estimator for this connection on this side.">m_snd_bandwidth_estimator</a>, which is a black box to it.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02022">2022</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a993edf95f6bce2e57e7111e42533dc74" name="a993edf95f6bce2e57e7111e42533dc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993edf95f6bce2e57e7111e42533dc74">&#9670;&nbsp;</a></span>m_snd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Socket__buffer.html">Socket_buffer</a> flow::net_flow::Peer_socket::m_snd_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Send buffer; user feeds data at the back; <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> consumes data at the front. </p>
<p >Contains application-layer data to be sent to the other side as supplied by user via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> and friends.</p>
<p >A maximum cumulative byte count is maintained. If data are supplied that would exceed this max (i.e., the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is not sending the data fast enough to keep up), <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> will inform the caller that fewer bytes than intended have been buffered. Typically this happens if the congestion control window is full, so data are getting buffered in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a993edf95f6bce2e57e7111e42533dc74" title="The Send buffer; user feeds data at the back; Node consumes data at the front.">m_snd_buf</a> instead of being immediately consumed and sent.</p>
<p >Note that this is a high-level structure, near the application layer. This does not store any metadata, like sequence numbers, or data not ready to be consumed by the user (such as out-of-order packets, if we implement that). Such packets and data should be stored elsewhere.</p>
<p >Thread safety: Analogous to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aae9cb8f2dbd50ddaa0265d940b149ef3" title="The Receive buffer; Node feeds data at the back; user consumes data at the front.">m_rcv_buf</a>. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01278">1278</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8hpp_source.html#l02448">send()</a>, and <a class="el" href="peer__socket_8hpp_source.html#l02518">sync_send_impl()</a>.</p>

</div>
</div>
<a id="a35eb43f2b5d7dd46a941def4523f673c" name="a35eb43f2b5d7dd46a941def4523f673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eb43f2b5d7dd46a941def4523f673c">&#9670;&nbsp;</a></span>m_snd_cong_ctl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html">Congestion_control_strategy</a>&gt; flow::net_flow::Peer_socket::m_snd_cong_ctl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The congestion control strategy in use for this connection on this side. </p>
<p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> informs this object of events, such as acknowedgments and loss events; conversely this object informs (or can inform if asked) the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> whether or not DATA packets can be sent, by means of providing the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> with the socket's current Congestion Window (CWND) computed based on the particular <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a> implementation's algorithm (e.g., Reno or Westwood+). <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> then determines whether data can be sent by comparing <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480" title="The number of bytes contained in all In-flight packets, used at least for comparison against the cong...">m_snd_flying_bytes</a> (# of bytes we think are currently In-flight) to CWND (# of bytes the strategy allows to be In-flight currently).</p>
<h3>Life cycle</h3>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> must be initialized to an instance before user gains access to this socket; the pointer must never change subsequently except back to null (permanently). The <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> destructor, at the latest, will delete the underlying object, as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> will be destructed. (Note <code>unique_ptr</code> has no copy operator or constructor.) There is a 1-to-1 relationship between <code>*this</code> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a>.</p>
<h3>Visibility between <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a></h3>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> gets read-only (<code>const</code>!) but otherwise complete private access (via <code>friend</code>) to the contents of <code>*this</code> <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. For example, it can read <code>this-&gt;m_snd_smoothed_round_trip_time</code> (the SRTT) and use it for computations if needed. <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> get only strict public API access to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a>, which is a black box to it.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01977">1977</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a2d8aded3761028967fd3abb464e64936" name="a2d8aded3761028967fd3abb464e64936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8aded3761028967fd3abb464e64936">&#9670;&nbsp;</a></span>m_snd_drop_timeout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> flow::net_flow::Peer_socket::m_snd_drop_timeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Drop Timeout: Time period between the next time <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a037459e6f1345cedf45e490d544c8567" title="The Drop Timer engine, which controls how In-flight (m_snd_flying_pkts_by_sent_when) packets are cons...">m_snd_drop_timer</a> schedules a Drop Timer and that timer expiring. </p>
<p >This is updated each time <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad08b53052e7eedfa7a925258f5ef1cba" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a> is updated, and the <a class="el" href="classflow_1_1net__flow_1_1Drop__timer.html" title="Internal net_flow class that maintains the Drop Timer for DATA packet(s) to have been sent out over a...">Drop_timer</a> itself may change it under certain circumstances.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02061">2061</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a037459e6f1345cedf45e490d544c8567" name="a037459e6f1345cedf45e490d544c8567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037459e6f1345cedf45e490d544c8567">&#9670;&nbsp;</a></span>m_snd_drop_timer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae804be57cf09b9bf76eafa8ffff73de6">Drop_timer_ptr</a> flow::net_flow::Peer_socket::m_snd_drop_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Drop Timer engine, which controls how In-flight (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>) packets are considered Dropped due to being unacknowledged for too long. </p>
<p >Used while <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2c5de5df50268168cbbad82eaf90fa93" title="Current internal state of the socket.">m_int_state</a> is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880fa16fdfce85d7bca9386378acd29eb7202" title="Public state is OPEN+CONNECTED; in our opinion the connection is established.">Int_state::S_ESTABLISHED</a>.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02051">2051</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ae870847f024fca7109c15557bb165480" name="ae870847f024fca7109c15557bb165480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae870847f024fca7109c15557bb165480">&#9670;&nbsp;</a></span>m_snd_flying_bytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_snd_flying_bytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes contained in all In-flight packets, used at least for comparison against the congestion window (CWND). </p>
<p >More formally, this is the sum of all <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a5b5762a1effba90f631c06ad76f9774b" title="Number of bytes in the Data_packet::m_data field of the sent packet.">Sent_packet::m_size</a> values in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>. We keep this, instead of computing it whenever needed, for performance. In various TCP and related RFCs this value (or something spiritually similar, if only cumulative ACKs are used) is called "pipe" or "FlightSize."</p>
<p >Though in protocols like DCCP, where CWND is stored in packets, instead of bytes, "pipe" is actually just <code>m_snd_flying_pkts_by_sent_when.size()</code>. Not for us though.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>, which must always be updated to be accurate w/r/t <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480" title="The number of bytes contained in all In-flight packets, used at least for comparison against the cong...">m_snd_flying_bytes</a>. Use <a class="el" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe" title="Updates Peer_socket::m_snd_flying_bytes according to an operation (add packets, remove packets) calle...">Node::snd_flying_pkts_updated()</a> whenever <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> is changed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01898">1898</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a5ea56c54a98289211fef4a672432a2ad" name="a5ea56c54a98289211fef4a672432a2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea56c54a98289211fef4a672432a2ad">&#9670;&nbsp;</a></span>m_snd_flying_pkts_by_sent_when</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad10b3cd1d32b48cab8146ba4d07cb814">Sent_pkt_by_sent_when_map</a> flow::net_flow::Peer_socket::m_snd_flying_pkts_by_sent_when</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of all In-flight packets, indexed by sequence number and ordered from most to least recently sent (including those queued up to wire-send in pacing module). </p>
<p >See also <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> which is a similar map but in order of sequence number. That map's keys are again sequence numbers, but its values are iterators into the present map to save memory and avoid having to sync up data between the two (the only thing we must sync between them are their key sets). The two maps together can be considered to be the sender-side "scoreboard."</p>
<p >These are all the packets that have been sent but not Acknowledged that we have not yet considered Dropped. (With retransmission on, packets are never considered permanently Dropped, but they are considered Dropped until retransmitted.) With retransmission off, the ultimate goal of having this structure at all is to handle ACKs, the ultimate goal of which is, in turn, for the In-flight vs. Congestion Window comparison for congestion control. With retransmission on, the structure additionally stores the data in the In-flight packets, so that they can be retransmitted if we determine they were probably dropped.</p>
<p >With retransmission on, this is NOT the retransmission queue itself &ndash; i.e., this does NOT store packet data that we know should be retransmitted when possible but rather only the data already In-flight (whether from first attempt or from retransmission).</p>
<p >Please see <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> for a breakdown of the sequence number space. Since that structure contains iterators to exactly the values in the present map, that comment will explain which packets are in the present map.</p>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> contains In-flight <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> objects as values, with each particular <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a>'s first sequence number as its key. If there are no In-flight <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> objects, then <code>m_snd_flying_pkts_by_sent_when.empty()</code>.</p>
<p >The above is an invariant, to be true at the end of each boost.asio handler in thread W, at least.</p>
<p >Each sent packet therefore is placed into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>, at the front (as is standard for a Linked_hash_map, and as is expected, since they are ordered by send time). (Note, however, that being in this map does not mean it has been sent; it may only be queued up to be sent and waiting in the pacing module; however, pacing does not change the order of packets but merely the exact send moment, which cannot change the position in this queue.) When a packet is Acknowledged, it is removed from <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> &ndash; could be from anywhere in the ordering. Similarly to Acknowledged packets, Dropped ones are also removed.</p>
<p >The type used is a map indexed by starting sequence number of each packet but also in order of being sent out. Lookup by sequence number is near constant time; insertion near the end is near constant time; and iteration by order of when it was sent out is easy/fast, with iterators remaining valid as long as the underlying elements are not erased. Why use this particular structure? Well, the lookup by sequence number occurs all the time, such as when matching up an arriving acknowledgment against a packet that we'd sent out. We'd prefer it to not invalidate iterators when something is erased, so Linked_hash_map is good in that way also. So finally, why order by time it was queued up for sending (as opposed to by sequence number, as would be the case if this were an std::map)? In truth, both are needed, which is why <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> exists. This ordering is needed particularly for the <code>m_acks_after_me</code> logic, wherein we count how many times packets that were sent after a given packet have been acknowledged so far; by arranging the packets in that same order, that value can be easily and quickly accumulated by walking back from the most recently sent packet. On the other hand, some operations need sequence number ordering, which is why we have <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a>; note (again) that the two maps have the same key set, with one's values being iterators pointing into the other.</p>
<p >Whenever a packet with <code>m_sent_when.back().m_sent_time == T</code> is acknowledged, we need to (by definition of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa" title="The number of times any packet with m_sent_when.back().m_order_num &gt; this-&gt;m_sent_when....">Sent_packet::m_acks_after_me</a>) increment <code>m_acks_after_me</code> for each packet with <code>m_sent_when.back().m_sent_time &lt; T</code>. So, if we find the latest-sent element that satisfies that, then all packets appearing to the right (i.e., "sent less recently than") and including that one, in this ordering, should have <code>m_acks_after_me</code> incremented. Using a certain priority queue-using algorithm (see <a class="el" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006" title="Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...">Node::handle_accumulated_acks()</a>) we can do this quite efficiently.</p>
<p >Note that this means <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#affeb974bc03966744adfcda0366a50aa" title="The number of times any packet with m_sent_when.back().m_order_num &gt; this-&gt;m_sent_when....">Sent_packet::m_acks_after_me</a> is strictly increasing as one walks this map.</p>
<p >Since any packet with <code>m_acks_after_me &gt;= C</code>, where <code>C</code> is some constant, is considered Dropped and removed from <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> and therefore this map also, we also get the property that if we find a packet in this map for which that is true, then it is also true for all packets following it ("sent less recently" than it) in this map. This allows us to more quickly determine which packets should be removed from <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>, without having to walk the entire structure(s).</p>
<h3>Memory use</h3>
<p >This structure's memory use is naturally bounded by the Congestion Window. Congestion control will not let it grow beyond that many packets (bytes really, but you get the point). At that point blocks will stay on the Send buffer, until that fills up too. Then <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> will refuse to enqueue any more packets (telling the user as much).</p>
<h3>Thread safety</h3>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd>Sent_when and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e" title="Time stamps, order numbers, and other info at the times when the different attempts (including origin...">Sent_packet::m_sent_when</a>, where if <code>X</code> is the the last element of the latter sequence, then <code>X.m_sent_time</code> is the value by which elements in the present map are ordered. However, this only happens to be the case, because by definition an element is always placed at the front of the present map (Linked_hash_map), and this order is inductively maintained; AND MEANWHILE A Sent_when::m_sent_time's constructed value can only increase over time (which is a guaranteed property of the clock we use (<a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>)). </dd>
<dd>
<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ae870847f024fca7109c15557bb165480" title="The number of bytes contained in all In-flight packets, used at least for comparison against the cong...">m_snd_flying_bytes</a>, which must always be updated to be accurate w/r/t <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>. Use <a class="el" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe" title="Updates Peer_socket::m_snd_flying_bytes according to an operation (add packets, remove packets) calle...">Node::snd_flying_pkts_updated()</a> whenever <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> is changed. </dd>
<dd>
<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a>, which provides an ordering of the elements of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> by sequence number. Whereas the present structure is used to determine <code>m_acks_after_me</code> (since logically "after" means "sent after"), <code>..._by_seq_num</code> is akin to the more classic TCP scoreboard, which is used to subdivide the sequence number space (closely related to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1f8bebf649551131e6ed6e75c6f98d54" title="The sequence number for the start of the data in the next new DATA packet to be sent out.">m_snd_next_seq_num</a> and such). With retransmission off, "after" would simply mean "having higher sequence number," so <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> would already provide this ordering, but with retransmission on a retransmitted packet with a lower number could be sent after one with a higher number. To make the code simpler, we therefore rely on a separate structure in either situation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01805">1805</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a2db7d11ece920d4adcacd00eaa2253fd" name="a2db7d11ece920d4adcacd00eaa2253fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db7d11ece920d4adcacd00eaa2253fd">&#9670;&nbsp;</a></span>m_snd_flying_pkts_by_seq_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1958264af0c40f3c9c5769ddff4c9ade">Sent_pkt_by_seq_num_map</a> flow::net_flow::Peer_socket::m_snd_flying_pkts_by_seq_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of all In-flight packets (including those queued up to send in pacing module), indexed AND ordered by sequence number. </p>
<p >See also <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> which is a similar map but in order of time sent. Our map's keys are sequence numbers again, but its values are iterators into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> to save memory and avoid having to sync up data between the two (only keys are in sync). The two maps together can be considered to be the "scoreboard," though in fact the present structure alone is closer to a classic TCP scoreboard.</p>
<p >The key sets of the two maps are identical. The values in this map are iterators to exactly all elements of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>. One can think of the present map as essentially achieving an alternate ordering of the values in the other map.</p>
<p >That said, the structure's contents and ordering are closely related to a breakdown of the sequence number space. I provide this breakdown here. I list the sequence number ranges in increasing order starting with the ISN. Let <code>first_flying_seq_num = m_snd_flying_pkts_by_seq_num.begin()-&gt;first</code> (i.e., the first key <a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html" title="An internal net_flow sequence number identifying a piece of data.">Sequence_number</a> in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a>) for exposition purposes.</p>
<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aca66d1cb582ca027745d1ef847266cc4" title="The Initial Sequence Number (ISN) used in our original SYN or SYN_ACK.">m_snd_init_seq_num</a> =<ul>
<li>SYN or SYN_ACK</li>
</ul>
</li>
<li>[<code>m_snd_init_seq_num + 1</code>, <code>first_flying_seq_num - 1</code>] =<ul>
<li>Largest possible range of sequence numbers such that each datum represented by this range has been sent and either:<ul>
<li>Acknowledged (ACK received for it); or</li>
<li>Dropped (ACK not received; we consider it dropped due to some factor like timeout or duplicate ACKs);</li>
</ul>
</li>
</ul>
</li>
<li>[<code>first_flying_seq_num</code>, <code>first_flying_seq_num + N - 1</code>] =<ul>
<li>The first packet that has been sent that is neither Acknowledged nor Dropped. <code>N</code> is length of that packet. This is always the first packet, if any, to be considered Dropped in the future. This packet is categorized In-flight.</li>
</ul>
</li>
<li>[<code>first_flying_seq_num + N</code>, <code>m_snd_next_seq_num - 1</code>] =<ul>
<li>All remaining sent packets. Each packet in this range is one of the following:<ul>
<li>Acknowledged;</li>
<li>not Acknowledged and not Dropped = categorized In-flight.</li>
</ul>
</li>
</ul>
</li>
<li>[<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1f8bebf649551131e6ed6e75c6f98d54" title="The sequence number for the start of the data in the next new DATA packet to be sent out.">m_snd_next_seq_num</a>, ...] =<ul>
<li>Unsent packets, if any.</li>
</ul>
</li>
</ul>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> contain In-flight <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> objects as values (though the latter indirectly via iterator into the former) with each particular <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a>'s first sequence number as its key in either structure. If there are no In-flight <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> objects, then <code>m_snd_flying_pkts_by_{sent_when|seq_num}.empty()</code> and hence <code>first_flying_seq_num</code> above does not exist. Each of the [ranges] above can be null (empty).</p>
<p >Each sent packet therefore is placed into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a>, at the back (if it's a new packet) or possibly elsewhere (if it's retransmitted) &ndash; while it is also placed into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> but always at the front (as, regardless of retransmission or anything else, it is the latest packet to be SENT). When packet is Acknowledged, it is removed from <code>m_snd_flying_pkts_by_*</code> &ndash; could be from anywhere in the ordering. Similarly to Acknowledged packets, Dropped ones are also removed.</p>
<p >Why do we need this map type in addition to <code>Linked_hash_map m_snd_flying_pkts_by_sent_when</code>? Answer: Essentially, when an acknowledgment comes in, we need to be able to determine where in the sequence number space this is. If packets are ordered by send time &ndash; not sequence number &ndash; and the sequence number does not match exactly one of the elements here (e.g., it erroneously straddles one, or it is a duplicate acknowledgement, which means that element isn't in the map any longer), then a tree-sorted-by-key map is invaluable (in particular: to get <code>upper_bound()</code>, and also to travel to the previous-by-sequence-number packet from the latter). So logarithmic-time upper-bound searches and iteration by sequence number are what we want and get with this added ordering on top of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>.</p>
<h3>Memory use</h3>
<p >This structure's memory use is naturally bounded the same as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>.</p>
<h3>Thread safety</h3>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>. There's a "see also" comment there that contrasts these two important structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01879">1879</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aca66d1cb582ca027745d1ef847266cc4" name="aca66d1cb582ca027745d1ef847266cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66d1cb582ca027745d1ef847266cc4">&#9670;&nbsp;</a></span>m_snd_init_seq_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> flow::net_flow::Peer_socket::m_snd_init_seq_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Initial Sequence Number (ISN) used in our original SYN or SYN_ACK. </p>
<p >Useful at least in re-sending the original SYN or SYN_ACK if unacknowledged for too long.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>.</dd></dl>
<p>This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01688">1688</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="af392484f79ffcead4f74ca351672d8d4" name="af392484f79ffcead4f74ca351672d8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af392484f79ffcead4f74ca351672d8d4">&#9670;&nbsp;</a></span>m_snd_last_data_sent_when</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> flow::net_flow::Peer_socket::m_snd_last_data_sent_when</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Time at which the last <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html" title="Internal net_flow struct that encapsulates the Flow-protocol low-level DATA packet.">Data_packet</a> low-level packet for this connection was sent. </p>
<p >We use this when determining whether the connection is in Idle Timeout (i.e., has sent no traffic for a while, which means there has been no data to send). It's used for congestion control.</p>
<p >Before any packets are sent, this is set to its default value (zero time since epoch).</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex.</p>
<h3>Pacing</h3>
<p >See Send_packet_pacing <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a55b44104a2c305b9679434ba623a7357" title="The state of outgoing packet pacing for this socket; segregated into a simple struct to keep Peer_soc...">m_snd_pacing_data</a>. See pacing-relevant note on <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e" title="Time stamps, order numbers, and other info at the times when the different attempts (including origin...">Sent_packet::m_sent_when</a> which applies equally to this data member. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02103">2103</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aa9f77167af54cfe2921fab5fd143eff4" name="aa9f77167af54cfe2921fab5fd143eff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f77167af54cfe2921fab5fd143eff4">&#9670;&nbsp;</a></span>m_snd_last_loss_event_when</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> flow::net_flow::Peer_socket::m_snd_last_loss_event_when</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last time that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has detected a packet loss event and so informed <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> by calling the appropriate method of class <a class="el" href="classflow_1_1net__flow_1_1Congestion__control__strategy.html" title="The abstract interface for a per-socket module that determines the socket&#39;s congestion control behavi...">Congestion_control_strategy</a>. </p>
<p >Roughly speaking, this is used to determine whether the detection of a given dropped packet is part of the same loss event as the previous one; if so then <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> is not informed again (presumably to avoid dropping CWND too fast); if not it is informed of the new loss event. Even more roughly speaking, if the new event is within a certain time frame of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9f77167af54cfe2921fab5fd143eff4" title="The last time that Node has detected a packet loss event and so informed m_snd_cong_ctl by calling th...">m_snd_last_loss_event_when</a>, then they're considered in the same loss event. You can find detailed discussion in a giant comment in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006" title="Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...">Node::handle_accumulated_acks()</a>.</p>
<p >Before any loss events, this is set to its default value (zero time since epoch).</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02087">2087</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1ec79951579d595bb790be87189d6e6c" name="a1ec79951579d595bb790be87189d6e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec79951579d595bb790be87189d6e6c">&#9670;&nbsp;</a></span>m_snd_last_order_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">order_num_t</a> flow::net_flow::Peer_socket::m_snd_last_order_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html" title="Metadata (and data, if retransmission is on) for a packet that has been sent one (if retransmission i...">Sent_packet</a> representing the next packet to be sent, this is the value to assign to <code>m_sent_when.back().first</code>. </p>
<p >In other words it's an ever-increasing number that is sort of like a sequence number but one per packet and represents time at which sent, not order in the byte stream. In particular the same packet retransmitted will have the same sequence number the 2nd time but an increased order number. Starts at 0.</p>
<p >This is only used for book-keeping locally and never transmitted over network.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01929">1929</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a1f8bebf649551131e6ed6e75c6f98d54" name="a1f8bebf649551131e6ed6e75c6f98d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8bebf649551131e6ed6e75c6f98d54">&#9670;&nbsp;</a></span>m_snd_next_seq_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> flow::net_flow::Peer_socket::m_snd_next_seq_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sequence number for the start of the data in the next new DATA packet to be sent out. </p>
<p >By "new" I mean not-retransmitted (assuming retransmission is even enabled).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000135">Todo:</a></b></dt><dd>Possibly <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a1f8bebf649551131e6ed6e75c6f98d54" title="The sequence number for the start of the data in the next new DATA packet to be sent out.">m_snd_next_seq_num</a> will apply to other packet types than DATA, probably anything to do with connection termination.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a2db7d11ece920d4adcacd00eaa2253fd" title="The collection of all In-flight packets (including those queued up to send in pacing module),...">m_snd_flying_pkts_by_seq_num</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a>.</dd></dl>
<p>This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01702">1702</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a55b44104a2c305b9679434ba623a7357" name="a55b44104a2c305b9679434ba623a7357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b44104a2c305b9679434ba623a7357">&#9670;&nbsp;</a></span>m_snd_pacing_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html">Send_pacing_data</a> flow::net_flow::Peer_socket::m_snd_pacing_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The state of outgoing packet pacing for this socket; segregated into a simple <code>struct</code> to keep <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> shorter and easier to understand. </p>
<p >Packet pacing tries to combat the burstiness of outgoing low-level packet stream.</p>
<dl class="section see"><dt>See also</dt><dd><code>struct <a class="el" href="structflow_1_1net__flow_1_1Send__pacing__data.html" title="The current outgoing packet pacing state, including queue of low-level packets to be sent,...">Send_pacing_data</a></code> doc header for much detail. </dd></dl>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02070">2070</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a07d885e5c8ec85e7ef8718dc0468ffe9" name="a07d885e5c8ec85e7ef8718dc0468ffe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d885e5c8ec85e7ef8718dc0468ffe9">&#9670;&nbsp;</a></span>m_snd_pending_rcv_wnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_snd_pending_rcv_wnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a> or async part of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8" title="Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...">Node::async_wait_latency_then_handle_incoming()</a> is running, contains the rcv_wnd (eventual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a12611e0ac9e8b86b8304b855050a8c8c" title="The receive window: the maximum number of bytes the other side has advertised it would be willing to ...">m_snd_remote_rcv_wnd</a>) value in the last observed ACK low-level packet received in those methods. </p>
<p >The reasoning is similar to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8229396adfd306d15e8a05dac3fe8c29" title="While Node::low_lvl_recv_and_handle() or async part of Node::async_wait_latency_then_handle_incoming(...">m_rcv_acked_packets</a>. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94" title="Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer soc...">Node::handle_ack_to_established()</a> for details.</p>
<p >This gains meaning only in thread W and only within <a class="el" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5" title="Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...">Node::low_lvl_recv_and_handle()</a>/etc. and loses meaning after either method exits. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01616">1616</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a12611e0ac9e8b86b8304b855050a8c8c" name="a12611e0ac9e8b86b8304b855050a8c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12611e0ac9e8b86b8304b855050a8c8c">&#9670;&nbsp;</a></span>m_snd_remote_rcv_wnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_snd_remote_rcv_wnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The receive window: the maximum number of bytes the other side has advertised it would be willing to accept into its Receive buffer if they'd arrived at the moment that advertisement was generated by the other side. </p>
<p >This starts as 0 (undefined) and is originally set at SYN_ACK or SYN_ACK_ACK receipt and then subsequently updated upon each ACK received. Each such update is called a "rcv_wnd update" or "window update."</p>
<p ><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a35eb43f2b5d7dd46a941def4523f673c" title="The congestion control strategy in use for this connection on this side.">m_snd_cong_ctl</a> provides congestion control; this value provides flow control. The socket's state machine must be extremely careful whenever either this value or <code>m_snd_cong_ctl-&gt;congestion_window_bytes()</code> may increase, as when that occurs it should call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1" title="Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...">Node::send_worker()</a> in order to possibly send data over the network.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01994">1994</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a845f21b754ef641b65b1fe44727fb429" name="a845f21b754ef641b65b1fe44727fb429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845f21b754ef641b65b1fe44727fb429">&#9670;&nbsp;</a></span>m_snd_rexmit_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;boost::shared_ptr&lt;<a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html">Sent_packet</a>&gt; &gt; flow::net_flow::Peer_socket::m_snd_rexmit_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If retransmission is on, this is the retransmission queue. </p>
<p >It's the queue of packets determined to have been dropped and thus to be retransmitted, when Congestion Window allows this. Packet in <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a704afa0007b8354ad78acad64d029ecf" title="If retransmission is on, this is the DATA packet itself that was sent; otherwise null.">Sent_packet::m_packet</a> field of element at top of the queue is to be retransmitted next; and the element itself is to be inserted into <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5ea56c54a98289211fef4a672432a2ad" title="The collection of all In-flight packets, indexed by sequence number and ordered from most to least re...">m_snd_flying_pkts_by_sent_when</a> while popped from the present structure. The packet's <a class="el" href="structflow_1_1net__flow_1_1Data__packet.html#ac149f87b8915213857c707b0f3562ef0" title="Retransmit counter of the DATA packet being sent.">Data_packet::m_rexmit_id</a> should be incremented before sending; and the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a3acccd2fcd0f4a0c5f7f0c2d6ad31c2e" title="Time stamps, order numbers, and other info at the times when the different attempts (including origin...">Sent_packet::m_sent_when</a> <code>vector</code> should be appended with the then-current time (for future RTT calculation).</p>
<p >If retransmission is off, this is empty.</p>
<p >Why use <code>list&lt;&gt;</code> and not <code>queue&lt;&gt;</code> or <code>deque&lt;&gt;</code>? Answer: I'd like to use <code>list::splice()</code>.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01946">1946</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a9f5063c85a2070822cf69a530f0af1f5" name="a9f5063c85a2070822cf69a530f0af1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5063c85a2070822cf69a530f0af1f5">&#9670;&nbsp;</a></span>m_snd_rexmit_q_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::m_snd_rexmit_q_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals <code>m_snd_rexmit_q.size().</code> Kept since <code>m_snd_rexmit_q.size()</code> may be <em>O(n)</em> depending on implementation. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01949">1949</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ad08b53052e7eedfa7a925258f5ef1cba" name="ad08b53052e7eedfa7a925258f5ef1cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08b53052e7eedfa7a925258f5ef1cba">&#9670;&nbsp;</a></span>m_snd_smoothed_round_trip_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> flow::net_flow::Peer_socket::m_snd_smoothed_round_trip_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimated current round trip time of packets, computed as a smooth value over the past individual RTT measurements. </p>
<p >This is updated each time we make an RTT measurement (i.e., receive a valid, non-duplicate acknowledgment of a packet we'd sent). The algorithm to compute it is taken from RFC 6298. The value is 0 (not a legal value otherwise) until the first RTT measurement is made.</p>
<p >We use <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79" title="A high-res time duration as computed from two Fine_time_pts.">Fine_duration</a> (the high fine-grainedness and large bit width corresponding to <a class="el" href="namespaceflow.html#a8f2e48761f9ca3ffcaa29872078bbf00" title="Clock used for delicate time measurements, such that the now() method gets the current time relative ...">Fine_clock</a>) to store this, and the algorithm we use to compute it avoids losing digits via unnecessary conversions between units (e.g., nanoseconds -&gt; milliseconds).</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02038">2038</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="ab4aff3e65ef9551b6c5ab890173b741e" name="ab4aff3e65ef9551b6c5ab890173b741e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4aff3e65ef9551b6c5ab890173b741e">&#9670;&nbsp;</a></span>m_snd_stats</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats__accumulator.html">Peer_socket_send_stats_accumulator</a> flow::net_flow::Peer_socket::m_snd_stats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stats regarding outgoing traffic (and resulting incoming ACKs) for this connection so far. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l02106">2106</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="aea98297d775f2085c21daf41c6582200" name="aea98297d775f2085c21daf41c6582200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea98297d775f2085c21daf41c6582200">&#9670;&nbsp;</a></span>m_snd_temp_pkts_marked_to_drop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">order_num_t</a>&gt; flow::net_flow::Peer_socket::m_snd_temp_pkts_marked_to_drop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper data structure to store the packet IDs of packets that are marked Dropped during a single run through accumulated ACKs; it is a data member instead of local variable for performance only. </p>
<p >The pattern is to simply <code>clear()</code> it just before use, then load it up with stuff in that same round of ACK handling; and the same thing each time we need to handle accumulated ACKs. Normally one would just create one of these locally within the code <code>{</code> block <code>}</code> each time instead. Not doing so avoids unnecessary various internal-to-<code>vector</code> buffer allocations. Instead the internal buffer will grow as large as it needs to and not go down from there, so that it can be reused in subsequent operations. (Even <code>clear()</code> does not internally shrink the buffer.) Of course some memory is held unnecessarily, but it's a small amount; on the other hand the performance gain may be non-trivial due to the frequency of the ACK-handling code being invoked.</p>
<p >This gains meaning only in thread W. This should NOT be accessed outside of thread W and is not protected by a mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01915">1915</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

</div>
</div>
<a id="a05a765055fd54412c63e57e43697f1bc" name="a05a765055fd54412c63e57e43697f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a765055fd54412c63e57e43697f1bc">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a> flow::net_flow::Peer_socket::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a>. </p>
<p >Should be set before user gets access to <code>*this</code>. Must not be modified by non-W threads after that.</p>
<p >Accessed from thread W and user threads U != W (in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> and others). Must be protected by mutex. </p>

<p class="definition">Definition at line <a class="el" href="peer__socket_8hpp_source.html#l01192">1192</a> of file <a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l00085">state()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="peer__socket_8hpp_source.html">peer_socket.hpp</a></li>
<li>net_flow/<a class="el" href="net__flow__fwd_8hpp_source.html">net_flow_fwd.hpp</a></li>
<li>net_flow/<a class="el" href="peer__socket_8cpp_source.html">peer_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 7 2024 00:49:11 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
