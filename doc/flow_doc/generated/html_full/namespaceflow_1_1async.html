<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::async Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1async.html">async</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">flow::async Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-task proactor pattern, by providing a streamlined API around boost.asio event loops with added advanced task- and thread-scheduling features.  
<a href="namespaceflow_1_1async.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> interface, providing an optionally multi-threaded thread pool onto which runnable <code>Task</code>s, optionally arranged into concurrency-avoiding <code>Op</code>s, can be boost.asio-posted for subsequent execution.  <a href="classflow_1_1async_1_1Concurrent__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html">Cross_thread_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> that is able to efficiently schedule <code>Task</code>s within a given <code>Op</code> to execute in different threads while still properly avoiding concurrency.  <a href="classflow_1_1async_1_1Cross__thread__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Op__list.html">Op_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, immutable <code>vector</code>-like sequence of N opaque <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> objects, usually corresponding to N worker threads, with typically used operations such as <code>[index]</code> and random <code>Op</code> selection.  <a href="classflow_1_1async_1_1Op__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html">Segregated_thread_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> that uses the legacy pin-<code>Task</code>s-within-1-<code>Op</code>-to-1-thread method of achieving required non-concurrency of <code>Task</code>s.  <a href="classflow_1_1async_1_1Segregated__thread__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html">Single_thread_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a></code>-related adapter-style class that represents a single-thread task loop; essentially it is pleasant syntactic sugar around a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> impl that cuts out concepts that become irrelevant with only one thread involved.  <a href="classflow_1_1async_1_1Single__thread__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Task__qing__thread.html">Task_qing_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used building block of various concrete <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> subclasses that encapsulates a thread that spawns at construction time and a dedicated-or-shared <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> (a/k/a boost.asio <code>io_service</code>) <code>run()</code>ning in that new thread.  <a href="classflow_1_1async_1_1Task__qing__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Timed__concurrent__task__loop.html">Timed_concurrent_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates a general &ndash; potentially multi-threaded &ndash; <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> of any kind but with timing capabilities.  <a href="classflow_1_1async_1_1Timed__concurrent__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Timed__concurrent__task__loop__impl.html">Timed_concurrent_task_loop_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorator of a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> with same or greater lifetime that accumulates time elapsed in any tasks posted or scheduled onto that loop.  <a href="classflow_1_1async_1_1Timed__concurrent__task__loop__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1async_1_1Timed__single__thread__task__loop.html">Timed_single_thread_task_loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html" title="A Concurrent_task_loop-related adapter-style class that represents a single-thread task loop; essenti...">Single_thread_task_loop</a>, but all tasks posted through it are automatically timed, with the result accessible via <a class="el" href="classflow_1_1async_1_1Timed__single__thread__task__loop.html#ae429fb31d17d422306cd9da398e53e5c" title="See Timed_concurrent_task_loop_impl::accumulated_time().">accumulated_time()</a>.  <a href="classflow_1_1async_1_1Timed__single__thread__task__loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af35fb65bdea1a3a92929ec2c4a6a6b72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72">Task</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void()&gt;</td></tr>
<tr class="memdesc:af35fb65bdea1a3a92929ec2c4a6a6b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a task that can be posted for execution by a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> or <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>; it is simply something callable via <code>()</code> with no arguments and returning nothing.  <a href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72">More...</a><br /></td></tr>
<tr class="separator:af35fb65bdea1a3a92929ec2c4a6a6b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024042c64b7dc544a7a5587afa4b1949"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> = boost::any</td></tr>
<tr class="memdesc:a024042c64b7dc544a7a5587afa4b1949"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of this opaque type represents a collection of 1 or more <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72" title="Short-hand for a task that can be posted for execution by a Concurrent_task_loop or flow::util::Task_...">async::Task</a>, past or future, such that: <em>if</em> one performs <code>C-&gt;post(J, F)</code> and <code>C-&gt;post(K, G)</code> (where C is <code>Concurrent_task_loop*</code>, JK are the same <code><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a>&amp;</code>, or one refers to a transitive copy of the other, and FG are both <code>Task</code>s), <em>then</em> F and G will NOT execute concurrently.  <a href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">More...</a><br /></td></tr>
<tr class="separator:a024042c64b7dc544a7a5587afa4b1949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c06052dd887bc77444550a7c243154"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#af8c06052dd887bc77444550a7c243154">Scheduled_task</a> = <a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">util::Scheduled_task</a></td></tr>
<tr class="memdesc:af8c06052dd887bc77444550a7c243154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72" title="Short-hand for a task that can be posted for execution by a Concurrent_task_loop or flow::util::Task_...">flow::async::Task</a> but used for scheduled-in-future tasks as opposed to to-be-run-ASAP tasks.  <a href="namespaceflow_1_1async.html#af8c06052dd887bc77444550a7c243154">More...</a><br /></td></tr>
<tr class="separator:af8c06052dd887bc77444550a7c243154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5986cd6dc055673792890502135a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#afdf5986cd6dc055673792890502135a8">Task_asio_err</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afdf5986cd6dc055673792890502135a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a boost.asio completion handler: The minimal type, taking only a <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> a/k/a <code>boost::system::error_code</code>.  <a href="namespaceflow_1_1async.html#afdf5986cd6dc055673792890502135a8">More...</a><br /></td></tr>
<tr class="separator:afdf5986cd6dc055673792890502135a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3808f400a39b77d712e0526fa412bf57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a3808f400a39b77d712e0526fa412bf57">Task_asio_err_sz</a> = <a class="el" href="classflow_1_1Function.html">Function</a>&lt; void(const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> &amp;, size_t)&gt;</td></tr>
<tr class="memdesc:a3808f400a39b77d712e0526fa412bf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a boost.asio completion handler: The type that takes a <code>size_t</code> count of things successfully transferred usually.  <a href="namespaceflow_1_1async.html#a3808f400a39b77d712e0526fa412bf57">More...</a><br /></td></tr>
<tr class="separator:a3808f400a39b77d712e0526fa412bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968806f54b14c697fd76b3339a2bdbbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a> = boost::shared_ptr&lt; <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> &gt;</td></tr>
<tr class="memdesc:a968806f54b14c697fd76b3339a2bdbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for reference-counting pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> (a/k/a <code>boost::asio::io_service</code>).  <a href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">More...</a><br /></td></tr>
<tr class="separator:a968806f54b14c697fd76b3339a2bdbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92feccafa90bce16db57131c0fcd9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a> = boost::shared_ptr&lt; <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e">util::Strand</a> &gt;</td></tr>
<tr class="memdesc:a2b92feccafa90bce16db57131c0fcd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>.  <a href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">More...</a><br /></td></tr>
<tr class="separator:a2b92feccafa90bce16db57131c0fcd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a06794b16b72f2829ce3353557c8485"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">Synchronicity</a> { <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f">S_ASYNC</a>
, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25">S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</a>
, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846">S_ASYNC_AND_AWAIT_CONCURRENT_START</a>
, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f">S_OPPORTUNISTIC_SYNC_ELSE_ASYNC</a>
 }</td></tr>
<tr class="memdesc:a0a06794b16b72f2829ce3353557c8485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration indicating the manner in which <a class="el" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4" title="An extension of boost.asio&#39;s post() and dispatch() free function templates, this free function templa...">asio_exec_ctx_post()</a>, and various boost.asio "post" operations like it or based on it, are to actually execute the given task in relation to when the "posting" routine, itself, returns control to its caller.  <a href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">More...</a><br /></td></tr>
<tr class="separator:a0a06794b16b72f2829ce3353557c8485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a24567271e97a67d3cae6bd8bf8dc63c4"><td class="memTemplParams" colspan="2">template&lt;typename Execution_context &gt; </td></tr>
<tr class="memitem:a24567271e97a67d3cae6bd8bf8dc63c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">asio_exec_ctx_post</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, Execution_context *exec_ctx, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">Synchronicity</a> synchronicity, <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72">Task</a> &amp;&amp;task)</td></tr>
<tr class="memdesc:a24567271e97a67d3cae6bd8bf8dc63c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of boost.asio's <code>post()</code> and <code>dispatch()</code> free function templates, this free function template allows the user to more easily select the synchronicity behavior as the given task is posted onto the given execution context (<a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> at least).  <a href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4">More...</a><br /></td></tr>
<tr class="separator:a24567271e97a67d3cae6bd8bf8dc63c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f32e9fc685e2e9013900b100321fff"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff">optimal_worker_thread_count_per_pool</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a> *logger_ptr, <a class="el" href="classbool.html">bool</a> est_hw_core_sharing_helps_algo)</td></tr>
<tr class="memdesc:ac2f32e9fc685e2e9013900b100321fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particular, per-op latency-affecting) operations are largely between processor and RAM: Returns the # of threads to store in that pool for efficient performance.  <a href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff">More...</a><br /></td></tr>
<tr class="separator:ac2f32e9fc685e2e9013900b100321fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02afaeea759dfc180890e376db79530e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a02afaeea759dfc180890e376db79530e">optimize_pinning_in_thread_pool</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a> *logger_ptr, const std::vector&lt; <a class="el" href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">util::Thread</a> * &gt; &amp;threads_in_pool, <a class="el" href="classbool.html">bool</a> est_hw_core_sharing_helps_algo, <a class="el" href="classbool.html">bool</a> est_hw_core_pinning_helps_algo, <a class="el" href="classbool.html">bool</a> hw_threads_is_grouping_collated)</td></tr>
<tr class="memdesc:a02afaeea759dfc180890e376db79530e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the same situation as documented for <a class="el" href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff" title="Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particul...">optimal_worker_thread_count_per_pool()</a>, and that indeed the pool now contains that number of running threads: Attempts to optimize thread-core-pinning behavior in that pool for efficient performance.  <a href="namespaceflow_1_1async.html#a02afaeea759dfc180890e376db79530e">More...</a><br /></td></tr>
<tr class="separator:a02afaeea759dfc180890e376db79530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90c1e763d49c3f3033a74871e897394"><td class="memTemplParams" colspan="2">template&lt;typename Handler &gt; </td></tr>
<tr class="memitem:af90c1e763d49c3f3033a74871e897394"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#af90c1e763d49c3f3033a74871e897394">asio_handler_via_op</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op, Handler &amp;&amp;handler)</td></tr>
<tr class="memdesc:af90c1e763d49c3f3033a74871e897394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boost.asio <em>completion handler</em> <code>handler</code> for a boost.asio <code>async_*()</code> action on some boost.asio I/O object to be initiated in the immediate near future, returns a wrapped handler with the same signature to be passed as the handler arg to that <code>async_*()</code> action, so that <code>handler()</code> will execute non-concurrently with other tasks in <code>Op op</code>.  <a href="namespaceflow_1_1async.html#af90c1e763d49c3f3033a74871e897394">More...</a><br /></td></tr>
<tr class="separator:af90c1e763d49c3f3033a74871e897394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2f976a53191a3b0cd28898bb23c551"><td class="memTemplParams" colspan="2">template&lt;typename Exec_ctx_ptr &gt; </td></tr>
<tr class="memitem:a7f2f976a53191a3b0cd28898bb23c551"><td class="memTemplItemLeft" align="right" valign="top">Exec_ctx_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">op_to_exec_ctx</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op)</td></tr>
<tr class="memdesc:a7f2f976a53191a3b0cd28898bb23c551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization model for operation that obtains the underlying execution context, such as a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a>.  <a href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">More...</a><br /></td></tr>
<tr class="separator:a7f2f976a53191a3b0cd28898bb23c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70c594985b402d9024b80370611fc1c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad70c594985b402d9024b80370611fc1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#ad70c594985b402d9024b80370611fc1c">op_to_exec_ctx&lt; Task_engine_ptr &gt;</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op)</td></tr>
<tr class="memdesc:ad70c594985b402d9024b80370611fc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>.  <a href="namespaceflow_1_1async.html#ad70c594985b402d9024b80370611fc1c">More...</a><br /></td></tr>
<tr class="separator:ad70c594985b402d9024b80370611fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dad6aeb3cf4219833e18343bec0b423"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5dad6aeb3cf4219833e18343bec0b423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a5dad6aeb3cf4219833e18343bec0b423">op_to_exec_ctx&lt; Strand_ptr &gt;</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op)</td></tr>
<tr class="memdesc:a5dad6aeb3cf4219833e18343bec0b423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>.  <a href="namespaceflow_1_1async.html#a5dad6aeb3cf4219833e18343bec0b423">More...</a><br /></td></tr>
<tr class="separator:a5dad6aeb3cf4219833e18343bec0b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce43f39672e80cba5512103c53ae60"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a4cce43f39672e80cba5512103c53ae60">cpu_idx</a> ()</td></tr>
<tr class="memdesc:a4cce43f39672e80cba5512103c53ae60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 0-based processor <em>logical</em> (not hardware) core index of the core executing the calling thread presently.  <a href="namespaceflow_1_1async.html#a4cce43f39672e80cba5512103c53ae60">More...</a><br /></td></tr>
<tr class="separator:a4cce43f39672e80cba5512103c53ae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932f51435b1776625df394e159e7e55"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad932f51435b1776625df394e159e7e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#ad932f51435b1776625df394e159e7e55">op_to_exec_ctx&lt; Task_engine_ptr &gt;</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op)</td></tr>
<tr class="memdesc:ad932f51435b1776625df394e159e7e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>.  <a href="namespaceflow_1_1async.html#ad932f51435b1776625df394e159e7e55">More...</a><br /></td></tr>
<tr class="separator:ad932f51435b1776625df394e159e7e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05632ba834a42315615900ee4382287d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a05632ba834a42315615900ee4382287d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceflow_1_1async.html#a05632ba834a42315615900ee4382287d">op_to_exec_ctx&lt; Strand_ptr &gt;</a> (<a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *loop, const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;op)</td></tr>
<tr class="memdesc:a05632ba834a42315615900ee4382287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>.  <a href="namespaceflow_1_1async.html#a05632ba834a42315615900ee4382287d">More...</a><br /></td></tr>
<tr class="separator:a05632ba834a42315615900ee4382287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-task proactor pattern, by providing a streamlined API around boost.asio event loops with added advanced task- and thread-scheduling features. </p>
<p >There is also support for single-threaded event loops.</p>
<p >In simpler terms, at its core &ndash; including when the "pool" has just one thread, which is very common &ndash; it provides a compact way of both starting thread(s) <em>and</em> posting/scheduling tasks and I/O to run in such thread(s). By default one must worry about each of those 2 concerns separately and decide how exactly to hook them up; which is not rocket science, but it <em>is</em> a ton of boiler-plate, and it <em>is</em> easy to make mistakes and/or omit useful startup/shutdown practices, logging, and more. This module provides, via <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> and its implementations, at least that consistency/standardization. Plus, it provides certain advanced features as mentioned above.</p>
<ul>
<li>boost.asio provides the core algorithmic abilities of an optionally multi-threaded task-executing loop, particularly through classes <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> (a/k/a <code>boost::asio::io_service</code>), <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> (a/k/a <code>boost::asio::io_service::strand</code>), and <a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6" title="boost.asio timer.">util::Timer</a>. <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> Flow module somewhat streamlines this API in such a way as to keep the user's focus on their conceptual async-task-driven algorithm as opposed to details of threads, handlers, cores, etc. The <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> opaque type is central to this streamlined API, plus the central class <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a>.<ul>
<li>The bottom line is the user thinks about their algorithm in terms of tasks; while the internals of the chosen <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> concrete object worry about the actual scheduling of these tasks across threads.</li>
</ul>
</li>
<li>boost.asio doesn't really provide ways to specify how threads should be assigned to processor cores; it only controls what code is executed on which thread. These abilities are available natively. <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> Flow module allows one to set certain knobs controlling this behavior, and the user can continue to only worry about their algorithm and not threading details.<ul>
<li>The combination of the generalized <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> mechanism and these thread-hardware-scheduling features in an integrated whole is what hopefully makes the Flow <code>async</code> module a value-add over just boost.asio, or over just boost.asio with some thread-core-affinity utility functions on the side.</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>The central type is the interface class <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a>. For single-thread <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">async</a> work, which is very common, see <a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html" title="A Concurrent_task_loop-related adapter-style class that represents a single-thread task loop; essenti...">Single_thread_task_loop</a>, a simplified adapter, similar to how <code>std::queue&lt;T&gt;</code> is commongly a simplified <code>std::deque&lt;T&gt;</code> or <code>list</code> underneath. </dd>
<dd>
<a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>The thread-to-core optimizations provided at this time are, at least, a good start, but more advanced logic can be devised with more low-level experience and/or by using certain open-source libraries. It's possible that a more knowledgeable person would devise more or better knobs and/or require less manual specification of values. The following background reading may help devise more advanced logic and/or knobs: [ <a href="https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/">https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/</a> | <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.2016.07.31a.pdf">https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.2016.07.31a.pdf</a> | <a href="https://lwn.net/Articles/255364/">https://lwn.net/Articles/255364/</a> | "hwloc" library (portable lib for detailed hardware topology info) | libNUMA ]. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a024042c64b7dc544a7a5587afa4b1949" name="a024042c64b7dc544a7a5587afa4b1949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024042c64b7dc544a7a5587afa4b1949">&#9670;&nbsp;</a></span>Op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">flow::async::Op</a> = typedef boost::any</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An object of this opaque type represents a collection of 1 or more <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72" title="Short-hand for a task that can be posted for execution by a Concurrent_task_loop or flow::util::Task_...">async::Task</a>, past or future, such that: <em>if</em> one performs <code>C-&gt;post(J, F)</code> and <code>C-&gt;post(K, G)</code> (where C is <code>Concurrent_task_loop*</code>, JK are the same <code><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a>&amp;</code>, or one refers to a transitive copy of the other, and FG are both <code>Task</code>s), <em>then</em> F and G will NOT execute concurrently. </p>
<p >In addition, it is guaranteed that copying (via constructor or assignment) of <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> is has performance characteristics no worse than those of <code>shared_ptr</code>. I.e., it is to be thought of as light-weight.</p>
<p >The value <code><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">Op()</a></code> is designated as a null/sentinel value and must not be passed to <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#a24f96f97ee24bfabb06c8609bc0e94a6" title="Cause the given Task (function) to execute within the thread pool as soon as possible,...">Concurrent_task_loop::post()</a> or anything built on it.</p>
<p >That's the formal definition. We reiterate that copying these is cheap; and moreover two <code>Op</code>s such that one is a copy (of a copy, of a copy, of a copy...) of another, then these are conceptually isomorphic: they represent the same op, or collection of <code>Task</code>s that must never execute concurrently. Finally, tip: Don't think of an <code>Op</code> as a collection of 2+ <code>Task</code>s; but rather a tag or label that associates 2+ <code>Task</code>s with each other. (Also, nothing prevents an <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72" title="Short-hand for a task that can be posted for execution by a Concurrent_task_loop or flow::util::Task_...">async::Task</a> being a part of 2+ <code>Op</code>s simultaneously, though informally speaking it's arguably best not to make code maintainers grok such a design.)</p>
<p >By convention in comments we represent <code>Op</code>s with the letters J, K, L.</p>
<h3>When to use an <code>Op</code> versus just a stand-alone <code>Task</code>?</h3>
<p >When choosing a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#a24f96f97ee24bfabb06c8609bc0e94a6" title="Cause the given Task (function) to execute within the thread pool as soon as possible,...">Concurrent_task_loop::post()</a> (the one with <code>Op</code> vs. one without; or similar choices in more advanced cases), here are some things to remember. These can be derived independently and are only included as a convenience/refresher:</p>
<ul>
<li>An <code>Op</code> prevents <code>Task</code>s from executing concurrently. If there is exactly 1 thread in a pool, then they couldn't anyway, so an <code>Op</code> is not needed...<ul>
<li>...except as future-proofing, in case conceivably 1 thread might soon turn into 2+ after all.</li>
</ul>
</li>
<li>It is quite common to follow the pattern wherein, as the very last statement to execute within a <code>Task</code>, one <code>post()</code>s (or similar) exactly 1 <code>Task</code> to asynchronously execute next. Since it's the last statement, and <code>post()</code> and similar are explicitly thread-safe, this ensures the current and next <code>Task</code>s do not execute concurrently. So an <code>Op</code> is not needed...<ul>
<li>...except as future-proofing. It is sometimes easier to maintain, and more expressive to read, when many <code>Task</code>s are "officially" run under the banner of a single <code>Op</code>, even if some parts of the async handling of the "conceptual" operation are serial and hence don't technically require an <code>Op</code>. Example: In a web server it is reasonable to create an <code>Op</code> for the entire request, with all <code>Task</code>s (even serially called ones) being associated with that per-request <code>Op</code>; then, simply, no locking is necessary for per-request data structure(s). It's much easier to explain, "you don't need to lock 'em," vs. "you don't need to lock 'em,
      unless the logic changes in such a way as to...."</li>
</ul>
</li>
</ul>
<p >To be fair, those tips ignore performance; they implicitly assume using <code>Op</code> pointlessly (functionally, not stylistically, so) is otherwise "free." It is <em>not</em> free; depending on internal details using <code>Op</code> might involve a <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> and/or pinning stuff to a specific thread. Informally, this is seldom a big deal in practice; but in performance-sensitive projects one must remember there is a cost.</p>
<p ><code>boost::any</code> (storing nothing heavier-weight than a <code>shared_ptr</code> to satisfy that explicit guarantee above) is one way to do this. A rigid polymorphic hierarchy (<code>virtual</code>) is another. Performance-wise they're similar, costing essentially a single <code>virtual</code> pointer lookup per <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#a24f96f97ee24bfabb06c8609bc0e94a6" title="Cause the given Task (function) to execute within the thread pool as soon as possible,...">Concurrent_task_loop::post()</a>. boost.any is much pithier, not requiring a class hierarchy at all, and otherwise it's pretty much the same in terms of how they're used internally. Some might say the polymorphic hierarchy is clearer, because it is explicit, but I feel comments alone, too, can be just as clear, and brevity is a virtue. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00153">153</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="af8c06052dd887bc77444550a7c243154" name="af8c06052dd887bc77444550a7c243154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c06052dd887bc77444550a7c243154">&#9670;&nbsp;</a></span>Scheduled_task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#af8c06052dd887bc77444550a7c243154">flow::async::Scheduled_task</a> = typedef <a class="el" href="namespaceflow_1_1util.html#aafa03984c5012ef7db2e7d01b6909a83">util::Scheduled_task</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72" title="Short-hand for a task that can be posted for execution by a Concurrent_task_loop or flow::util::Task_...">flow::async::Task</a> but used for scheduled-in-future tasks as opposed to to-be-run-ASAP tasks. </p>
<p >In practice it's the same thing but takes a single <code>bool</code> argument with the meaning explained in <a class="el" href="namespaceflow_1_1util.html#a74d4a66fb00055be4e1bd6ee98e04667" title="Schedule the given function to execute in a certain amount of time: A handy wrapper around Timer (asi...">util::schedule_task_from_now()</a> doc header (spoiler alert: whether it ran as scheduled or was short-fired by user, as of this writing).</p>
<dl class="section note"><dt>Note</dt><dd>Whenever a comment explains how <code>Task</code>s are dealt with, one may usually assume the same extends equally to a <code>Scheduled_task</code>, merely at a different point in time. We omit that explicit language for brevity; it is to be assumed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00165">165</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="a2b92feccafa90bce16db57131c0fcd9e" name="a2b92feccafa90bce16db57131c0fcd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b92feccafa90bce16db57131c0fcd9e">&#9670;&nbsp;</a></span>Strand_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">flow::async::Strand_ptr</a> = typedef boost::shared_ptr&lt;<a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e">util::Strand</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for ref-counted pointer to <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>. </p>
<h3>Rationale</h3>
<p >We at times return new <code>Strand</code>s (<a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html#a2c713a2692fd7eb17e4c6ebc22cc8cfc" title="Implements superclass API.">Cross_thread_task_loop::create_op()</a>), so universally use ref-counted pointers to <code>Strand</code>s to not have to worry about <code>Strand</code> lifetimes too hard.</p>
<p >Key fact: The type <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a> loads into superclass's <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> (<code>boost::any</code>) is <code>Strand_ptr</code>. That is, a <code>Strand</code> is the mechanism used to bundle together non-concurrent tasks in <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00212">212</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="af35fb65bdea1a3a92929ec2c4a6a6b72" name="af35fb65bdea1a3a92929ec2c4a6a6b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35fb65bdea1a3a92929ec2c4a6a6b72">&#9670;&nbsp;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72">flow::async::Task</a> = typedef <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void ()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for a task that can be posted for execution by a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> or <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">flow::util::Task_engine</a>; it is simply something callable via <code>()</code> with no arguments and returning nothing. </p>
<p >By convention in comments we represent <code>Task</code>s with the letters F, G, H. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00096">96</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="afdf5986cd6dc055673792890502135a8" name="afdf5986cd6dc055673792890502135a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf5986cd6dc055673792890502135a8">&#9670;&nbsp;</a></span>Task_asio_err</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#afdf5986cd6dc055673792890502135a8">flow::async::Task_asio_err</a> = typedef <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void (const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for a boost.asio completion handler: The minimal type, taking only a <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> a/k/a <code>boost::system::error_code</code>. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00171">171</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="a3808f400a39b77d712e0526fa412bf57" name="a3808f400a39b77d712e0526fa412bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3808f400a39b77d712e0526fa412bf57">&#9670;&nbsp;</a></span>Task_asio_err_sz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#a3808f400a39b77d712e0526fa412bf57">flow::async::Task_asio_err_sz</a> = typedef <a class="el" href="classflow_1_1Function.html">Function</a>&lt;void (const <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp;, size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for a boost.asio completion handler: The type that takes a <code>size_t</code> count of things successfully transferred usually. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00177">177</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<a id="a968806f54b14c697fd76b3339a2bdbbf" name="a968806f54b14c697fd76b3339a2bdbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968806f54b14c697fd76b3339a2bdbbf">&#9670;&nbsp;</a></span>Task_engine_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">flow::async::Task_engine_ptr</a> = typedef boost::shared_ptr&lt;<a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for reference-counting pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> (a/k/a <code>boost::asio::io_service</code>). </p>
<p >This is generally how classes in the <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> hierarchy refer to their internally used <code>Task_engine</code>s but also in advanced cases may be communicated to their user.</p>
<h3>Rationale</h3>
<p >Why do that instead of using raw <code>Task_engine*</code>? It may not be obvious as you read this now, but all kinds of pain goes away due to the possibilities of who happens to own an underlying <code>Task_engine</code> &ndash; it can be shared by all threads in pool, or each can have its own <code>Task_engine</code>, depending on the chosen <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> subclass &ndash; and in what order those things might execute their destructors. By simply using a <code>shared_ptr&lt;&gt;</code> everywhere, with small overhead we ensure an underlying <code>Task_engine</code> does not get destroyed until everything that uses it is destroyed first, and that could be a number of things. By using <code>shared_ptr&lt;&gt;</code> we needn't break our heads worrying about executing de-init pieces of code in just the right order just to avoid early-free. (This is said from experience.)</p>
<p >This is reinforced in those semi-advanced cases where a <code>Task_engine</code> is passed to user via public API. </p>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00198">198</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a06794b16b72f2829ce3353557c8485" name="a0a06794b16b72f2829ce3353557c8485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a06794b16b72f2829ce3353557c8485">&#9670;&nbsp;</a></span>Synchronicity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">flow::async::Synchronicity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration indicating the manner in which <a class="el" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4" title="An extension of boost.asio&#39;s post() and dispatch() free function templates, this free function templa...">asio_exec_ctx_post()</a>, and various boost.asio "post" operations like it or based on it, are to actually execute the given task in relation to when the "posting" routine, itself, returns control to its caller. </p>
<p >Basically it indicates whether the execution should be synchronous or asynchronous and how, if it all, to wait for its completion &ndash; or its initiation. The <code>enum</code> members' meanings are the key things to understand; and there's some discussion in their doc headers that might be useful as a boost.asio refresher. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f" name="a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f"></a>S_ASYNC&#160;</td><td class="fielddoc"><p >Simply post the given task to execute asynchronously in some execution context &ndash; as soon as the context's scheduler deems wise but specifically <em>not</em> inside the posting routine itself; and return as soon as possible having thus posted it. </p>
<p >That is: work in the manner of boost.asio <code>post(Task_engine, F)</code>.</p>
<p >In particular, suppose you're calling <code>POST(F)</code> in this mode, where <code>POST()</code> is some posting routine controlling a thread pool P, and <code>F()</code> is the task; and suppose the scheduler would deem wise to run <code>F()</code> in some thread P.W in that pool (perhaps for load-balancing reasons). Then:</p><ul>
<li>If <code>POST()</code> is being called outside of pool P, or it is being called from a sibling thread P.W' but not W itself, then <code>F()</code> will run at some point in the future (possibly even concurrently with <code>POST()</code> itself), in thread P.W.<ul>
<li>One typical case is when some external user of P loads work onto P.</li>
<li>The other is if some task or completion handler already in P loads async work back onto its own pool P, but the scheduler decides it's best for it to run in a different thread than the posting code.<ul>
<li>This is only possible with 2 or more threads in P (by no means always the case).</li>
</ul>
</li>
</ul>
</li>
<li>If <code>POST()</code> is being called from W itself, meaning the scheduler decided that the task should load on the same thread as the posting task, then <code>F()</code> will run at some point in the future strictly after the <code>POST()</code> returns.<ul>
<li>This usually means some task or completion handler in pool P is loading async work back onto its own pool, and either that pool contains only 1 thread (so there is no other choice), or else the scheduler decided the calling thread is still the best choice for task <code>F()</code> at this time (e.g., maybe the other thread(s) are loaded with queued work).</li>
</ul>
</li>
</ul>
<p >Either way, <code>POST()</code> will return quickly. Then <code>F()</code> will either run concurrently or after this return &ndash; but never <em>in</em> <code>POST()</code> synchronously. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25" name="a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25"></a>S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION&#160;</td><td class="fielddoc"><p >Same as <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f" title="Simply post the given task to execute asynchronously in some execution context  as soon as the conte...">Synchronicity::S_ASYNC</a> but the posting routine then waits as long as necessary for the given task to complete; and only then returns. </p>
<p >That is: work in the manner of boost.asio <code>post(Task_engine, F)</code>, but wait until <code>F()</code> actually runs and returns. This must only be used when posting from a thread <em>outside</em> the target thread pool; or undefined behavior will result.</p>
<dl class="section warning"><dt>Warning</dt><dd>One must <em>not</em> use this mode when posting onto a thread pool from inside that thread pool: boost.asio <code>post()</code>-like function by definition won't execute a task synchronously inside itself, yet by the definition of this mode it must also wait for the task to run and complete. So if <code>post()</code> (or similar) were to decide the task belongs on the calling thread, an inifinite block (deadlock) occurs, as it will be waiting for something to happen that the wait prevents from happening.</dd></dl>
<p>This mode is reminiscent of the promise/future concept and allows one to easily solve the age-old problem of "how do I ask a thread/pool to do a thing and then wait for get a result?". One might do this by manually using a promise/future pair; or even mutex/condition variable pair; but by using this such boiler-plate is reduced (along with fewer bugs).</p>
<dl class="section warning"><dt>Warning</dt><dd>Be aware that the wait for completion will block infinitely, if one were to do something that would prevent the task from ever running. When working with boost.asio <code>Task_engine</code>s, this may occur when one <code>stop()</code>s or simply destroys the <code>Task_engine</code> (though the time period during which one would have to do this is short, assuming the task is quick). Naturally the way to avoid this is by not stopping or destroying the execution context during a posting call in mode <code>S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</code>. For example, the <code>Task_engine::stop()</code> call might be placed in the same thread as the posting; then they cannot be concurrent. If this is triggered from a SIGTERM/INT handler, one might only set or post something that will trigger the destruction in an orderly fashion at the proper time as opposed to doing it directly from the sig handler itself. This warning isn't anything that should be particularly new &ndash; orderly shutdown is typically concerned with such logic anyway &ndash; but it seemed worth putting in perspective of the fact this mode involves a wait for something that doesn't necessarily ever run, unless you actively make sure it does.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Much like the promise/future mechanism provides optional timed wait functionality, it might make sense to provide the API ability to set an optional time limit for any wait invoked by <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</a> or <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_START</a>. Probably best to add this only once a need clearly arises though. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846" name="a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846"></a>S_ASYNC_AND_AWAIT_CONCURRENT_START&#160;</td><td class="fielddoc"><p >Same as <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f" title="Simply post the given task to execute asynchronously in some execution context  as soon as the conte...">Synchronicity::S_ASYNC</a> but the posting routine then waits as long as necessary for the given task to <em>just</em> about to begin executing concurrently (so that any subsequent <code>Task_engine::stop()</code> shall be unable to prevent it from executing and eventually finishing) &ndash; and only then returns. </p>
<p >This is most similar to <code>S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</code> but may improve responsiveness of the calling thread, if what one needs to achieve is a guarantee that <code>F()</code> <em>will definitely</em> execute and complete, but does <em>not</em> need to wait for this to happen. So it's a weapon against a "dangling" <code>post()</code> that might be followed immediately by <code>Task_engine::stop()</code> &ndash; while not blocking until the posted thing finishes.</p>
<dl class="section warning"><dt>Warning</dt><dd>One must <em>not</em> use this mode when posting onto a thread pool from inside that thread pool; as with <code>S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</code> that may hang the thread. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f" name="a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f"></a>S_OPPORTUNISTIC_SYNC_ELSE_ASYNC&#160;</td><td class="fielddoc"><p >Execute the given task synchronously, if the scheduler determines that the calling thread is in its thread pool <em>and</em> is the best thread for the task; otherwise act identically to <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f" title="Simply post the given task to execute asynchronously in some execution context  as soon as the conte...">Synchronicity::S_ASYNC</a>. </p>
<p >That is: work in the manner of boost.asio <code>dispatch(Task_engine, F)</code>. This can be useful for performance, since when the opportunity presents itself this way avoids exiting a task only to immediately enter the posted task, when one could just synchronously execute one after the other.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do <em>not</em> presume to know when a given scheduler will actually decide it will invoke the given task synchronously, unless documentation very clearly explains such rules. Just because it can does not mean it will. For example, boost.asio <code>post()</code> says that the task "might" run synchronously when this is possible; not that it "will." Assumptions about when it might in fact do so can lead to subtle and difficult-to-reproduce bugs. (Example of broken assumptions: Suppose it's a 1-thread pool, and one posts F from task G. Surely it must run F synchronously &ndash; there's no other thread! But what if some other task or completion handler was already queued up to run before F was? That's not even the point though; the scheduler is still free to not do it, say because of some spurious lock-related logic that is there for some obscure performance reason.)</dd>
<dd>
If you choose to use this mode (or <code>dispatch()</code>-like routines in general), it is almost never a good idea to do so from anywhere except just before returning from a task (or from outside the thread pool). If called from the middle of a task, you now cannot be sure if A happens before B or B happens before A. Usually that makes things complicated unnecessarily. </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="async__fwd_8hpp_source.html#l00222">222</a> of file <a class="el" href="async__fwd_8hpp_source.html">async_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24567271e97a67d3cae6bd8bf8dc63c4" name="a24567271e97a67d3cae6bd8bf8dc63c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24567271e97a67d3cae6bd8bf8dc63c4">&#9670;&nbsp;</a></span>asio_exec_ctx_post()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Execution_context &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void flow::async::asio_exec_ctx_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Execution_context *&#160;</td>
          <td class="paramname"><em>exec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485">Synchronicity</a>&#160;</td>
          <td class="paramname"><em>synchronicity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1async.html#af35fb65bdea1a3a92929ec2c4a6a6b72">Task</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An extension of boost.asio's <code>post()</code> and <code>dispatch()</code> free function templates, this free function template allows the user to more easily select the synchronicity behavior as the given task is posted onto the given execution context (<a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> at least). </p>
<p >It also adds TRACE logging including that book-ending the task's execution (aiding debugging, etc.). The <code>synchronicity</code> argument controls the specific way in which <code>task</code> is posted onto <code>*exec_ctx</code>; see <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485" title="Enumeration indicating the manner in which asio_exec_ctx_post(), and various boost....">Synchronicity</a> doc header.</p>
<p >This call causes <code>task</code> to execute in a thread controlled by <code>*exec_ctx</code>. The latter, at this time, must be either <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> (which itself is born of a <code>Task_engine</code>). It is likely that it will work equally well for other entities satisfying the boost.asio <code>ExecutionContext</code> concept (see boost.asio docs), but this is untested and not thought through formally, so officially such uses cause undefined behavior as of this writing.</p>
<p >Semantics can be found in <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485" title="Enumeration indicating the manner in which asio_exec_ctx_post(), and various boost....">Synchronicity</a> doc headers which are required reading before using this function. However, briefly and informally, the utility of this function is as follows:</p><ul>
<li><code>post()</code> works on a <code>Task_engine</code> or <code>Strand</code> already and equals mode <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f" title="Simply post the given task to execute asynchronously in some execution context  as soon as the conte...">Synchronicity::S_ASYNC</a>; with this function you'll get some added debug logging as well.</li>
<li><code>dispatch()</code> and <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f" title="Execute the given task synchronously, if the scheduler determines that the calling thread is in its t...">Synchronicity::S_OPPORTUNISTIC_SYNC_ELSE_ASYNC</a> are similarly related: same thing but more logging.</li>
<li><a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</a> equals a <code>post()</code> with a promise/future pair, wherein the caller performs <code>unique_future.wait()</code> after the <code>post()</code>, while the task always sets <code>promise.set_value()</code> just before returning (and, again, more logging).</li>
<li>Lastly, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_START</a> is similar, but the <code>promise.set_value()</code> executes just <em>before</em> executing <code>task()</code>. Hence any tasks queued before <code>task()</code> will first execute (same as previous bullet); and <em>then</em> <a class="el" href="namespaceflow_1_1async.html#a24567271e97a67d3cae6bd8bf8dc63c4" title="An extension of boost.asio&#39;s post() and dispatch() free function templates, this free function templa...">asio_exec_ctx_post()</a> will return, just as <code>task()</code> begins executing as opposed to wait for its completion. This is useful to prevent <code>E.stop()</code> after our return (where <code>E</code> is the <code>Task_engine</code> that either is or produced <code>*exec_ctx</code>) will be too late to prevent <code>task()</code> from executing and completing.</li>
</ul>
<p >In all cases, one gets more logging and arguably a bit of syntactic sugar, but <code>S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</code> and <code>S_ASYNC_AND_AWAIT_CONCURRENT_START</code> in particular eliminate quite a bit of tedious and hairy code and explanations.</p>
<p >Lastly, if <code>*exec_ctx</code> is currently not running, then the semantics described in <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485" title="Enumeration indicating the manner in which asio_exec_ctx_post(), and various boost....">Synchronicity</a> doc header still apply but are deferred until it does run. In particular in mode <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</a> and <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846" title="Same as Synchronicity::S_ASYNC but the posting routine then waits as long as necessary for the given ...">Synchronicity::S_ASYNC_AND_AWAIT_CONCURRENT_START</a> this function shall not return until <code>*exec_ctx</code> at least does begin running in at least 1 thread; while the other two modes reduce to <code>post()</code>, which returns immediately, leaving <code>task()</code> to run once <code>*exec_ctx</code> starts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Execution_context</td><td><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>. See note above regarding other possibilities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use in this function. </td></tr>
    <tr><td class="paramname">exec_ctx</td><td>The execution context controlling the thread pool onto which to load the <code>task</code> for ASAP execution. </td></tr>
    <tr><td class="paramname">synchronicity</td><td>Controls the precise behavior. See above. </td></tr>
    <tr><td class="paramname">task</td><td>The task &ndash; taking no arguments and returning no value &ndash; to load onto <code>*exec_ctx</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async_2util_8hpp_source.html#l00031">31</a> of file <a class="el" href="async_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="async_8cpp_source.html#l00033">cpu_idx()</a>, <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a4d7a5700444c0570af37b1f9bcc6eb1f">S_ASYNC</a>, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485a57525f29ac96f4edd56c951e7d7c7b25">S_ASYNC_AND_AWAIT_CONCURRENT_COMPLETION</a>, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485ae9a9ae292ea3fbbe3b313348dcec0846">S_ASYNC_AND_AWAIT_CONCURRENT_START</a>, <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f">S_OPPORTUNISTIC_SYNC_ELSE_ASYNC</a>, and <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger::should_log()</a>.</p>

<p class="reference">Referenced by <a class="el" href="peer__socket_8cpp_source.html#l05621">flow::net_flow::Node::close_abruptly()</a>, <a class="el" href="peer__socket_8cpp_source.html#l03957">flow::net_flow::Node::connect_with_metadata()</a>, <a class="el" href="event__set_8cpp_source.html#l01273">flow::net_flow::Node::event_set_close()</a>, <a class="el" href="event__set_8cpp_source.html#l00881">flow::net_flow::Node::event_set_create()</a>, <a class="el" href="server__socket_8cpp_source.html#l00144">flow::net_flow::Node::listen()</a>, and <a class="el" href="peer__socket_8cpp_source.html#l06344">flow::net_flow::Node::sock_info()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a24567271e97a67d3cae6bd8bf8dc63c4_cgraph.svg" width="338" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a24567271e97a67d3cae6bd8bf8dc63c4_icgraph.svg" width="1031" height="484"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af90c1e763d49c3f3033a74871e897394" name="af90c1e763d49c3f3033a74871e897394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90c1e763d49c3f3033a74871e897394">&#9670;&nbsp;</a></span>asio_handler_via_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::async::asio_handler_via_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a boost.asio <em>completion handler</em> <code>handler</code> for a boost.asio <code>async_*()</code> action on some boost.asio I/O object to be initiated in the immediate near future, returns a wrapped handler with the same signature to be passed as the handler arg to that <code>async_*()</code> action, so that <code>handler()</code> will execute non-concurrently with other tasks in <code>Op op</code>. </p>
<p >This is analogous to boost.asio's <code>bind_executor(Strand, Handler)</code> (which replaces boost.asio's now-deprecated <code>util::Strand::wrap(Handler)</code>).</p>
<p >The mechanics of using this are explained in <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header. Using this in any other fashion leads to undefined behavior.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>boost.asio handlers are, essentially, all <code>void</code>-returning but can take various arg sets. E.g., <a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6" title="boost.asio timer.">util::Timer</a> (a/k/a <code>boost::asio::basic_waitable_timer</code>) expects a handler that takes only an <code>Error_code</code>; while <code>boost::asio::ip:tcp::socket::read_some()</code> expects one to take bytes-received <code>size_t</code> and an <code>Error_code</code>. This template supports all handlers via <code>auto</code> magic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Active loop that spawned <code>Op op</code>. </td></tr>
    <tr><td class="paramname">op</td><td>See 3-arg <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#a24f96f97ee24bfabb06c8609bc0e94a6" title="Cause the given Task (function) to execute within the thread pool as soon as possible,...">Concurrent_task_loop::post()</a>. </td></tr>
    <tr><td class="paramname">handler</td><td>Completion handler for the boost.asio <code>async_*()</code> operation to be initiated soon. It may be <code>move</code>d and saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A completion handler that will act as <code>handler()</code> but also satisfying the constraints of <code>Op op</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__task__loop_8hpp_source.html#l00691">691</a> of file <a class="el" href="concurrent__task__loop_8hpp_source.html">concurrent_task_loop.hpp</a>.</p>

<p class="reference">References <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#a24f96f97ee24bfabb06c8609bc0e94a6">flow::async::Concurrent_task_loop::post()</a>, and <a class="el" href="namespaceflow_1_1async.html#a0a06794b16b72f2829ce3353557c8485aff6bc53ee6c14f2eee463c06d9dff01f">S_OPPORTUNISTIC_SYNC_ELSE_ASYNC</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_af90c1e763d49c3f3033a74871e897394_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4cce43f39672e80cba5512103c53ae60" name="a4cce43f39672e80cba5512103c53ae60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cce43f39672e80cba5512103c53ae60">&#9670;&nbsp;</a></span>cpu_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t flow::async::cpu_idx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 0-based processor <em>logical</em> (not hardware) core index of the core executing the calling thread presently. </p>
<p >Since the value of this can change from statement to statement in the same thread, probably this is not to be used except for logging/reporting.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="async_8cpp_source.html#l00033">33</a> of file <a class="el" href="async_8cpp_source.html">async.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async_2util_8hpp_source.html#l00031">asio_exec_ctx_post()</a>, <a class="el" href="x__thread__task__loop_8cpp_source.html#l00319">flow::async::Cross_thread_task_loop::schedule_from_now()</a>, and <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00374">flow::async::Segregated_thread_task_loop::schedule_from_now_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a4cce43f39672e80cba5512103c53ae60_icgraph.svg" width="1079" height="720"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7f2f976a53191a3b0cd28898bb23c551" name="a7f2f976a53191a3b0cd28898bb23c551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2f976a53191a3b0cd28898bb23c551">&#9670;&nbsp;</a></span>op_to_exec_ctx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Exec_ctx_ptr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Exec_ctx_ptr op_to_exec_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization model for operation that obtains the underlying execution context, such as a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a>. </p>
<p >Each subclass (impl) of <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> shall provide a specialization of this template with <code>Exec_ctx_ptr</code> template param being the appropriate boost.asio-compatible execution context type for that loop type's <code>Op create_op()</code>.</p>
<p >The mechanics of using this are explained in <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header. Beyond that please see the particular specialization's doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exec_ctx_ptr</td><td>A pointer type (raw or smart) pointing to an execution context type satisfying boost.asio's "execution context" concept. As of this writing the known values would be pointers to <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> and <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, but really it depends on the particular subclass of <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> for the <code>*loop</code> arg. See its doc header near the particular <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> subclass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Loop object that, one way or another, generated and returned <code>op</code>. </td></tr>
    <tr><td class="paramname">op</td><td><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> from <code>*loop</code> from which to extract the execution context object on which you'd like to perform custom boost.asio work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a mutable execution context object. </dd></dl>

</div>
</div>
<a id="a5dad6aeb3cf4219833e18343bec0b423" name="a5dad6aeb3cf4219833e18343bec0b423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dad6aeb3cf4219833e18343bec0b423">&#9670;&nbsp;</a></span>op_to_exec_ctx&lt; Strand_ptr &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a> <a class="el" href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">op_to_exec_ctx</a>&lt; <a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>. </p>
<p >boost.asio tip: The returned <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> may be useful not only as an argument to <code>bind_executor()</code> (formerly <code>Strand::wrap()</code>, now deprecated) but can also be passed in lieu of a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> into boost.asio-enabled I/O object constructors (<a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6" title="boost.asio timer.">util::Timer</a>, <code>boost::asio::ip::tcp::socket</code>, etc.). The latter use uses the <code>Strand</code> as an "execution context."</p>
<p >Note <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#ac446f6bfed9fb54d073a5f3f578ec4bb" title="Returns a pointer to an internal util::Task_engine (a/k/a boost.asio io_service) for the purpose of p...">Concurrent_task_loop::task_engine()</a> is spiritually related to this function; but while that one gives one a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, which corresponds to the entire thread pool, this one returns an execution context specifically assigned to a multi-step async op <code>op</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header for discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Loop object that, one way or another, generated and returned <code>op</code>. Behavior is undefined if the concrete pointed-to type is not <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>. (assertion may trip). </td></tr>
    <tr><td class="paramname">op</td><td><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> from <code>*loop</code> from which to extract the execution context on which you'd like to perform custom boost.asio work. Behavior is undefined if it is not from <code>*loop</code> (assertion may trip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> created from <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> <code>E</code> such that <code>loop-&gt;task_engine() == &amp;E</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="x__thread__task__loop_8cpp_source.html#l00420">420</a> of file <a class="el" href="x__thread__task__loop_8cpp_source.html">x_thread_task_loop.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="x__thread__task__loop_8cpp_source.html#l00292">flow::async::Cross_thread_task_loop::post()</a>, and <a class="el" href="x__thread__task__loop_8cpp_source.html#l00351">flow::async::Cross_thread_task_loop::schedule_from_now()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a5dad6aeb3cf4219833e18343bec0b423_icgraph.svg" width="391" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a05632ba834a42315615900ee4382287d" name="a05632ba834a42315615900ee4382287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05632ba834a42315615900ee4382287d">&#9670;&nbsp;</a></span>op_to_exec_ctx&lt; Strand_ptr &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a> <a class="el" href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">flow::async::op_to_exec_ctx</a>&lt; <a class="el" href="namespaceflow_1_1async.html#a2b92feccafa90bce16db57131c0fcd9e">Strand_ptr</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>. </p>
<p >boost.asio tip: The returned <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> may be useful not only as an argument to <code>bind_executor()</code> (formerly <code>Strand::wrap()</code>, now deprecated) but can also be passed in lieu of a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> into boost.asio-enabled I/O object constructors (<a class="el" href="namespaceflow_1_1util.html#ae7416d64d2989051104bb396e28e15e6" title="boost.asio timer.">util::Timer</a>, <code>boost::asio::ip::tcp::socket</code>, etc.). The latter use uses the <code>Strand</code> as an "execution context."</p>
<p >Note <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#ac446f6bfed9fb54d073a5f3f578ec4bb" title="Returns a pointer to an internal util::Task_engine (a/k/a boost.asio io_service) for the purpose of p...">Concurrent_task_loop::task_engine()</a> is spiritually related to this function; but while that one gives one a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, which corresponds to the entire thread pool, this one returns an execution context specifically assigned to a multi-step async op <code>op</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header for discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Loop object that, one way or another, generated and returned <code>op</code>. Behavior is undefined if the concrete pointed-to type is not <a class="el" href="classflow_1_1async_1_1Cross__thread__task__loop.html" title="Concrete Concurrent_task_loop that is able to efficiently schedule Tasks within a given Op to execute...">Cross_thread_task_loop</a>. (assertion may trip). </td></tr>
    <tr><td class="paramname">op</td><td><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> from <code>*loop</code> from which to extract the execution context on which you'd like to perform custom boost.asio work. Behavior is undefined if it is not from <code>*loop</code> (assertion may trip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#aa59354ab408e978c8a7bda1a4706924e" title="Short-hand for boost.asio strand, an ancillary class that works with Task_engine for advanced task sc...">util::Strand</a> created from <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> <code>E</code> such that <code>loop-&gt;task_engine() == &amp;E</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="x__thread__task__loop_8cpp_source.html#l00420">420</a> of file <a class="el" href="x__thread__task__loop_8cpp_source.html">x_thread_task_loop.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="x__thread__task__loop_8cpp_source.html#l00292">flow::async::Cross_thread_task_loop::post()</a>, and <a class="el" href="x__thread__task__loop_8cpp_source.html#l00351">flow::async::Cross_thread_task_loop::schedule_from_now()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a05632ba834a42315615900ee4382287d_icgraph.svg" width="391" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad70c594985b402d9024b80370611fc1c" name="ad70c594985b402d9024b80370611fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70c594985b402d9024b80370611fc1c">&#9670;&nbsp;</a></span>op_to_exec_ctx&lt; Task_engine_ptr &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a> <a class="el" href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">op_to_exec_ctx</a>&lt; <a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>. </p>
<p >While <code>*loop</code> is running, the Task_engine is running in exactly 1 thread.</p>
<p >Note <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#ac446f6bfed9fb54d073a5f3f578ec4bb" title="Returns a pointer to an internal util::Task_engine (a/k/a boost.asio io_service) for the purpose of p...">Concurrent_task_loop::task_engine()</a> is spiritually related to this function; but while that one gives one a random thread's <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, this one returns the specific thread's assigned to a multi-step async op <code>op</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header for discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Loop object that, one way or another, generated and returned <code>op</code>. Behavior is undefined if the concrete pointed-to type is not <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>. (assertion may trip). </td></tr>
    <tr><td class="paramname">op</td><td><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> from <code>*loop</code> from which to extract the execution context on which you'd like to perform custom boost.asio work. Behavior is undefined if it is not from <code>*loop</code> (assertion may trip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> <code>E</code> used by <code>*loop</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00419">419</a> of file <a class="el" href="segregated__thread__task__loop_8cpp_source.html">segregated_thread_task_loop.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00295">flow::async::Segregated_thread_task_loop::post()</a>, and <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00328">flow::async::Segregated_thread_task_loop::schedule_from_now()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_ad70c594985b402d9024b80370611fc1c_icgraph.svg" width="422" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad932f51435b1776625df394e159e7e55" name="ad932f51435b1776625df394e159e7e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad932f51435b1776625df394e159e7e55">&#9670;&nbsp;</a></span>op_to_exec_ctx&lt; Task_engine_ptr &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a> <a class="el" href="namespaceflow_1_1async.html#a7f2f976a53191a3b0cd28898bb23c551">flow::async::op_to_exec_ctx</a>&lt; <a class="el" href="namespaceflow_1_1async.html#a968806f54b14c697fd76b3339a2bdbbf">Task_engine_ptr</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html">Concurrent_task_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949">Op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template specialization for operation that obtains the underlying execution context, in this case a <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, stored in an <a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> generated by the given <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>. </p>
<p >While <code>*loop</code> is running, the Task_engine is running in exactly 1 thread.</p>
<p >Note <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html#ac446f6bfed9fb54d073a5f3f578ec4bb" title="Returns a pointer to an internal util::Task_engine (a/k/a boost.asio io_service) for the purpose of p...">Concurrent_task_loop::task_engine()</a> is spiritually related to this function; but while that one gives one a random thread's <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a>, this one returns the specific thread's assigned to a multi-step async op <code>op</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> doc header for discussion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>Loop object that, one way or another, generated and returned <code>op</code>. Behavior is undefined if the concrete pointed-to type is not <a class="el" href="classflow_1_1async_1_1Segregated__thread__task__loop.html" title="Concrete Concurrent_task_loop that uses the legacy pin-Tasks-within-1-Op-to-1-thread method of achiev...">Segregated_thread_task_loop</a>. (assertion may trip). </td></tr>
    <tr><td class="paramname">op</td><td><a class="el" href="namespaceflow_1_1async.html#a024042c64b7dc544a7a5587afa4b1949" title="An object of this opaque type represents a collection of 1 or more async::Task, past or future,...">async::Op</a> from <code>*loop</code> from which to extract the execution context on which you'd like to perform custom boost.asio work. Behavior is undefined if it is not from <code>*loop</code> (assertion may trip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a mutable <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> <code>E</code> used by <code>*loop</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00419">419</a> of file <a class="el" href="segregated__thread__task__loop_8cpp_source.html">segregated_thread_task_loop.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00295">flow::async::Segregated_thread_task_loop::post()</a>, and <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00328">flow::async::Segregated_thread_task_loop::schedule_from_now()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_ad932f51435b1776625df394e159e7e55_icgraph.svg" width="422" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac2f32e9fc685e2e9013900b100321fff" name="ac2f32e9fc685e2e9013900b100321fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f32e9fc685e2e9013900b100321fff">&#9670;&nbsp;</a></span>optimal_worker_thread_count_per_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::async::optimal_worker_thread_count_per_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>est_hw_core_sharing_helps_algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particular, per-op latency-affecting) operations are largely between processor and RAM: Returns the # of threads to store in that pool for efficient performance. </p>
<dl class="section see"><dt>See also</dt><dd>After the threads are created, use <a class="el" href="namespaceflow_1_1async.html#a02afaeea759dfc180890e376db79530e" title="Assuming the same situation as documented for optimal_worker_thread_count_per_pool(),...">optimize_pinning_in_thread_pool()</a> to complete the work that targets this good performance.</dd></dl>
<p>This will be used, by doc header contract, by all (as of this writing) <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a> subclasses if so specified via <code>n_threads_or_zero == 0</code>. So in that context one needn't call this directly. However, it may be useful directly when one is operating a thread pool but without a <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">Concurrent_task_loop</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use in this function. </td></tr>
    <tr><td class="paramname">est_hw_core_sharing_helps_algo</td><td>Set this to <code>true</code> if you estimate the intended use for this thread pool is such that 2+ identically loaded pool threads sharing 1 physical core would handle the load (in total over those 2+ threads) better than just 1 thread using that same core would. Set it to <code>false</code> otherwise. Note that, generally, this should be assumed <code>false</code>, unless there is significant cache locality between those 2+ threads, meaning they tend to work on the same cacheably-small area in memory at ~the same time. For example, parallel matrix multiplication algorithms can thus benefit and would set it to <code>true</code>; but that is the not the case by default; one would have to prove it, or design the algorithm with that in mind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of threads mandated for the thread pool in question. </dd></dl>

<p class="definition">Definition at line <a class="el" href="concurrent__task__loop_8cpp_source.html#l00035">35</a> of file <a class="el" href="concurrent__task__loop_8cpp_source.html">concurrent_task_loop.cpp</a>.</p>

<p class="reference">References <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, and <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>.</p>

<p class="reference">Referenced by <a class="el" href="concurrent__task__loop_8cpp_source.html#l00078">optimize_pinning_in_thread_pool()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_ac2f32e9fc685e2e9013900b100321fff_icgraph.svg" width="971" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a02afaeea759dfc180890e376db79530e" name="a02afaeea759dfc180890e376db79530e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02afaeea759dfc180890e376db79530e">&#9670;&nbsp;</a></span>optimize_pinning_in_thread_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::async::optimize_pinning_in_thread_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">util::Thread</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>threads_in_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>est_hw_core_sharing_helps_algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>est_hw_core_pinning_helps_algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>hw_threads_is_grouping_collated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming the same situation as documented for <a class="el" href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff" title="Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particul...">optimal_worker_thread_count_per_pool()</a>, and that indeed the pool now contains that number of running threads: Attempts to optimize thread-core-pinning behavior in that pool for efficient performance. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff" title="Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particul...">optimal_worker_thread_count_per_pool()</a> first. The two functions work together (one before, the other after spawning the threads). Behavior is undefined if the two aren't used in coherent fashion, meaning one passed different values for same-named args.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is a to-do, as of this writing, to allow one to query system to auto-determine <code>hw_threads_is_grouping_collated</code> if desired. See <code>namespace</code> <a class="el" href="namespaceflow_1_1async.html" title="Flow module containing tools enabling multi-threaded event loops operating under the asynchronous-tas...">flow::async</a> doc header.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>For the Darwin/Mac platform only: There is likely a bug in <a class="el" href="namespaceflow_1_1async.html#a02afaeea759dfc180890e376db79530e" title="Assuming the same situation as documented for optimal_worker_thread_count_per_pool(),...">optimize_pinning_in_thread_pool()</a> regarding certain low-level pinning calls, the effect of which is that this function is probably effectively a no-op for now in Macs. The bug is explained inside the body of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use in this function. </td></tr>
    <tr><td class="paramname">threads_in_pool</td><td>These raw threads, which must number <code>optimal_worker_thread_count_per_pool(same-relevant-args)</code>, comprise the pool in question. They must be already spawned (e.g., have had some caller's code execute OK). </td></tr>
    <tr><td class="paramname">est_hw_core_sharing_helps_algo</td><td>See <a class="el" href="namespaceflow_1_1async.html#ac2f32e9fc685e2e9013900b100321fff" title="Assuming a planned thread pool will be receiving ~symmetrical load, and its UX-affecting (in particul...">optimal_worker_thread_count_per_pool()</a>. </td></tr>
    <tr><td class="paramname">est_hw_core_pinning_helps_algo</td><td>Set this to <code>true</code> if you have reason to believe that pinning each of the pool's threads to N (N &gt;= 1) logical cores would improve performance in some way. Set it to <code>false</code> otherwise. As of this writing I don't know why it would be <code>true</code> specifically; but it can be researched; and I know in practice some applications do (in fact) do it, so it's not necessarily worthless, at least. </td></tr>
    <tr><td class="paramname">hw_threads_is_grouping_collated</td><td>When the number of physical cores does not equal # of logical cores (hardware threads) &ndash; otherwise this arg is ignored &ndash; this determines the pattern in which each set of 2+ core-sharing hardware threads is arranged vs. the other sets. When <code>false</code>, it's like ABCDABCD, meaning logical cores 0,4 share core, 1,5 share different core, 2,6 yet another, etc. When <code>true</code>, it's like AABBCCDD instead. It seems <code>true</code> is either rare or non-existent, but I do not know for sure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="concurrent__task__loop_8cpp_source.html#l00078">78</a> of file <a class="el" href="concurrent__task__loop_8cpp_source.html">concurrent_task_loop.cpp</a>.</p>

<p class="reference">References <a class="el" href="error_2error_8hpp_source.html#l00269">FLOW_ERROR_SYS_ERROR_LOG_WARNING</a>, <a class="el" href="log_8hpp_source.html#l00197">FLOW_LOG_INFO</a>, <a class="el" href="log_8hpp_source.html#l00405">FLOW_LOG_SET_CONTEXT</a>, <a class="el" href="log_8hpp_source.html#l00227">FLOW_LOG_TRACE</a>, <a class="el" href="concurrent__task__loop_8cpp_source.html#l00035">optimal_worker_thread_count_per_pool()</a>, and <a class="el" href="util_2util_8hpp_source.html#l00356">flow::util::ostream_op_string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="segregated__thread__task__loop_8cpp_source.html#l00098">flow::async::Segregated_thread_task_loop::start()</a>, and <a class="el" href="x__thread__task__loop_8cpp_source.html#l00081">flow::async::Cross_thread_task_loop::start()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a02afaeea759dfc180890e376db79530e_cgraph.svg" width="703" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceflow_1_1async_a02afaeea759dfc180890e376db79530e_icgraph.svg" width="782" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 01:11:12 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
