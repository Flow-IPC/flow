<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: net_flow/node.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_460afd45d0ec637b1427e0e06a6fbcf7.html">net_flow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">node.hpp</div></div>
</div><!--header-->
<div class="contents">
<a href="node_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/* Flow</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * Copyright 2023 Akamai Technologies, Inc.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> *</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> * Licensed under the Apache License, Version 2.0 (the</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> * &quot;License&quot;); you may not use this file except in</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> * compliance with the License.  You may obtain a copy</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment"> * of the License at</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"> *</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"> *</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment"> * Unless required by applicable law or agreed to in</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment"> * writing, software distributed under the License is</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment"> * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment"> * CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment"> * See the License for the specific language governing</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment"> * permissions and limitations under the License. */</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment"></span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment">/// @file</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment"></span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="preprocessor">#include &quot;<a class="code" href="net__flow__fwd_8hpp.html">flow/net_flow/net_flow_fwd.hpp</a>&quot;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &quot;<a class="code" href="log_8hpp.html">flow/log/log.hpp</a>&quot;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &quot;<a class="code" href="net__flow_2error_2error_8hpp.html">flow/net_flow/error/error.hpp</a>&quot;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="preprocessor">#include &quot;<a class="code" href="peer__socket_8hpp.html">flow/net_flow/peer_socket.hpp</a>&quot;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &quot;<a class="code" href="server__socket_8hpp.html">flow/net_flow/server_socket.hpp</a>&quot;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="preprocessor">#include &quot;<a class="code" href="event__set_8hpp.html">flow/net_flow/event_set.hpp</a>&quot;</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="preprocessor">#include &quot;<a class="code" href="detail_2net__flow__fwd_8hpp.html">flow/net_flow/detail/net_flow_fwd.hpp</a>&quot;</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="preprocessor">#include &quot;<a class="code" href="low__lvl__packet_8hpp.html">flow/net_flow/detail/low_lvl_packet.hpp</a>&quot;</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="preprocessor">#include &quot;<a class="code" href="port__space_8hpp.html">flow/net_flow/detail/port_space.hpp</a>&quot;</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="preprocessor">#include &quot;<a class="code" href="net__env__simulator_8hpp.html">flow/net_flow/net_env_simulator.hpp</a>&quot;</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="preprocessor">#include &quot;<a class="code" href="util_2util_8hpp.html">flow/util/util.hpp</a>&quot;</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="preprocessor">#include &lt;boost/unordered_map.hpp&gt;</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="comment"></span> </div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="comment">/**</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="comment"> * Flow module containing the API and implementation of the *Flow network protocol*, a TCP-inspired stream protocol</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="comment"> * that uses UDP as underlying transport.  See the large doc header on class net_flow::Node for the &quot;root&quot; of all</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="comment"> * documentation w/r/t `net_flow`, beyond the present brief sentences.</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="comment"> *</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="comment"> * ### Historical note ###</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span><span class="comment"> * Historically, the Flow project only existed in the first place to deliver the functionality now in this</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="comment"> * `namespace` flow::net_flow.  However, since then, `net_flow` has become merely one of several Flow modules, each</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="comment"> * providing functionality independent of the others&#39;.  In the past, all/most `net_flow{}`</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment"> * contents resided directly in `namespace` ::flow, but now it has been segregated into its own namespace.</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment"> *</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="comment"> * `net_flow` may still be, by volume, the largest module (hence also perhaps the largest user of general-use modules</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="comment"> * like flow::log and flow::util).  Nevertheless, it is no longer &quot;special.&quot;</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="comment"> *</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span><span class="comment"> * @see Main class net_flow::Node.</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment"> */</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceflow_1_1net__flow.html">flow::net_flow</a></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>{</div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment">// Types.</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment"></span> </div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="comment">/**</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"> * An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment"> * address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer.  Here we summarize class Node</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment"> * and its entire containing Flow module flow::net_flow.</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment"> *</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment"> * See also flow::asio::Node, a subclass that allows for full use of our API (its superclass) and turns our sockets</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment"> * into boost.asio I/O objects, able to participate with ease in all boost.asio event loops.  If you&#39;re already very</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment"> * familiar with `boost::asio::ip::tcp`, you can skip to the asio::Node doc header.  If not, recommend becoming</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment"> * comfortable with the asio-less API, then read the forementioned asio::Node doc header.</span></div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment"> *</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment"> * The flow::asio::Node class doc header (as of this writing) includes a compact summary of all network operations</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment"> * supported by the entire hierarchy and hence deserves a look for your convenience.</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment"> *</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span><span class="comment"> * Using flow::net_flow, starting with the present class Node</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment"> * ----------------------------------------------------------</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment"> *</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment"> * Node is an important and central class of the `netflow` Flow module and thus deserves some semi-philosophical</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span><span class="comment"> * discussion, namely what makes a Node a Node -- why the name?  Let&#39;s delve into the 2 aforementioned properties of a</span></div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span><span class="comment"> * Node.</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span><span class="comment"> *</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span><span class="comment"> * ### A Node has a distinct IP address and UDP port: util::Udp_endpoint ###</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span><span class="comment"> * A Node binds to an IP address and UDP port, both of which are given (with the usual ephemeral port and</span></div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="comment"> * IP address&lt;-&gt;interface(s) nomenclature) as an argument at Node::Node() construction and can never change over the</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="comment"> * lifetime of the object.  The IP and port together are a util::Udp_endpoint, which is a `using`-alias of boost.asio&#39;s</span></div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span><span class="comment"> * `boost::asio::ip::udp::endpoint` .  In the same network (e.g., the Internet) no two Node</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment"> * objects (even in separate processes; even on different machines) may be alive (as defined by</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment"> * `Node::running() == true`) with constructor-provided util::Udp_endpoint objects `R1` and `R2` such that `R1 == R2`.</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment"> * In particular, if `Node n1` exists, with `n1.running()` and `n1.local_low_lvl_endpoint() == R1`, and on the same</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment"> * machine one attempts to construct `Node n2(R2)`, such that `R1 == R2` (their IPs and ports are equal), then `n2`</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment"> * will fail to properly construct, hence `n2.running() == false` will be the case, probably due to port-already-bound</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="comment"> * OS error.  (There are counter-examples with NAT&#39;ed IP addresses and special values 0.0.0.0 and port 0, but please</span></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment"> * just ignore those and other pedantic objections and take the spirit of what I am saying.  Ultimately, the point</span></div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="comment"> * is:</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="comment"> *</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment"> * &lt;em&gt;A successfully constructed (`running() == true`) Node occupies the same IP-and-UDP &quot;real estate&quot; as would a</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="comment"> * a mere successfully bound UDP socket.&lt;/em&gt;</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span><span class="comment"> *</span></div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment"> * So all that was a long, overbearing way to emphasize that a Node binds to an IP address and UDP port, and a single</span></div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment"> * such combo may have at most one Node on it (unless it has `!running()`).</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment"> * *That&#39;s why it is called a Node*: it&#39;s a node on the network, especially on Internet.</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment"> *</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment"> * ### A Node speaks the *Flow network protocol* to other, remote Nodes ###</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment"> * If `Node n1` is successfully constructed, and `Node n2` is as well, the two can communicate via a new protocol</span></div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment"> * implemented by this Flow module.  This protocol is capable of working with stream (TCP-like) sockets</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment"> * implemented on top of UDP in a manner analogous to how an OS&#39;s net-stack implements</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment"> * TCP over IP.  So one could call this Flow/UDP.  One can talk Flow/UDP to another</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment"> * Flow/UDP endpoint (a/k/a Node) only; no compatibility with any other protocol is supported.</span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="comment"> * (This isn&#39;t, for example, an improvement to one side of TCP that is still compatible with legacy TCPs on</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="comment"> * the other end; though that is a fertile area for research in its own right.)  The socket can also operate in</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span><span class="comment"> * unreliable, message boundary-preserving mode, controllable via a Flow-protocol-native socket option; in which case</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment"> * reliability is the responsibility of the `net_flow` user.  By default, though, it&#39;s like TCP: message bounds are not</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment"> * preserved; reliability is guaranteed inside the protocol.  `n1` and `n2` can be local in the same process, or local</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment"> * in the same machine, or remote in the same overall network -- as long as one is routable to the other, they can talk.</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment"> *</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment"> * For practical purposes, it&#39;s important to have idea of a single running() Node&#39;s &quot;weight.&quot;  Is it light-weight like</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment"> * a UDP or TCP socket?  Is it heavy-weight like an Apache server instance?  The answer is that it&#39;s MUCH close to</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment"> * the former: it is fairly light-weight.  As of this writing, internally, it stores a table of peer and server sockets</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment"> * (of which there could be a handful or tons, depending on the user&#39;s own API calls prior); and uses at least one</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment"> * dedicated worker thread (essentially not visible to the user but conceptually similar to a UDP or TCP stack user&#39;s</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment"> * view of the kernel: it does stuff for one in the background -- for example it can wait for incoming connections,</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment"> * if asked).  So, a Node is an intricate but fairly light-weight object that stores socket tables (proportional in</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment"> * size to the sockets currently required by the Node&#39;s user) and roughly a single worker thread performing low-level</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span><span class="comment"> * I/O and other minimally CPU-intensive tasks.  A Node can get busy if a high-bandwidth network is sending or</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment"> * receiving intense traffic, as is the case for any TCP or UDP net-stack.  In fact, a Node can be seen as a little</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment"> * Flow-protocol stack implemented on top of UDP transport.  (Historical note: `class Node` used to be `class Stack`,</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment"> * but this implied a heavy weight and misleadingly discouraged multiple constructions in the same program; all that</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment"> * ultimately caused the renaming to Node.)</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment"> *</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment"> * ### Essential properties of Flow network protocol (Flow ports, mux/demuxing) ###</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment"> * A single Node supports 0 or more (an arbitrary # of) peer-to-peer connections to other `Node`s.</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment"> * Moreover, given two `Node`s `n1` and `n2`, there can similarly be 0 or more peer-to-peer connections</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment"> * running between the two.  In order to allow this, a port (and therefore multiplexing/demultiplexing) system is</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment"> * a feature of Flow protocol.  (Whether this features is necessary or even desirable is slightly controversial and</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment"> * not a settled matter -- a to-do on this topic can be found below.)</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment"> *</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span><span class="comment"> * More specifically, think of a *given* `Node n1` as analogous (in terms of is multiplexing capabilities) to</span></div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment"> * one TCP stack running on a one-interface machine.  To recap the TCP port-addressing scheme (assuming only 1</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment"> * interface): The TCP stack has approximately 2^16 (~65k) ports available.  One may create and &quot;bind&quot; a server &quot;socket&quot;</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="comment"> * to (more or less, for our discussion) any 1 of these ports.  Let&#39;s say a server socket is bound to port P1.</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment"> * If a remote TCP stack successfully connects to such a server-bound port, this results in a passively-connected</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment"> * client &quot;socket,&quot; which -- also -- is bound to P1 (bear with me as to how this is possible).  Finally, the TCP</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment"> * stack&#39;s user may bind an *actively* connecting client &quot;socket&quot; to another port P2 (P2 =/= P1; as P1 is reserved</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment"> * to that server and passively connected clients from that server).  Recall that we&#39;re contriving a situation where</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment"> * there is only one other remote stack, so suppose there is the remote, 1-interface TCP stack.</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment"> * Now, let&#39;s say a packet arrives along an established connection from this stack.</span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment"> * How does our local TCP stack determine to which connection this belongs?  This is</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment"> * &quot;demultiplexing.&quot;  If the packet contains the info &quot;destination port: P2,&quot; then that clearly belongs to the</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment"> * actively-connected client we mentioned earlier... but what if it&#39;s &quot;dest. port: P1&quot;?  This could belong to any</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment"> * number of connections originally passive-connected by incoming server connection requests to port P1.</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment"> * Answer: the packet also contains a &quot;source TCP port&quot; field.  So the *connection ID*</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment"> * (a/k/a *socket ID*) consists of BOTH pieces of data: (1) destination (local) port; (2) source (remote) port.</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment"> * (Recall that, symmetrically, the remote TCP stack had to have a client bind to some port,</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment"> * and that means no more stuff can bind to that port; so it is unique and can&#39;t clash with anything else -- inside that</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span><span class="comment"> * remote stack.)  So this tuple uniquely identifies the connection in this scenario of a single-interface local TCP</span></div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment"> * that can have both active client sockets and passive-client-socket-spawning server sockets; and talk to other stacks</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment"> * like it.  Of course, there can be more than one remote TCP stack.  So the 2-tuple (pair) becomes a 3-tuple (triplet)</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="comment"> * in our slightly simplified version of reality: (1) destination (local) TCP port; (2) source (remote) IP address;</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="comment"> * and (3) source (remote) TCP port.  (In reality, the local TCP stack can bind</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span><span class="comment"> * to different interfaces, so it becomes a 4-tuple by adding in destination (local) IP address... but that&#39;s TCP and</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="comment"> * is of no interest to our analogy to Flow protocol.)</span></div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="comment"> *</span></div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span><span class="comment"> * What about Flow protocol?  GIVEN `n1` and `n2`, it works just the same.  We have a special, TCP-like, Flow port space</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="comment"> * WITHIN `n1` and similarly within `n2`.  So if only `n1` and `n2` are involved, an `n1` Server_socket (class) object</span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span><span class="comment"> * can listen() (&lt;-- actual method) on a net_flow::flow_port_t (&lt;-- alias to 2-byte unsigned as of this writing)</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span><span class="comment"> * port P1; Server_socket::accept() (another method) incoming connections, each still bound to port P1; and `n1` can</span></div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span><span class="comment"> * also actively connect() (another method) to `n2` at some port over there.  Then an incoming UDP packet&#39;s</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="comment"> * intended established connection is demuxed to by a 2-tuple: (1) destination (local) `flow_port_t`;</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span><span class="comment"> * (2) source (remote) `flow_port_t`.</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="comment"> *</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment"> * In reality, other remote `Node`s can of course be involved: `n3`, `n4`, whatever.  As we&#39;ve established, each Node</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment"> * lives at a UDP endpoint: util::Udp_endpoint (again, IP address + UDP port).  Therefore, from the stand-point of</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment"> * a given local `Node n1`, each established peer-to-peer connection is identified fully by the 5-tuple (marked here</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment"> * with roman numerals):</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment"> *   1. Local `flow_port_t` within `n1`&#39;s port-space (not dissimilar to TCP&#39;s port space in size and behavior). (I)</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment"> *   2. Remote endpoint identifying the remote Node: Remote_endpoint.</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment"> *      1. util::Udp_endpoint.</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="comment"> *         1. IP address. (II)</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span><span class="comment"> *         2. UDP port. (III)</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span><span class="comment"> *      3. Remote net_flow::flow_port_t. (IV)</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span><span class="comment"> *</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="comment"> * So, that is how it works.  Of course, if this complexity is not really necessary for some application, then</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment"> * only really (II) and (III) are truly necessary.  (I) and (IV) can just be chosen to be some agreed-upon</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment"> * constant port number.  Only one connection can ever exist in this situation, and one would need to create</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment"> * more `Node`s one side or the other or both to achieve more connections between the same pair of IP addresses,</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment"> * but that&#39;s totally reasonable: it&#39;s no different from simply binding to more UDP ports.  My point here is that</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment"> * the Flow-protocol-invented construct of &quot;Flow ports&quot; (given as `flow_port_t` values) can be used to conserve UDP</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment"> * ports; but they can also be NOT used, and one can just use more UDP ports, as a &quot;regular&quot; UDP-using pair of</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="comment"> * applications would, if more than one flow of information is necessary between those two apps.  It is up to you.</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="comment"> * (Again, some arguments can be made for getting rid of (I) and (IV), after all.  This possibility is discussed in</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span><span class="comment"> * a below to-do.)</span></div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="comment"> *</span></div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment"> * (Do note that, while we&#39;ve emulated TCP&#39;s port scheme, there is no equivalent of IP&#39;s &quot;interfaces.&quot;  Each Node</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="comment"> * just has a bunch of ports; there is no port table belonging to each of N interfaces or any such thing.)</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="comment"> *</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="comment"> * ### flow::net_flow API overview ###</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span><span class="comment"> * This is a summary (and some of this is very briefly mentioned above); all the classes and APIs are much more</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span><span class="comment"> * deeply documented in their own right.  Also, see above pointer to asio::Node whose doc header may be immediately</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span><span class="comment"> * helpful to experienced users.  Meanwhile, to summarize:</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="comment"> *</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="comment"> * The Node hands out sockets as Peer_socket objects; it acts as a factory for them (directly) via its connect() and</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span><span class="comment"> * (indirectly) Server_socket::accept() families of methods.  It is not possible to construct a Peer_socket</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment"> * independently of a Node, due to tight coordination between the Node and each Peer_socket.  Moreover each Peer_socket</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span><span class="comment"> * is handed out via `boost::shared_ptr` smart pointer.  While not strictly necessary, this is a situation where both</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment"> * the user and a central registry (Node) can own the Peer_socket at a given time, which is an ideal application for</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="comment"> * `shared_ptr&lt;&gt;` that can greatly simplify questions of object ownership and providing auto-`delete` to boot.</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span><span class="comment"> *</span></div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span><span class="comment"> * Thus: `Node::listen(flow_port_t P)` yields a Server_socket::Ptr, which will listen for incoming connections on `P`.</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span><span class="comment"> * Server_socket::accept() (and similar) yields a Peer_socket::Ptr, one side of a peer-to-peer connection.</span></div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span><span class="comment"> * On the other side, `Node::connect(Remote_endpoint R)` (where `R` contains `Udp_endpoint U`, where</span></div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="comment"> * value equal to `U` had been earlier passed to constructor of the `listen()`ing `Node`; and `R` also contains</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment"> * `flow_port_t P`, passed to `Node::listen()`).  connect(), too, yields a Peer_socket::Ptr.  And thus, if all went</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="comment"> * well, each side now has a Peer_socket::Ptr `S1` and `S2`, which -- while originating quite differently --</span></div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span><span class="comment"> * are now completely equal in capabilities: they are indeed *peer* sockets.  They have methods like Peer_socket::send()</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="comment"> * and Peer_socket::receive().</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment"> *</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span><span class="comment"> * Further nuances can be explored in the various other doc headers, but I&#39;ll mention that both non-blocking behavior</span></div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span><span class="comment"> * (meaning the call always returns immediately, even if unable to immediately perform the desired task such as</span></div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment"> * accept a connection or receive 1 or more bytes) and blocking behavior as supported, as in (for example) a BSD</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="comment"> * sockets API.  However, there is no &quot;blocking&quot; or &quot;non-blocking&quot; mode as in BSD or WinSock (personally I, Yuri, see it</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span><span class="comment"> * as an annoying anachronism).  Instead you simply call a method named according to whether it will never block or</span></div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="comment"> * (possibly -- if appropriate) block.  The nomenclature convention is as follows: if the action is `X` (e.g.,</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span><span class="comment"> * `X` is `receive` or `accept`), then `-&gt;X()` is the non-blocking version; and `-&gt;sync_X()` is the blocking one.</span></div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span><span class="comment"> * A non-blocking version always exists for any possible action; and a blocking version exists if it makes sense for it</span></div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span><span class="comment"> * to exist.  (Exception: Event_set::async_wait() explicitly includes `async_` prefix contrary to this convention.</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span><span class="comment"> * Partially it&#39;s because just calling it `wait()` -- convention or not -- makes it sound like it&#39;s going to block,</span></div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment"> * whereas it emphatically will never do so.  ALSO it&#39;s because it&#39;s a &quot;special&quot; method with unique properties</span></div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span><span class="comment"> * including letting user execute their own code in a Node&#39;s internal worker thread.  So rules go out the window a</span></div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span><span class="comment"> * little bit for that method; hence the slight naming exception.)</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span><span class="comment"> *</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span><span class="comment"> * ### Nomenclature: &quot;low-level&quot; instead of &quot;UDP&quot; ###</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span><span class="comment"> * Side note: You will sometimes see the phrase `low_lvl` in various identifiers among `net_flow` APIs.</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment"> * `low_lvl` (low-level) really means &quot;UDP&quot; -- but theoretically some other packet-based transport could be used</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="comment"> * instead in the future; or it could even be an option to chooose between possible underlying protocols.</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment"> * For example, if `net_flow` moved to kernel-space, the transport could become IP, as it is for TCP.</span></div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment"> * So this nomenclature is a hedge; and also it argubly is nicer/more generic: the fact it&#39;s UDP is immaterial; that</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment"> * it&#39;s the low-level (from our perspective) protocol is the salient fact.  However, util::Udp_endpoint is thus named</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment"> * because it is very specifically a gosh-darned UDP port (plus IP address), so hiding from that by naming it</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment"> * `Low_Lvl_endpoint` (or something) seemed absurd.</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment"> *</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="comment"> * ### Event, readability, writability, etc. ###</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span><span class="comment"> * Any experienced use of BSD sockets, WinSock, or similar is probably wondering by now, &quot;That sounds reasonable, but</span></div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span><span class="comment"> * how does the API allow me to wait until I can connect/accept/read/write, letting me do other stuff in the meantime?&quot;</span></div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span><span class="comment"> * Again, one can use a blocking version of basically every operation; but then the wait for</span></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span><span class="comment"> * readability/writability/etc. may block the thread.  One can work around this by creating multiple threads, but</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span><span class="comment"> * multi-threaded coding introduced various difficulties.  So, the experienced socketeer will want to use non-blocking</span></div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span><span class="comment"> * operations + an event loop + something that allow one to wait of various states (again, readability, writability,</span></div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span><span class="comment"> * etc.) with various modes of operation (blocking, asynchronous, with or without a timeout, etc.).</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="comment"> * The most advanced and best way to get these capabilities is to use boost.asio integration (see asio::Node).</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span><span class="comment"> * As explained elsewhere (see Event_set doc header) this is sometimes not usable in practice.  In that case:</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="comment"> * These capabilities are supplied in the class Event_set.  See that class&#39;s doc header for further information.</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span><span class="comment"> * Event_set is the `select()` of this socket API.  However it is significantly more convenient AND indeed supports</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span><span class="comment"> * a model that will allow one to use Flow-protocol sockets in a `select()`- or equivalent-based event loop, making</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="comment"> * `net_flow` module usable in a true server, such as a web server.  That is, you don&#39;t just have to write a separate</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="comment"> * Flow event loop operating independently of your other sockets, file handles, etc.  This is an important property in</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="comment"> * practice.  (Again: Ideally you wouldn&#39;t need Event_set for this; asio::Node/etc. might be better to use.)</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment"> *</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment"> * ### Error reporting ###</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="comment"> * Like all Flow modules, `net_flow` uses error reporting conventions/semantics introduced in `namespace` ::flow</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span><span class="comment"> * doc header Error Reporting section.</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span><span class="comment"> *</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span><span class="comment"> * In particular, this module does add its own error code set.  See `namespace` net_flow::error doc header which</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span><span class="comment"> * should point you to error::Code `enum`.  All error-emitting `net_flow` APIs emit `Error_code`s assigned from</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span><span class="comment"> * error::Code `enum` values.</span></div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span><span class="comment"> *</span></div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="comment"> * ### Configurability, statistics, logging ###</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span><span class="comment"> * Great care is taken to provide visibility into the &quot;black box&quot; that is Flow-protocol.  That is, while the API follows</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span><span class="comment"> * good practices wherein implementation is shielded away from the user, at the same time the *human* user has powerful</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment"> * tools to both examine the insides of the library/protocol&#39;s performance AND to tweak the parameters of its</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="comment"> * behavior.  Picture a modern automobile: while you&#39;re driving at least, it&#39;s not going to let you look at or mess with</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment"> * its engine or transmission -- nor do you need to understand how they work; BUT, the onboard monitor</span></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment"> * will feature screens that tell you about its fuel economy performance, the engine&#39;s inner workings, and perhaps a</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment"> * few knobs to control the transmission&#39;s performance (for example).  Same principles are followed here.</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span><span class="comment"> *</span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="comment"> * More specifically:</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span><span class="comment"> *   - *Configuration* Socket options are supported via Node_options and Peer_socket_options.  These control many</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span><span class="comment"> *     aspects of the library&#39;s behavior, for example which congestion control algorithm to use.</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span><span class="comment"> *     These options can be set programmatically, through a config file, or through command line options.</span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span><span class="comment"> *     Particular care was taken to make the latter two features seamlessly available by</span></div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment"> *     leveraging boost.program_options.</span></div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment"> *   - *Statistics* Very detailed stats are kept in Peer_socket_receive_stats and Peer_socket_send_stats, combined</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span><span class="comment"> *     with more data in Peer_socket_info.  These can be accessed programmatically; their individual stats can also</span></div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment"> *     be accessed programmatically; or they can be logged to any `ostream`.  Plus, the logging system periodically logs</span></div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment"> *     them (assuming this logging level is enabled).</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment"> *   - *Logging* Like all Flow modules, `net_flow` uses logging conventions/semantics introduced in `namespace` ::flow</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment"> *     doc header Logging section.</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment"> *</span></div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment"> * ### Multiple Node objects ###</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment"> * As mentioned already many times, multiple Node objects can exist and function simultaneously (as long as they</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="comment"> * are not bound to the same conceptual util::Udp_endpoint, or to the same UDP port of at least one IP interface).</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="comment"> * However, it is worth emphasizing that -- practically speaking -- class Node is implemented in such a way as to make</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span><span class="comment"> * a given Node 100% independent of any other Node in the same process.  They don&#39;t share working thread(s), data</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span><span class="comment"> * (except `static` data, probably just constants), any namespaces, port spaces, address spaces, anything.  Each Node</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span><span class="comment"> * is independent both API-wise and in terms of  internal implementation.</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment"> *</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="comment"> * ### Thread safety ###</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment"> * All operations safe for simultaneous execution on 2+ separate Node objects *or on the same Node*,</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment"> * or on any objects (e.g., Peer_socket) returned by Node.  (Please note the *emphasized* phrase.)</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment"> * &quot;Operations&quot; are any Node or Node-returned-object method calls after construction and before destruction of the</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="comment"> * Node.  (In particular, for example, one thread can listen() while another connect()s.)  The same guarantee may or</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"> * may not apply to other classes; see their documentation headers for thread safety information.</span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment"> *</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="comment"> * ### Thread safety of destructor ###</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment"> * Generally it is not safe to destruct a Node (i.e., let Node::~Node() get called) while a Node operation is in</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment"> * progress on that Node (obviously, in another thread).  There is one exception to this: if a blocking operation</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment"> * (any operation with name starting with `sync_`) has entered its blocking (sleep) phase, it is safe to delete the</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span><span class="comment"> * underlying Node.  In practice this means simply that, while you need not lock a given Node with an external</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span><span class="comment"> * mutex while calling its various methods from different threads (if you really must use multiple threads this way),</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span><span class="comment"> * you should take care to probably join the various threads before letting a Node go away.</span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span><span class="comment"> *</span></div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment"> * Historical note re. FastTCP, Google BBR</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span><span class="comment"> *</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment"> * ### Historical note re. FastTCP ###</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="comment"> * One notable change in this `net_flow` vs. the original libgiga is this</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span><span class="comment"> * one lacks the FastTCP congestion control strategy.  I omit the historical reasons for this for now</span></div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span><span class="comment"> * (see to-do regarding re-introducing licensing/history/location/author info, in common.hpp).</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="comment"> *</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span><span class="comment"> * Addendum to the topic of congestion control: I am not that interested in FastTCP, as I don&#39;t see it as cutting-edge</span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span><span class="comment"> * any longer.  I am interested in Google BBR.  It is a goal to implement Google BBR in `net_flow`, as that congestion</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment"> * control algorithm is seen by many as simply the best one available; a bold conclusion given how much research</span></div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment"> * and given-and-take and pros-and-cons discussions have tramspired ever since the original Reno TCP became ubiquitous.</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment"> * Google BBR is (modulo whatever proprietary improvements Google chooses to implement in their closed-source software)</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment"> * publicly documented in research paper(s) and, I believe, available as Google open source.</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment"> *</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment"> * @todo flow::net_flow should use flow::cfg for its socket-options mechanism.  It is well suited for that purpose, and</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment"> * it uses some ideas from those socket-options in the first place but is generic and much more advanced.  Currently</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="comment"> * `net_flow` socket-options are custom-coded from long before flow::cfg existed.</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span><span class="comment"> *</span></div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment"> * @todo `ostream` output operators for Node and asio::Node should exist.  Also scour through all types; possibly</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="comment"> * some others could use the same.  (I have been pretty good at already implementing these as-needed for logging; but</span></div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span><span class="comment"> * I may have &quot;missed a spot.&quot;)</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span><span class="comment"> *</span></div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span><span class="comment"> * @todo Some of the `ostream&lt;&lt;` operators we have take `X*` instead of `const X&amp;`; this should be changed to the latter</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="comment"> * for various minor reasons and for consistency.</span></div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span><span class="comment"> *</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment"> * @todo Actively support IPv6 and IPv4, particularly in dual-stack mode (wherein net_flow::Server_socket would bind to</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="comment"> * an IPv6 endpoint but accept incoming V4 and V6 connections alike).  It already supports it nominally, in that one</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span><span class="comment"> * can indeed listen on either type of address and connect to either as well, but how well it works is untested, and</span></div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span><span class="comment"> * from some outside experience it might involve some subtle provisions internally.</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment"> *</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="comment"> * @todo Based on some outside experience, there maybe be problems -- particularly considering the to-do regarding</span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment"> * dual-stack IPv6/v4 support -- in servers listening in multiple-IP situations; make sure we support these seamlessly.</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment"> * For example consider a machine with a WAN IP address and a LAN (10.x.x.x) IP address (and possibly IPv6 versions</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span><span class="comment"> * of each also) that (as is typical) binds on all of them at ANY:P (where P is some port; and ANY is the IPv6 version,</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span><span class="comment"> * with dual-stack mode ensuring V4 datagrams are also received).  If a client connects to a LAN IP, while in our</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment"> * return datagrams we set the source IP to the default, does it work?  Outside experience shows it might not,</span></div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span><span class="comment"> * depending, plus even if in our protocol it does, it might be defeated by some firewall... the point is it requires</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span><span class="comment"> * investigation (e.g., mimic TCP itself; or look into what IETF or Google QUIC does; and so on).</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="comment"> *</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="comment"> * @internal</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span><span class="comment"> *</span></div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment"> * Implementation notes</span></div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span><span class="comment"> * --------------------</span></div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment"> *</span></div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment"> * In this section, and within implementation, I may simply say &quot;Flow&quot; instead of &quot;Flow [network] protocol,&quot; for</span></div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span><span class="comment"> * brevity.  This is not meant to represent all of the containing Flow project nor refer to any module other</span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment"> * that `net_flow`.</span></div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment"> *</span></div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span><span class="comment"> * ### Note on general design philosophy ###</span></div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment"> * The protocol is TCP-like.  However, it is not TCP.  Moreover, it is not</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment"> * TCP even if you remove the fact that it sends UDP datagrams instead of IP packets.  It follows the basic</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span><span class="comment"> * goals of TCP (stream of bytes, reliability, congestion control, etc.), and it borrows many of its internal</span></div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="comment"> * techniques (congestion window, receive window ACKs, drop timeout, etc.), but it specifically will not</span></div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span><span class="comment"> * inherit those limitations of TCP that are essentially historic and/or a result of having to be backwards-</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment"> * compatible with the other side which may be behind.  For example, all ACKs in Flow are selective; whereas in</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment"> * TCP ACKs are generally cumulative, while selective ACKs (SACKs) are an advanced option that the other side</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span><span class="comment"> * may or may not support.  Making certain modern decisions in Flow that TCP implementations simply cannot</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span><span class="comment"> * make means (1) a simpler protocol and implementation; and (2) potentially higher performance before we can</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="comment"> * try any advanced stuff like new congestion control strategies or FEC (forward error correction).</span></div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment"> *</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment"> * Moreover, I tried to take care in not copying various classic TCP RFCs mindlessly.  Instead, the idea was</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment"> * to evaluate the spirit, or intent, of each technical detail of a given RFC -- and then translate it into</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment"> * the (hopefully) more elegant and less historical baggage-encumbered world of Flow.  This is particularly</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span><span class="comment"> * something I felt when translating the terse congestion control-related TCP RFCs into `net_flow` C++ code. (For</span></div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment"> * a more specific explanation of what I mean, check out the &quot;general design note&quot; in the class doc header of</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment"> * the class Congestion_control_strategy.)  Hopefully this means terse, concern-conflating TCP RFCs (and at</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="comment"> * times Linux kernel&#39;s somewhat less concern-conflating implementations of these RFCs) become clean, concern-</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment"> * separated Flow code.  This means, also, a rather extremely high ratio of comments to code in many areas</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment"> * of this project.  I wanted to clearly explain every non-trivial decision, even if it meant many long-winded</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span><span class="comment"> * English explanations.</span></div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span><span class="comment"> *</span></div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span><span class="comment"> * ### Basic implementation ###</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="comment"> * Constructor creates new thread, henceforth called thread W, which houses the Node&#39;s</span></div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="comment"> * main loop  and performs all blocking work (and generally most work) for the class; this exists until the</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment"> * destructor executes.  In general, for simplicity (in a way) and consistency, even when a given call (e.g.,</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment"> * non-blocking connect()) could perform some preliminary work (e.g., argument checking and ephemeral port</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment"> * reservation) directly in the caller&#39;s thread and then place a callback (e.g., connect_worker()) on W for</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment"> * the real work (e.g., filling out packet, sending SYN, etc.), we instead choose to put all the work (even</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment"> * the aforementioned preliminary kind) onto W and (non-blockingly!) wait for that callback to finish, via a</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment"> * boost.thread `future`.  While a bit slower, I find this simplifies the code by breaking it up less and</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment"> * keeping it in one place in the code base for a given operation (in this example, connect()).  It can also</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment"> * reduce mutex usage in our code.  Also it enables a slightly better user experience, as errors are reported</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment"> * earlier in the user code and state changes are not asynchronous, when they don&#39;t need to be.</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment"> *</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment"> * The above can apply to such things as non-blocking connect(), listen().  It probably wouldn&#39;t apply</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment"> * to Peer_socket::send(), Peer_socket::receive(), Server_socket::accept() for performance reasons.</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment"> *</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment"> * ### Note on threads W and U ###</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment"> * In classic Berkeley sockets, one often thinks of &quot;the kernel&quot; performing certain</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment"> * work in &quot;the background,&quot; the results of which the user level code might access.  For example, the kernel</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment"> * might receive IP packets on some port and deserialize them into a socket&#39;s receive buffer -- while the</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment"> * user&#39;s program is busy doing something completely unrelated like showing graphics in a video game -- then</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment"> * the `recv()` call would later transfer the deserialized stream into the user&#39;s own user-level buffer (e.g., a</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment"> * `char[]` array).  In our terminology, &quot;thread W&quot; is the equivalent of &quot;the kernel&quot; doing stuff &quot;in the</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment"> * background&quot;; while &quot;thread U&quot; refers to the user&#39;s own thread where they do other stuff and at times access</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment"> * the results of the &quot;kernel background&quot; stuff.  However, Flow is a user-level tool, so thread W is not</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment"> * actually running in the kernel... but conceptually it is like it.</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment"> *</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="comment"> * ### boost.asio ###</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment"> * The implementation heavily uses the boost.asio library, as recommended by ::flow doc</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment"> * header boost.asio section.  This implements the main loop&#39;s flow</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="comment"> * (with a callback-based model), all UDP traffic, timers.</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment"> * Why use boost.asio and not home-made networking and event loop code?  There are a few good reasons.  For</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment"> * UDP networking, boost.asio provides a pain-free, portable, object-oriented wrapper around BSD</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment"> * sockets/WinSock (that nevertheless exposes the native resources like sockets/FDs *if* needed).  For a high-</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment"> * performance event loop, boost.asio gives a flexible *proactor pattern* implementation, supporting arbitrary</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment"> * callbacks with lambdas or `bind()`, which is much easier and prettier than C-style function pointers with `void*`</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment"> * arguments a-la old-school HTTP servers written in C.  For a complex event-driven loop like this, we&#39;d have</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment"> * to implement some callback system anyway, and it would likely be far worse than boost.asio&#39;s, which is</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment"> * full-featured and proven through the years.</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment"> *</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment"> * To-dos and future features</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment"> * --------------------------</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="comment"> *</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow):</span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="comment"> * The OS UDP net-stack buffers arriving datagrams until they&#39;re `recv()`d by the application</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="comment"> * layer.  This buffer is limited; on my Linux test machine the default appears to buffer ~80 1k datagrams.</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="comment"> * With a high sender CWND and high throughput (e.g., over loopback), thread W -- which both reads off UDP</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span><span class="comment"> * datagrams and handles them, synchronously -- cannot always keep up, and the buffer fills up.  This</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="comment"> * introduces Flow loss despite the fact that the datagram actually safely got to the destination; and this is</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span><span class="comment"> * with just ONE sender; in a server situation there could be thousands.  In Linux I was able to raise, via</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="comment"> * `setsockopt()`, the buffer size to somewhere between 1000 and 2000 1k datagrams.  This helps quite a bit.</span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="comment"> * However, we may still overflow the buffer in busy situations (I have seen it, still with only one</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="comment"> * connection).  So, the to-do is to solve this problem.  See below to-dos for ideas.</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="comment"> * WARNING: UDP buffer overflow can be hard to detect and may just look like loss; plus the user not</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="comment"> * reading off the Receive buffer quickly enough will also incur similar-looking loss.  If there</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span><span class="comment"> * were a way to detect the total # of bytes or datagrams pending on a socket, that would be cool,</span></div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment"> * but `sock.available()` (where `sock` is a UDP socket) just gives the size of the first queued datagram.</span></div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment"> * Congestion control (if effective) should prevent this problem, if it is a steady-state situation (i.e.,</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="comment"> * loss or queueing delay resulting from not keeping up with incoming datagrams should decrease CWND).</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="comment"> * However, if it happens in bursts due to high CPU use in the environment, then that may not help.</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment"> * NOTE 1: In practice a Node with many connections is running on a server and thus doesn&#39;t</span></div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment"> * receive that much data but rather sends a lot.  This mitigates the UDP-receive-buffer-overflow</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment"> * problem, as the Node receiving tons of data is more likely to be a client and thus have only one</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment"> * or two connections.  Hence if we can handle a handful of really fast flows without such loss,</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="comment"> * we&#39;re good.  (On other hand, ACKs are also traffic, and server may get a substantial amount of</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="comment"> * them.  Much testing is needed.)  Packet pacing on the sender side may also avoid this loss</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="comment"> * problem; on the other hand it may also decrease throughput.</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span><span class="comment"> * NOTE 2: Queue delay-based congestion control algorithms, such as FastTCP and Vegas, are highly</span></div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="comment"> * sensitive to accurate RTT (round trip time) readings.  Heavy CPU load can delay the recording of the</span></div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="comment"> * &quot;received&quot; time stamp, because we call UDP `recv()` and handle the results all in one thread.  Any solution,</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="comment"> * such as the dedicated thread proposed below, would _allow_ one to record the time stamp immediately upon receipt</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="comment"> * of the packet by the dedicated thread; while W would independently handle everything else.  Is that a good</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment"> * idea though?  Maybe not.  If the CPU load is such that ACK-receiver-side can&#39;t get to the time-stamp-saving,</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment"> * RTT-measuring step without tricks like doing it immediately upon some low-level datagram receipt hook, then</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment"> * that CPU-pegged jungle is, in a way, part of the network and should probably be fairly counted as part of</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment"> * the RTT.  So perhaps we should continue to take the RTT time stamp while actually handling the individual</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment"> * acknowledgments.  Instead we should strive to use multi-core resources efficiently, so that the gap between</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment"> * receipt (on whatever thread) and acknowledgment processing (on whatever thread) is as small as possible.</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment"> * Then RTT is RTT, but we make it smaller via improved performance.  Meanwhile, we hopefully also solve the</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment"> * original problem (internal kernel buffer overflowing and dropping datagrams).</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span><span class="comment"> *</span></div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 1 (CO-WINNER!):</span></div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span><span class="comment"> * One approach is to note that, as of this writing, we call `m_low_lvl_sock.async_receive(null_buffers)`;</span></div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span><span class="comment"> * the `null_buffers` value for the buffers arg means that the handler is called without any actual UDP</span></div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="comment"> * receive is performed by boost.asio; our handler is called once there is at least 1 message TO read;</span></div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="comment"> * and then indeed our handler does read it (and any more messages that may also have arrived).</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="comment"> * Well, if we pass in an actual buffer instead, then boost.asio will read 1 (and no more, even if there are more)</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment"> * message into that buffer and have it ready in the handler.  Assuming the mainstream case involves only 1</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment"> * message being ready, and/or assuming that reading at least 1 message each time ASAP would help significantly,</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment"> * this may be a good step toward relieving the problem, when it exists.  The code becomes a tiny bit less</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="comment"> * elegant, but that&#39;s negligible.  This seems like a no-brainer that should be included in any solution, but it</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment"> * by itself may not be sufficient, since more than 1 datagram may be waiting, and datagrams 2, 3, ... would</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment"> * still have to be read off by our code in the handler.  So other approaches should still be considered.</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment"> *</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 2:</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span><span class="comment"> * To eliminate the problem to the maximum extent possible, we can dedicate its own thread --</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="comment"> * call it W2 -- to reading #m_low_lvl_sock.  We could also write to #m_low_lvl_sock on W2 (which would also</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span><span class="comment"> * allow us to use a different util::Task_engine from #m_task_engine to exclusively deal with W2 and</span></div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span><span class="comment"> * the UDP socket #m_low_lvl_sock -- simpler in some ways that the strand-based solution described below).</span></div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span><span class="comment"> * There are a couple of problems with this.  One, it may delay receive ops due to send ops, which compromises</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="comment"> * the goals of this project in the first place.  Two, send pacing code is in thread W (and moving it to W2</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment"> * would be complex and unhelpful); and once the decision to REALLY send a given datagram has been made,</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment"> * this send should occur right then and there -- queuing that task on W2 may delay it, compromising the</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="comment"> * quality of send pacing (whose entire nature is about being precise down to the microsecond or even better).</span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment"> * Therefore, we&#39;d like to keep `m_low_lvl_sock.async_send()` in thread W along with all other work (which</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment"> * allows vast majority of internal state to be accessed without locking, basically just the Send/Receive</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment"> * buffers excluded); except the chain of [`m_low_lvl_sock.async_receive()` -&gt; post handler of received datagram</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment"> * onto thread W; and immediately `m_low_lvl_sock.async_receive()` again] would be on W2.</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment"> * AS WRITTEN, this is actually hard or impossible to do with boost.asio because of its design: #m_low_lvl_sock</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment"> * must belong to exactly one `Task_engine` (here, #m_task_engine), whereas to directly schedule a specific</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="comment"> * task onto a specific thread (as above design requires) would require separate `Task_engine` objects (1 per</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="comment"> * thread): boost.asio guarantees a task will run on *a* thread which is currently executing `run()` --</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="comment"> * if 2 threads are executing `run()` on the same service, it is unknown which thread a given task will land</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment"> * upon, which makes the above design (AS WRITTEN) impossible.  (Side note: I&#39;m not sure it&#39;s possible in plain C</span></div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment"> * with BSD sockets either.  A naive design, at least, might have W `select()` on `m_low_lvl_sock.native()` for</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="comment"> * writability as well other stuff like timers, while W2 `select()`s on same for readability; then the two</span></div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="comment"> * threads perform UDP `send()` and `recv()`, respectively, when so instructed by `select()`s.  Is it allowed</span></div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="comment"> * to use `select()` on the same socket concurrently like that?  StackOverflow.com answers are not clear cut, and</span></div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment"> * to me, at least, it seems somewhat dodgy.)  However, an equivalent design IS possible (and supported cleanly by</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment"> * boost.asio):  In addition to the 2 threads, set up 2 strands, S and S2.  All work except the #m_low_lvl_sock</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment"> * reads and posting of the handler onto S will be scheduled with a strand S.  All work regarding</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span><span class="comment"> * #m_low_lvl_sock reads and posting of its handler onto S will be scheduled with a strand S2.</span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment"> * Recall that executing tasks in 1 strand, with 2+ threads executing `run()`, guarantees that no 2+ of</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment"> * those tasks will execute simultaneously -- always in series.  This is actually -- in terms of efficiency</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="comment"> * and thread safety -- equivalent to the above W/W2 design.  Since the S tasks will always execute serially,</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span><span class="comment"> * no locking is necessary to prevent concurrent execution; thus what we know today as thread W tasks (which</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span><span class="comment"> * need no locking against each other) will be equally thread safe; and same holds for the new S2 tasks</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="comment"> * (which are considerably simpler and fewer in number).  So that&#39;s the thread safety aspect; but why is</span></div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span><span class="comment"> * efficiency guaranteed?  The answer becomes clear if one pictures the original thread W/W2 design;</span></div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment"> * basically little task blocks serially pepper thread W timeline; and same for W2.  By doing it with strands</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="comment"> * S and S2 (running on top of threads W and W2), the only thing that changes is that the little blocks</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment"> * might at random be swapped between threads.  So the series of tasks T1 -&gt; T2 -&gt; T3 -&gt; T4 meant for</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment"> * for S might actually jump between W and W2 randomly; but whenever thread W2 is chosen instead of</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment"> * thread W, that leaves an empty &quot;space&quot; in thread W, which will be used by the S2 task queue if it</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment"> * needs to do work at the same time.  So tasks may go on either thread, but the strands ensure</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment"> * that both are used with maximum efficiency while following the expected concurrency constraints</span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment"> * (that each strand&#39;s tasks are to be executed in series).  Note, however, that #m_low_lvl_sock (the</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment"> * socket object) is not itself safe for concurrent access, so we WILL need a lock to protect the tiny/short</span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span><span class="comment"> * calls `m_low_lvl_sock.async_receive()` and `m_low_lvl_sock.async_send()`: we specifically allow that</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span><span class="comment"> * a read and write may be scheduled to happen simultaneously, since the two are independent of each</span></div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span><span class="comment"> * other and supposed to occur as soon as humanly possible (once the desire to perform either one</span></div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span><span class="comment"> * is expressed by the code -- either in the pacing module in strand S or the read handler in S2).</span></div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="comment"> * In terms of nomenclature, if we do this, it&#39;d be more fair to call the threads W1 and W2 (as they</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="comment"> * become completely equal in this design).  (In general, any further extensions of this nature (if</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="comment"> * we want still more mostly-independent task queues to use available processor cores efficiently),</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment"> * we would add 1 strand and 1 worker thread per each such new queue.  So basically there&#39;s a thread pool</span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment"> * of N threads for N mostly-independent queues, and N strands are used to use that pool efficiently</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment"> * without needing to lock any data that are accessed exclusively by at most 1 queue&#39;s tasks only.</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment"> * Resources accessed by 2 or more task queues concurrently would need explicit locking (e.g.,</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span><span class="comment"> * #m_low_lvl_sock in this design).)  So then where we start thread W today, we&#39;d start the thread</span></div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment"> * pool of 2 threads W1, W2, with each executing `m_task_engine.run()`.  Before the run()s execute,</span></div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment"> * the initial tasks (each wrapped in strand S or S2, as appropriate) need to be posted onto</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment"> * #m_task_engine; this can even occur in the user thread U in the constructor, before W1 and W2</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment"> * are created.  The destructor would `m_task_engine.stop()` (like today), ending each thread&#39;s</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span><span class="comment"> * `run()` and trigger the imminent end of that thread; at which point destructor can `W1.join()` and `W2.join()`</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="comment"> * (today it&#39;s just `W.join()`).</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment"> *</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 3:</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="comment"> * Suppose we take APPROACH 1 (no-brainer) plus APPROACH 2.  Certain decisions in the latter were made for</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span><span class="comment"> * certain stated reasons, but let&#39;s examine those more closely.  First note that the APPROACH 1 part will</span></div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="comment"> * ensure that, given a burst of incoming datagrams, the first UDP `recv()` will occur somewhere inside boost.asio,</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span><span class="comment"> * so that&#39;s definitely a success.  Furthermore, strand S will invoke `m_low_lvl_sock.async_send()` as soon as</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="comment"> * the pacing module decides to do so; if I recall correctly, boost.asio will invoke the UDP `send()` right then</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="comment"> * and there, synchronously (at least I wrote that unequivocally in a Node::async_low_lvl_packet_send_impl() comment).</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="comment"> * Again, that&#39;s as good as we can possibly want.  Finally, for messages 2, 3, ... in that incoming datagram burst,</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="comment"> * our handler will (indirectly but synchronously) perform the UDP `recv()`s in strand S2.  Here we&#39;re somewhat</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span><span class="comment"> * at boost.asio&#39;s mercy, but assuming its strand task scheduling is as efficient as possible, it should occur</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span><span class="comment"> * on the thread that&#39;s free, and either W1 or W2 should be free given the rest of the design.  Still, boost.asio</span></div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span><span class="comment"> * docs even say that different strands&#39; tasks are NOT guaranteed to be invoked concurrently (though common</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span><span class="comment"> * sense implies they will be when possible... but WHAT IF WE&#39;RE WRONG!!!?).  Also, we don&#39;t know how much</span></div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment"> * computational overhead is involved in making strands work so nicely (again, hopefully it&#39;s well written...</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment"> * but WHAT IF!!!?).  A negative is the small mutex section around the two #m_low_lvl_sock calls; not complex</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="comment"> * and probably hardly a performance concern, but still, it&#39;s a small cost.  Finally, using strands -- while</span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="comment"> * not ugly -- does involve a bit more code, and one has to be careful not to forget to wrap each handler with</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="comment"> * the appropriate strand (there is no compile- or runtime error if we forget!)  So what can we change about</span></div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="comment"> * APPROACH 2 to avoid those negatives?  As stated in that approach&#39;s description, we could have thread W</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="comment"> * not deal with #m_low_lvl_sock at all; thread W2 would have a separate `Task_engine` handling only</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="comment"> * #m_low_lvl_sock (so no mutex needed).  W2 would do both sends and receives on the socket; and absolutely</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment"> * nothing else (to ensure it&#39;s as efficient as possible at getting datagrams off the kernel buffer, solving</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment"> * the original problem).  Yes, the receiving would have to share time with the sends, but assuming nothing</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="comment"> * else interferes, this feels like not much of a cost (at least compared with all the heavy lifting thread W</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="comment"> * does today anyway).  Each receive would read off all available messages into raw buffers and pass those</span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="comment"> * (sans any copying) on to thread W via `post(W)`.  The other negative, also already mentioned, is that</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span><span class="comment"> * once pacing module (in thread W) decides that a datagram should be sent, the `post(W2)` for the task that</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment"> * would peform the send introduces a delay between the decision and the actual UDP `send()` done by boost.asio.</span></div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment"> * Thinking about it now, it is questionable to me how much of a cost that really is.  Without CPU contention,</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment"> * we can measure it; I expect it to be quite cheap, but I coudl be wrong.  With CPU contention -- which would</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span><span class="comment"> * have to come from many datagrams arriving at the same time -- I&#39;m not sure.  It wouldn&#39;t be overly hard to</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="comment"> * test; basically flood with UDP traffic over loopback and log the delay between W deciding to send datagram</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span><span class="comment"> * and W2 calling `m_low_lvl_sock.async_send_to()` (obviously use #Fine_clock!).  All in all, if we name</span></div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment"> * the dedicated thread approach described here as APPROACH 3, then APPROACH 3 is appealingly simpler than</span></div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment"> * APPROACH 2; and in most ways appears like it&#39;d be at least as efficient and good at solving the original</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span><span class="comment"> * problem as APPROACH 2.  The only danger that worries me is this business with messing up pacing (and no,</span></div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment"> * moving pacing into W2 just endangers the receiving efficiency and introduces thread safety problems and</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment"> * complexity) by having it compete with receiving during incoming-traffic-heavy times.  Ultimately, I&#39;d</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="comment"> * recommend timing this &quot;danger zone&quot; as described a bit earlier (also time delay introduced by `post(W2)`</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="comment"> * without any traffic coming in); and if it looks good, do APPROACH 3.  Otherwise spring for APPROACH 2.</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="comment"> *</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 4:</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="comment"> * It now occurs to me how to solve the main questionable part about APPROACH 3.  If we fear that the reads and</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment"> * writes in thread W2 may compete for CPU, especially the reads delaying timing-sensitive paced writes,</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment"> * then we can eliminate the problem by taking W2&#39;s own util::Task_engine (which would be separate from</span></div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment"> * #m_task_engine) and have two equal threads W2&#39; and W2&#39;&#39; start up and then each call `Task_engine::run()`.</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment"> * Without having to use any strand, this will essentially (as documented in boost.asio&#39;s doc overview)</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment"> * establish a thread pool of 2 threads and then perform the receive and send tasks at random on whichever</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment"> * thread(s) is/are available at a particular time.  Since there&#39;s no strand(s) to worry about, the underlying</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment"> * overhead in boost.asio is probably small, so there&#39;s nothing to fear about efficiency.  In fact, in this</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment"> * case we&#39;ve now created 3 separate threads W, W2&#39;, W2&#39;&#39;, all doing things independently of each other, which</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment"> * is an excellent feature in terms of using multiple cores.  Do note we will now need a mutex and very short</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment"> * critical sections around the calls to `m_low_lvl_sock::async_receive()` and `m_low_lvl_sock::async_send()`,</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span><span class="comment"> * but as noted before this seems extremely unlikely to have any real cost due to the shortess of critical</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span><span class="comment"> * sections in both threads.  If this is APPROACH 4, then I&#39;d say just time how much absolute delay is</span></div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span><span class="comment"> * introduced by a `post(W2&#39;)` or `post(W2&#39;&#39;)` of the async send call compared to directly making such a</span></div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment"> * call on thread W, as is done today.  I suspect it&#39;s small, in which case the action is go for</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment"> * APPROACH 4... finally.</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment"> *</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment"> * @todo Receive UDP datagrams as soon as possible (avoid internal buffer overflow): APPROACH 5 (CO-WINNER!):</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment"> * Actually, the thing I&#39;ve been dismissing in approaches 2-4, which was to combine the pacing logic with the</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment"> * actual `m_low_lvl_sock.async_send()` (like today) but in their own dedicated thread, now seems like the best</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment"> * way to solve the one questionable aspect of APPROACH 4.  So, APPROACH 4, but: Move the pacing stuff into</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment"> * the task queue associated with threads W2&#39; and W2&#39;&#39;.  So then these 2 threads/cores will be available for</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="comment"> * 2 task queues: one for pacing timers + datagram sending over #m_low_lvl_sock (with mutex); the other for</span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span><span class="comment"> * receiving over #m_low_lvl_sock (with same mutex).  Now, the only &quot;delay&quot; is moved to before pacing occurs:</span></div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="comment"> * whatever minimal time cost exists of adding a queue from thread W to thread W2&#39; or W2&#39;&#39; occurs just before</span></div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment"> * the pacing logic, after which chances are the datagram will be placed on a pacing queue anyway and sent</span></div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span><span class="comment"> * off somewhat later; intuitively this is better than the delay occurring between pacing logic and the</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span><span class="comment"> * actual UDP send.  Note, also, that the timing-sensitive pacing logic now gets its own thread/core and should</span></div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span><span class="comment"> * thus work better vs. today in situations when thread W is doing a lot of work.  This is even more logical</span></div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span><span class="comment"> * than APPROACH 4 in that sense; the pacing and sending are concern 1 and get their own thread (essentially;</span></div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span><span class="comment"> * really they get either W2&#39; or W2&#39;&#39; for each given task); the receiving is concern 2 and gets its own thread</span></div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span><span class="comment"> * (same deal); and all the rest is concern 3 and remains in its own thread W (until we can think of ways to</span></div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span><span class="comment"> * split that into concerns; but that is another to-do).  Only one mutex with 2 very small critical sections,</span></div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment"> * as in APPROACH 4, is used.  The only subtlety regarding concurrent data access is in</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment"> * Node::mark_data_packet_sent(), which is called just before `m_low_lvl_sock.async_send()`, and which</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span><span class="comment"> * finalizes certain aspects of Peer_socket::Sent_packet::Sent_when; most notably</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span><span class="comment"> * Peer_socket::Sent_packet::Sent_when::m_sent_time (used in RTT calculation upon ACK receipt later).</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment"> * This is stored in Peer_socket::m_snd_flying_pkts_by_sent_when, which today is not protected by mutex due</span></div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment"> * to only being accessed from thread W; and which is extremely frequently accessed.  So either we protect</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment"> * the latter with a mutex (out of the question: it is too frequently accessed and would quite possibly</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span><span class="comment"> * reduce performance) or something else.  Currently I think Node::mark_data_packet_sent() should just</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span><span class="comment"> * be placed onto #m_task_engine (thread W) via `post()` but perhaps take all or most of the items to</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span><span class="comment"> * update Sent_when with as arguments, so that they (especially `Sent_when::m_sent_time`) could be determined</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span><span class="comment"> * in thread W2&#39; or W2&#39;&#39; but written thread-safely in W.  (There is no way some other thread W task would mess</span></div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span><span class="comment"> * with this area of Peer_socket::m_snd_flying_pkts_by_sent_when before the proposed mark_data_packet_sent()</span></div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span><span class="comment"> * was able to run; thread W had just decided to send that packet over wire in the first place; so there&#39;s no</span></div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span><span class="comment"> * reason to access it until ACK -- much later -- or some kind of socket-wide catastrophe.)  All that put</span></div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span><span class="comment"> * together I dub APPROACH 5.  Thus, APPROACH 1 + APPROACH 5 seems like the best idea of all, distilling all</span></div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment"> * the trade-offs into the the fastest yet close to simplest approach.</span></div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="comment"> *</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="comment"> * @todo More uniform diagnostic logging: There is much diagnostic logging in the</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span><span class="comment"> * implementation (FLOW_ERROR*(), etc.), but some of it lacks useful info like `sock` or `serv` (i.e., the</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span><span class="comment"> * `ostream` representations of Peer_socket and Server_socket objects, which include the UDP/Flow endpoints</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><span class="comment"> * involved in each socket).  The messages that do include these have to do so explicitly.  Provide some</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span><span class="comment"> * macros to automatically insert this info, then convert the code to use the macros in most places.  Note that</span></div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span><span class="comment"> * existing logging is rather exhaustive, so this is not the biggest of deals but would be nice for ease of coding</span></div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span><span class="comment"> * (and detailed logging).</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span><span class="comment"> *</span></div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span><span class="comment"> * @todo It may be desirable to use not boost.asio&#39;s out-of-the-box UDP receive routines but rather extensions</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment"> * capable of some advanced features, such as `recvmsg()` -- which can obtain kernel receipt time stamps and</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment"> * destination IP address via the `cmsg` feature.  This would tie into various other to-dos listed around here.</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="comment"> * There is, as of this writing, also a to-do in the top-level `flow` namespace doc header about bringing some code</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="comment"> * into a new `io` namespace/Flow module; this includes the aforementioned `recvmsg()` wrapper.</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span><span class="comment"> *</span></div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span><span class="comment"> * @todo It may be desirable to further use `recvmmsg()` for UDP input; this allows to read multiple UDP datagrams</span></div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span><span class="comment"> * with one call for performance.</span></div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span><span class="comment"> *</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span><span class="comment"> * @todo By the same token, wrapping `sendmsg()` and `sendmmsg()` may allow for futher perf and feature</span></div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span><span class="comment"> * improvements -- in some ways potentially symmetrically to `recvmsg()` and `recvmmsg()` respectively.</span></div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span><span class="comment"> * However, as of this writing, I (ygoldfel) see this more of an opportunistic &quot;look into it&quot; thing and not something</span></div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span><span class="comment"> * of active value; whereas `recv[m]msg()` bring actual features we actively desire for practical reasons.</span></div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span><span class="comment"> *</span></div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span><span class="comment"> * @todo Send and Receive buffer max sizes:  These are set to some constants right now.  That&#39;s not</span></div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span><span class="comment"> * optimal.  There are two competing factors: throughput and RAM.  If buffer is too small, throughput can</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span><span class="comment"> * suffer in practice, if the Receiver can&#39;t read the data fast enough (there are web pages that show this).</span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span><span class="comment"> * Possibly with today&#39;s CPUs it&#39;s no longer true, but I don&#39;t know.  If buffer is too large and with a lot of</span></div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span><span class="comment"> * users, a LOT of RAM can be eaten up (however note that a server will likely be mostly sending, not</span></div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span><span class="comment"> * receiving, therefore it may need smaller Receive buffers).  Therefore, as in Linux 2.6.17+, the buffer</span></div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span><span class="comment"> * sizes should be adaptively sized.  It may be non-trivial to come up with a good heuristic, but we may be</span></div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span><span class="comment"> * able to copy Linux.  The basic idea would probably be to use some total RAM budget and divide it up among</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span><span class="comment"> * the # of sockets (itself a constant estimate, or adaptive based on the number of sockets at a given time?).</span></div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span><span class="comment"> * Also, buffer size should be determined on the Receive side; the Send side should make its buffer to be of</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span><span class="comment"> * equal size. Until we implement some sensible buffer sizing, it might be a good idea (for demo purposes with</span></div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span><span class="comment"> * few users) to keep the buffers quite large.  However, flow control (receive window) is now implemented and</span></div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span><span class="comment"> * should cope well with momentary Receive buffer exhaustion.</span></div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span><span class="comment"> * Related facts found on the web: In Linux, since a long time ago, Send buffer size is determined by other</span></div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span><span class="comment"> * side&#39;s Receive buffer size (probably sent over in the SYN or SYN-ACK as the receive window).  Also, in</span></div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span><span class="comment"> * older Linuxes, Receive buffer defaults to 128k but can be manually set. Supposedly the default can lead to</span></div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span><span class="comment"> * low throughput in high-speed (gigabit+) situations.  Thus Linux 2.6.17+ apparently made the Receive buffer</span></div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment"> * size adaptive.</span></div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment"> *</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span><span class="comment"> * @todo Drop Acknowledgments:  DCCP, a somewhat similar UDP-based protocol, uses the concept of</span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment"> * Data-Dropped acknowledgments.  If a packet gets to the receiver, but the receiver is forced to drop it (for</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment"> * example, no Receive buffer space; not sure if there are other reasons in Flow protocol), then the sender will only</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="comment"> * find out about this by inferring the drop via Drop Timeout or getting acknowledgments for later data.  That</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment"> * may take a while, and since receiver-side drops can be quite large, it would be more constructive for the</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment"> * receive to send an un-ACK of sorts: a Data-Dropped packet informing the sender that specific data were</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment"> * dropped.  The sender can then update his congestion state (and retransmit if we enable that).  See RFC 4340</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span><span class="comment"> * and 4341.</span></div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span><span class="comment"> *</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span><span class="comment"> * @todo Add extra-thread-safe convention for setting options: We can provide a thread-safe (against other user</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span><span class="comment"> * threads doing the same thing) macro to set a given option.  set_options() has a documented, albeit in</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span><span class="comment"> * practice not usually truly problematic, thread safety flaw if one calls options(), modifies the result,</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span><span class="comment"> * then calls set_options().  Since another thread may modify the Node&#39;s options between the two calls, the</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span><span class="comment"> * latter call may unintentionally revert an option&#39;s value.  Macro would take an option &quot;name&quot; (identifier</span></div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span><span class="comment"> * for the Node_options member), a Node, and a target value for the option and would work together with a</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span><span class="comment"> * helper method template to obtain the necessary lock, make the assignment to the internal option, and give</span></div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span><span class="comment"> * up the lock.  The implementation would probably require Node to expose its internal stored Node_options</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="comment"> * for the benefit of this macro only.  Anyway, this feature is not super-important, as long as the user is</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span><span class="comment"> * aware that modifying options from multiple threads simultaneously may result in incorrect settings being</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span><span class="comment"> * applied.</span></div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span><span class="comment"> *</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span><span class="comment"> * @todo The preceding to-do regarding Node_options applies to Peer_socket_options stored in Peer_socket in</span></div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span><span class="comment"> * in an analogous way.</span></div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span><span class="comment"> *</span></div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span><span class="comment"> * @todo Consider removing Flow ports and even Server_socket:</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span><span class="comment"> * As explained above, we add the concept of a large set of available Flow ports within each</span></div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span><span class="comment"> * Node, and each Node itself has a UDP port all to itself.  So, for example, I could bind a Node to UDP</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span><span class="comment"> * port 1010, and within that listen() on Flow ports 1010 (unrelated to UDP port 1010!) and 1011.  In</span></div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span><span class="comment"> * retrospect, though, is that complexity necessary?  We could save quite a few lines of code, particularly in</span></div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span><span class="comment"> * the implementation (class Port_space, for example) and the protocol (extra bytes for Flow source and target</span></div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span><span class="comment"> * ports, for example). (They&#39;re fun and pretty lines, but the absence of lines is arguably even prettier</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span><span class="comment"> * albeit less fun.  On the other hand, bugs aren&#39;t fun, and more code implies a higher probability of bugs,</span></div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span><span class="comment"> * maintenance errors, etc.)  The interface would also be a bit simpler; and not just due to fewer items in</span></div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span><span class="comment"> * Remote_endpoint (which would in fact reduce to util::Udp_endpoint and cease to exist).  Consider Server_socket;</span></div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span><span class="comment"> * currently listen() takes a #flow_port_t argument and returns a Server_socket which is listening; calling</span></div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span><span class="comment"> * accept() (etc.) on the latter yields Peer_socket, as the other side connects.  Without Flow ports, there is</span></div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span><span class="comment"> * no argument to listen(); in fact, Server_socket itself is not strictly necessary and could be folded into</span></div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span><span class="comment"> * Node, with listen() becoming essentially something that turns on the &quot;are we listening?&quot; Boolean state,</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span><span class="comment"> * while stop_listening() would turn it off (instead of something like `Server_socket::close()`).  (Important</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span><span class="comment"> * note: That was not an endorsement of removing Server_socket.  Arguably it is still a nice abstraction.</span></div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span><span class="comment"> * Removing it would certainly remove some boiler-plate machinery to do with Server_socket&#39;s life cycle, on</span></div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span><span class="comment"> * the other hand.  Perhaps it&#39;s best to take a two-step appraoch; remove Flow ports first; then after a long</span></div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span><span class="comment"> * time, assuming it becomes clear that nothing like them is going to come back, remove Server_socket as</span></div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span><span class="comment"> * well.)  A key question is, of course what would we lose?  At first glance, Flow port allows multiple</span></div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span><span class="comment"> * connections on a single UDP-port-taking Flow server, including multiple connections from one client (e.g.,</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span><span class="comment"> * with differing connection parameters such as reliability levels among the different connections, or</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span><span class="comment"> * &quot;channels&quot;)... but actually that&#39;d still work without Flow ports, assuming the &quot;one client&#39;s&quot; multiple</span></div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span><span class="comment"> * connections can bind to different (presumably ephemeral) UDP ports; since the tuple (source host, source</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span><span class="comment"> * UDP port) is still enough to distinguish from the 2+ &quot;channels&quot; of the same &quot;client&quot; connecting to the one</span></div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span><span class="comment"> * Flow Node (vs. today&#39;s tuple: source host, source UDP port, source Flow port, destination Flow port; see</span></div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span><span class="comment"> * `struct` Socket_id). However, without Flow ports, it is not possible for one Node to connect to another</span></div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span><span class="comment"> * Node twice, as each Node by definition is on one port.  Is this important?  Maybe, maybe not; for NAT</span></div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span><span class="comment"> * purposes it can be important to use only 1 port; but that typically applies only to the server, while the</span></div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span><span class="comment"> * client can send packets from anywhere.  However, gaming applications can be very demanding and for the most</span></div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span><span class="comment"> * restrictive NAT types might desire only a single port used on both sides.  So whether to remove Flow ports</span></div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span><span class="comment"> * is somewhat questionable, now that they exist; but arguably they didn&#39;t need to be added in the first</span></div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span><span class="comment"> * place, until they were truly needed.  I&#39;d probably leave them alone, since they do exist.</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span><span class="comment"> *</span></div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span><span class="comment"> * @todo Multi-core/multi-threading: The existing implementation already has a nice multi-threaded property,</span></div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span><span class="comment"> * namely that each Node (object that binds to a single UDP endpoint/port) is entirely independent of any other</span></div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span><span class="comment"> * such object -- they have entirely separate data, and each one does all its work on a separate thread.</span></div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span><span class="comment"> * So to make use of multiple cores/processors, one can set up multiple Node objects.  (Obviously this only makes</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span><span class="comment"> * sense for apps where using multiple ports is acceptable or even desired.  E.g., a server could listen</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span><span class="comment"> * on N different UDP ports, where N=# of cores.)  However, it would be nice for a single Node to be as</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span><span class="comment"> * multi-core/processor-friendly as possible.  This is partially addressed by the &quot;Dedicated thread to receive</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span><span class="comment"> * UDP datagrams ASAP&quot; to-do item elsewhere.  We could go further.   boost.asio lets one easily go from</span></div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span><span class="comment"> * 1 thread to multiple threads by simply starting more worker threads like W (W1, W2, ...) and executing</span></div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span><span class="comment"> * `m_task_engine::run()` in each one -- note that #m_task_engine is shared (sans lock).  Then subsequent</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span><span class="comment"> * handlers (timer-fired handlers, ack-received handlers, data-received handlers, and many more) would be</span></div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span><span class="comment"> * assigned evenly to available threads currently executing run().  However, then all data these handlers</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment"> * access would need to be protected by a mutex or mutexes, which would be a significant increase in</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment"> * complexity and maintenance headaches compared to existing code, which features mutexes for data accessed</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span><span class="comment"> * both by W and the user thread(s) U -- which excludes most Node, Server_socket, Peer_socket state --</span></div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span><span class="comment"> * essentially the user-visible &quot;state&quot; enums, and the Receive and Send buffers; but hugely complex things</span></div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span><span class="comment"> * like the scoreboards, etc. etc., needed no mutex protection, but with this change they would need it.</span></div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span><span class="comment"> * Actually, if the implementation essentially uses one mutex M, and every handler locks it for the entirety</span></div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span><span class="comment"> * of its execution, then one isn&#39;t really making use of multi-cores/etc. anyway.  One could make use of</span></div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span><span class="comment"> * boost.asio &quot;strands&quot; to avoid the need for the mutex -- just wrap every handler in a shared strand S,</span></div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span><span class="comment"> * and no locking is needed; boost.asio will never execute two handlers simultaneously in different threads.</span></div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span><span class="comment"> * While this would arguably make the code simpler, but in terms of performance it wouldn&#39;t make any</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span><span class="comment"> * difference anyway, as it is functionally equivalent to the lock-M-around-every-operation solution (in</span></div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span><span class="comment"> * fact, internally, it might even amount to exactly that anyway).  So that&#39;s probably not worth it.</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="comment"> * We need to have more mutexes or strands, based on some other criterion/criteria.  After a datagram is demuxed,</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span><span class="comment"> * vast majority of work is done on a particular socket independently of all others.  Therefore we could</span></div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="comment"> * add a mutex (or use an equivalent) into the socket object and then lock on that mutex.  Multiple</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span><span class="comment"> * threads could then concurrently handle multiple sockets.  However, for this to be used, one would have to</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span><span class="comment"> * use a single Node (UDP endpoint) with multiple sockets at the same time.  Without any changes at all, one can</span></div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span><span class="comment"> * get the same concurrency by instead setting up multiple Node objects.  Other than a bit of lost syntactic sugar</span></div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span><span class="comment"> * (arguably) -- multiple Node objects needed, each one having to initialize with its own set of options,</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span><span class="comment"> * for example -- this is particularly cost-free on the client side, as each Node can just use its own ephemeral</span></div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span><span class="comment"> * UDP port.  On the server side the network architecture has to allow for multiple non-ephemeral ports, and</span></div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span><span class="comment"> * the client must know to (perhaps randomly) connect to one of N UDP ports/endpoints on the server, which is</span></div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span><span class="comment"> * more restrictive than on the client.  So perhaps there are some reasons to add the per-socket concurrency -- but</span></div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="comment"> * I would not put a high priority on it.  IMPORTANT UPDATE: Long after the preceding text was written, flow::async</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="comment"> * Flow module was created containing flow::async::Concurrent_task_loop interface.  That looks at the general</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span><span class="comment"> * problem of multi-tasking thread pools and what&#39;s the user-friendliest-yet-most-powerful way of doing it.</span></div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span><span class="comment"> * While the preceding discussion in this to-do has been left unchanged, one must first familiarize self with</span></div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span><span class="comment"> * flow::async; and *then* read the above, both because some of those older ideas might need reevaluation; and because</span></div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span><span class="comment"> * some of those ideas may have been implemented by flow::async and are now available easily.</span></div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span><span class="comment"> *</span></div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span><span class="comment"> * @todo In Node::low_lvl_packet_sent(), the UDP `async_send()` handler, there is an inline to-do about specially</span></div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span><span class="comment"> * treating the corner case of the `would_block` and `try_again` boost.asio errors being reported (a/k/a POSIX</span></div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span><span class="comment"> * `EAGAIN`/`EWOULDBLOCK`).  Please see that inline comment for details.</span></div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span><span class="comment"> *</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment"> * @todo Class Node `private` section is very large.  It&#39;s so large that the implementations of the methods therein</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span><span class="comment"> * are split up among different files such as `flow_peer_socket.cpp`, `flow_event_set.cpp`, `flow_low_lvl_io.cpp`, etc.</span></div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span><span class="comment"> * Consider the following scheme to both better express this separation as well as enforce which of a given method</span></div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span><span class="comment"> * group&#39;s method(s) are meant to be called by outside code vs. being helpers thereof: Introduce `static`-method-only</span></div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span><span class="comment"> * inner classes (and, conceivably, even classes within those classes) to enforce this grouping (`public` methods</span></div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span><span class="comment"> * and `private` methods enforcing what is a &quot;public&quot; helper vs. a helper&#39;s helper).</span></div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span><span class="comment"> *</span></div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span><span class="comment"> * @todo We are now on Boost 1.75; the use of asio&#39;s `null_buffers` semantics is deprecated and should be changed to</span></div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span><span class="comment"> * the replacement mechanism suggested in Boost docs -- the `async_wait()` method.</span></div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span><span class="comment"> *</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment"> * @todo Make use of flow::async::Concurrent_task_loop or flow::async::Single_thread_task_loop, instead of manually</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment"> * setting up a thread and util::Task_engine, for #m_worker.  I, Yuri, wrote the constructor, worker_run(), destructor,</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment"> * and related setup/teardown code as my very first boost.asio activity ever.  It&#39;s solid, but flow::async just makes</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span><span class="comment"> * it easier and more elegant to read/maintain; plus this would increase Flow-wide consistency.  It would almost</span></div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment"> * certainly reduce the number of methods and, even nicely, state (such as #m_event_loop_ready).</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span><span class="comment"> *</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment"> * Misc. topic: Doxygen markup within a Doxygen command</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment"> * ----------------------------------------------------</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span><span class="comment"> * This section may seem random: Indeed, it is the meat of a similarly named (&quot;Doxygen markup,&quot; etc.) subsection of</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span><span class="comment"> * the doc header on the very-general namespace ::flow.  As noted in that subsection, this Node class is a more</span></div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span><span class="comment"> * convenient place to explain this, because it is a large class with many examples available.  Without further ado:</span></div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span><span class="comment"> *</span></div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span><span class="comment"> * ::flow doc header discusses which items should be accompanied by Doxygen comment snippets.  More specifically, each</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span><span class="comment"> * item is accompanied by a Doxygen &quot;command&quot;.  `&quot;@param param_name Explain parameter here.&quot;`, for example, documents</span></div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span><span class="comment"> * the parameter `param_name` with the text following that.  (Some commands are implicit; namely without</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span><span class="comment"> * an explicit `&quot;@brief&quot;`, the first sentence is the brief description of the class/function/whatever.)</span></div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span><span class="comment"> *</span></div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span><span class="comment"> * However, all that doesn&#39;t talk about formatting the *insides* of paragraphs in these commands.  Essentially</span></div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span><span class="comment"> * we are saying just use English.  However, Doxygen uses certain markup language conventions when interpreting</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span><span class="comment"> * those paragraphs.  For example `backticks` will turn the thing inside the ticks into an inline code snippet,</span></div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span><span class="comment"> * in fixed-width font.  There are a few things to watch out for with this:</span></div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span><span class="comment"> *</span></div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span><span class="comment"> *   - Don&#39;t accidentally enable markup when you don&#39;t mean to.  E.g., an * asterisk as the first character</span></div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span><span class="comment"> *     in a paragraph will cause a bullet point to appear.  Also, sometimes you do want to</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span><span class="comment"> *     use some character for semantical reason X which Doxygen shares with you, but automatic markup</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span><span class="comment"> *     handling might make it come out a little wrong.  Just learn these through practice</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span><span class="comment"> *     and check over the generated web page(s) before checking in the code.</span></div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span><span class="comment"> *   - DO use markup within reason for certain COMMON items.  Do not overdo it: mostly it should be things</span></div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span><span class="comment"> *     you&#39;re keen to do even if there were NO Doxygen or Javadoc involved.  Bullet point lists are an example.</span></div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span><span class="comment"> *     Basically:  If you were going to do something anyway, why not have it come out nicely in the doc page(s)?</span></div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span><span class="comment"> *   - Make use of auto-linking (a/k/a automatic liwnk generation) liberally.  This is when Doxygen sees a certain</span></div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span><span class="comment"> *     pattern within a Doxygen comment and understands it a reference to some other object, like a class or</span></div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span><span class="comment"> *     method; so in the output this will come out as a link to that thing.  The nice thing is that, usually,</span></div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span><span class="comment"> *     within raw code it looks fine/normal; AND the generated page has the convenient linking functionality.</span></div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span><span class="comment"> *     However, if enabling linking in a certain case is too tedious, feel free to not.</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span><span class="comment"> *</span></div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span><span class="comment"> * That said, I will now list all of the pieces of markup that are allowed within comments inside Flow code.</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span><span class="comment"> * Try not to add to this list without a very good reason.  Simplicity is a virtue.</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span><span class="comment"> *</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span><span class="comment"> *  - Bullet points: Just a dash after one indent level: `&quot;  - Item text.&quot;`.  Nesting allowed.</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment"> *    - Numbered points: just type out the numbers explicitly instead of auto-numbering: `&quot; 2. Item text.&quot;`; not</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span><span class="comment"> *      `&quot;  -# Item text.&quot;`.  Yes, it leaves the numbering to you, but more importantly the raw comment remains</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span><span class="comment"> *      readable, and you can refer to the numbers (e.g., &quot;according to the condition in item 3&quot; makes more sense</span></div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span><span class="comment"> *      when you can see a `3.` nearby).</span></div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span><span class="comment"> *  - Emphasis: Just one asterisk before and after the emphasized stuff: *word*, *multiple words*.  No &quot;_underscores_&quot;</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span><span class="comment"> *    please.  In general try to avoid too much emphasis, as asterisks are common characters and can confuse</span></div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span><span class="comment"> *    Doxygen.  Plus, you shouldn&#39;t need to emphasize stuff THAT much.  Plus, feel free to use CAPITALS to emphasize</span></div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span><span class="comment"> *    instead.</span></div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span><span class="comment"> *  - Inline code snippets: Backticks.  `single_word`, `an_expression != other_expression * 2`.  Definitely use</span></div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span><span class="comment"> *    this liberally: it helps readability of BOTH raw code and looks delightful in the generated web page(s).</span></div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span><span class="comment"> *    However, note explanation below regarding how this relates to auto-linking.</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span><span class="comment"> *    - Syntax-highlighted code spans: Use three tildes `&quot;~~~&quot;` to begin and end a code snippet.  This MUST be</span></div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span><span class="comment"> *      used for multi-line code snippets; and CAN be used instead of `backticks` for single-line code snippets.</span></div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span><span class="comment"> *      The output will be a separate paragraph, just like the raw code should be.  More precisely, the tildes</span></div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span><span class="comment"> *      and code should follow a single absolute indentation level:</span></div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span><span class="comment"> *</span></div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span><span class="comment"> *   if (some_condition) // Generated output will also be syntax-highlighted.</span></div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span><span class="comment"> *   {</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span><span class="comment"> *     obj.call_it(arg1, &quot;quote&quot;);</span></div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span><span class="comment"> *     return false;</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span><span class="comment"> *   }</span></div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span><span class="comment"> *   ~~~</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span><span class="comment"> *</span></div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span><span class="comment"> *  - Large heading in a long doc header: Use the format seen in this comment itself: Words, underlined by a</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span><span class="comment"> *    row of dashes (&quot;----&quot;, etc.) on the next line.  This results in a fairly large-fonted title.</span></div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span><span class="comment"> *  - Small heading is a long doc header: IF AND ONLY IF you need a sub-heading under a large heading</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span><span class="comment"> *    (which would probably be in only quite long doc headers indeed), use the ### format.  Again use the</span></div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment"> *    format seen in this very doc header.  This results in a slightly large-fonted title (pretty close to</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span><span class="comment"> *    normal).</span></div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span><span class="comment"> *    - Avoid any other levels of heading.  At that point things have become too complex.</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span><span class="comment"> *  - Escape from Doxygen formatting: To ensure Doxygen interprets a bunch of characters literally, when you</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span><span class="comment"> *    know there is danger of it applying unwanted formatting, surround it in quotes.  The quotes will</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span><span class="comment"> *    be included in the output just like in the raw code; but anything inside quotes will be output verbatim</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span><span class="comment"> *    even if full of Doxygen markup or commands.  For example, if I don&#39;t want a to-do item to begin in</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span><span class="comment"> *    the middle of this paragraph, but I do want to refer to how a to-do is declared is Doxygen comments,</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span><span class="comment"> *    I will surround it in quotes: To declare a to-do, use the `&quot;@todo&quot;` command.  Note that in that example</span></div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span><span class="comment"> *    I put `backticks` around the text to format the whole thing a certain way; any formatting already in</span></div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span><span class="comment"> *    effect will continue through the &quot;quoted&quot; text; but no formatting inside the &quot;quotes&quot; will go in effect.</span></div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span><span class="comment"> *    Plus, it looks appropriate in raw code.  Best of all worlds.</span></div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span><span class="comment"> *</span></div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span><span class="comment"> * The most tricky yet powerful technique to learn here is the interplay between auto-linking and `inline code</span></div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span><span class="comment"> * snippets`.  Before discussing that in some detail, note the auto-linking which is allowed in this source</span></div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span><span class="comment"> * code:</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span><span class="comment"> *</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span><span class="comment"> *   - Class/`struct`/union names are auto-linked: for example, just Peer_socket.  That&#39;s because every</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span><span class="comment"> *     class/`struct`/union for us starts with a Capital letter.  Easy!</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span><span class="comment"> *   - A method local to the class/`struct` being documented, like running() in this class Node which we are</span></div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span><span class="comment"> *     documenting right now, is auto-linked as written.</span></div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span><span class="comment"> *   - ANY member explicitly specified as belonging to a class/`struct`/union or namespace is</span></div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span><span class="comment"> *     auto-linked as written.  It can be a member function, variable, alias, nested class, or *anything* else.</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span><span class="comment"> *     The presence of `&quot;::&quot;` will auto-link whatever it is.  Note this is a very powerful auto-linking technique;</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span><span class="comment"> *     the vast majority of things are members of something, even if&#39;s merely a namespace, so if you absolutely must</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span><span class="comment"> *     auto-link something, there is always at least one straightforward way: a *fully or partially qualified name*.</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span><span class="comment"> *     It will be simple/readable as raw source and equally simple/readable AND linked in the doc output.  The only</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span><span class="comment"> *     *possible* (not really probable, but it certainly happens) down-side is it can be too verbose.</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span><span class="comment"> *     - Example: alias-type: Drop_timer::timer_wait_id_t; method: Port_space::return_port().</span></div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span><span class="comment"> *     - Macros are not members of anything and thus cannot be auto-linked by qualifying them.  However, read below</span></div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span><span class="comment"> *       on how to auto-link them too.</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span><span class="comment"> *   - A free (non-member) function or functional macro will generally auto-link, even if it&#39;s in some other namespace.</span></div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span><span class="comment"> *     - This can result in name collisions, if some function `f()` is in two namespaces meaning two entirely</span></div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span><span class="comment"> *       different things.  And not just functions but anything else, like classes, can thus collide.</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span><span class="comment"> *       That is, after all, why namespaces exist!  Just be careful and qualify things with namespace paths</span></div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span><span class="comment"> *       when needed (or even just for clarity).</span></div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span><span class="comment"> *   - For non-functions/methods: Things like variables/constants, type aliases, `enum` values will not auto-link</span></div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span><span class="comment"> *     if seen &quot;naked.&quot;  For example S_PORT_ANY is, to Doxygen, just a word.  We use either `&quot;#&quot;` or `&quot;::&quot;` to force</span></div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span><span class="comment"> *     auto-linking.  Here is how to decide which one to use:</span></div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span><span class="comment"> *     - `&quot;#id&quot;`: To refer to a *member* of anything (compound type, namespace) member named `id`,</span></div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span><span class="comment"> *       such that the *currently documented item* is also a member of that [anything] -- either at the same depth</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span><span class="comment"> *       (e.g., in the same class) or deeper (e.g., `id` is in namespace `flow`, while we are in namespace</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span><span class="comment"> *       `flow::net_flow`, or in class `flow::Some_class`, or both -- `flow::net_flow::Some_class`).</span></div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span><span class="comment"> *       Example: #Udp_socket (member alias), #S_NUM_PORTS (member constant), #m_low_lvl_sock (member variable).</span></div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span><span class="comment"> *     - `&quot;::id&quot;`: To refer to an item in the global namespace.  Almost always, this will be an (outer) namespace.</span></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span><span class="comment"> *       Global-namespace members that are not themselves namespaces are strongly discouraged elsewhere.</span></div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span><span class="comment"> *       Example: ::flow (namespace).</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span><span class="comment"> *   - A functional macro is formatted the same as a free function in global namespace: e.g., FLOW_LOG_WARNING().</span></div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span><span class="comment"> *   - If a non-functional macro needs to be documented (VERY rare or non-existent given our coding style), use</span></div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span><span class="comment"> *     this special format: `&quot;#MACRO_NAME&quot;`.  `&quot;::&quot;` is inappropriate, since a macro does not belong to a namespace</span></div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span><span class="comment"> *     (global or otherwise), and that would look confusing in raw code.</span></div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span><span class="comment"> *</span></div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="comment"> * Now finally here are the guidelines about what to use: `backticks`, an auto-linked symbol, or both.</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="comment"> * Suppose there is some comment *snippet* X that you are considering how to format.</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span><span class="comment"> *</span></div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="comment"> *   - If X is just a piece of English language and not referring to or quoting code per se, then do not format</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span><span class="comment"> *     it.  Type it verbatim: &quot;The socket&#39;s state is ESTABLISHED here.&quot;  Even though ESTABLISHED may be thought</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span><span class="comment"> *     of as code, here it&#39;s referring more to a concept (the state &quot;ESTABLISHED&quot;) rather than code snippet.</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span><span class="comment"> *     `S_ESTABLISHED` is a different story, on the other hand, and that one you must either backtick (as I just</span></div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span><span class="comment"> *     did there) or auto-link; read on for guidelines on that.</span></div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span><span class="comment"> *   - If the *entirety* of X is an identifier:</span></div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span><span class="comment"> *     - Auto-link it, WITHOUT backticks, if to auto-link it you would just write X verbatim anyway.</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span><span class="comment"> *       For example, mentioning Peer_socket just like that will auto-link it.  So, that&#39;s great.  Do NOT</span></div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span><span class="comment"> *       add backticks, as that increases code verbosity and adds very little (making the auto-linked `Peer_socket`</span></div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="comment"> *       also use a fixed-width font; meh).</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span><span class="comment"> *     - Auto-link it, WITHOUT backticks, if you would like the convenience of it being auto-linked in the output.</span></div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span><span class="comment"> *       - Do NOT auto-link it, but DO add `backticks`, if you do not need the convenience of the auto-linked output.</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span><span class="comment"> *         Backticks are easy: auto-linking can be a little tricky/verbose.  So in that case just `backtick` it</span></div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span><span class="comment"> *         for readable raw source AND pretty output; without worrying about subtleties of proper auto-linking.</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span><span class="comment"> *   - If X consists of some identifiers but also contains non-identifiers:</span></div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span><span class="comment"> *     - The non-code parts should be verbatim.</span></div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span><span class="comment"> *     - ALL code parts should be in `backticks`.</span></div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span><span class="comment"> *     - IF you want the convenience of some parts of the output being auto-linked, auto-link those parts.</span></div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span><span class="comment"> *       - IF you&#39;d prefer shorter and clearer raw code, then don&#39;t auto-link where doing so would require extra</span></div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span><span class="comment"> *         raw code characters.</span></div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span><span class="comment"> *     - Example: Suppose X is: &quot;The allowed range is [S_FIRST_SERVICE_PORT + 1, S_FIRST_EPHEMERAL_PORT + 2).&quot;</span></div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span><span class="comment"> *       Variant 1 will auto-link but a bit longer and less readable as raw code.  Variant 2 will forego auto-linking</span></div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span><span class="comment"> *       but is short and readable as raw code.</span></div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span><span class="comment"> *       - *Variant 1*: The allowed range is [`#S_FIRST_SERVICE_PORT + 1`, `#S_FIRST_EPHEMERAL_PORT + 2`).</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span><span class="comment"> *       - *Variant 2*: The allowed range is [`S_FIRST_SERVICE_PORT + 1`, `S_FIRST_EPHEMERAL_PORT + 2`).</span></div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span><span class="comment"> *     - Example: Suppose X is: &quot;The condition holds if sock-&gt;m_local_port != 2223.&quot;  Variant 1 is brief and readable.</span></div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span><span class="comment"> *       Variant 2 is readable enough but much longer.  However, it will very conveniently auto-link to</span></div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span><span class="comment"> *       that obscure data member for the web page reader&#39;s pleasure, the convenience of which shouldn&#39;t be dismissed.</span></div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span><span class="comment"> *       - *Variant 1*: The condition holds if `sock-&gt;m_local_port != 2223`.</span></div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span><span class="comment"> *       - *Variant 2*: The condition holds if `Peer_socket::m_local_port != 2223` (for `sock`).</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span><span class="comment"> */</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html">  933</a></span><span class="keyword">class </span><a class="code hl_class" href="classflow_1_1net__flow_1_1Node.html">Node</a> :</div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span>  <span class="keyword">public</span> <a class="code hl_class" href="classflow_1_1util_1_1Null__interface.html">util::Null_interface</a>,</div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span>  <span class="keyword">public</span> <a class="code hl_class" href="classflow_1_1log_1_1Log__context.html">log::Log_context</a>,</div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span>  <span class="keyword">private</span> boost::noncopyable</div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span>{</div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span>  <span class="comment">// Constants.</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span><span class="comment"></span> </div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span><span class="comment">  /// Total number of Flow ports in the port space, including #S_PORT_ANY.</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">  942</a></span><span class="comment"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">S_NUM_PORTS</a>;</div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span><span class="comment"></span> </div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span><span class="comment">  /// Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">  945</a></span><span class="comment"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">S_NUM_SERVICE_PORTS</a>;</div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span><span class="comment"></span> </div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span><span class="comment">   * Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with</span></div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span><span class="comment">   * `Node::listen(S_PORT_ANY)` or Node::connect()).</span></div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span><span class="comment">   */</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">  951</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">S_NUM_EPHEMERAL_PORTS</a>;</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span><span class="comment"></span> </div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span><span class="comment">   * The port number of the lowest service port, making the range of service ports</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span><span class="comment">   * [#S_FIRST_SERVICE_PORT, #S_FIRST_SERVICE_PORT + #S_NUM_SERVICE_PORTS - 1].</span></div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span><span class="comment">   */</span></div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">  957</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&amp; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">S_FIRST_SERVICE_PORT</a>;</div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span><span class="comment"></span> </div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span><span class="comment">   * The port number of the lowest ephemeral Flow port, making the range of ephemeral ports</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span><span class="comment">   * [#S_FIRST_EPHEMERAL_PORT, #S_FIRST_EPHEMERAL_PORT + #S_NUM_EPHEMERAL_PORTS - 1].</span></div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span><span class="comment">   */</span></div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">  963</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&amp; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">S_FIRST_EPHEMERAL_PORT</a>;</div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span> </div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>  <span class="comment">// Constructors/destructor.</span></div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span><span class="comment"></span> </div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span><span class="comment">   * Constructs Node.</span></div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span><span class="comment">   * Post-condition: Node ready for arbitrary use.  (Internally this includes asynchronously</span></div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span><span class="comment">   * waiting for any incoming UDP packets on the given endpoint.)</span></div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span><span class="comment">   *</span></div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span><span class="comment">   * Does not block.  After exiting this constructor, running() can be used to determine whether</span></div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span><span class="comment">   * Node initialized or failed to do so; or one can get this from `*err_code`.</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span><span class="comment">   *</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span><span class="comment">   * ### Potential shared use of `Logger *logger` ###</span></div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span><span class="comment">   * All logging, both in this thread (from which the constructor executes) and any potential internally</span></div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span><span class="comment">   * spawned threads, by this Node and all objects created through it (directly</span></div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span><span class="comment">   * or otherwise) will be through this Logger.  `*logger` may have been used or not used</span></div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span><span class="comment">   * for any purpose whatsoever prior to this constructor call.  However, from now on,</span></div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span><span class="comment">   * Node will assume that `*logger` will be in exclusive use by this Node and no other code until</span></div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span><span class="comment">   * destruction.  It is strongly recommended that all code refrains from further use of</span></div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span><span class="comment">   * `*logger` until the destructor ~Node() exits.  Otherwise, quality of this Node&#39;s logging (until destruction)</span></div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span><span class="comment">   * may be lowered in undefined fashion except for the following formal guarantees: the output will not</span></div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span><span class="comment">   * be corrupted from unsafe concurrent logging; and the current thread&#39;s nickname (for logging purposes only) will</span></div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span><span class="comment">   * not be changed at any point.  Less formally, interleaved or concurrent use of the same Logger might</span></div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span><span class="comment">   * result in such things as formatters from Node log calls affecting output of your log calls or vice versa.</span></div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span><span class="comment">   * Just don&#39;t, and it&#39;ll look good.</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span><span class="comment">   *</span></div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span><span class="comment">   * @param low_lvl_endpoint</span></div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span><span class="comment">   *        The UDP endpoint (IP address and UDP port) which will be used for receiving incoming and</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span><span class="comment">   *        sending outgoing Flow traffic in this Node.</span></div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span><span class="comment">   *        E.g.: `Udp_endpoint(Ip_address_v4::any(), 1234)` // UDP port 1234 on all IPv4 interfaces.</span></div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span><span class="comment">   * @param logger</span></div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span><span class="comment">   *        The Logger implementation through which all logging from this Node will run.</span></div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span><span class="comment">   *        See notes on logger ownership above.</span></div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span><span class="comment">   * @param net_env_sim</span></div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span><span class="comment">   *        Network environment simulator to use to simulate (fake) external network conditions</span></div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span><span class="comment">   *        inside the code, e.g., for testing.  If 0, no such simulation will occur.  Otherwise the</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span><span class="comment">   *        code will add conditions such as loss and latency (in addition to any present naturally)</span></div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span><span class="comment">   *        and will take ownership of the the passed in pointer (meaning, we will `delete` as we see fit;</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span><span class="comment">   *        and you must never do so from now on).</span></div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span><span class="comment">   *        error::Code::S_NODE_NOT_RUNNING (Node failed to initialize),</span></div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span><span class="comment">   *        error::Code::S_OPTION_CHECK_FAILED.</span></div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span><span class="comment">   *        The low-level per-Node options to use.  The default uses reasonable values that</span></div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span><span class="comment">   *        normally need not be changed.  No reference to opts is saved; it is only copied.</span></div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span><span class="comment">   *        See also Node::set_options(), Node::options(), Node::listen(), Node::connect(),</span></div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span><span class="comment">   *        Peer_socket::set_options(), Peer_socket::options().</span></div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span><span class="comment">   */</span></div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">Node</a>(<a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_endpoint,</div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span>                <a class="code hl_class" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a>* net_env_sim = 0, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span>                <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&amp; opts = <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>());</div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span><span class="comment"></span> </div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span><span class="comment">   * Destroys Node.  Closes all Peer_socket objects as if by `sock-&gt;close_abruptly()`.  Then closes all</span></div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span><span class="comment">   * Server_socket objects  Then closes all Event_set objects as if by `event_set-&gt;close()`.</span></div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span><span class="comment">   * @todo Server_socket objects closed as if by what?</span></div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span><span class="comment">   *</span></div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span><span class="comment">   * Frees all resources except the objects still shared by `shared_ptr&lt;&gt;`s returned to the Node</span></div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span><span class="comment">   * user.  All `shared_ptr&lt;&gt;` instances inside Node sharing the latter objects are, however,</span></div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span><span class="comment">   * eliminated.  Therefore any such object will be deleted the moment the user also eliminates all</span></div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span><span class="comment">   * her `shared_ptr&lt;&gt;` instances sharing that same object; any object for which that is already the</span></div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span><span class="comment">   * case is deleted immediately.</span></div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span><span class="comment">   *</span></div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"> 1027</span><span class="comment">   * Does not block.</span></div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span><span class="comment">   *</span></div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span><span class="comment">   * Note: as a corollary of the fact this acts as if `{Peer|Server_}socket::close_abruptly()` and</span></div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span><span class="comment">   * Event_set::close(), in that order, were called, all event waits on the closed</span></div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span><span class="comment">   * sockets (`sync_send()`, `sync_receive()`, `sync_accept()`, Event_set::sync_wait(),</span></div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span><span class="comment">   * Event_set::async_wait()) will execute their on-event behavior (`sync_send()` return,</span></div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span><span class="comment">   * `sync_receive()` return, `sync_accept()` return, `sync_wait()` return and invoke handler, respectively).</span></div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span><span class="comment">   * Since Event_set::close() is executed soon after the sockets close, those Event_set objects are</span></div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span><span class="comment">   * cleared.  Therefore, the user on-event behavior handling may find that, despite a given</span></div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span><span class="comment">   * event firing, the containing Event_set is empty; or they may win the race and see an Event_set</span></div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span><span class="comment">   * with a bunch of `S_CLOSED` sockets.  Either way, no work is possible on these sockets.</span></div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span><span class="comment">   *</span></div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span><span class="comment">   * Rationale for previous paragraph: We want to wake up any threads or event loops waiting on</span></div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span><span class="comment">   * these sockets, so they don&#39;t sit around while the underlying Node is long since destroyed.  On</span></div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"> 1041</span><span class="comment">   * the other hand, we want to free any resources we own (including socket handles inside</span></div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"> 1042</span><span class="comment">   * Event_set).  This solution satisfies both desires.  It does add a bit of non-determinism</span></div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"> 1043</span><span class="comment">   * (easily handled by the user: any socket in the Event_set, even if user wins the race, will be</span></div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"> 1044</span><span class="comment">   * `S_CLOSED` anyway).  However it introduces no actual thread safety problems (corruption, etc.).</span></div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"> 1045</span><span class="comment">   *</span></div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span><span class="comment">   * @todo Provide another method to shut down everything gracefully?</span></div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"> 1047</span><span class="comment">   */</span></div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span>  <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">~Node</a>() <span class="keyword">override</span>;</div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span> </div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span><span class="comment"></span> </div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span><span class="comment">   * Returns `true` if and only if the Node is operating.  If not, all attempts to use this object or</span></div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span><span class="comment">   * any objects generated by this object (Peer_socket::Ptr, etc.) will result in error.</span></div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span><span class="comment">   * @return Ditto.</span></div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span><span class="comment">   */</span></div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span><span class="comment"></span> </div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span><span class="comment">   * Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and</span></div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span><span class="comment">   * sending outgoing Flow traffic in this Node.  This is similar to to the value passed to the</span></div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"> 1062</span><span class="comment">   * Node constructor, except that it represents the actual bound address and port (e.g., if you</span></div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"> 1063</span><span class="comment">   * chose 0 as the port, the value returned here will contain the actual emphemeral port randomly chosen by</span></div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span><span class="comment">   * the OS).</span></div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span><span class="comment">   *</span></div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span><span class="comment">   * If `!running()`, this equals Udp_endpoint().  The logical value of the returned util::Udp_endpoint</span></div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span><span class="comment">   * never changes over the lifetime of the Node.</span></div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span><span class="comment">   *</span></div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span><span class="comment">   * @return See above.  Note that it is a reference.</span></div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span><span class="comment">   */</span></div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">local_low_lvl_endpoint</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span><span class="comment"></span> </div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span><span class="comment">   * Initiates an active connect to the specified remote Flow server.  Returns a safe pointer to a</span></div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span><span class="comment">   * new Peer_socket.  The socket&#39;s state will be some substate of `S_OPEN` at least initially.  The</span></div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"> 1076</span><span class="comment">   * connection operation, involving network traffic, will be performed asynchronously.</span></div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"> 1077</span><span class="comment">   *</span></div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"> 1078</span><span class="comment">   * One can treat the resulting socket as already connected; its Writable and Readable status can</span></div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"> 1079</span><span class="comment">   * be determined; once Readable or Writable one can receive or send, respectively.</span></div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span><span class="comment">   *</span></div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span><span class="comment">   * Port selection: An available local Flow port will be chosen and will be available for</span></div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span><span class="comment">   * information purposes via sock-&gt;local_port(), where `sock` is the returned socket.  The port will</span></div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span><span class="comment">   * be in the range [Node::S_FIRST_EPHEMERAL_PORT, Node::S_FIRST_EPHEMERAL_PORT +</span></div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span><span class="comment">   * Node::S_NUM_EPHEMERAL_PORTS - 1].  Note that there is no overlap between that range and the</span></div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span><span class="comment">   * range [Node::S_FIRST_SERVICE_PORT, Node::S_FIRST_SERVICE_PORT + Node::S_NUM_SERVICE_PORTS - 1].</span></div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span><span class="comment">   *</span></div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span><span class="comment">   *        The remote Flow port to which to connect.</span></div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"> 1090</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span><span class="comment">   *        error::Code::S_OUT_OF_PORTS, error::Code::S_INTERNAL_ERROR_PORT_COLLISION,</span></div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"> 1092</span><span class="comment">   *        error::Code::S_OPTION_CHECK_FAILED.</span></div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span><span class="comment">   *        The low-level per-Peer_socket options to use in the new socket.</span></div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span><span class="comment">   *        If null (typical), the per-socket options template in Node::options() is used.</span></div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span><span class="comment">   *        If not null, the given per-socket options are first validated and, if valid, used.</span></div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span><span class="comment">   *        If invalid, it is an error.  See also Peer_socket::set_options(),</span></div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span><span class="comment">   *        Peer_socket::options().</span></div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span><span class="comment">   * @return Shared pointer to Peer_socket, which is in the `S_OPEN` main state; or null pointer,</span></div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span><span class="comment">   *         indicating an error.</span></div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span><span class="comment">   */</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span>                           <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span><span class="comment"></span> </div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"> 1105</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"> 1106</span><span class="comment">   * Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,</span></div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span><span class="comment">   * which the other side can access via Peer_socket::get_connect_metadata() after accepting the</span></div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span><span class="comment">   * connection.</span></div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span><span class="comment">   *</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span><span class="comment">   * @note It is up to the user to serialize the metadata portably.  One recommended convention is to</span></div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span><span class="comment">   *       use `boost::endian::native_to_little()` (and similar) before connecting; and</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span><span class="comment">   *       on the other side use the reverse (`boost::endian::little_to_native()`) before using the value.</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span><span class="comment">   *       Packet dumps will show a flipped (little-endian) representation, while with most platforms the conversion</span></div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span><span class="comment">   *       will be a no-op at compile time.  Alternatively use `native_to_big()` and vice-versa.</span></div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span><span class="comment">   * @note Why provide this metadata facility?  After all, they could just send the data upon connection via</span></div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span><span class="comment">   *       send()/receive()/etc.  Answers: Firstly, this is guaranteed to be delivered (assuming successful</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span><span class="comment">   *       connection), even if reliability (such as via retransmission) is disabled in socket options (opts</span></div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"> 1118</span><span class="comment">   *       argument).  For example, if a reliability mechanism (such as FEC) is built on top of the Flow layer,</span></div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span><span class="comment">   *       parameters having to do with configuring that reliability mechanism can be bootstrapped reliably</span></div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span><span class="comment">   *       using this mechanism.  Secondly, it can be quite convenient (albeit not irreplaceably so) for</span></div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span><span class="comment">   *       connection-authenticating techniques like security tokens known by both sides.</span></div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span><span class="comment">   * @param serialized_metadata</span></div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span><span class="comment">   *        Data copied and sent to the other side during the connection establishment.  The other side can get</span></div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span><span class="comment">   *        equal data using Peer_socket::get_connect_metadata().  The returned socket `sock` also stores it; it&#39;s</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span><span class="comment">   *        similarly accessible via sock-&gt;get_connect_metadata() on this side.</span></div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span><span class="comment">   *        The metadata must fit into a single low-level packet; otherwise</span></div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span><span class="comment">   *        error::Code::S_CONN_METADATA_TOO_LARGE error is returned.</span></div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span><span class="comment">   *        See connect().  Added error: error::Code::S_CONN_METADATA_TOO_LARGE.</span></div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span><span class="comment">   * @return See connect().</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span><span class="comment">   */</span></div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span>                                         <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span>                                         <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span>                                         <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="comment"></span> </div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment">   * The blocking (synchronous) version of connect().  Acts just like connect() but instead of</span></div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment">   * returning a connecting socket immediately, waits until the initial handshake either succeeds or</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span><span class="comment">   * fails, and then returns the socket or null, respectively.  Additionally, you can specify a</span></div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span><span class="comment">   * timeout; if the connection is not successful by this time, the connection attempt is aborted</span></div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span><span class="comment">   * and null is returned.</span></div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span><span class="comment">   *</span></div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"> 1148</span><span class="comment">   * Note that there is always a built-in Flow protocol connect timeout that is mandatory</span></div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"> 1149</span><span class="comment">   * and will report an error if it expires; but it may be too long for your purposes, so you can</span></div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"> 1150</span><span class="comment">   * specify your own that may expire before it.  The two timeouts should be thought of as fundamentally</span></div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"> 1151</span><span class="comment">   * independent (built-in one is in the lower level of Flow protocol; the one you provide is at the application</span></div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span><span class="comment">   * layer), so don&#39;t make assumptions about Flow&#39;s behavior and set a timeout if you know you need one -- even</span></div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span><span class="comment">   * if in practice it is longer than the Flow one (which as of this writing can be controlled via socket option).</span></div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span><span class="comment">   *</span></div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span><span class="comment">   * The following are the possible outcomes:</span></div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span><span class="comment">   *   1. Connection succeeds before the given timeout expires (or succeeds, if no timeout given).</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span><span class="comment">   *      Socket is at least Writable at time of return.  The new socket is returned, no error is</span></div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span><span class="comment">   *      returned via `*err_code`.</span></div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span><span class="comment">   *   2. Connection fails before the given timeout expires (or fails, if no timeout given).  null</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span><span class="comment">   *      is returned, `*err_code` is set to reason for connection failure.  (Note that a built-in</span></div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span><span class="comment">   *      handshake timeout -- NOT the given user timeout, if any -- falls under this category.)</span></div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span><span class="comment">   *      `*err_code == error::Code::S_WAIT_INTERRUPTED` means the wait was interrupted (similarly to POSIX&#39;s `EINTR`).</span></div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span><span class="comment">   *   3. A user timeout is given, and the connection does not succeed before it expires.  null is</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span><span class="comment">   *      returned, and `*err_code` is set to error::Code::S_WAIT_USER_TIMEOUT.</span></div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span><span class="comment">   *      (Rationale: consistent with Server_socket::sync_accept(),</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span><span class="comment">   *      Peer_socket::sync_receive(), Peer_socket::sync_send() behavior.)</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span><span class="comment">   *</span></div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span><span class="comment">   * Tip: Typical types you might use for `max_wait`: `boost::chrono::milliseconds`,</span></div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment">   * `boost::chrono::seconds`, `boost::chrono::high_resolution_clock::duration`.</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span><span class="comment">   *</span></div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span><span class="comment">   * @tparam Rep</span></div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="comment">   *         See `boost::chrono::duration` documentation (and see above tip).</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span><span class="comment">   * @tparam Period</span></div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span><span class="comment">   *         See `boost::chrono::duration` documentation (and see above tip).</span></div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span><span class="comment">   * @param max_wait</span></div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"> 1178</span><span class="comment">   *        The maximum amount of time from now to wait before giving up on the wait and returning.</span></div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span><span class="comment">   *        `&quot;duration&lt;Rep, Period&gt;::max()&quot;` will eliminate the time limit and cause indefinite wait</span></div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span><span class="comment">   *        -- however, not really, as there is a built-in connection timeout that will expire.</span></div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span><span class="comment">   *        error::Code::S_WAIT_INTERRUPTED, error::Code::S_WAIT_USER_TIMEOUT, error::Code::S_NODE_NOT_RUNNING,</span></div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span><span class="comment">   *        error::Code::S_CANNOT_CONNECT_TO_IP_ANY, error::Code::S_OUT_OF_PORTS,</span></div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span><span class="comment">   *        error::Code::S_INTERNAL_ERROR_PORT_COLLISION,</span></div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span><span class="comment">   *        error::Code::S_CONN_TIMEOUT, error::Code::S_CONN_REFUSED,</span></div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span><span class="comment">   *        error::Code::S_CONN_RESET_BY_OTHER_SIDE, error::Code::S_NODE_SHUTTING_DOWN,</span></div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span><span class="comment">   *        error::Code::S_OPTION_CHECK_FAILED.</span></div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span><span class="comment">   * @return See connect().</span></div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span><span class="comment">   */</span></div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">sync_connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <span class="keyword">const</span> boost::chrono::duration&lt;Rep, Period&gt;&amp; max_wait,</div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span>                                <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span>                                <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span><span class="comment"></span> </div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment">   * A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><span class="comment">   * metadata).</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span><span class="comment">   *</span></div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span><span class="comment">   * @param max_wait</span></div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment">   * @param serialized_metadata</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment">   *        See connect_with_metadata().</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span><span class="comment">   *        See sync_connect().  Added error: error::Code::S_CONN_METADATA_TOO_LARGE.</span></div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span><span class="comment">   * @return See sync_connect().</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span><span class="comment">   */</span></div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span>                                              <span class="keyword">const</span> boost::chrono::duration&lt;Rep, Period&gt;&amp; max_wait,</div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span>                                              <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span>                                              <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span>                                              <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span><span class="comment"></span> </div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span><span class="comment">   * Equivalent to `sync_connect(to, duration::max(), err_code, opt)s`; i.e., sync_connect() with no user</span></div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span><span class="comment">   * timeout.</span></div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span><span class="comment">   *</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span><span class="comment">   *        See other sync_connect().</span></div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span><span class="comment">   *        See other sync_connect().</span></div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"> 1229</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span><span class="comment">   * @return See other sync_connect().</span></div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span><span class="comment">   */</span></div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">sync_connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span>                                <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span><span class="comment"></span> </div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span><span class="comment">   * Equivalent to `sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)`; i.e.,</span></div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span><span class="comment">   * sync_connect_with_metadata() with no user timeout.</span></div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span><span class="comment">   *</span></div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span><span class="comment">   * @param serialized_metadata</span></div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span><span class="comment">   *        See connect_with_metadata().</span></div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span><span class="comment">   *        See sync_connect().  Added error: error::Code::S_CONN_METADATA_TOO_LARGE.</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span><span class="comment">   * @return See sync_connect().</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span><span class="comment">   */</span></div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span>                                              <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span>                                              <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span>                                              <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts = 0);</div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="comment"></span> </div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span><span class="comment">   * Sets up a server on the given local Flow port and returns Server_socket which can be used to</span></div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span><span class="comment">   * accept subsequent incoming connections to this server.  Any subsequent incoming connections</span></div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="comment">   * will be established asynchronously and, once established, can be claimed (as Peer_socket</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span><span class="comment">   * objects) via Server_server::accept() and friends.</span></div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span><span class="comment">   *</span></div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span><span class="comment">   * Port specification: You must select a port in the range [Node::S_FIRST_SERVICE_PORT,</span></div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span><span class="comment">   * Node::S_FIRST_SERVICE_PORT + Node::S_NUM_SERVICE_PORTS - 1] or the special value #S_PORT_ANY.</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span><span class="comment">   * In the latter case an available port in the range [Node::S_FIRST_EPHEMERAL_PORT,</span></div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span><span class="comment">   * Node::S_FIRST_EPHEMERAL_PORT + Node::S_NUM_EPHEMERAL_PORTS - 1] will be chosen for you.</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span><span class="comment">   * Otherwise we will use the port you explicitly specified.</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span><span class="comment">   *</span></div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span><span class="comment">   * Note that using #S_PORT_ANY in this context typically makes sense only if you somehow</span></div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span><span class="comment">   * communicate `serv-&gt;local_port()` (where `serv` is the returned socket) to the other side through</span></div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span><span class="comment">   * some other means (for example if both client and server are running in the same program, you</span></div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span><span class="comment">   * could just pass it via variable or function call).  Note that there is no overlap between the</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span><span class="comment">   * two aforementioned port ranges.</span></div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span><span class="comment">   *</span></div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span><span class="comment">   * @param local_port</span></div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span><span class="comment">   *        The local Flow port to which to bind.</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span><span class="comment">   *        error::Code::S_NODE_NOT_RUNNING, error::Code::S_PORT_TAKEN,</span></div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span><span class="comment">   *        error::Code::S_OUT_OF_PORTS, error::Code::S_INVALID_SERVICE_PORT_NUMBER,</span></div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span><span class="comment">   *        error::Code::S_INTERNAL_ERROR_PORT_COLLISION.</span></div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span><span class="comment">   * @param child_sock_opts</span></div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span><span class="comment">   *        If null, any Peer_sockets that `serv-&gt;accept()` may return (where `serv` is the returned</span></div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span><span class="comment">   *        Server_socket) will be initialized with the options set equal to</span></div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span><span class="comment">   *        `options().m_dyn_sock_opts`.  If not null, they will be initialized with a copy of</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span><span class="comment">   *        `*child_sock_opts`.  No reference to `*child_sock_opts` is saved.</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span><span class="comment">   * @return Shared pointer to Server_socket, which is in the Server_socket::State::S_LISTENING state at least</span></div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span><span class="comment">   *         initially; or null pointer, indicating an error.</span></div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span><span class="comment">   */</span></div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">listen</a>(<a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0,</div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span>                            <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* child_sock_opts = 0);</div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span><span class="comment"></span> </div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span><span class="comment">   * Creates a new Event_set in Event_set::State::S_INACTIVE state with no sockets/events stored; returns this</span></div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span><span class="comment">   * Event_set.</span></div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span><span class="comment">   *</span></div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span><span class="comment">   *        error::Code::S_NODE_NOT_RUNNING.</span></div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span><span class="comment">   * @return Shared pointer to Event_set; or null pointer, indicating an error.</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span><span class="comment">   */</span></div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">event_set_create</a>(<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0);</div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span><span class="comment"></span> </div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span><span class="comment">   * Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the</span></div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span><span class="comment">   * blocking operation&#39;s outcome was being interrupted.  Conceptually, this causes a similar fate as a POSIX</span></div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span><span class="comment">   * blocking function exiting with -1/`EINTR`, for all such functions currently executing.  This may be called</span></div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span><span class="comment">   * from any thread whatsoever and, particularly, from signal handlers as well.</span></div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span><span class="comment">   *</span></div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span><span class="comment">   * Before deciding to call this explicitly from signal handler(s), consider using the simpler</span></div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span><span class="comment">   * Node_options::m_st_capture_interrupt_signals_internally instead.</span></div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span><span class="comment">   *</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span><span class="comment">   * The above is vague about how an interrupted &quot;wait&quot; exhibits itself.  More specifically, then:</span></div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span><span class="comment">   * Any operation with name `sync_...()` will return with an error, that error being</span></div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span><span class="comment">   * #Error_code error::Code::S_WAIT_INTERRUPTED.  Event_set::async_wait()-initiated wait will end, with the handler</span></div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span><span class="comment">   * function being called, passing the Boolean value `true` to that function.  `true` indicates the wait was</span></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span><span class="comment">   * interrupted rather than successfully finishing with 1 or more active events (`false` would&#39;ve indicated th</span></div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span><span class="comment">   * latter, more typical situation).</span></div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span><span class="comment">   *</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span><span class="comment">   * Note that various calsses have `sync_...()` operations, including Node (Node::sync_connect()),</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span><span class="comment">   * Server_socket (Server_socket::sync_accept()), and Peer_socket (Peer_socket::sync_receive()).</span></div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span><span class="comment">   *</span></div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span><span class="comment">   *        error::Code::S_NODE_NOT_RUNNING.</span></div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span><span class="comment">   */</span></div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">interrupt_all_waits</a>(<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0);</div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span><span class="comment"></span> </div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment">   * Dynamically replaces the current options set (options()) with the given options set.</span></div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="comment">   * Only those members of `opts` designated as dynamic (as opposed to static) may be different</span></div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span><span class="comment">   * between options() and `opts`.  If this is violated, it is an error, and no options are changed.</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span><span class="comment">   *</span></div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="comment">   * Typically one would acquire a copy of the existing options set via options(), modify the</span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span><span class="comment">   * desired dynamic data members of that copy, and then apply that copy back by calling</span></div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="comment">   * set_options().  Warning: this technique is only safe if other (user) threads do not call</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span><span class="comment">   * set_options() simultaneously.  There is a to-do to provide a thread-safe maneuver for when this is</span></div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="comment">   * a problem (see class Node doc header).</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span><span class="comment">   *</span></div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span><span class="comment">   *        The new options to apply to this socket.  It is copied; no reference is saved.</span></div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span><span class="comment">   *        error::Code::S_OPTION_CHECK_FAILED, error::Code::S_NODE_NOT_RUNNING.</span></div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span><span class="comment">   * @return `true` on success, `false` on error.</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span><span class="comment">   */</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">set_options</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&amp; opts, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code = 0);</div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span><span class="comment"></span> </div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span><span class="comment">   * Copies this Node&#39;s option set and returns that copy.  If you intend to use set_options() to</span></div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="comment">   * modify a Node&#39;s options, we recommend you make the modifications on the copy returned by</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span><span class="comment">   * options().</span></div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span><span class="comment">   *</span></div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span><span class="comment">   * @return Ditto.</span></div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span><span class="comment">   */</span></div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span>  <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">options</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span><span class="comment"></span> </div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span><span class="comment">   * The maximum number of bytes of user data per received or sent block on connections generated</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span><span class="comment">   * from this Node, unless this value is overridden in the Peer_socket_options argument to</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span><span class="comment">   * listen() or connect() (or friend).  See Peer_socket_options::m_st_max_block_size.</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment">   *</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span><span class="comment">   * @return Ditto.</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span><span class="comment">   */</span></div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span> </div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span><span class="keyword">protected</span>:</div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span> </div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span> </div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span>  <span class="comment">// Basic setup/teardown/driver/general methods.</span></div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span><span class="comment"></span> </div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span><span class="comment">   * Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket, depending on</span></div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span><span class="comment">   * the template parameter.</span></div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span><span class="comment">   *</span></div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span><span class="comment">   * @tparam Peer_socket_impl_type</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span><span class="comment">   *         Either net_flow::Peer_socket or net_flow::asio::Peer_socket, as of this writing.</span></div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span><span class="comment">   *        See, for example, `Peer_socket::connect(..., const Peer_socket_options&amp;)`.</span></div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span><span class="comment">   * @return Pointer to new object of type Peer_socket or of a subclass.</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span><span class="comment">   */</span></div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Peer_socket_impl_type&gt;</div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">sock_create_forward_plus_ctor_args</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts);</div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span><span class="comment"></span> </div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span><span class="comment">   * Like sock_create_forward_plus_ctor_args() but for Server_sockets.</span></div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span><span class="comment">   *</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span><span class="comment">   * @tparam Server_socket_impl_type</span></div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span><span class="comment">   *         Either net_flow::Server_socket or net_flow::asio::Server_socket, as of this writing.</span></div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span><span class="comment">   * @param child_sock_opts</span></div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span><span class="comment">   *        See, for example, `Peer_socket::accept(..., const Peer_socket_options* child_sock_opts)`</span></div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span><span class="comment">   * @return Pointer to new object of type Server_socket or of a subclass.</span></div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span><span class="comment">   */</span></div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Server_socket_impl_type&gt;</div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"> 1394</span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">serv_create_forward_plus_ctor_args</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* child_sock_opts);</div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span> </div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span>  <span class="comment">// Constants.</span></div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span><span class="comment"></span> </div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span><span class="comment">   * Type and value to supply as user-supplied metadata in SYN, if user chooses to use</span></div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span><span class="comment">   * `[[a]sync_]connect()` instead of `[[a]sync_]connect_with_metadata()`.  If you change this value, please</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span><span class="comment">   * update Peer_socket::get_connect_metadata() doc header.</span></div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span><span class="comment">   */</span></div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13"> 1403</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a>;</div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span> </div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span><span class="keyword">private</span>:</div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span>  <span class="comment">// Friends.</span></div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span><span class="comment"></span> </div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span><span class="comment">   * Peer_socket must be able to forward `send()`, `receive()`, etc. to Node.</span></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span><span class="comment">   * @see Peer_socket.</span></div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span><span class="comment">   */</span></div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a62cd43d29137c6c9abc7d9dd731555f9"> 1412</a></span>  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>;<span class="comment"></span></div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span><span class="comment">   * Server_socket must be able to forward `accept()`, etc. to Node.</span></div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span><span class="comment">   * @see Server_socket.</span></div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span><span class="comment">   */</span></div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a2165381af6166d76afba06862c762367"> 1417</a></span>  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_class" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a>;<span class="comment"></span></div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span><span class="comment">   * Event_set must be able to forward `close()`, `event_set_async_wait()`, etc. to Node.</span></div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span><span class="comment">   * @see Event_set.</span></div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span><span class="comment">   */</span></div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aec2bd684093a1769e08a56c9a088801a"> 1422</a></span>  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code hl_class" href="classflow_1_1net__flow_1_1Event__set.html">Event_set</a>;</div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span> </div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span><span class="comment"></span> </div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span><span class="comment">  /// Short-hand for UDP socket.</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a"> 1427</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">Udp_socket</a> = boost::asio::ip::udp::socket;</div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span><span class="comment"></span> </div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span><span class="comment">  /// boost.asio timer wrapped in a ref-counted pointer.</span></div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3"> 1430</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3">Timer_ptr</a> = boost::shared_ptr&lt;util::Timer&gt;;</div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span><span class="comment"></span> </div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span><span class="comment">  /// Short-hand for a signal set.</span></div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f"> 1433</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">Signal_set</a> = boost::asio::signal_set;</div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span><span class="comment"></span> </div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span><span class="comment">  /// Short-hand for high-performance, non-reentrant, exclusive mutex used to lock #m_opts.</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138"> 1436</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">Options_mutex</a> = <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">Peer_socket::Options_mutex</a>;</div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span><span class="comment"></span> </div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span><span class="comment">  /// Short-hand for lock that acquires exclusive access to an #Options_mutex.</span></div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7"> 1439</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">Options_lock</a> = <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">Peer_socket::Options_lock</a>;</div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span> </div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span>  <span class="keyword">struct </span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>;</div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span>  <span class="comment">// Friend of Node: For ability to reference private `struct` Node::Socket_id.</span></div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span>  <span class="keyword">friend</span> <span class="keywordtype">size_t</span> <a class="code hl_friend" href="classflow_1_1net__flow_1_1Node.html#a7e9629b88c4cd0b337a51c2363893908">hash_value</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>);</div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span>  <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code hl_friend" href="classflow_1_1net__flow_1_1Node.html#a99561404e8389fef08fa4ac5c16a7f36">operator==</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; rhs);</div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span><span class="comment"></span> </div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span><span class="comment">   * A map from the connection ID (= remote-local socket pair) to the local Peer_socket that is</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span><span class="comment">   * the local portion of the connection.  Applies to peer-to-peer (not server) sockets.</span></div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span><span class="comment">   */</span></div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c"> 1450</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">Socket_id_to_socket_map</a> = boost::unordered_map&lt;Socket_id, Peer_socket::Ptr&gt;;</div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span><span class="comment"></span> </div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span><span class="comment">  /// A map from the local Flow port to the local Server_socket listening on that port.</span></div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"> 1453</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">Port_to_server_map</a> = boost::unordered_map&lt;flow_port_t, Server_socket::Ptr&gt;;</div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"> 1454</span><span class="comment"></span> </div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span><span class="comment">  /// A set of Event_set objects.</span></div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883"> 1456</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">Event_sets</a> = boost::unordered_set&lt;Event_set::Ptr&gt;;</div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span> </div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span> </div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span>  <span class="comment">// Basic setup/teardown/driver/general methods.</span></div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span><span class="comment"></span> </div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span><span class="comment">   * Worker thread W (main event loop) body.  Does not exit unless told to do so by Node&#39;s</span></div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span><span class="comment">   * destruction (presumably from a non-W thread, as W is not exposed to Node user).</span></div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span><span class="comment">   *</span></div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span><span class="comment">   * @param low_lvl_endpoint</span></div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span><span class="comment">   *        See that parameter on Node constructor.  Intentionally passed by value, to</span></div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span><span class="comment">   *        avoid race with user&#39;s Udp_endpoint object disappearing before worker_run() can</span></div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span><span class="comment">   *        use it.</span></div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span><span class="comment">   */</span></div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7">worker_run</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> low_lvl_endpoint);</div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span><span class="comment"></span> </div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span><span class="comment">   * Helper to invoke for each thread in which this Node executes, whether or not it starts that thread,</span></div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span><span class="comment">   * that applies certain common settings to all subsequent logging from that thread.</span></div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span><span class="comment">   *</span></div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span><span class="comment">   * E.g., it might nickname the thread (w/r/t logging) and set a certain style of printing duration units (short</span></div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span><span class="comment">   * like &quot;ms&quot; or long like &quot;milliseconds&quot;): these probably won&#39;t change for the rest of the Node&#39;s logging.</span></div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span><span class="comment">   *</span></div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span><span class="comment">   * @param thread_type</span></div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span><span class="comment">   *        Roughly 3-letter character sequence identifying the thread&#39;s purpose, to be included in the thread&#39;s logged</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span><span class="comment">   *        nickname in subsequent log message prefixes; or empty string to let the thread&#39;s nickname stay as-is.</span></div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span><span class="comment">   * @param logger</span></div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span><span class="comment">   *        The Logger whose logging to configure(); or null to assume `this-&gt;get_logger()` (which is typical but may</span></div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span><span class="comment">   *        not yet be available, say, during object construction).</span></div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span><span class="comment">   * @return Address of the Logger that was configured (either `logger` or `this-&gt;get_logger()`).</span></div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span><span class="comment">   */</span></div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span>  <a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa894fd58b246c2a8d6c7c7d25a8748cb">this_thread_init_logger_setup</a>(<span class="keyword">const</span> std::string&amp; thread_type, <a class="code hl_class" href="classflow_1_1log_1_1Logger.html">log::Logger</a>* logger = 0);</div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span><span class="comment"></span> </div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"> 1490</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span><span class="comment">   * Given a new set of Node_options intended to replace (or initialize) a Node&#39;s #m_opts, ensures</span></div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"> 1492</span><span class="comment">   * that these new option values are legal.  In all cases, values are checked for individual and</span></div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"> 1493</span><span class="comment">   * mutual validity.  Additionally, unless init is true, which means we&#39;re being called from</span></div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"> 1494</span><span class="comment">   * constructor, ensures that no `static` data member is different between #m_opts and opts.  If any</span></div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"> 1495</span><span class="comment">   * validation fails, it is an error.</span></div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"> 1496</span><span class="comment">   *</span></div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span><span class="comment">   * Pre-condition: If `!init`, #m_opts_mutex is locked.</span></div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span><span class="comment">   *</span></div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span><span class="comment">   * @todo Is it necessary to return `opts` now that we&#39;ve switched to C++11 or better?</span></div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span><span class="comment">   *</span></div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"> 1502</span><span class="comment">   *        New option values to validate.</span></div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span><span class="comment">   * @param init</span></div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"> 1504</span><span class="comment">   *        True if called from constructor; false if called from set_options().</span></div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"> 1505</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"> 1506</span><span class="comment">   *        See flow::Error_code docs for error reporting semantics.  error::Code generated:</span></div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"> 1507</span><span class="comment">   *        error::Code::S_OPTION_CHECK_FAILED, error::Code::S_STATIC_OPTION_CHANGED.</span></div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"> 1508</span><span class="comment">   * @return `opts`.  The only reason we return this is so that it can be called during the</span></div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span><span class="comment">   *         construction&#39;s initializer section (go, C++03!).</span></div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span><span class="comment">   */</span></div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e">validate_options</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&amp; opts, <span class="keywordtype">bool</span> init, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span><span class="comment"></span> </div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span><span class="comment">   * Helper that compares `new_val` to `old_val` and, if they are not equal, logs and returns an error;</span></div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span><span class="comment">   * used to ensure static options are not changed.</span></div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"> 1516</span><span class="comment">   *</span></div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"> 1517</span><span class="comment">   * @tparam Opt_type</span></div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"> 1518</span><span class="comment">   *         Type of a Node_options, etc., data member.</span></div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"> 1519</span><span class="comment">   * @param new_val</span></div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span><span class="comment">   *        Proposed new value for the option.</span></div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span><span class="comment">   * @param old_val</span></div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span><span class="comment">   *        Current value of the option.</span></div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span><span class="comment">   * @param opt_id</span></div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span><span class="comment">   *        The name of the option, suitable for logging; this is presumably obtained using the</span></div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span><span class="comment">   *        macro `#` technique.</span></div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span><span class="comment">   *        See Peer_socket::set_options().</span></div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"> 1528</span><span class="comment">   * @return `true` on success, `false` on validation error.</span></div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"> 1529</span><span class="comment">   */</span></div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"> 1530</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Opt_type&gt;</div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"> 1531</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b">validate_static_option</a>(<span class="keyword">const</span> Opt_type&amp; new_val, <span class="keyword">const</span> Opt_type&amp; old_val, <span class="keyword">const</span> std::string&amp; opt_id,</div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span>                              <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span><span class="comment"></span> </div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span><span class="comment">   * Helper that, if the given condition is false, logs and returns an error; used to check for</span></div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span><span class="comment">   * option value validity when setting options.</span></div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span><span class="comment">   *</span></div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span><span class="comment">   * @param check</span></div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span><span class="comment">   *        `false` if and only if some validity check failed.</span></div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"> 1540</span><span class="comment">   * @param check_str</span></div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"> 1541</span><span class="comment">   *        String describing which condition was checked; this is presumably obtained using the</span></div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"> 1542</span><span class="comment">   *        macro # technique.</span></div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"> 1543</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"> 1544</span><span class="comment">   *        See Peer_socket::set_options().</span></div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span><span class="comment">   * @return `true` on success, `false` on validation error.</span></div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"> 1546</span><span class="comment">   */</span></div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a9511f3ba50d19f2c32a8de94f0a306e8">validate_option_check</a>(<span class="keywordtype">bool</span> check, <span class="keyword">const</span> std::string&amp; check_str, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span><span class="comment"></span> </div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span><span class="comment">   * Obtain a copy of the value of a given option in a thread-safe manner.  Because #m_opts may be</span></div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span><span class="comment">   * modified at any time -- even if the desired option is static and not being modified, this is</span></div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span><span class="comment">   * still unsafe -- #m_opts must be locked, the desired value must be copied, and #m_opts must be</span></div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span><span class="comment">   * unlocked.  This method does so.</span></div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"> 1554</span><span class="comment">   *</span></div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"> 1555</span><span class="comment">   * Do NOT read option values without opt().</span></div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"> 1556</span><span class="comment">   *</span></div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"> 1557</span><span class="comment">   * @tparam Opt_type</span></div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"> 1558</span><span class="comment">   *         The type of the option data member.</span></div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span><span class="comment">   * @param opt_val_ref</span></div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span><span class="comment">   *        A reference (important!) to the value you want; this may be either a data member of</span></div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span><span class="comment">   *        `this-&gt;m_opts` or the entire `this-&gt;m_opts` itself.</span></div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span><span class="comment">   * @return A copy of the value at the given reference.</span></div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span><span class="comment">   */</span></div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Opt_type&gt;</div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"> 1565</span>  Opt_type <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">opt</a>(<span class="keyword">const</span> Opt_type&amp; opt_val_ref) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"> 1566</span><span class="comment"></span> </div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"> 1567</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"> 1568</span><span class="comment">   * Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat</span></div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"> 1569</span><span class="comment">   * logging and schedules the next time this should happen.  This is the timer handler for that</span></div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"> 1570</span><span class="comment">   * timer.</span></div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span><span class="comment">   *</span></div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span><span class="comment">   * @param reschedule</span></div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span><span class="comment">   *        If `true`, after completing the tasks, the timer is scheduled to run again later;</span></div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span><span class="comment">   *        otherwise it is not.</span></div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span><span class="comment">   */</span></div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb">perform_regular_infrequent_tasks</a>(<span class="keywordtype">bool</span> reschedule);</div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"> 1577</span> </div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span>  <span class="comment">/* Methods dealing with low-level packet I/O.  Implementations are in low_lvl_io.cpp.  The</span></div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"> 1579</span><span class="comment">   * line between these methods and the ones further down (like handle_incoming())) is blurred, but basically the</span></div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"> 1580</span><span class="comment">   * latter methods deal with each incoming packet after it has been read off wire and gone through</span></div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"> 1581</span><span class="comment">   * the network simulator (if any is active).  By contrast the methods just below</span></div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span><span class="comment">   * (low_lvl_io.cpp) deal with receiving and sending low-level packets (including packet</span></div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span><span class="comment">   * pacing) and network condition simulation (if active) -- basically leaving the core protocol</span></div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span><span class="comment">   * logic to the aforementioned core logic methods. */</span></div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span> </div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span>  <span class="comment">// Input.</span></div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span><span class="comment"></span> </div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span><span class="comment">   * Registers so that during the current or next `m_task_engine.run()`, the latter will wait for a receivable UDP</span></div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"> 1590</span><span class="comment">   * packet and, when one is available, will call low_lvl_recv_and_handle().</span></div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"> 1591</span><span class="comment">   *</span></div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"> 1592</span><span class="comment">   * Pre-condition: we are in thread W.</span></div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span><span class="comment">   */</span></div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade12d2ebbd88b62432089a3a071b9514">async_low_lvl_recv</a>();</div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span><span class="comment"></span> </div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span><span class="comment">   * Handles the pre-condition that #m_low_lvl_sock has a UDP packet available for reading, or that there</span></div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span><span class="comment">   * was an error in waiting for this pre-condition.  If no error (`!sys_err_code`) then the packet is read</span></div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span><span class="comment">   * (thus erased) from the OS UDP net-stack&#39;s packet queue.  The packet is then properly handled (for</span></div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span><span class="comment">   * example it may result in more data decoded into an appropriate Peer_socket&#39;s stream buffer).</span></div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"> 1601</span><span class="comment">   *</span></div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"> 1602</span><span class="comment">   * @param sys_err_code</span></div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"> 1603</span><span class="comment">   *        Error code of the operation.</span></div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span><span class="comment">   */</span></div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5">low_lvl_recv_and_handle</a>(<a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> sys_err_code);</div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span><span class="comment"></span> </div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span><span class="comment">   * Helper for low_lvl_recv_and_handle() that calls handle_incoming() on the not-yet-deserialized low-level</span></div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span><span class="comment">   * packet just read off the UDP socket, but first handles simulation of various network conditions</span></div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"> 1610</span><span class="comment">   * like latency, loss, and duplication.  Pre-condition is that a UDP receive just successfully</span></div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span><span class="comment">   * got the data, or that a simulation thereof occurred.</span></div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span><span class="comment">   *</span></div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"> 1613</span><span class="comment">   * @param packet_data</span></div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"> 1614</span><span class="comment">   *        See handle_incoming().  Note that, despite this method possibly acting asynchronously (e.g.,</span></div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"> 1615</span><span class="comment">   *        if simulating latency), `*packet_data` ownership is retained by the immediate caller.</span></div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"> 1616</span><span class="comment">   *        Caller must not assume anything about its contents upon return and is free to do anything else to it</span></div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span><span class="comment">   *        (e.g., read another datagram into it).</span></div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span><span class="comment">   *        See handle_incoming().</span></div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span><span class="comment">   * @param is_sim_duplicate_packet</span></div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span><span class="comment">   *        `false` if `packet_data` contains data actually just read from UDP socket.</span></div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span><span class="comment">   *        `true` if `packet_data` contains data placed there as a simulated duplicate packet.</span></div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span><span class="comment">   *        The latter is used to prevent that simulated duplicated packet from itself getting</span></div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span><span class="comment">   *        duplicated or dropped.</span></div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"> 1625</span><span class="comment">   * @return The number of times handle_incoming() was called *within* this call (before this call</span></div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"> 1626</span><span class="comment">   *         returned); i.e., the number of packets (e.g., packet and/or its duplicate) handled</span></div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"> 1627</span><span class="comment">   *         immediately as opposed to dropped or scheduled to be handled later.</span></div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"> 1628</span><span class="comment">   */</span></div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"> 1629</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513">handle_incoming_with_simulation</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>* packet_data,</div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span>                                               <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint,</div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span>                                               <span class="keywordtype">bool</span> is_sim_duplicate_packet = <span class="keyword">false</span>);</div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span><span class="comment"></span> </div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span><span class="comment">   * Sets up `handle_incoming(packet_data, low_lvl_remote_endpoint)` to be called asynchronously after a</span></div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span><span class="comment">   * specified period of time.  Used to simulate latency.</span></div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span><span class="comment">   *</span></div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"> 1637</span><span class="comment">   * @param latency</span></div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"> 1638</span><span class="comment">   *        After how long to call handle_incoming().</span></div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"> 1639</span><span class="comment">   * @param packet_data</span></div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"> 1640</span><span class="comment">   *        See handle_incoming_with_simulation().</span></div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span><span class="comment">   *        See handle_incoming_with_simulation().</span></div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span><span class="comment">   */</span></div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8">async_wait_latency_then_handle_incoming</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; latency,</div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span>                                               <a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>* packet_data,</div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span>                                               <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint);</div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span> </div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span>  <span class="comment">// Output.</span></div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span><span class="comment"></span> </div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span><span class="comment">   * async_low_lvl_packet_send_impl() wrapper to call when `packet` is to be sent to the remote side of</span></div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span><span class="comment">   * the connection `sock`.  In particular, this records certain per-socket stats accordingly.</span></div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span><span class="comment">   *</span></div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span><span class="comment">   *        Socket whose remote side to target when sending.</span></div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"> 1657</span><span class="comment">   *        See async_low_lvl_packet_send_impl().</span></div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"> 1658</span><span class="comment">   * @param delayed_by_pacing</span></div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"> 1659</span><span class="comment">   *        See async_low_lvl_packet_send_impl().</span></div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"> 1660</span><span class="comment">   */</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"> 1661</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff">async_sock_low_lvl_packet_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a>&amp;&amp; packet,</div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span>                                      <span class="keywordtype">bool</span> delayed_by_pacing);</div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span><span class="comment"></span> </div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span><span class="comment">   * async_low_lvl_packet_send_impl() wrapper to call when `packet` is to be sent to the remote side of</span></div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span><span class="comment">   * the connection `sock`.  In particular, this records certain per-socket stats accordingly.</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span><span class="comment">   *</span></div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"> 1669</span><span class="comment">   *        UDP endpoint for the Node to which to send the packet.</span></div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"> 1670</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"> 1671</span><span class="comment">   *        See async_low_lvl_packet_send_impl().</span></div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"> 1672</span><span class="comment">   */</span></div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"> 1673</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a08a5752bf3848f31abbe753be47c1fcf">async_no_sock_low_lvl_packet_send</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint,</div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span>                                         <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet);</div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span><span class="comment"></span> </div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span><span class="comment">   * Takes given low-level packet structure, serializes it, and initiates</span></div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span><span class="comment">   * asynchronous send of these data to the remote Node specified by the given UDP endpoint.</span></div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span><span class="comment">   * The local and target ports are assumed to be already filled out in `*packet`.</span></div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span><span class="comment">   * Once the send is possible (i.e., UDP net-stack is able to buffer it for sending; or there is an</span></div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span><span class="comment">   * error), low_lvl_packet_sent() is called (asynchronously).</span></div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span><span class="comment">   *</span></div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span><span class="comment">   * Takes ownership of `packet`; do not reference it in any way after this method returns.</span></div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span><span class="comment">   *</span></div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span><span class="comment">   * @note This method exiting in no way indicates the send succeeded (indeed,</span></div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"> 1686</span><span class="comment">   *       the send cannot possibly initiate until this method exits).</span></div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"> 1687</span><span class="comment">   *</span></div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"> 1688</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"> 1689</span><span class="comment">   *        UDP endpoint for the Node to which to send the packet.</span></div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span><span class="comment">   *        Pointer to packet structure with everything filled out as desired.</span></div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span><span class="comment">   * @param delayed_by_pacing</span></div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span><span class="comment">   *        `true` if there was a (pacing-related) delay between when higher-level code decided to send this packet</span></div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span><span class="comment">   *        and the execution of this method; `false` if there was not, meaning said higher-level code executed us</span></div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span><span class="comment">   *        immediately (synchronously), though not necessarily via a direct call (in fact that&#39;s unlikely; hence</span></div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span><span class="comment">   *        `_impl` in the name).</span></div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span><span class="comment">   *        Peer_socket associated with this connection; null pointer if none is so associated.</span></div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span><span class="comment">   *        If not null, behavior undefined unless `low_lvl_remote_endpoint == sock-&gt;remote_endpoint().m_udp_endpoint`.</span></div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span><span class="comment">   */</span></div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4">async_low_lvl_packet_send_impl</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint,</div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span>                                      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet, <span class="keywordtype">bool</span> delayed_by_pacing, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span><span class="comment"></span> </div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span><span class="comment">   * Completion handler for async_low_lvl_packet_send_impl(); called when the packet is either</span></div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span><span class="comment">   * successfully fed to the UDP net-stack for sending, or when there is an error in doing so.</span></div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"> 1707</span><span class="comment">   *</span></div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"> 1708</span><span class="comment">   * @warning It is important to pass `packet` to this, because the serialization operation produces</span></div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"> 1709</span><span class="comment">   *          a bunch of pointers into `*packet`; if one does not pass it here through the</span></div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"> 1710</span><span class="comment">   *          boost.asio send call, `*packet` might get deleted, and then send op will try to access</span></div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span><span class="comment">   *          pointer(s) to invalid memory.</span></div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span><span class="comment">   *        Ref-counted pointer to the packet that was hopefully sent.</span></div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span><span class="comment">   *        Will be destroyed at the end of low_lvl_packet_sent() unless a copy of this pointer is</span></div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"> 1715</span><span class="comment">   *        saved elsewhere before that point.  (Usually you should indeed let it be destroyed.)</span></div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span><span class="comment">   *        See async_low_lvl_packet_send_impl().  Note the null pointer is allowed.</span></div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span><span class="comment">   * @param bytes_expected_transferred</span></div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span><span class="comment">   *        Size of the serialization of `*packet`, that being the total # of bytes we want sent</span></div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span><span class="comment">   *        over UDP.</span></div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span><span class="comment">   * @param sys_err_code</span></div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"> 1722</span><span class="comment">   *        Result of UDP send operation.</span></div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"> 1723</span><span class="comment">   * @param bytes_transferred</span></div>
<div class="line"><a id="l01724" name="l01724"></a><span class="lineno"> 1724</span><span class="comment">   *        Number of bytes transferred assuming `!err_code`.</span></div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"> 1725</span><span class="comment">   *        Presumably that would equal `bytes_expected_transferred`, but we will see.</span></div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span><span class="comment">   */</span></div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5">low_lvl_packet_sent</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> packet, <span class="keywordtype">size_t</span> bytes_expected_transferred,</div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span>                           <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code, <span class="keywordtype">size_t</span> bytes_transferred);</div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span><span class="comment"></span> </div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span><span class="comment">   * Performs important book-keeping based on the event &quot;DATA packet was sent to destination.&quot;</span></div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span><span class="comment">   * The affected data structures are: Sent_packet::m_sent_when (for the Sent_packet in question),</span></div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span><span class="comment">   * Peer_socket::m_snd_last_data_sent_when, Drop_timer Peer_socket::m_snd_drop_timer (in `*sock`).</span></div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span><span class="comment">   * sock-&gt;m_snd_drop_timer.  More information is in the doc headers for</span></div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span><span class="comment">   * those data members.</span></div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span><span class="comment">   *</span></div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span><span class="comment">   *        Socket for which the given DATA packet is sent.</span></div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span><span class="comment">   * @param seq_num</span></div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span><span class="comment">   *        The first sequence number for the sent DATA packet.</span></div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span><span class="comment">   *        Sent_packet::m_sent_when for its Sent_packet should contain the time at which send_worker() removed</span></div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"> 1742</span><span class="comment">   *        the data from Send buffer and packetized it; it&#39;s used to log the difference between</span></div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"> 1743</span><span class="comment">   *        that time and now.</span></div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"> 1744</span><span class="comment">   */</span></div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"> 1745</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8">mark_data_packet_sent</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num);</div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"> 1746</span><span class="comment"></span> </div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span><span class="comment">   * Sends an RST to the given UDP endpoint in response to the given incoming low-level packet that</span></div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span><span class="comment">   * came from that endpoint, when there is no associated Peer_socket for that remote endpoint/local port combo.</span></div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span><span class="comment">   * An error is unlikely, but if it happens there is no reporting other than logging.</span></div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span><span class="comment">   *</span></div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span><span class="comment">   * You should use this to reply with an RST in situations where no Peer_socket is applicable; for</span></div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span><span class="comment">   * example if anything but a SYN or RST is sent to a server port.  In situations where a</span></div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span><span class="comment">   * Peer_socket is applicable (which is most of the time an RST is needed), use</span></div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span><span class="comment">   * async_sock_low_lvl_rst_send().</span></div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span><span class="comment">   *</span></div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span><span class="comment">   * @param causing_packet</span></div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span><span class="comment">   *        Packet we&#39;re responding to (used at least to set the source and destination Flow ports</span></div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"> 1759</span><span class="comment">   *        of the sent packet).</span></div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"> 1760</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"> 1761</span><span class="comment">   *        Where `causing_packet` came from (the Node low-level endpoint).</span></div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"> 1762</span><span class="comment">   */</span></div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a74a6a82a1390a76e985593969fb47184">async_no_sock_low_lvl_rst_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Low_lvl_packet::Const_ptr</a> causing_packet,</div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span>                                      <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint);</div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span><span class="comment"></span> </div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span><span class="comment">   * Begins the process of asynchronously sending the given low-level packet to the remote Node</span></div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span><span class="comment">   * specified by the given Peer_socket.  The method, if this feature is applicable and enabled,</span></div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span><span class="comment">   * applies packet pacing (which attempts to avoid burstiness by spreading out packets without</span></div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span><span class="comment">   * changing overall sending rate).  Therefore the given packet may be sent as soon as a UDP send</span></div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span><span class="comment">   * is possible according to OS (which is typically immediate), or later, if pacing delays it.  Once it is</span></div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span><span class="comment">   * time to send it, async_sock_low_lvl_packet_send() is used.</span></div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"> 1773</span><span class="comment">   *</span></div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"> 1774</span><span class="comment">   * Takes ownership of packet; do not reference it in any way after this method returns.</span></div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"> 1775</span><span class="comment">   *</span></div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"> 1776</span><span class="comment">   * Note that an error may occur in asynchronous operations triggered by this method; if this</span></div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"> 1777</span><span class="comment">   * happens the socket will be closed via close_connection_immediately().  However if the error</span></div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span><span class="comment">   * happens IN this method (`false` is returned), it is up to the caller to handle the error as</span></div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span><span class="comment">   * desired.</span></div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span><span class="comment">   *</span></div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span><span class="comment">   *        Socket whose `remote_endpoint()` specifies to what Node and what Flow port within that</span></div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"> 1783</span><span class="comment">   *        Node this socket will go.</span></div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span><span class="comment">   *        Pointer to packet structure with everything except the source, destination, and</span></div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span><span class="comment">   *        retransmission mode fields (essentially, the public members of Low_lvl_packet proper but</span></div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span><span class="comment">   *        not its derived types) filled out as desired.</span></div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"> 1788</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"> 1789</span><span class="comment">   *        After return, `*err_code` is success or:</span></div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"> 1790</span><span class="comment">   *        error::Code::S_INTERNAL_ERROR_SYSTEM_ERROR_ASIO_TIMER.</span></div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"> 1791</span><span class="comment">   * @return `true` on success so far; `false` on failure (and thus no send initiation).</span></div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span><span class="comment">   *         Note that `true` in no way indicates the send succeeded (indeed, the send cannot possibly</span></div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span><span class="comment">   *         *initiate* until this method exits).</span></div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span><span class="comment">   */</span></div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0">async_sock_low_lvl_packet_send_paced</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&amp; sock,</div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span>                                            <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a>&amp;&amp; packet,</div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span>                                            <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span><span class="comment"></span> </div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span><span class="comment">   * async_sock_low_lvl_packet_send_paced() pacing helper: Handles a DATA or ACK packet that was just</span></div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span><span class="comment">   * passed into async_sock_low_lvl_packet_send_paced(), i.e., is available for sending.  That is, either</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"> 1802</span><span class="comment">   * sends the packet via async_sock_low_lvl_packet_send() immediately or queues it for sending later.</span></div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span><span class="comment">   *</span></div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span><span class="comment">   * Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed</span></div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span><span class="comment">   * (is not undefined); packet is DATA or ACK; packet is fully filled out; `sock` is in OPEN state;</span></div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"> 1806</span><span class="comment">   * invariants described for `struct` Send_pacing_data hold.</span></div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"> 1807</span><span class="comment">   *</span></div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"> 1808</span><span class="comment">   * Note that an error may occur in asynchronous operations triggered by this method; if this</span></div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span><span class="comment">   * happens the socket will be closed via close_connection_immediately().  However if the error</span></div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span><span class="comment">   * happens IN this method (`false` is returned), it is up to the caller to handle the error as</span></div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span><span class="comment">   * desired.</span></div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span><span class="comment">   *</span></div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span><span class="comment">   * Takes ownership of packet; do not reference it in any way after this method returns.</span></div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span><span class="comment">   *</span></div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span><span class="comment">   *        Packet to send.</span></div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span><span class="comment">   *        See async_sock_low_lvl_packet_send_paced().</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span><span class="comment">   * @return See async_sock_low_lvl_packet_send_paced().</span></div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span><span class="comment">   */</span></div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a62e1f8e6da36d7cd3ad905924aea376c">sock_pacing_new_packet_ready</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a> packet,</div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"> 1824</span>                                    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"> 1825</span><span class="comment"></span> </div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"> 1826</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span><span class="comment">   * async_sock_low_lvl_packet_send_paced() pacing helper: Resets the socket&#39;s Send_pacing_data structure</span></div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span><span class="comment">   * to reflect that a new pacing time slice should begin right now.  The slice start is set to now,</span></div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span><span class="comment">   * its period is set based on the current SRTT and congestion window (so that packets are evenly</span></div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span><span class="comment">   * spread out over the next SRTT); and the number of full packets allowed over this time slice are</span></div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span><span class="comment">   * computed.</span></div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span><span class="comment">   *</span></div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span><span class="comment">   * Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed</span></div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span><span class="comment">   * (is not undefined); `sock` is in OPEN state; invariants described for `struct` Send_pacing_data</span></div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span><span class="comment">   * hold.</span></div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span><span class="comment">   *</span></div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"> 1837</span><span class="comment">   * @see `struct` Send_pacing_data doc header.</span></div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"> 1838</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"> 1839</span><span class="comment">   *        Socket under consideration.  Should be in OPEN state.</span></div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"> 1840</span><span class="comment">   * @param now</span></div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span><span class="comment">   *        For performance (so that we don&#39;t need to acquire the current time again), this is the</span></div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span><span class="comment">   *        very recent time point at which it was determined it is time for a new pacing time slice.</span></div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span><span class="comment">   */</span></div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afb88dafa8ec5c1b412de86dfdccd9c8f">sock_pacing_new_time_slice</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; now);</div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span><span class="comment"></span> </div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span><span class="comment">   * async_sock_low_lvl_packet_send_paced() pacing helper: Given that we are currently in the pacing time</span></div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"> 1848</span><span class="comment">   * slice in `sock-&gt;m_snd_pacing_data`, sends as many queued packets as possible given the time</span></div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span><span class="comment">   * slice&#39;s budget, and if any remain queued after this, schedules for them to be sent in the next</span></div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span><span class="comment">   * time slice.</span></div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span><span class="comment">   *</span></div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"> 1852</span><span class="comment">   * Pre-conditions: pacing is enabled for the socket in options; an SRTT value has been computed</span></div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"> 1853</span><span class="comment">   * (is not undefined); `sock` is in OPEN state; invariants described for `struct` Send_pacing_data</span></div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"> 1854</span><span class="comment">   * hold; the current time is roughly within the current pacing time slice.</span></div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"> 1855</span><span class="comment">   *</span></div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span><span class="comment">   * Note that an error may occur in asynchronous operations triggered by this method; if this</span></div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"> 1857</span><span class="comment">   * happens to socket will be closed via close_connection_immediately().  However if the error</span></div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span><span class="comment">   * happens IN this method (`false` is returned), it is up to the caller to handle the error as</span></div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span><span class="comment">   * desired.</span></div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"> 1860</span><span class="comment">   *</span></div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"> 1863</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span><span class="comment">   *        See async_sock_low_lvl_packet_send_paced().</span></div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span><span class="comment">   * @param executing_after_delay</span></div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span><span class="comment">   *        `true` if executing from a pacing-related timer handler; `false` otherwise (i.e.,</span></div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"> 1867</span><span class="comment">   *        if sock_pacing_new_packet_ready() is in the call stack).</span></div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"> 1868</span><span class="comment">   * @return See async_sock_low_lvl_packet_send_paced().</span></div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"> 1869</span><span class="comment">   */</span></div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"> 1870</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49">sock_pacing_process_q</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code, <span class="keywordtype">bool</span> executing_after_delay);</div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span><span class="comment"></span> </div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span><span class="comment">   * async_sock_low_lvl_packet_send_paced() pacing helper: If sock_pacing_process_q() ran out of the last</span></div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span><span class="comment">   * time slice&#39;s budget and still had packets to send, this is the handler that triggers when the</span></div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span><span class="comment">   * out-of-budget time slice ends.  Sets up a new time slice starting now and tries to send as many</span></div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"> 1876</span><span class="comment">   * queud packets as possible with the new budget; if still more packets remain after this,</span></div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span><span class="comment">   * schedules yet another timer.</span></div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span><span class="comment">   *</span></div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span><span class="comment">   * This may also be called via `cancel()` of the timer.  In this case, the pre-condition is that</span></div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span><span class="comment">   * `sock-&gt;state() == Peer_socket::State::S_CLOSED`; the method will do nothing.</span></div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"> 1881</span><span class="comment">   *</span></div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"> 1882</span><span class="comment">   * Otherwise, pre-conditions: Send_pacing_data::m_packet_q for `sock` is NOT empty; the byte budget for</span></div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"> 1883</span><span class="comment">   * the current time slice is less than the packet at the head `m_packet_q`; `sock` is in OPEN state;</span></div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"> 1884</span><span class="comment">   * invariants described for `struct` Send_pacing_data hold; the current time is roughly just past</span></div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span><span class="comment">   * the current pacing time slice.</span></div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span><span class="comment">   *</span></div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span><span class="comment">   * Note that an error may occur in asynchronous operations triggered by this method; if this</span></div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span><span class="comment">   * happens to socket will be closed via close_connection_immediately().  However if the error</span></div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span><span class="comment">   * happens IN this method (`false` is returned), it is up to the caller to handle the error as</span></div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span><span class="comment">   * desired.</span></div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span><span class="comment">   *</span></div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"> 1893</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span><span class="comment">   * @param sys_err_code</span></div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span><span class="comment">   *        boost.asio error code.</span></div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"> 1896</span><span class="comment">   */</span></div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"> 1897</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3fd57a0d025a78cbeccfd8a15a983575">sock_pacing_time_slice_end</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code);</div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"> 1898</span><span class="comment"></span> </div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"> 1899</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span><span class="comment">   * Similar to async_sock_low_lvl_packet_send_paced() except it also calls</span></div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"> 1901</span><span class="comment">   * `close_connection_immediately(sock)` if the former fails.</span></div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span><span class="comment">   *</span></div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span><span class="comment">   *        See async_sock_low_lvl_packet_send_paced().  Additionally, `sock` must be suitable for</span></div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span><span class="comment">   *        close_connection_immediately(); see that method&#39;s doc comment.</span></div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span><span class="comment">   *        See async_sock_low_lvl_packet_send_paced() analogous parameter.</span></div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"> 1908</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span><span class="comment">   *        Same meaning as in close_connection_immediately().</span></div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span><span class="comment">   * @return See async_low_lvl_packet_send_paced().</span></div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span><span class="comment">   */</span></div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d">async_sock_low_lvl_packet_send_or_close_immediately</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&amp; sock,</div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span>                                                           <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Low_lvl_packet::Ptr</a>&amp;&amp; packet,</div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"> 1914</span>                                                           <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span><span class="comment"></span> </div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"> 1916</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"> 1917</span><span class="comment">   * Sends an RST to the other side of the given socket asynchronously when possible.  An error is</span></div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"> 1918</span><span class="comment">   * unlikely, but if it happens there is no reporting other than logging.</span></div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"> 1919</span><span class="comment">   *</span></div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span><span class="comment">   *        Socket the remote side of which will get the RST.</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"> 1922</span><span class="comment">   */</span></div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">async_sock_low_lvl_rst_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span><span class="comment"></span> </div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"> 1925</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span><span class="comment">   * Sends an RST to the other side of the given socket, synchronously.  An error is</span></div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span><span class="comment">   * unlikely, but if it happens there is no reporting other than logging.  Will block (though</span></div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"> 1928</span><span class="comment">   * probably not for long, this being UDP) if #m_low_lvl_sock is in blocking mode.</span></div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span><span class="comment">   *</span></div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"> 1930</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"> 1931</span><span class="comment">   *        Socket the remote side of which will get the RST.</span></div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"> 1932</span><span class="comment">   */</span></div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"> 1933</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a287eae1113865dba06c103cf023404ae">sync_sock_low_lvl_rst_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span> </div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span>  <span class="comment">// Methods for core protocol logic dealing with deserialized packets before demuxing to Peer_socket or Server_socket.</span></div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span><span class="comment"></span> </div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span><span class="comment">   * Handles a just-received, not-yet-deserialized low-level packet.  A rather important method....</span></div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span><span class="comment">   *</span></div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span><span class="comment">   * @param packet_data</span></div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span><span class="comment">   *        Packet to deserialize and handle.  Upon return, the state of `*packet_data` is not known; and caller retains</span></div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span><span class="comment">   *        ownership of it (e.g., can read another datagram into it if desired).</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"> 1944</span><span class="comment">   *        From where the packet came.</span></div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"> 1945</span><span class="comment">   */</span></div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"> 1946</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116">handle_incoming</a>(<a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a>* packet_data,</div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"> 1947</span>                       <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint);</div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"> 1948</span><span class="comment"></span> </div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span><span class="comment">   * Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or</span></div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span><span class="comment">   * async part of async_wait_latency_then_handle_incoming(), as determined over the course of the execution</span></div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span><span class="comment">   * of either of those methods.  This includes at least performing event_set_all_check_delta() for</span></div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span><span class="comment">   * anything in #m_sock_events, etc., and any accumulated ACK-related tasks stored in the Peer_sockets</span></div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span><span class="comment">   * in #m_socks_with_accumulated_pending_acks and similar.  This is done for efficiency and to</span></div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span><span class="comment">   * reduce network overhead (for example, to combine several individual acknowledgments into one</span></div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span><span class="comment">   * ACK packet).</span></div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span><span class="comment">   */</span></div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc">perform_accumulated_on_recv_tasks</a>();</div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"> 1959</span> </div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"> 1960</span>  <span class="comment">// Methods dealing with individual Peer_sockets.  Implementations are in peer_socket.cpp.</span></div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"> 1961</span><span class="comment"></span> </div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"> 1962</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed low-level SYN_ACK packet delivered to the given</span></div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span><span class="comment">   * peer socket in `S_SYN_SENT` state.  So it will hopefully send back a SYN_ACK_ACK, etc.</span></div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span><span class="comment">   *</span></div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_SYN_SENT internal state.</span></div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span><span class="comment">   * @param syn_ack</span></div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span><span class="comment">   *        Deserialized immutable SYN_ACK.</span></div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span><span class="comment">   */</span></div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"> 1973</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">handle_syn_ack_to_syn_sent</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>,</div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span>                                  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span>                                  boost::shared_ptr&lt;const Syn_ack_packet&gt; syn_ack);</div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span><span class="comment"></span> </div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed, duplicate (equal to already-received SYN_ACK)</span></div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span><span class="comment">   * low-level SYN_ACK packet delivered to the given peer socket in `S_ESTABLISHED` state.  This will</span></div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"> 1980</span><span class="comment">   * hopefully reply with SYN_ACK_ACK again.  Reasoning for this behavior is given in</span></div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span><span class="comment">   * handle_incoming() at the call to this method.</span></div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span><span class="comment">   *</span></div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"> 1984</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_ESTABLISHED internal state with sock-&gt;m_active_connect.</span></div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"> 1985</span><span class="comment">   * @param syn_ack</span></div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"> 1986</span><span class="comment">   *        Deserialized immutable SYN_ACK.</span></div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"> 1987</span><span class="comment">   */</span></div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">handle_syn_ack_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span>                                     boost::shared_ptr&lt;const Syn_ack_packet&gt; syn_ack);</div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span><span class="comment"></span> </div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given</span></div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"> 1993</span><span class="comment">   * peer socket in `S_ESTABLISHED` state.  This will hopefully reply with ACK and deliver the data to</span></div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"> 1994</span><span class="comment">   * the Receive buffer, where the user can receive() them.</span></div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"> 1995</span><span class="comment">   *</span></div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"> 1996</span><span class="comment">   * Also similarly handles packets received and queued earlier while in `S_SYN_RCVD` state.</span></div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"> 1997</span><span class="comment">   *</span></div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"> 1998</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"> 2001</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_ESTABLISHED internal state.</span></div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"> 2003</span><span class="comment">   *        Deserialized DATA packet.  (For performance when moving data to Receive</span></div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"> 2004</span><span class="comment">   *        buffer, this is modifiable.)</span></div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"> 2005</span><span class="comment">   * @param syn_rcvd_qd_packet</span></div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"> 2006</span><span class="comment">   *        If `true`, this packet was saved during Peer_socket::Int_state::S_SYN_RCVD by handle_data_to_syn_rcvd() and</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"> 2007</span><span class="comment">   *        is being handled now that socket is Peer_socket::Int_state::S_ESTABLISHED.  If `false`, this packet was</span></div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span><span class="comment">   *        received normally during `S_ESTABLISHED` state.</span></div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span><span class="comment">   */</span></div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">handle_data_to_established</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>,</div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span>                                  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"> 2012</span>                                  boost::shared_ptr&lt;Data_packet&gt; packet,</div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"> 2013</span>                                  <span class="keywordtype">bool</span> syn_rcvd_qd_packet);</div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"> 2014</span><span class="comment"></span> </div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"> 2015</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span><span class="comment">   * Helper for handle_data_to_established() that categorizes the DATA packet received as either</span></div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"> 2017</span><span class="comment">   * illegal; legal but duplicate of a previously received DATA packet;</span></div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span><span class="comment">   * legal but out-of-order; and finally legal and in-order. Illegal means sender can never validly send</span></div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span><span class="comment">   * such sequence numbers in a DATA packet. Legal means it can, although network problems may still lead to</span></div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span><span class="comment">   * the received DATA being not-useful in some way. Out-of-order means that `packet` occupies seq. numbers</span></div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"> 2021</span><span class="comment">   * past the start of the first unreceived data, or &quot;first gap,&quot; which starts at Peer_socket::m_rcv_next_seq_num.</span></div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"> 2022</span><span class="comment">   * In-order, therefore, means `packet` indeed begins exactly at Peer_socket::m_rcv_next_seq_num (which means typically</span></div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"> 2023</span><span class="comment">   * one should increment the latter by `packet-&gt;m_data.size()`).</span></div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"> 2024</span><span class="comment">   *</span></div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span><span class="comment">   * No statistics are marked down on `sock`; the caller should proceed depending on the output as described</span></div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span><span class="comment">   * just below.</span></div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span><span class="comment">   *</span></div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span><span class="comment">   * If a truthy value is returned, packet is illegal; other outputs are meaningless. Otherwise, falsy is returned;</span></div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span><span class="comment">   * and: If `*dupe`, then packet is a legal dupe; and other outputs are meaningless. Otherwise, `!*dupe`. and:</span></div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"> 2030</span><span class="comment">   * `*slide` if and only if the packet is in-order (hence receive window left edge should &quot;slide&quot; right).</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"> 2031</span><span class="comment">   * `*slide_size` is the number of bytes by which Peer_socket::m_rcv_next_seq_num should increment (&quot;slide&quot;);</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"> 2032</span><span class="comment">   * it is meaningful if and only if `*slide`.</span></div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"> 2033</span><span class="comment">   *</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span><span class="comment">   * (Aside: Every attempt to detect illegality is made, within reason, but NOT every illegal behavior can be detected</span></div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span><span class="comment">   * as such; but defensive coding strives that a failure to detect such leads to nothing worse than meaningless data</span></div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"> 2036</span><span class="comment">   * received by user.)</span></div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span><span class="comment">   *</span></div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"> 2040</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"> 2041</span><span class="comment">   *        See handle_data_to_established(). Note it is read-only, however.</span></div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"> 2042</span><span class="comment">   *.@param dupe</span></div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"> 2043</span><span class="comment">   *        Output for whether the packet is a dupe (true if so). Meaningless if truthy is returned.</span></div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span><span class="comment">   * @param slide</span></div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span><span class="comment">   *        Output for whether the packet consists of the next data to be passed to Receive buffer.</span></div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span><span class="comment">   *        Meaningless if truthy is returned, or else if `*dupe` is set to `true`.</span></div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"> 2047</span><span class="comment">   * @param slide_size</span></div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span><span class="comment">   *        By how much to increment Peer_socket::m_rcv_next_seq_num due to this in-order packet.</span></div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span><span class="comment">   *        Meaningless unless `*slide` is set to `true`.</span></div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"> 2050</span><span class="comment">   * @return Success if `packet` is legal; the recommended error to accompany the connection-breaking RST due</span></div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"> 2051</span><span class="comment">   *        to the illegal `packet`, otherwise.</span></div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"> 2052</span><span class="comment">   */</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"> 2053</span>  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">sock_categorize_data_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span>                                                 boost::shared_ptr&lt;const Data_packet&gt; packet,</div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span>                                                   <span class="keywordtype">bool</span>* dupe, <span class="keywordtype">bool</span>* slide, <span class="keywordtype">size_t</span>* slide_size);</div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span><span class="comment"></span> </div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span><span class="comment">   * Helper for handle_data_to_established() that aims to pass the payload of the given DATA packet to</span></div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"> 2059</span><span class="comment">   * the given socket&#39;s Receive buffer for user consumption; but detects and reports overflow if appropriate,</span></div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"> 2060</span><span class="comment">   * instead. Certain relevant stats are logged in all cases. `packet.m_data` is emptied due to moving it</span></div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"> 2061</span><span class="comment">   * elsewhere -- for performance (recommend saving its `.size()` before-hand, if needed for later) --</span></div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"> 2062</span><span class="comment">   * and the implications on rcv_wnd recovery (if any) are handled. `true` is returned assuming no overflow.</span></div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span><span class="comment">   *</span></div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span><span class="comment">   * If overflow detected, only statistical observations and logs are made, and `false` is returned.</span></div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span><span class="comment">   *</span></div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"> 2068</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"> 2069</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"> 2070</span><span class="comment">   * @return `false` on overflow; `true` on success.</span></div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"> 2071</span><span class="comment">   */</span></div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">sock_data_to_rcv_buf_unless_overflow</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span>                                            boost::shared_ptr&lt;Data_packet&gt; packet);</div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span><span class="comment"></span> </div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"> 2075</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span><span class="comment">   * Helper for handle_data_to_established() that assumes the given&#39;s socket Receive buffer is currently</span></div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"> 2077</span><span class="comment">   * readable and handles implications on the Event_set subsystem.</span></div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"> 2078</span><span class="comment">   *</span></div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"> 2079</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"> 2080</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span><span class="comment">   * @param syn_rcvd_qd_packet</span></div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span><span class="comment">   */</span></div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">sock_rcv_buf_now_readable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> syn_rcvd_qd_packet);</div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span><span class="comment"></span> </div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"> 2086</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"> 2087</span><span class="comment">   * Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-order</span></div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"> 2088</span><span class="comment">   * packet in `sock-&gt;m_rcv_packets_with_gaps` -- in retransmission-off mode. The retransmission-on counterpart</span></div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"> 2089</span><span class="comment">   * is, roughly speaking, sock_data_to_reassembly_q_unless_overflow().</span></div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span><span class="comment">   *</span></div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span><span class="comment">   * This assumes that sock_categorize_data_to_established() returned</span></div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span><span class="comment">   * `*slide == false`. However, due to overflow considerations</span></div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span><span class="comment">   * this helper itself set its own `*slide` (and `*slide_size`) value. The `*slide` argument should be</span></div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"> 2094</span><span class="comment">   * interpereted the same way as from sock_categorize_data_to_established(); `*slide_size` (meaningful if</span></div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span><span class="comment">   * and only if `*slide = true` is set) specifies by how much Peer_socket::m_rcv_next_seq_num must now increment.</span></div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"> 2096</span><span class="comment">   * (Note, then, that in the caller this can only set `*slide` from `false` to `true`; or not touch it.)</span></div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"> 2097</span><span class="comment">   *</span></div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"> 2098</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"> 2099</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span><span class="comment">   *        See handle_data_to_established(). Note it is read-only, however.</span></div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"> 2102</span><span class="comment">   * @param data_size</span></div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span><span class="comment">   *        Original `packet-&gt;m_data.size()` value; by now presumbly that value is 0, but we want the original.</span></div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span><span class="comment">   * @param slide</span></div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span><span class="comment">   *        Same semantics as in sock_categorize_data_to_established() (except it is always set; no &quot;illegal&quot; case).</span></div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"> 2106</span><span class="comment">   * @param slide_size</span></div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"> 2107</span><span class="comment">   *        By how much to increment Peer_socket::m_rcv_next_seq_num due certain overflow considerations.</span></div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"> 2108</span><span class="comment">   */</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"> 2109</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">sock_track_new_data_after_gap_rexmit_off</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span>                                                boost::shared_ptr&lt;const Data_packet&gt; packet,</div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span>                                                <span class="keywordtype">size_t</span> data_size,</div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span>                                                <span class="keywordtype">bool</span>* slide, <span class="keywordtype">size_t</span>* slide_size);</div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span><span class="comment"></span> </div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"> 2115</span><span class="comment">   * Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-order</span></div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"> 2116</span><span class="comment">   * packet in the reassembly queue `sock-&gt;m_rcv_packets_with_gaps` -- in retransmission-on mode; but detects</span></div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"> 2117</span><span class="comment">   * and reports overflow if appropriate, instead.  Certain relevant stats are logged in all cases.</span></div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"> 2118</span><span class="comment">   * `packet.m_data` is emptied due to moving it elsewhere -- for performance (recommend saving its `.size()`</span></div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span><span class="comment">   * before-hand, if needed for later) -- and the implications on rcv_wnd recovery (if any) are handled.</span></div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span><span class="comment">   * `true` is returned assuming no overflow. The retransmission-off counterpart</span></div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span><span class="comment">   * is, roughly speaking, sock_track_new_data_after_gap_rexmit_off().</span></div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span><span class="comment">   *</span></div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span><span class="comment">   * If overflow detected, only statistical observations and logs are made, and `false` is returned.</span></div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"> 2124</span><span class="comment">   *</span></div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"> 2125</span><span class="comment">   * This assumes that sock_categorize_data_to_established() returned `*slide == false`.</span></div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"> 2126</span><span class="comment">   *</span></div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"> 2127</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span><span class="comment">   * @return `false` on overflow; `true` on success.</span></div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span><span class="comment">   */</span></div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"> 2133</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">sock_data_to_reassembly_q_unless_overflow</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"> 2134</span>                                                 boost::shared_ptr&lt;Data_packet&gt; packet);</div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"> 2135</span><span class="comment"></span> </div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"> 2136</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span><span class="comment">   * Helper for handle_data_to_established() that aims to register a set of received DATA packet data as in-order</span></div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span><span class="comment">   * payload in the structures Peer_socket::m_rcv_packets_with_gaps and Peer_socket::m_rcv_next_seq_num</span></div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span><span class="comment">   * in `sock`.  Both structures are updated given the precondition that a set of data had arrived with data</span></div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span><span class="comment">   * starting at `sock-&gt;m_rcv_next_seq_num`.  If `reassembly_in_progress` (which should be `true` if and only</span></div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span><span class="comment">   * if retransmission is on), then the reassembly queue is popped into `sock-&gt;m_rcv_buf` to the appropriate</span></div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span><span class="comment">   * extent (as the just-arrived packet may have bridged the entire gap to the first packet in that queue).</span></div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"> 2143</span><span class="comment">   *</span></div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"> 2144</span><span class="comment">   * Certain relevant stats are logged in all cases.  Note that it&#39;s possible to simulate DATA packets&#39; receipt</span></div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"> 2145</span><span class="comment">   * without actually having received such a packet.  This method will slide the window as directed regardless.</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"> 2146</span><span class="comment">   *</span></div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"> 2148</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span><span class="comment">   * @param slide_size</span></div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span><span class="comment">   *        By how much to increment (slide right) Peer_socket::m_rcv_packets_with_gaps.</span></div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span><span class="comment">   *        See handle_data_to_established().</span></div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"> 2152</span><span class="comment">   * @param reassembly_in_progress</span></div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"> 2153</span><span class="comment">   *        Basically, `sock-&gt;rexmit_on()`.</span></div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"> 2154</span><span class="comment">   */</span></div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"> 2155</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">sock_slide_rcv_next_seq_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">size_t</span> slide_size, <span class="keywordtype">bool</span> reassembly_in_progress);</div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span><span class="comment"></span> </div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span><span class="comment">   * Computes and returns the max size for Peer_socket::m_rcv_packets_with_gaps for `sock`.</span></div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span><span class="comment">   *</span></div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"> 2160</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"> 2161</span><span class="comment">   *        An open socket.</span></div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"> 2162</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"> 2163</span><span class="comment">   */</span></div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"> 2164</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">sock_max_packets_after_unrecvd_packet</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span><span class="comment"></span> </div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"> 2166</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span><span class="comment">   * Causes an acknowledgment of the given received packet to be included in a future Ack_packet</span></div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span><span class="comment">   * sent to the other side.  That ACK low-level UDP packet is not sent in this handler, even if</span></div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span><span class="comment">   * the low-level UDP socket is currently writable.  The sending of this packet is performed</span></div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"> 2170</span><span class="comment">   * asynchronously in the manner of `boost::asio::io_service::post()`.</span></div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"> 2171</span><span class="comment">   *</span></div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"> 2172</span><span class="comment">   * Note that the Ack_packet may include other packets being acknowledged; and that ACK may be</span></div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"> 2173</span><span class="comment">   * artificially delayed for reasons like the desire to accumulate more acknowledgments before</span></div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span><span class="comment">   * sending ACK (to cut down on overhead).</span></div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span><span class="comment">   *</span></div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_ESTABLISHED.</span></div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span><span class="comment">   * @param seq_num</span></div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span><span class="comment">   *        Sequence number of first datum in the packet to be acknowledged.</span></div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"> 2180</span><span class="comment">   * @param rexmit_id</span></div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"> 2181</span><span class="comment">   *        Which attempt are we acknowledging (0 = initial send, 1 = first retransmission, 2 =</span></div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"> 2182</span><span class="comment">   *        second retransmission, ...).  Always 0 if retransmission is off.</span></div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"> 2183</span><span class="comment">   * @param data_size</span></div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span><span class="comment">   *        Number of bytes in the user data in the packet to be acknowledged.</span></div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span><span class="comment">   */</span></div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"> 2186</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">async_acknowledge_packet</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rexmit_id,</div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span>                                <span class="keywordtype">size_t</span> data_size);</div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span><span class="comment"></span> </div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that handles any additional individual outgoing</span></div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span><span class="comment">   * acknowledgments accumulated during the currently running receive handler.  Pre-conditions:</span></div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"> 2192</span><span class="comment">   * executed from perform_accumulated_on_recv_tasks(); `!(Peer_socket::m_rcv_pending_acks).empty()`</span></div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"> 2193</span><span class="comment">   * for `sock`; Peer_socket::m_rcv_pending_acks_size_at_recv_handler_start (for `sock`) has been set;</span></div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"> 2194</span><span class="comment">   * `sock` is in #m_socks_with_accumulated_pending_acks.</span></div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"> 2195</span><span class="comment">   *</span></div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span><span class="comment">   * If state is not Peer_socket::Int_state::S_ESTABLISHED, method does nothing except possibly log.</span></div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span><span class="comment">   *</span></div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"> 2198</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"> 2202</span><span class="comment">   */</span></div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"> 2203</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">handle_accumulated_pending_acks</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"> 2204</span><span class="comment"></span> </div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"> 2205</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span><span class="comment">   * Helper for handle_data_to_established() that gets simple info about</span></div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span><span class="comment">   * Peer_socket::m_rcv_packets_with_gaps in `sock`.</span></div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span><span class="comment">   *</span></div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span><span class="comment">   *        Socket to examine.</span></div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span><span class="comment">   * @param first_gap_exists</span></div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"> 2212</span><span class="comment">   *        Pointer to value to set to true if and only if !(Peer_socket::m_rcv_packets_with_gaps).empty()</span></div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"> 2213</span><span class="comment">   *        in `sock`.  If the Peer_socket::m_rcv_packets_with_gaps invariant fully holds, this means that</span></div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"> 2214</span><span class="comment">   *        there is at least one gap of unreceived packets between some received packets and other received packets,</span></div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"> 2215</span><span class="comment">   *        by sequence number order.</span></div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span><span class="comment">   * @param seq_num_after_first_gap</span></div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span><span class="comment">   *        Pointer to value that will be set to the first sequence number of the first element of</span></div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span><span class="comment">   *        `sock-&gt;m_rcv_packets_with_gaps`; untouched if `!*first_gap_exists` at return.</span></div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span><span class="comment">   */</span></div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">rcv_get_first_gap_info</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock,</div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"> 2221</span>                              <span class="keywordtype">bool</span>* first_gap_exists, <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_after_first_gap);</div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"> 2222</span><span class="comment"></span> </div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"> 2223</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"> 2224</span><span class="comment">   * Logs TRACE or DATA messages that show the detailed state of the receiving sequence number</span></div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span><span class="comment">   * space.  Quite slow if DATA log level is enabled or `force_verbose_info_logging` is `true`.</span></div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span><span class="comment">   *</span></div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span><span class="comment">   *        Socket whose data to log.</span></div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span><span class="comment">   * @param force_verbose_info_logging</span></div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"> 2230</span><span class="comment">   *        If `true`, then the method acts as if DATA logging is enabled, i.e., the maximum amount of</span></div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"> 2231</span><span class="comment">   *        information is logged (but with INFO verbosity).  You should only do this if you know</span></div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"> 2232</span><span class="comment">   *        for a fact that this is being called infrequently (such as from</span></div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"> 2233</span><span class="comment">   *        perform_regular_infrequent_tasks()).</span></div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span><span class="comment">   */</span></div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">log_rcv_window</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <span class="keywordtype">bool</span> force_verbose_info_logging = <span class="keyword">false</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span><span class="comment"></span> </div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"> 2237</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given</span></div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"> 2239</span><span class="comment">   * peer socket in Peer_socket::Int_state::S_ESTABLISHED state.  This will hopefully</span></div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"> 2240</span><span class="comment">   * update internal data structures and inform congestion control (or queue that to be done by the end of the</span></div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"> 2241</span><span class="comment">   * current receive handler, low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming().</span></div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"> 2242</span><span class="comment">   *</span></div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_ESTABLISHED.</span></div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span><span class="comment">   * @param ack</span></div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span><span class="comment">   *        Deserialized immutable ACK.</span></div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span><span class="comment">   */</span></div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"> 2248</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">handle_ack_to_established</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"> 2249</span>                                 boost::shared_ptr&lt;const Ack_packet&gt; ack);</div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"> 2250</span><span class="comment"></span> </div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"> 2251</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and</span></div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span><span class="comment">   * rcv_wnd updates accumulated during the currently running receive handler.  Pre-conditions:</span></div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span><span class="comment">   * executed from perform_accumulated_on_recv_tasks(); Peer_socket::m_rcv_acked_packets and</span></div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span><span class="comment">   * Peer_socket::m_snd_pending_rcv_wnd (in `sock`) have been set; `sock` is in</span></div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span><span class="comment">   * #m_socks_with_accumulated_acks.</span></div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"> 2257</span><span class="comment">   *</span></div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"> 2258</span><span class="comment">   * If `sock` is not in Peer_socket::Int_state::S_ESTABLISHED, method does nothing except possibly log.</span></div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"> 2259</span><span class="comment">   *</span></div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"> 2260</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span><span class="comment">   */</span></div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"> 2265</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">handle_accumulated_acks</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"> 2266</span><span class="comment"></span> </div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"> 2267</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"> 2268</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that categorizes the given accumulated individual acknowledgment</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"> 2269</span><span class="comment">   * w/r/t legality and validity; determines the DATA packet being acked if possible; logs and record stats accordingly;</span></div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"> 2270</span><span class="comment">   * and closes underlying socket if ack is illegal.</span></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"> 2271</span><span class="comment">   *</span></div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"> 2272</span><span class="comment">   * In all cases, all relevant (to the categorization of the given ack) information is logged and stats are recorded.</span></div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"> 2273</span><span class="comment">   *</span></div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"> 2274</span><span class="comment">   * Furthermore, if the ack is illegal, the socket is closed (while `false` is returned).  Otherwise, `true` is</span></div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"> 2275</span><span class="comment">   * returned, and `*dupe_or_late` is set to indicate whether the ack is valid or not.  If valid,</span></div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"> 2276</span><span class="comment">   * `*acked_pkt_it` is definitely set to indicate which DATA packet is being acked.  If invalid, `*acked_pkt_it`</span></div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"> 2277</span><span class="comment">   * may or may not be set, as that information may or may not be available any longer (example of it being available:</span></div>
<div class="line"><a id="l02278" name="l02278"></a><span class="lineno"> 2278</span><span class="comment">   * the ack is for an earlier transmission attempt of packet P, but packet P is currently In-flight due to a</span></div>
<div class="line"><a id="l02279" name="l02279"></a><span class="lineno"> 2279</span><span class="comment">   * subsequent retransmission attempt).</span></div>
<div class="line"><a id="l02280" name="l02280"></a><span class="lineno"> 2280</span><span class="comment">   *</span></div>
<div class="line"><a id="l02281" name="l02281"></a><span class="lineno"> 2281</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02282" name="l02282"></a><span class="lineno"> 2282</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02283" name="l02283"></a><span class="lineno"> 2283</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02284" name="l02284"></a><span class="lineno"> 2284</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02285" name="l02285"></a><span class="lineno"> 2285</span><span class="comment">   * @param ack</span></div>
<div class="line"><a id="l02286" name="l02286"></a><span class="lineno"> 2286</span><span class="comment">   *        Individual acknowledgment being categorized.</span></div>
<div class="line"><a id="l02287" name="l02287"></a><span class="lineno"> 2287</span><span class="comment">   * @param dupe_or_late</span></div>
<div class="line"><a id="l02288" name="l02288"></a><span class="lineno"> 2288</span><span class="comment">   *        Set to false if ack refers to currently In-flight instance of a packet; true if no longer In-flight</span></div>
<div class="line"><a id="l02289" name="l02289"></a><span class="lineno"> 2289</span><span class="comment">   *        (late = considered Dropped laready; duplicate = was acked before); untouched if `false` returned.</span></div>
<div class="line"><a id="l02290" name="l02290"></a><span class="lineno"> 2290</span><span class="comment">   * @param acked_pkt_it</span></div>
<div class="line"><a id="l02291" name="l02291"></a><span class="lineno"> 2291</span><span class="comment">   *        Set to point into Peer_socket::m_snd_flying_pkts_by_sent_when that is being acked if `!*dupe_or_late`,</span></div>
<div class="line"><a id="l02292" name="l02292"></a><span class="lineno"> 2292</span><span class="comment">   *        or if `*dupe_or_late` but the acked packet is still known; set to `end()` a/k/a `past_oldest()`</span></div>
<div class="line"><a id="l02293" name="l02293"></a><span class="lineno"> 2293</span><span class="comment">   *        otherwise; untouched if `false`</span></div>
<div class="line"><a id="l02294" name="l02294"></a><span class="lineno"> 2294</span><span class="comment">   *        returned.</span></div>
<div class="line"><a id="l02295" name="l02295"></a><span class="lineno"> 2295</span><span class="comment">   * @return `false` if and only if the ack is sufficiently invalid to have made this method close the socket.</span></div>
<div class="line"><a id="l02296" name="l02296"></a><span class="lineno"> 2296</span><span class="comment">   */</span></div>
<div class="line"><a id="l02297" name="l02297"></a><span class="lineno"> 2297</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">categorize_individual_ack</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02298" name="l02298"></a><span class="lineno"> 2298</span>                                 <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack,</div>
<div class="line"><a id="l02299" name="l02299"></a><span class="lineno"> 2299</span>                                 <span class="keywordtype">bool</span>* dupe_or_late, <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>* acked_pkt_it);</div>
<div class="line"><a id="l02300" name="l02300"></a><span class="lineno"> 2300</span><span class="comment"></span> </div>
<div class="line"><a id="l02301" name="l02301"></a><span class="lineno"> 2301</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02302" name="l02302"></a><span class="lineno"> 2302</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that computes the RTT implied by a given individual acknowledgment.</span></div>
<div class="line"><a id="l02303" name="l02303"></a><span class="lineno"> 2303</span><span class="comment">   * In addition to returning the RTT, note the convenience out-param.</span></div>
<div class="line"><a id="l02304" name="l02304"></a><span class="lineno"> 2304</span><span class="comment">   *</span></div>
<div class="line"><a id="l02305" name="l02305"></a><span class="lineno"> 2305</span><span class="comment">   * @param flying_pkt</span></div>
<div class="line"><a id="l02306" name="l02306"></a><span class="lineno"> 2306</span><span class="comment">   *        The In-flight DATA packet to which the ack pertains.</span></div>
<div class="line"><a id="l02307" name="l02307"></a><span class="lineno"> 2307</span><span class="comment">   * @param time_now</span></div>
<div class="line"><a id="l02308" name="l02308"></a><span class="lineno"> 2308</span><span class="comment">   *        The current time to use for the RTT computation (not using value within to allow for caller to simulate</span></div>
<div class="line"><a id="l02309" name="l02309"></a><span class="lineno"> 2309</span><span class="comment">   *        simultaneity between nearby RTT computations).</span></div>
<div class="line"><a id="l02310" name="l02310"></a><span class="lineno"> 2310</span><span class="comment">   * @param ack</span></div>
<div class="line"><a id="l02311" name="l02311"></a><span class="lineno"> 2311</span><span class="comment">   *        Individual acknowledgment being categorized.</span></div>
<div class="line"><a id="l02312" name="l02312"></a><span class="lineno"> 2312</span><span class="comment">   * @param sent_when</span></div>
<div class="line"><a id="l02313" name="l02313"></a><span class="lineno"> 2313</span><span class="comment">   *        This out-param is set to point within Peer_socket::m_snd_flying_pkts_by_sent_when&#39;s `Sent_when`</span></div>
<div class="line"><a id="l02314" name="l02314"></a><span class="lineno"> 2314</span><span class="comment">   *        structure pertaining to the DATA packet send attempt to which `ack` refers.</span></div>
<div class="line"><a id="l02315" name="l02315"></a><span class="lineno"> 2315</span><span class="comment">   * @return The RTT.  May be zero.</span></div>
<div class="line"><a id="l02316" name="l02316"></a><span class="lineno"> 2316</span><span class="comment">   */</span></div>
<div class="line"><a id="l02317" name="l02317"></a><span class="lineno"> 2317</span>  <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">compute_rtt_on_ack</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Sent_packet::Const_ptr</a> flying_pkt,</div>
<div class="line"><a id="l02318" name="l02318"></a><span class="lineno"> 2318</span>                                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; time_now,</div>
<div class="line"><a id="l02319" name="l02319"></a><span class="lineno"> 2319</span>                                   <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">Ack_packet::Individual_ack::Const_ptr</a> ack,</div>
<div class="line"><a id="l02320" name="l02320"></a><span class="lineno"> 2320</span>                                   <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">Peer_socket::Sent_packet::Sent_when</a>** sent_when) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02321" name="l02321"></a><span class="lineno"> 2321</span><span class="comment"></span> </div>
<div class="line"><a id="l02322" name="l02322"></a><span class="lineno"> 2322</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02323" name="l02323"></a><span class="lineno"> 2323</span><span class="comment">   * Handles a just-computed new RTT (round trip time) measurement for an individual packet earlier</span></div>
<div class="line"><a id="l02324" name="l02324"></a><span class="lineno"> 2324</span><span class="comment">   * sent: updates smoothed RTT, DTO, and anything else relevant.</span></div>
<div class="line"><a id="l02325" name="l02325"></a><span class="lineno"> 2325</span><span class="comment">   *</span></div>
<div class="line"><a id="l02326" name="l02326"></a><span class="lineno"> 2326</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02327" name="l02327"></a><span class="lineno"> 2327</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_ESTABLISHED.</span></div>
<div class="line"><a id="l02328" name="l02328"></a><span class="lineno"> 2328</span><span class="comment">   * @param round_trip_time</span></div>
<div class="line"><a id="l02329" name="l02329"></a><span class="lineno"> 2329</span><span class="comment">   *        The RTT just computed, with as much resolution as is available.</span></div>
<div class="line"><a id="l02330" name="l02330"></a><span class="lineno"> 2330</span><span class="comment">   */</span></div>
<div class="line"><a id="l02331" name="l02331"></a><span class="lineno"> 2331</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">new_round_trip_time_sample</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> round_trip_time);</div>
<div class="line"><a id="l02332" name="l02332"></a><span class="lineno"> 2332</span><span class="comment"></span> </div>
<div class="line"><a id="l02333" name="l02333"></a><span class="lineno"> 2333</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02334" name="l02334"></a><span class="lineno"> 2334</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that should be</span></div>
<div class="line"><a id="l02335" name="l02335"></a><span class="lineno"> 2335</span><span class="comment">   * Dropped due to given individual acks that have just been processed; and updates the relevant `m_acks_after_me`</span></div>
<div class="line"><a id="l02336" name="l02336"></a><span class="lineno"> 2336</span><span class="comment">   * members in the socket.</span></div>
<div class="line"><a id="l02337" name="l02337"></a><span class="lineno"> 2337</span><span class="comment">   *</span></div>
<div class="line"><a id="l02338" name="l02338"></a><span class="lineno"> 2338</span><span class="comment">   * Logging is minimal, and no stats are recorded.  However, see associated drop_pkts_on_acks() method.</span></div>
<div class="line"><a id="l02339" name="l02339"></a><span class="lineno"> 2339</span><span class="comment">   *</span></div>
<div class="line"><a id="l02340" name="l02340"></a><span class="lineno"> 2340</span><span class="comment">   * Peer_socket::Sent_packet::m_acks_after_me data members, as documented, are incremented where relevant based</span></div>
<div class="line"><a id="l02341" name="l02341"></a><span class="lineno"> 2341</span><span class="comment">   * on the just-processed acks in `flying_now_acked_pkts`.</span></div>
<div class="line"><a id="l02342" name="l02342"></a><span class="lineno"> 2342</span><span class="comment">   *</span></div>
<div class="line"><a id="l02343" name="l02343"></a><span class="lineno"> 2343</span><span class="comment">   * Finally, the following In-flight packets must be considered Dropped due to acks:</span></div>
<div class="line"><a id="l02344" name="l02344"></a><span class="lineno"> 2344</span><span class="comment">   *   - The packet referred to by the returned iterator into Peer_socket::m_snd_flying_pkts_by_sent_when.</span></div>
<div class="line"><a id="l02345" name="l02345"></a><span class="lineno"> 2345</span><span class="comment">   *   - All packets contained in the same structure appearing later in it (i.e., sent out earlier), up to</span></div>
<div class="line"><a id="l02346" name="l02346"></a><span class="lineno"> 2346</span><span class="comment">   *     `past_oldest()` (a/k/a `end()`).</span></div>
<div class="line"><a id="l02347" name="l02347"></a><span class="lineno"> 2347</span><span class="comment">   *</span></div>
<div class="line"><a id="l02348" name="l02348"></a><span class="lineno"> 2348</span><span class="comment">   * Note that this method does not actually perform the various tasks: it only updates `m_acks_after_me` and</span></div>
<div class="line"><a id="l02349" name="l02349"></a><span class="lineno"> 2349</span><span class="comment">   * computes/returns the start of the to-be-Dropped range.  See drop_pkts_on_acks() for the actual dropping.</span></div>
<div class="line"><a id="l02350" name="l02350"></a><span class="lineno"> 2350</span><span class="comment">   *</span></div>
<div class="line"><a id="l02351" name="l02351"></a><span class="lineno"> 2351</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02352" name="l02352"></a><span class="lineno"> 2352</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02353" name="l02353"></a><span class="lineno"> 2353</span><span class="comment">   * @param flying_now_acked_pkts</span></div>
<div class="line"><a id="l02354" name="l02354"></a><span class="lineno"> 2354</span><span class="comment">   *        The individual DATA packet send attempts acks of which have just been processed.</span></div>
<div class="line"><a id="l02355" name="l02355"></a><span class="lineno"> 2355</span><span class="comment">   *        The Peer_socket::Sent_packet (and within it, the Peer_socket::Sent_packet::Sent_when) with the order ID</span></div>
<div class="line"><a id="l02356" name="l02356"></a><span class="lineno"> 2356</span><span class="comment">   *        P, where P is in `flying_now_acked_pkts`, must be in Peer_socket::m_snd_flying_pkts_by_sent_when.</span></div>
<div class="line"><a id="l02357" name="l02357"></a><span class="lineno"> 2357</span><span class="comment">   * @return Iterator into `sock-&gt;m_snd_flying_pkts_by_sent_when` indicating the latest-sent packet that should</span></div>
<div class="line"><a id="l02358" name="l02358"></a><span class="lineno"> 2358</span><span class="comment">   *         be Dropped due to acks; `past_oldest()` a/k/a `end()` if none should be so Dropped.</span></div>
<div class="line"><a id="l02359" name="l02359"></a><span class="lineno"> 2359</span><span class="comment">   */</span></div>
<div class="line"><a id="l02360" name="l02360"></a><span class="lineno"> 2360</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a></div>
<div class="line"><a id="l02361" name="l02361"></a><span class="lineno"> 2361</span>    <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">categorize_pkts_as_dropped_on_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02362" name="l02362"></a><span class="lineno"> 2362</span>                                       <span class="keyword">const</span> boost::unordered_set&lt;Peer_socket::order_num_t&gt;&amp; flying_now_acked_pkts);</div>
<div class="line"><a id="l02363" name="l02363"></a><span class="lineno"> 2363</span><span class="comment"></span> </div>
<div class="line"><a id="l02364" name="l02364"></a><span class="lineno"> 2364</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02365" name="l02365"></a><span class="lineno"> 2365</span><span class="comment">   * Helper of perform_accumulated_on_recv_tasks() that acts on the determination made by</span></div>
<div class="line"><a id="l02366" name="l02366"></a><span class="lineno"> 2366</span><span class="comment">   * categorize_pkts_as_dropped_on_acks().</span></div>
<div class="line"><a id="l02367" name="l02367"></a><span class="lineno"> 2367</span><span class="comment">   *</span></div>
<div class="line"><a id="l02368" name="l02368"></a><span class="lineno"> 2368</span><span class="comment">   * In all cases, all relevant (to the categorization of the In-flight packets as Dropped) information is logged</span></div>
<div class="line"><a id="l02369" name="l02369"></a><span class="lineno"> 2369</span><span class="comment">   * and stats are recorded.</span></div>
<div class="line"><a id="l02370" name="l02370"></a><span class="lineno"> 2370</span><span class="comment">   *</span></div>
<div class="line"><a id="l02371" name="l02371"></a><span class="lineno"> 2371</span><span class="comment">   * This acts, or gathers information necessary to act, on the determination by categorize_pkts_as_dropped_on_acks()</span></div>
<div class="line"><a id="l02372" name="l02372"></a><span class="lineno"> 2372</span><span class="comment">   * that a certain range of In-flight packets should be Dropped due to excess acks of packets sent before them.</span></div>
<div class="line"><a id="l02373" name="l02373"></a><span class="lineno"> 2373</span><span class="comment">   * Namely:</span></div>
<div class="line"><a id="l02374" name="l02374"></a><span class="lineno"> 2374</span><span class="comment">   *   - `*cong_ctl_dropped_...` are set to the values to report congestion control as part of a new loss event.</span></div>
<div class="line"><a id="l02375" name="l02375"></a><span class="lineno"> 2375</span><span class="comment">   *   - `*dropped_...` are set to values that indicate totals w/r/t the packets Dropped (regardless of whether it&#39;s</span></div>
<div class="line"><a id="l02376" name="l02376"></a><span class="lineno"> 2376</span><span class="comment">   *     a new or existing loss event).</span></div>
<div class="line"><a id="l02377" name="l02377"></a><span class="lineno"> 2377</span><span class="comment">   *   - `*pkts_marked_to_drop` are loaded with the Peer_socket::Sent_packet::Sent_when::m_order_num order IDs</span></div>
<div class="line"><a id="l02378" name="l02378"></a><span class="lineno"> 2378</span><span class="comment">   *     specifying the Dropped packets.</span></div>
<div class="line"><a id="l02379" name="l02379"></a><span class="lineno"> 2379</span><span class="comment">   *   - `sock` members `m_snd_flying_pkts*` and related are updated, meaning the newly Dropped packets are removed.</span></div>
<div class="line"><a id="l02380" name="l02380"></a><span class="lineno"> 2380</span><span class="comment">   *   - On the other hand, if retransmission is on, Peer_socket::m_snd_rexmit_q is pushed onto, gaining the</span></div>
<div class="line"><a id="l02381" name="l02381"></a><span class="lineno"> 2381</span><span class="comment">   *     just-Dropped packets to retransmit.</span></div>
<div class="line"><a id="l02382" name="l02382"></a><span class="lineno"> 2382</span><span class="comment">   *   - `true` is returned.</span></div>
<div class="line"><a id="l02383" name="l02383"></a><span class="lineno"> 2383</span><span class="comment">   *</span></div>
<div class="line"><a id="l02384" name="l02384"></a><span class="lineno"> 2384</span><span class="comment">   * However, if it is determined that a retransmission placed onto `sock-&gt;m_snd_rexmit_q` would indicate one</span></div>
<div class="line"><a id="l02385" name="l02385"></a><span class="lineno"> 2385</span><span class="comment">   * retransmission too many, the socket is closed, and `false` is returned.</span></div>
<div class="line"><a id="l02386" name="l02386"></a><span class="lineno"> 2386</span><span class="comment">   *</span></div>
<div class="line"><a id="l02387" name="l02387"></a><span class="lineno"> 2387</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02388" name="l02388"></a><span class="lineno"> 2388</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02389" name="l02389"></a><span class="lineno"> 2389</span><span class="comment">   * @param last_dropped_pkt_it</span></div>
<div class="line"><a id="l02390" name="l02390"></a><span class="lineno"> 2390</span><span class="comment">   *        Return value of of categorize_pkts_as_dropped_on_acks().</span></div>
<div class="line"><a id="l02391" name="l02391"></a><span class="lineno"> 2391</span><span class="comment">   * @param cong_ctl_dropped_pkts</span></div>
<div class="line"><a id="l02392" name="l02392"></a><span class="lineno"> 2392</span><span class="comment">   *        Will be set to total # of packets marked as Dropped to report to congestion control as part of</span></div>
<div class="line"><a id="l02393" name="l02393"></a><span class="lineno"> 2393</span><span class="comment">   *        a loss event (`&lt;= *dropped_pkts`).</span></div>
<div class="line"><a id="l02394" name="l02394"></a><span class="lineno"> 2394</span><span class="comment">   * @param cong_ctl_dropped_bytes</span></div>
<div class="line"><a id="l02395" name="l02395"></a><span class="lineno"> 2395</span><span class="comment">   *        Total data size corresponding to `cong_ctl_dropped_pkts` (`&lt;= *dropped_bytes)`).</span></div>
<div class="line"><a id="l02396" name="l02396"></a><span class="lineno"> 2396</span><span class="comment">   * @param dropped_pkts</span></div>
<div class="line"><a id="l02397" name="l02397"></a><span class="lineno"> 2397</span><span class="comment">   *        Will be set to total # of packets marked as Dropped by this method.</span></div>
<div class="line"><a id="l02398" name="l02398"></a><span class="lineno"> 2398</span><span class="comment">   * @param dropped_bytes</span></div>
<div class="line"><a id="l02399" name="l02399"></a><span class="lineno"> 2399</span><span class="comment">   *        Total data size corresponding to `dropped_pkts`.</span></div>
<div class="line"><a id="l02400" name="l02400"></a><span class="lineno"> 2400</span><span class="comment">   * @param pkts_marked_to_drop</span></div>
<div class="line"><a id="l02401" name="l02401"></a><span class="lineno"> 2401</span><span class="comment">   *        Will be filled with packet IDs (`sock-&gt;m_snd_flying_pkts_by_sent_when[...]-&gt;m_sent_when-&gt;m_order_num`)</span></div>
<div class="line"><a id="l02402" name="l02402"></a><span class="lineno"> 2402</span><span class="comment">   *        of the packets marked dropped by this method.  Results undefined unless empty at method start.</span></div>
<div class="line"><a id="l02403" name="l02403"></a><span class="lineno"> 2403</span><span class="comment">   * @return `true` normally; `false` if too many retransmissions detected, and thus `sock` was closed.</span></div>
<div class="line"><a id="l02404" name="l02404"></a><span class="lineno"> 2404</span><span class="comment">   */</span></div>
<div class="line"><a id="l02405" name="l02405"></a><span class="lineno"> 2405</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">drop_pkts_on_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02406" name="l02406"></a><span class="lineno"> 2406</span>                         <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; last_dropped_pkt_it,</div>
<div class="line"><a id="l02407" name="l02407"></a><span class="lineno"> 2407</span>                         <span class="keywordtype">size_t</span>* cong_ctl_dropped_pkts, <span class="keywordtype">size_t</span>* cong_ctl_dropped_bytes,</div>
<div class="line"><a id="l02408" name="l02408"></a><span class="lineno"> 2408</span>                         <span class="keywordtype">size_t</span>* dropped_pkts, <span class="keywordtype">size_t</span>* dropped_bytes,</div>
<div class="line"><a id="l02409" name="l02409"></a><span class="lineno"> 2409</span>                         std::vector&lt;Peer_socket::order_num_t&gt;* pkts_marked_to_drop);</div>
<div class="line"><a id="l02410" name="l02410"></a><span class="lineno"> 2410</span><span class="comment"></span> </div>
<div class="line"><a id="l02411" name="l02411"></a><span class="lineno"> 2411</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02412" name="l02412"></a><span class="lineno"> 2412</span><span class="comment">   * Helper of handle_accumulated_acks() that logs the about-to-be-handled accumulated individual acknowledgments.</span></div>
<div class="line"><a id="l02413" name="l02413"></a><span class="lineno"> 2413</span><span class="comment">   *</span></div>
<div class="line"><a id="l02414" name="l02414"></a><span class="lineno"> 2414</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02415" name="l02415"></a><span class="lineno"> 2415</span><span class="comment">   *        Peer socket with 0 or more accumulated acks recorded.</span></div>
<div class="line"><a id="l02416" name="l02416"></a><span class="lineno"> 2416</span><span class="comment">   */</span></div>
<div class="line"><a id="l02417" name="l02417"></a><span class="lineno"> 2417</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">log_accumulated_acks</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02418" name="l02418"></a><span class="lineno"> 2418</span><span class="comment"></span> </div>
<div class="line"><a id="l02419" name="l02419"></a><span class="lineno"> 2419</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02420" name="l02420"></a><span class="lineno"> 2420</span><span class="comment">   * Handles a Drop_timer (Peer_socket::m_snd_drop_timer) event in ESTABLISHED state by dropping the specified</span></div>
<div class="line"><a id="l02421" name="l02421"></a><span class="lineno"> 2421</span><span class="comment">   * packets.  To be executed as a Drop_timer callback.</span></div>
<div class="line"><a id="l02422" name="l02422"></a><span class="lineno"> 2422</span><span class="comment">   *</span></div>
<div class="line"><a id="l02423" name="l02423"></a><span class="lineno"> 2423</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02424" name="l02424"></a><span class="lineno"> 2424</span><span class="comment">   *        Peer socket is Peer_socket::Int_state::S_ESTABLISHED with at least one In-flight sent packet.</span></div>
<div class="line"><a id="l02425" name="l02425"></a><span class="lineno"> 2425</span><span class="comment">   * @param drop_all_packets</span></div>
<div class="line"><a id="l02426" name="l02426"></a><span class="lineno"> 2426</span><span class="comment">   *        If `true`, will consider all packets Dropped.  If `false`, will consider only the earliest</span></div>
<div class="line"><a id="l02427" name="l02427"></a><span class="lineno"> 2427</span><span class="comment">   *        In-flight packet dropped.</span></div>
<div class="line"><a id="l02428" name="l02428"></a><span class="lineno"> 2428</span><span class="comment">   */</span></div>
<div class="line"><a id="l02429" name="l02429"></a><span class="lineno"> 2429</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">drop_timer_action</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> drop_all_packets);</div>
<div class="line"><a id="l02430" name="l02430"></a><span class="lineno"> 2430</span><span class="comment"></span> </div>
<div class="line"><a id="l02431" name="l02431"></a><span class="lineno"> 2431</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02432" name="l02432"></a><span class="lineno"> 2432</span><span class="comment">   * Logs TRACE or DATA messages thats show the detailed state of the sending sequence number space.</span></div>
<div class="line"><a id="l02433" name="l02433"></a><span class="lineno"> 2433</span><span class="comment">   * Quite slow if DATA log level is enabled or `force_verbose_info_logging` is `true`.</span></div>
<div class="line"><a id="l02434" name="l02434"></a><span class="lineno"> 2434</span><span class="comment">   *</span></div>
<div class="line"><a id="l02435" name="l02435"></a><span class="lineno"> 2435</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02436" name="l02436"></a><span class="lineno"> 2436</span><span class="comment">   *        Socket whose data to log.</span></div>
<div class="line"><a id="l02437" name="l02437"></a><span class="lineno"> 2437</span><span class="comment">   * @param force_verbose_info_logging</span></div>
<div class="line"><a id="l02438" name="l02438"></a><span class="lineno"> 2438</span><span class="comment">   *        Similar to same argument in log_rcv_window().</span></div>
<div class="line"><a id="l02439" name="l02439"></a><span class="lineno"> 2439</span><span class="comment">   */</span></div>
<div class="line"><a id="l02440" name="l02440"></a><span class="lineno"> 2440</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">log_snd_window</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <span class="keywordtype">bool</span> force_verbose_info_logging = <span class="keyword">false</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02441" name="l02441"></a><span class="lineno"> 2441</span><span class="comment"></span> </div>
<div class="line"><a id="l02442" name="l02442"></a><span class="lineno"> 2442</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02443" name="l02443"></a><span class="lineno"> 2443</span><span class="comment">   * Thread W implementation of connect().  Performs all the needed work up to waiting for network</span></div>
<div class="line"><a id="l02444" name="l02444"></a><span class="lineno"> 2444</span><span class="comment">   * traffic, gives the resulting Peer_socket to the user thread, and signals that user thread.</span></div>
<div class="line"><a id="l02445" name="l02445"></a><span class="lineno"> 2445</span><span class="comment">   *</span></div>
<div class="line"><a id="l02446" name="l02446"></a><span class="lineno"> 2446</span><span class="comment">   * Pre-condition: We&#39;re in thread W; thread U != W is waiting for us to return having set `*sock`.  Post-condition:</span></div>
<div class="line"><a id="l02447" name="l02447"></a><span class="lineno"> 2447</span><span class="comment">   * `*sock` contains a Peer_socket::Ptr in an OPEN+CONNECTING state if `!(Peer_socket::m_disconnect_cause)`</span></div>
<div class="line"><a id="l02448" name="l02448"></a><span class="lineno"> 2448</span><span class="comment">   * for `*sock`; otherwise an error occurred, and that error is Peer_socket::m_disconnect_cause (in `*sock`).</span></div>
<div class="line"><a id="l02449" name="l02449"></a><span class="lineno"> 2449</span><span class="comment">   *</span></div>
<div class="line"><a id="l02450" name="l02450"></a><span class="lineno"> 2450</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l02451" name="l02451"></a><span class="lineno"> 2451</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l02452" name="l02452"></a><span class="lineno"> 2452</span><span class="comment">   * @param serialized_metadata</span></div>
<div class="line"><a id="l02453" name="l02453"></a><span class="lineno"> 2453</span><span class="comment">   *        Serialized metadata to provide to the peer when the connection is being established.</span></div>
<div class="line"><a id="l02454" name="l02454"></a><span class="lineno"> 2454</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l02455" name="l02455"></a><span class="lineno"> 2455</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l02456" name="l02456"></a><span class="lineno"> 2456</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02457" name="l02457"></a><span class="lineno"> 2457</span><span class="comment">   *        `*sock` shall be set to the resulting new Peer_socket.  Check `(*sock)-&gt;m_disconnect_cause`.</span></div>
<div class="line"><a id="l02458" name="l02458"></a><span class="lineno"> 2458</span><span class="comment">   */</span></div>
<div class="line"><a id="l02459" name="l02459"></a><span class="lineno"> 2459</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">connect_worker</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l02460" name="l02460"></a><span class="lineno"> 2460</span>                      <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l02461" name="l02461"></a><span class="lineno"> 2461</span>                      <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts,</div>
<div class="line"><a id="l02462" name="l02462"></a><span class="lineno"> 2462</span>                      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>* sock);</div>
<div class="line"><a id="l02463" name="l02463"></a><span class="lineno"> 2463</span><span class="comment"></span> </div>
<div class="line"><a id="l02464" name="l02464"></a><span class="lineno"> 2464</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02465" name="l02465"></a><span class="lineno"> 2465</span><span class="comment">   * Implementation core of `sync_connect*()` that gets rid of templated or missing arguments thereof.</span></div>
<div class="line"><a id="l02466" name="l02466"></a><span class="lineno"> 2466</span><span class="comment">   *</span></div>
<div class="line"><a id="l02467" name="l02467"></a><span class="lineno"> 2467</span><span class="comment">   * E.g., the API would wrap this and supply a Fine_duration instead of generic `duration`; and supply</span></div>
<div class="line"><a id="l02468" name="l02468"></a><span class="lineno"> 2468</span><span class="comment">   * `Fine_duration::max()` if user omitted the timeout argument.  Code bloat and possible circular definition issues</span></div>
<div class="line"><a id="l02469" name="l02469"></a><span class="lineno"> 2469</span><span class="comment">   * are among the reasons for this &quot;de-templating&quot; pattern.</span></div>
<div class="line"><a id="l02470" name="l02470"></a><span class="lineno"> 2470</span><span class="comment">   *</span></div>
<div class="line"><a id="l02471" name="l02471"></a><span class="lineno"> 2471</span><span class="comment">   * @param to</span></div>
<div class="line"><a id="l02472" name="l02472"></a><span class="lineno"> 2472</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l02473" name="l02473"></a><span class="lineno"> 2473</span><span class="comment">   * @param max_wait</span></div>
<div class="line"><a id="l02474" name="l02474"></a><span class="lineno"> 2474</span><span class="comment">   *        See the public `sync_connect(timeout)`.  `&quot;duration&lt;Rep, Period&gt;::max()&quot;` maps to the value</span></div>
<div class="line"><a id="l02475" name="l02475"></a><span class="lineno"> 2475</span><span class="comment">   *        `Fine_duration::max()` for this argument.</span></div>
<div class="line"><a id="l02476" name="l02476"></a><span class="lineno"> 2476</span><span class="comment">   * @param serialized_metadata</span></div>
<div class="line"><a id="l02477" name="l02477"></a><span class="lineno"> 2477</span><span class="comment">   *        See connect_with_metadata().</span></div>
<div class="line"><a id="l02478" name="l02478"></a><span class="lineno"> 2478</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02479" name="l02479"></a><span class="lineno"> 2479</span><span class="comment">   *        See sync_connect().</span></div>
<div class="line"><a id="l02480" name="l02480"></a><span class="lineno"> 2480</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l02481" name="l02481"></a><span class="lineno"> 2481</span><span class="comment">   *        See connect().</span></div>
<div class="line"><a id="l02482" name="l02482"></a><span class="lineno"> 2482</span><span class="comment">   * @return See sync_connect().</span></div>
<div class="line"><a id="l02483" name="l02483"></a><span class="lineno"> 2483</span><span class="comment">   */</span></div>
<div class="line"><a id="l02484" name="l02484"></a><span class="lineno"> 2484</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">sync_connect_impl</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a>&amp; max_wait,</div>
<div class="line"><a id="l02485" name="l02485"></a><span class="lineno"> 2485</span>                                     <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l02486" name="l02486"></a><span class="lineno"> 2486</span>                                     <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code,</div>
<div class="line"><a id="l02487" name="l02487"></a><span class="lineno"> 2487</span>                                     <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts);</div>
<div class="line"><a id="l02488" name="l02488"></a><span class="lineno"> 2488</span><span class="comment"></span> </div>
<div class="line"><a id="l02489" name="l02489"></a><span class="lineno"> 2489</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02490" name="l02490"></a><span class="lineno"> 2490</span><span class="comment">   * Assuming we&#39;ve just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some</span></div>
<div class="line"><a id="l02491" name="l02491"></a><span class="lineno"> 2491</span><span class="comment">   * amount of time, so that we may try the SYN[_ACK] again if we don&#39;t get the acknowledgement by</span></div>
<div class="line"><a id="l02492" name="l02492"></a><span class="lineno"> 2492</span><span class="comment">   * then (or we may close socket after too many such retries).  If `initial` is `true`, an overall</span></div>
<div class="line"><a id="l02493" name="l02493"></a><span class="lineno"> 2493</span><span class="comment">   * connection timeout scheduled task is also set up, to trigger the aforementioned close on timeout.</span></div>
<div class="line"><a id="l02494" name="l02494"></a><span class="lineno"> 2494</span><span class="comment">   *</span></div>
<div class="line"><a id="l02495" name="l02495"></a><span class="lineno"> 2495</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02496" name="l02496"></a><span class="lineno"> 2496</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02497" name="l02497"></a><span class="lineno"> 2497</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02498" name="l02498"></a><span class="lineno"> 2498</span><span class="comment">   *        Peer socket in SYN_SENT or SYN_RCVD internal state.</span></div>
<div class="line"><a id="l02499" name="l02499"></a><span class="lineno"> 2499</span><span class="comment">   * @param initial</span></div>
<div class="line"><a id="l02500" name="l02500"></a><span class="lineno"> 2500</span><span class="comment">   *        `true` if and only if the first SYN or SYN_ACK; otherwise it is a retry.</span></div>
<div class="line"><a id="l02501" name="l02501"></a><span class="lineno"> 2501</span><span class="comment">   */</span></div>
<div class="line"><a id="l02502" name="l02502"></a><span class="lineno"> 2502</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">setup_connection_timers</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> initial);</div>
<div class="line"><a id="l02503" name="l02503"></a><span class="lineno"> 2503</span><span class="comment"></span> </div>
<div class="line"><a id="l02504" name="l02504"></a><span class="lineno"> 2504</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02505" name="l02505"></a><span class="lineno"> 2505</span><span class="comment">   * Handles the triggering of the retransmit timer wait set up by</span></div>
<div class="line"><a id="l02506" name="l02506"></a><span class="lineno"> 2506</span><span class="comment">   * setup_connection_timers(); it will re-send the SYN or SYN_ACK.</span></div>
<div class="line"><a id="l02507" name="l02507"></a><span class="lineno"> 2507</span><span class="comment">   *</span></div>
<div class="line"><a id="l02508" name="l02508"></a><span class="lineno"> 2508</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02509" name="l02509"></a><span class="lineno"> 2509</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02510" name="l02510"></a><span class="lineno"> 2510</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02511" name="l02511"></a><span class="lineno"> 2511</span><span class="comment">   *        Peer socket.</span></div>
<div class="line"><a id="l02512" name="l02512"></a><span class="lineno"> 2512</span><span class="comment">   */</span></div>
<div class="line"><a id="l02513" name="l02513"></a><span class="lineno"> 2513</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">handle_connection_rexmit_timer_event</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02514" name="l02514"></a><span class="lineno"> 2514</span><span class="comment"></span> </div>
<div class="line"><a id="l02515" name="l02515"></a><span class="lineno"> 2515</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02516" name="l02516"></a><span class="lineno"> 2516</span><span class="comment">   * Cancel any timers and scheduled tasks active in the given socket.  More precisely, causes for each handler</span></div>
<div class="line"><a id="l02517" name="l02517"></a><span class="lineno"> 2517</span><span class="comment">   * scheduled to happen in the future to be called as soon as possible with error code</span></div>
<div class="line"><a id="l02518" name="l02518"></a><span class="lineno"> 2518</span><span class="comment">   * `operation_aborted`.  If, by the time the current handler has begun, the handler was about to be</span></div>
<div class="line"><a id="l02519" name="l02519"></a><span class="lineno"> 2519</span><span class="comment">   * called due the timer triggering, this method will not be able to induce `operation_aborted`.</span></div>
<div class="line"><a id="l02520" name="l02520"></a><span class="lineno"> 2520</span><span class="comment">   * Therefore the handler should be careful to check state and not rely on `operation_aborted`,</span></div>
<div class="line"><a id="l02521" name="l02521"></a><span class="lineno"> 2521</span><span class="comment">   * despite this method.</span></div>
<div class="line"><a id="l02522" name="l02522"></a><span class="lineno"> 2522</span><span class="comment">   *</span></div>
<div class="line"><a id="l02523" name="l02523"></a><span class="lineno"> 2523</span><span class="comment">   * Update: The caveats in previous paragraph do not apply to scheduled tasks (`util::schedule_task_*()`).</span></div>
<div class="line"><a id="l02524" name="l02524"></a><span class="lineno"> 2524</span><span class="comment">   * Canceling such tasks (which this method also does) prevents their handlers from running.</span></div>
<div class="line"><a id="l02525" name="l02525"></a><span class="lineno"> 2525</span><span class="comment">   *</span></div>
<div class="line"><a id="l02526" name="l02526"></a><span class="lineno"> 2526</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02527" name="l02527"></a><span class="lineno"> 2527</span><span class="comment">   *        Socket whose timers/scheduled tasks to abort.</span></div>
<div class="line"><a id="l02528" name="l02528"></a><span class="lineno"> 2528</span><span class="comment">   */</span></div>
<div class="line"><a id="l02529" name="l02529"></a><span class="lineno"> 2529</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">cancel_timers</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02530" name="l02530"></a><span class="lineno"> 2530</span><span class="comment"></span> </div>
<div class="line"><a id="l02531" name="l02531"></a><span class="lineno"> 2531</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02532" name="l02532"></a><span class="lineno"> 2532</span><span class="comment">   * Creates a new Drop Timer and saves it to `sock-&gt;m_snd_drop_timer`.  Pre-condition: `m_int_state ==</span></div>
<div class="line"><a id="l02533" name="l02533"></a><span class="lineno"> 2533</span><span class="comment">   * S_ESTABLISHED`, and `sock-&gt;m_snd_drop_timer` is null.</span></div>
<div class="line"><a id="l02534" name="l02534"></a><span class="lineno"> 2534</span><span class="comment">   *</span></div>
<div class="line"><a id="l02535" name="l02535"></a><span class="lineno"> 2535</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02536" name="l02536"></a><span class="lineno"> 2536</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02537" name="l02537"></a><span class="lineno"> 2537</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02538" name="l02538"></a><span class="lineno"> 2538</span><span class="comment">   *        Socket that just entered ESTABLISHED state.</span></div>
<div class="line"><a id="l02539" name="l02539"></a><span class="lineno"> 2539</span><span class="comment">   */</span></div>
<div class="line"><a id="l02540" name="l02540"></a><span class="lineno"> 2540</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">setup_drop_timer</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02541" name="l02541"></a><span class="lineno"> 2541</span><span class="comment"></span> </div>
<div class="line"><a id="l02542" name="l02542"></a><span class="lineno"> 2542</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02543" name="l02543"></a><span class="lineno"> 2543</span><span class="comment">   * Implementation of non-blocking `sock-&gt;close_abruptly()` for socket `sock` in all cases except when</span></div>
<div class="line"><a id="l02544" name="l02544"></a><span class="lineno"> 2544</span><span class="comment">   * `sock-&gt;state() == State::S_CLOSED`.  See Peer_socket::close_abruptly() doc</span></div>
<div class="line"><a id="l02545" name="l02545"></a><span class="lineno"> 2545</span><span class="comment">   * header; this method is the entirety of that method&#39;s implementation after CLOSED is</span></div>
<div class="line"><a id="l02546" name="l02546"></a><span class="lineno"> 2546</span><span class="comment">   * eliminated as a possibility.</span></div>
<div class="line"><a id="l02547" name="l02547"></a><span class="lineno"> 2547</span><span class="comment">   *</span></div>
<div class="line"><a id="l02548" name="l02548"></a><span class="lineno"> 2548</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l02549" name="l02549"></a><span class="lineno"> 2549</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l02550" name="l02550"></a><span class="lineno"> 2550</span><span class="comment">   *   - `sock-&gt;m_mutex` is locked and just after entering `sock-&gt;close_abruptly()`;</span></div>
<div class="line"><a id="l02551" name="l02551"></a><span class="lineno"> 2551</span><span class="comment">   *   - no changes to `*sock` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l02552" name="l02552"></a><span class="lineno"> 2552</span><span class="comment">   *   - `sock-&gt;state() == Stated::S_OPEN` (so `sock` is in #m_socks);</span></div>
<div class="line"><a id="l02553" name="l02553"></a><span class="lineno"> 2553</span><span class="comment">   *   - `sock` has been given to user via accept() or connect() or friends.</span></div>
<div class="line"><a id="l02554" name="l02554"></a><span class="lineno"> 2554</span><span class="comment">   *</span></div>
<div class="line"><a id="l02555" name="l02555"></a><span class="lineno"> 2555</span><span class="comment">   * Post-condition (not exhaustive): `sock-&gt;m_mutex` is unlocked.</span></div>
<div class="line"><a id="l02556" name="l02556"></a><span class="lineno"> 2556</span><span class="comment">   *</span></div>
<div class="line"><a id="l02557" name="l02557"></a><span class="lineno"> 2557</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02558" name="l02558"></a><span class="lineno"> 2558</span><span class="comment">   *        Socket in OPEN state.</span></div>
<div class="line"><a id="l02559" name="l02559"></a><span class="lineno"> 2559</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02560" name="l02560"></a><span class="lineno"> 2560</span><span class="comment">   *        See Peer_socket::close_abruptly().</span></div>
<div class="line"><a id="l02561" name="l02561"></a><span class="lineno"> 2561</span><span class="comment">   */</span></div>
<div class="line"><a id="l02562" name="l02562"></a><span class="lineno"> 2562</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">close_abruptly</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l02563" name="l02563"></a><span class="lineno"> 2563</span><span class="comment"></span> </div>
<div class="line"><a id="l02564" name="l02564"></a><span class="lineno"> 2564</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02565" name="l02565"></a><span class="lineno"> 2565</span><span class="comment">   * A thread W method that handles the transition of the given socket from OPEN (any sub-state)</span></div>
<div class="line"><a id="l02566" name="l02566"></a><span class="lineno"> 2566</span><span class="comment">   * to CLOSED (including eliminating the given Peer_socket from our data structures).  For</span></div>
<div class="line"><a id="l02567" name="l02567"></a><span class="lineno"> 2567</span><span class="comment">   * example, if an invalid packet comes in on the socket, and we send back an RST, then we&#39;re free</span></div>
<div class="line"><a id="l02568" name="l02568"></a><span class="lineno"> 2568</span><span class="comment">   * to then close our side immediately, as no further communication (with the other side or the</span></div>
<div class="line"><a id="l02569" name="l02569"></a><span class="lineno"> 2569</span><span class="comment">   * local user) is needed.  As another example, if we there is a graceful close while Receive buffer</span></div>
<div class="line"><a id="l02570" name="l02570"></a><span class="lineno"> 2570</span><span class="comment">   * has data, user must Receive all of it, and the final handshake must finish, and then this is called.</span></div>
<div class="line"><a id="l02571" name="l02571"></a><span class="lineno"> 2571</span><span class="comment">   *</span></div>
<div class="line"><a id="l02572" name="l02572"></a><span class="lineno"> 2572</span><span class="comment">   * @todo Graceful close not yet implemented w/r/t close_connection_immediately().</span></div>
<div class="line"><a id="l02573" name="l02573"></a><span class="lineno"> 2573</span><span class="comment">   *</span></div>
<div class="line"><a id="l02574" name="l02574"></a><span class="lineno"> 2574</span><span class="comment">   * Pre-condition: if `err_code` is failure: `sock` is in #m_socks; `sock-&gt;state() == S_OPEN` (and any</span></div>
<div class="line"><a id="l02575" name="l02575"></a><span class="lineno"> 2575</span><span class="comment">   * `sock-&gt;m_int_state` that corresponds to it); `err_code` contains the reason for the close.</span></div>
<div class="line"><a id="l02576" name="l02576"></a><span class="lineno"> 2576</span><span class="comment">   *</span></div>
<div class="line"><a id="l02577" name="l02577"></a><span class="lineno"> 2577</span><span class="comment">   * Pre-condition: if `err_code` is success: `sock` is in #m_socks; `sock` state is</span></div>
<div class="line"><a id="l02578" name="l02578"></a><span class="lineno"> 2578</span><span class="comment">   * OPEN+DISCONNECTING; `m_int_state` is CLOSED; Send and Receive buffers are empty;</span></div>
<div class="line"><a id="l02579" name="l02579"></a><span class="lineno"> 2579</span><span class="comment">   * `m_disconnect_cause` is not success.</span></div>
<div class="line"><a id="l02580" name="l02580"></a><span class="lineno"> 2580</span><span class="comment">   *</span></div>
<div class="line"><a id="l02581" name="l02581"></a><span class="lineno"> 2581</span><span class="comment">   * Post-condition: `sock` Receive and Send buffers are empty; `sock-&gt;state() == S_CLOSED` (and `sock`</span></div>
<div class="line"><a id="l02582" name="l02582"></a><span class="lineno"> 2582</span><span class="comment">   * is no longer in #m_socks or any other Node structures, directly or indirectly) with</span></div>
<div class="line"><a id="l02583" name="l02583"></a><span class="lineno"> 2583</span><span class="comment">   * `sock-&gt;m_disconnect_cause` set to reason for closing.  Other decently memory-consuming structures</span></div>
<div class="line"><a id="l02584" name="l02584"></a><span class="lineno"> 2584</span><span class="comment">   * are also cleared to conserve memory.</span></div>
<div class="line"><a id="l02585" name="l02585"></a><span class="lineno"> 2585</span><span class="comment">   *</span></div>
<div class="line"><a id="l02586" name="l02586"></a><span class="lineno"> 2586</span><span class="comment">   * Any socket that is in #m_socks MUST be eventually closed using this method.  No</span></div>
<div class="line"><a id="l02587" name="l02587"></a><span class="lineno"> 2587</span><span class="comment">   * socket that is not in #m_socks must be passed to this method.  In particular, do not call this</span></div>
<div class="line"><a id="l02588" name="l02588"></a><span class="lineno"> 2588</span><span class="comment">   * method during connect() or handle_syn_to_listening_server().</span></div>
<div class="line"><a id="l02589" name="l02589"></a><span class="lineno"> 2589</span><span class="comment">   *</span></div>
<div class="line"><a id="l02590" name="l02590"></a><span class="lineno"> 2590</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02591" name="l02591"></a><span class="lineno"> 2591</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l02592" name="l02592"></a><span class="lineno"> 2592</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02593" name="l02593"></a><span class="lineno"> 2593</span><span class="comment">   *        Socket to close.</span></div>
<div class="line"><a id="l02594" name="l02594"></a><span class="lineno"> 2594</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02595" name="l02595"></a><span class="lineno"> 2595</span><span class="comment">   *        If this is not success, then it is an abrupt close, and this is why `sock` is being</span></div>
<div class="line"><a id="l02596" name="l02596"></a><span class="lineno"> 2596</span><span class="comment">   *        abruptly closed.  `m_disconnect_cause` is set accordingly and logged.</span></div>
<div class="line"><a id="l02597" name="l02597"></a><span class="lineno"> 2597</span><span class="comment">   *        If `err_code` is failure, then: `sock` is OPEN+DISCONNECTING (graceful close), and all</span></div>
<div class="line"><a id="l02598" name="l02598"></a><span class="lineno"> 2598</span><span class="comment">   *        criteria required for it to move so CLOSED are satisfied: internal state is CLOSED</span></div>
<div class="line"><a id="l02599" name="l02599"></a><span class="lineno"> 2599</span><span class="comment">   *        (goodbye handshake finished), and Receive and Send buffers are empty; `m_disconnect_cause`</span></div>
<div class="line"><a id="l02600" name="l02600"></a><span class="lineno"> 2600</span><span class="comment">   *        is already set.</span></div>
<div class="line"><a id="l02601" name="l02601"></a><span class="lineno"> 2601</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l02602" name="l02602"></a><span class="lineno"> 2602</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l02603" name="l02603"></a><span class="lineno"> 2603</span><span class="comment">   */</span></div>
<div class="line"><a id="l02604" name="l02604"></a><span class="lineno"> 2604</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">close_connection_immediately</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02605" name="l02605"></a><span class="lineno"> 2605</span>                                    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l02606" name="l02606"></a><span class="lineno"> 2606</span><span class="comment"></span> </div>
<div class="line"><a id="l02607" name="l02607"></a><span class="lineno"> 2607</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02608" name="l02608"></a><span class="lineno"> 2608</span><span class="comment">   * Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to</span></div>
<div class="line"><a id="l02609" name="l02609"></a><span class="lineno"> 2609</span><span class="comment">   * async_sock_low_lvl_packet_send_paced().  `sock` members that reflect any data in Syn_packet must already be</span></div>
<div class="line"><a id="l02610" name="l02610"></a><span class="lineno"> 2610</span><span class="comment">   * saved and are not used as the source for such data.</span></div>
<div class="line"><a id="l02611" name="l02611"></a><span class="lineno"> 2611</span><span class="comment">   *</span></div>
<div class="line"><a id="l02612" name="l02612"></a><span class="lineno"> 2612</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02613" name="l02613"></a><span class="lineno"> 2613</span><span class="comment">   *        See async_sock_low_lvl_packet_send().</span></div>
<div class="line"><a id="l02614" name="l02614"></a><span class="lineno"> 2614</span><span class="comment">   * @return Pointer to new packet object suitable for async_sock_low_lvl_packet_send_paced() without having to fill</span></div>
<div class="line"><a id="l02615" name="l02615"></a><span class="lineno"> 2615</span><span class="comment">   *         any further data members in the object.</span></div>
<div class="line"><a id="l02616" name="l02616"></a><span class="lineno"> 2616</span><span class="comment">   */</span></div>
<div class="line"><a id="l02617" name="l02617"></a><span class="lineno"> 2617</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_packet::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">create_syn</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock);</div>
<div class="line"><a id="l02618" name="l02618"></a><span class="lineno"> 2618</span><span class="comment"></span> </div>
<div class="line"><a id="l02619" name="l02619"></a><span class="lineno"> 2619</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02620" name="l02620"></a><span class="lineno"> 2620</span><span class="comment">   * Like create_syn() but for SYN_ACK.</span></div>
<div class="line"><a id="l02621" name="l02621"></a><span class="lineno"> 2621</span><span class="comment">   *</span></div>
<div class="line"><a id="l02622" name="l02622"></a><span class="lineno"> 2622</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02623" name="l02623"></a><span class="lineno"> 2623</span><span class="comment">   *        See create_syn().</span></div>
<div class="line"><a id="l02624" name="l02624"></a><span class="lineno"> 2624</span><span class="comment">   * @return See create_syn().</span></div>
<div class="line"><a id="l02625" name="l02625"></a><span class="lineno"> 2625</span><span class="comment">   */</span></div>
<div class="line"><a id="l02626" name="l02626"></a><span class="lineno"> 2626</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Syn_ack_packet::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">create_syn_ack</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock);</div>
<div class="line"><a id="l02627" name="l02627"></a><span class="lineno"> 2627</span><span class="comment"></span> </div>
<div class="line"><a id="l02628" name="l02628"></a><span class="lineno"> 2628</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02629" name="l02629"></a><span class="lineno"> 2629</span><span class="comment">   * Helper to create, fully fill out, and asynchronously send via async_sock_low_lvl_packet_send_or_close_immediately()</span></div>
<div class="line"><a id="l02630" name="l02630"></a><span class="lineno"> 2630</span><span class="comment">   * a SYN_ACK_ACK packet.  Since rcv_wnd is advertised, Peer_socket::m_rcv_last_sent_rcv_wnd is updated for `sock`.</span></div>
<div class="line"><a id="l02631" name="l02631"></a><span class="lineno"> 2631</span><span class="comment">   *</span></div>
<div class="line"><a id="l02632" name="l02632"></a><span class="lineno"> 2632</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02633" name="l02633"></a><span class="lineno"> 2633</span><span class="comment">   *        See async_sock_low_lvl_packet_send().</span></div>
<div class="line"><a id="l02634" name="l02634"></a><span class="lineno"> 2634</span><span class="comment">   * @param syn_ack</span></div>
<div class="line"><a id="l02635" name="l02635"></a><span class="lineno"> 2635</span><span class="comment">   *        SYN_ACK to which the resulting SYN_ACK_ACK is the reply.</span></div>
<div class="line"><a id="l02636" name="l02636"></a><span class="lineno"> 2636</span><span class="comment">   * @return See async_sock_low_lvl_packet_send().</span></div>
<div class="line"><a id="l02637" name="l02637"></a><span class="lineno"> 2637</span><span class="comment">   */</span></div>
<div class="line"><a id="l02638" name="l02638"></a><span class="lineno"> 2638</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#acaf55766783893827061fd85cab2634f">async_low_lvl_syn_ack_ack_send_or_close_immediately</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&amp; sock,</div>
<div class="line"><a id="l02639" name="l02639"></a><span class="lineno"> 2639</span>                                                           boost::shared_ptr&lt;const Syn_ack_packet&gt;&amp; syn_ack);</div>
<div class="line"><a id="l02640" name="l02640"></a><span class="lineno"> 2640</span><span class="comment"></span> </div>
<div class="line"><a id="l02641" name="l02641"></a><span class="lineno"> 2641</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02642" name="l02642"></a><span class="lineno"> 2642</span><span class="comment">   * Asynchronously send RST to the other side of the given socket and</span></div>
<div class="line"><a id="l02643" name="l02643"></a><span class="lineno"> 2643</span><span class="comment">   * close_connection_immediately().</span></div>
<div class="line"><a id="l02644" name="l02644"></a><span class="lineno"> 2644</span><span class="comment">   *</span></div>
<div class="line"><a id="l02645" name="l02645"></a><span class="lineno"> 2645</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l02646" name="l02646"></a><span class="lineno"> 2646</span><span class="comment">   *        See close_connection_immediately().</span></div>
<div class="line"><a id="l02647" name="l02647"></a><span class="lineno"> 2647</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02648" name="l02648"></a><span class="lineno"> 2648</span><span class="comment">   *        See close_connection_immediately().</span></div>
<div class="line"><a id="l02649" name="l02649"></a><span class="lineno"> 2649</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02650" name="l02650"></a><span class="lineno"> 2650</span><span class="comment">   *        See close_connection_immediately().</span></div>
<div class="line"><a id="l02651" name="l02651"></a><span class="lineno"> 2651</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l02652" name="l02652"></a><span class="lineno"> 2652</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l02653" name="l02653"></a><span class="lineno"> 2653</span><span class="comment">   */</span></div>
<div class="line"><a id="l02654" name="l02654"></a><span class="lineno"> 2654</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">rst_and_close_connection_immediately</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02655" name="l02655"></a><span class="lineno"> 2655</span>                                            <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l02656" name="l02656"></a><span class="lineno"> 2656</span><span class="comment"></span> </div>
<div class="line"><a id="l02657" name="l02657"></a><span class="lineno"> 2657</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02658" name="l02658"></a><span class="lineno"> 2658</span><span class="comment">   * Implementation of non-blocking `sock-&gt;send()` for socket `sock` in all cases except when</span></div>
<div class="line"><a id="l02659" name="l02659"></a><span class="lineno"> 2659</span><span class="comment">   * `sock-&gt;state() == State::S_CLOSED`.</span></div>
<div class="line"><a id="l02660" name="l02660"></a><span class="lineno"> 2660</span><span class="comment">   *</span></div>
<div class="line"><a id="l02661" name="l02661"></a><span class="lineno"> 2661</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l02662" name="l02662"></a><span class="lineno"> 2662</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l02663" name="l02663"></a><span class="lineno"> 2663</span><span class="comment">   *   - `sock-&gt;m_mutex` is locked and after entering `sock-&gt;[sync_]send()`;</span></div>
<div class="line"><a id="l02664" name="l02664"></a><span class="lineno"> 2664</span><span class="comment">   *   - no changes to `*sock` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l02665" name="l02665"></a><span class="lineno"> 2665</span><span class="comment">   *   - `sock-&gt;state() == State::S_OPEN` (so `sock` is in #m_socks);</span></div>
<div class="line"><a id="l02666" name="l02666"></a><span class="lineno"> 2666</span><span class="comment">   *   - `snd_buf_feed_func is as described below.</span></div>
<div class="line"><a id="l02667" name="l02667"></a><span class="lineno"> 2667</span><span class="comment">   *</span></div>
<div class="line"><a id="l02668" name="l02668"></a><span class="lineno"> 2668</span><span class="comment">   * This method completes the functionality of `sock-&gt;send()`.</span></div>
<div class="line"><a id="l02669" name="l02669"></a><span class="lineno"> 2669</span><span class="comment">   *</span></div>
<div class="line"><a id="l02670" name="l02670"></a><span class="lineno"> 2670</span><span class="comment">   * @see Important: see giant comment inside Node::send() for overall design and how send_worker()</span></div>
<div class="line"><a id="l02671" name="l02671"></a><span class="lineno"> 2671</span><span class="comment">   *      fits into it.</span></div>
<div class="line"><a id="l02672" name="l02672"></a><span class="lineno"> 2672</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02673" name="l02673"></a><span class="lineno"> 2673</span><span class="comment">   *        Socket, which must be in #m_socks, on which `[sync_]send()` was called.</span></div>
<div class="line"><a id="l02674" name="l02674"></a><span class="lineno"> 2674</span><span class="comment">   * @param snd_buf_feed_func</span></div>
<div class="line"><a id="l02675" name="l02675"></a><span class="lineno"> 2675</span><span class="comment">   *        Pointer to function with signature `size_t fn(size_t x)` that will perform</span></div>
<div class="line"><a id="l02676" name="l02676"></a><span class="lineno"> 2676</span><span class="comment">   *        `sock-&gt;m_snd_buf.feed_bufs_copy(...)` call with `max_data_size == X`, which will feed the</span></div>
<div class="line"><a id="l02677" name="l02677"></a><span class="lineno"> 2677</span><span class="comment">   *        data the user wants to `sock-&gt;send()` into `sock-&gt;m_snd_buf`, and return the return value</span></div>
<div class="line"><a id="l02678" name="l02678"></a><span class="lineno"> 2678</span><span class="comment">   *        of that call (which indicates how many bytes the call was able to fit into `m_snd_buf`).</span></div>
<div class="line"><a id="l02679" name="l02679"></a><span class="lineno"> 2679</span><span class="comment">   *        Doing it this way prevents this Node::send() from being a template, which prevents</span></div>
<div class="line"><a id="l02680" name="l02680"></a><span class="lineno"> 2680</span><span class="comment">   *        circular dependency unpleasantness.  See Peer_socket::send() for details.</span></div>
<div class="line"><a id="l02681" name="l02681"></a><span class="lineno"> 2681</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02682" name="l02682"></a><span class="lineno"> 2682</span><span class="comment">   *        See Peer_socket::send().</span></div>
<div class="line"><a id="l02683" name="l02683"></a><span class="lineno"> 2683</span><span class="comment">   * @return See Peer_socket::send().</span></div>
<div class="line"><a id="l02684" name="l02684"></a><span class="lineno"> 2684</span><span class="comment">   */</span></div>
<div class="line"><a id="l02685" name="l02685"></a><span class="lineno"> 2685</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02686" name="l02686"></a><span class="lineno"> 2686</span>              <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> (<span class="keywordtype">size_t</span> max_data_size)&gt;&amp; snd_buf_feed_func,</div>
<div class="line"><a id="l02687" name="l02687"></a><span class="lineno"> 2687</span>              <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l02688" name="l02688"></a><span class="lineno"> 2688</span><span class="comment"></span> </div>
<div class="line"><a id="l02689" name="l02689"></a><span class="lineno"> 2689</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02690" name="l02690"></a><span class="lineno"> 2690</span><span class="comment">   * Returns `true` if and only if calling `sock-&gt;send()` with at least some arguments would return</span></div>
<div class="line"><a id="l02691" name="l02691"></a><span class="lineno"> 2691</span><span class="comment">   * either non-zero (i.e., successfully enqueued data to send) or zero and an error (but not</span></div>
<div class="line"><a id="l02692" name="l02692"></a><span class="lineno"> 2692</span><span class="comment">   * zero and NO error).  `sock` will be locked and unlocked; safe to call from any thread.</span></div>
<div class="line"><a id="l02693" name="l02693"></a><span class="lineno"> 2693</span><span class="comment">   *</span></div>
<div class="line"><a id="l02694" name="l02694"></a><span class="lineno"> 2694</span><span class="comment">   * @param sock_as_any</span></div>
<div class="line"><a id="l02695" name="l02695"></a><span class="lineno"> 2695</span><span class="comment">   *        Socket to examine, as an `any` wrapping a Peer_socket::Ptr.</span></div>
<div class="line"><a id="l02696" name="l02696"></a><span class="lineno"> 2696</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02697" name="l02697"></a><span class="lineno"> 2697</span><span class="comment">   */</span></div>
<div class="line"><a id="l02698" name="l02698"></a><span class="lineno"> 2698</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">sock_is_writable</a>(<span class="keyword">const</span> boost::any&amp; sock_as_any) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02699" name="l02699"></a><span class="lineno"> 2699</span><span class="comment"></span> </div>
<div class="line"><a id="l02700" name="l02700"></a><span class="lineno"> 2700</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02701" name="l02701"></a><span class="lineno"> 2701</span><span class="comment">   * Helper placed by send() onto W to invoke send_worker() but ensures that the socket has not</span></div>
<div class="line"><a id="l02702" name="l02702"></a><span class="lineno"> 2702</span><span class="comment">   * entered some state such that sending data is not possible and no longer going to be possible.</span></div>
<div class="line"><a id="l02703" name="l02703"></a><span class="lineno"> 2703</span><span class="comment">   *</span></div>
<div class="line"><a id="l02704" name="l02704"></a><span class="lineno"> 2704</span><span class="comment">   * Example: `send(sock)` runs while `sock` is in ESTABLISHED state; queues up</span></div>
<div class="line"><a id="l02705" name="l02705"></a><span class="lineno"> 2705</span><span class="comment">   * send_worker_check_state() on thread W; thread W detects a connection reset and moves `sock` to</span></div>
<div class="line"><a id="l02706" name="l02706"></a><span class="lineno"> 2706</span><span class="comment">   * CLOSED; send_worker_check_state() gets its turn on thread W; detects state is now CLOSED and</span></div>
<div class="line"><a id="l02707" name="l02707"></a><span class="lineno"> 2707</span><span class="comment">   * returns without doing anything.</span></div>
<div class="line"><a id="l02708" name="l02708"></a><span class="lineno"> 2708</span><span class="comment">   *</span></div>
<div class="line"><a id="l02709" name="l02709"></a><span class="lineno"> 2709</span><span class="comment">   * @see Important: see giant comment inside Node::send() for overall design and how send_worker()</span></div>
<div class="line"><a id="l02710" name="l02710"></a><span class="lineno"> 2710</span><span class="comment">   *      fits into it.</span></div>
<div class="line"><a id="l02711" name="l02711"></a><span class="lineno"> 2711</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02712" name="l02712"></a><span class="lineno"> 2712</span><span class="comment">   *        Socket on which to possibly send low-level packets.</span></div>
<div class="line"><a id="l02713" name="l02713"></a><span class="lineno"> 2713</span><span class="comment">   */</span></div>
<div class="line"><a id="l02714" name="l02714"></a><span class="lineno"> 2714</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">send_worker_check_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02715" name="l02715"></a><span class="lineno"> 2715</span><span class="comment"></span> </div>
<div class="line"><a id="l02716" name="l02716"></a><span class="lineno"> 2716</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02717" name="l02717"></a><span class="lineno"> 2717</span><span class="comment">   * Thread W implemention of send(): synchronously or asynchronously send the contents of</span></div>
<div class="line"><a id="l02718" name="l02718"></a><span class="lineno"> 2718</span><span class="comment">   * `sock-&gt;m_snd_buf` to the other side.  This locks the socket and examines `m_snd_buf`.  If a low-level</span></div>
<div class="line"><a id="l02719" name="l02719"></a><span class="lineno"> 2719</span><span class="comment">   * UDP packet cannot be produced from the front of `m_snd_buf` (i.e., not enough data in `m_snd_buf`),</span></div>
<div class="line"><a id="l02720" name="l02720"></a><span class="lineno"> 2720</span><span class="comment">   * then there is nothing to do.  Otherwise, determines whether network conditions (e.g.,</span></div>
<div class="line"><a id="l02721" name="l02721"></a><span class="lineno"> 2721</span><span class="comment">   * congestion control) allow for 1 or more such packets to be sent.  If not, then there is nothing</span></div>
<div class="line"><a id="l02722" name="l02722"></a><span class="lineno"> 2722</span><span class="comment">   * to do.  Otherwise (if 1 or more packets can be sent), 1 or more packets are sent and removed</span></div>
<div class="line"><a id="l02723" name="l02723"></a><span class="lineno"> 2723</span><span class="comment">   * from `sock-&gt;m_snd_buf`.  Finally, `m_snd_buf` is unlocked.</span></div>
<div class="line"><a id="l02724" name="l02724"></a><span class="lineno"> 2724</span><span class="comment">   *</span></div>
<div class="line"><a id="l02725" name="l02725"></a><span class="lineno"> 2725</span><span class="comment">   * Pre-condition: `sock-&gt;m_int_state == S_ESTABLISHED`.  @todo Are there other states where sending</span></div>
<div class="line"><a id="l02726" name="l02726"></a><span class="lineno"> 2726</span><span class="comment">   * DATA packets is OK?  If so it would be during graceful termination, if we implement it.  See</span></div>
<div class="line"><a id="l02727" name="l02727"></a><span class="lineno"> 2727</span><span class="comment">   * send_worker() for contedt for this to-do.</span></div>
<div class="line"><a id="l02728" name="l02728"></a><span class="lineno"> 2728</span><span class="comment">   *</span></div>
<div class="line"><a id="l02729" name="l02729"></a><span class="lineno"> 2729</span><span class="comment">   * @see Important: see giant comment inside Node::send() for overall design and how send_worker()</span></div>
<div class="line"><a id="l02730" name="l02730"></a><span class="lineno"> 2730</span><span class="comment">   *      fits into it.</span></div>
<div class="line"><a id="l02731" name="l02731"></a><span class="lineno"> 2731</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02732" name="l02732"></a><span class="lineno"> 2732</span><span class="comment">   *        Socket on which to possibly send low-level packets.</span></div>
<div class="line"><a id="l02733" name="l02733"></a><span class="lineno"> 2733</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l02734" name="l02734"></a><span class="lineno"> 2734</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l02735" name="l02735"></a><span class="lineno"> 2735</span><span class="comment">   */</span></div>
<div class="line"><a id="l02736" name="l02736"></a><span class="lineno"> 2736</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">send_worker</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l02737" name="l02737"></a><span class="lineno"> 2737</span><span class="comment"></span> </div>
<div class="line"><a id="l02738" name="l02738"></a><span class="lineno"> 2738</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02739" name="l02739"></a><span class="lineno"> 2739</span><span class="comment">   * Answers the perennial question of congestion and flow control: assuming there is a DATA packet</span></div>
<div class="line"><a id="l02740" name="l02740"></a><span class="lineno"> 2740</span><span class="comment">   * to send to the other side on the given socket, should we do so at this moment?  Over a perfect</span></div>
<div class="line"><a id="l02741" name="l02741"></a><span class="lineno"> 2741</span><span class="comment">   * link and with a perfect receiver, this would always return true, and we would always send every</span></div>
<div class="line"><a id="l02742" name="l02742"></a><span class="lineno"> 2742</span><span class="comment">   * packet as soon as we could make it.  As it is, some congestion control algorithm is used here</span></div>
<div class="line"><a id="l02743" name="l02743"></a><span class="lineno"> 2743</span><span class="comment">   * to determine if the link should be able to handle a packet, and rcv_wnd is used to determine if</span></div>
<div class="line"><a id="l02744" name="l02744"></a><span class="lineno"> 2744</span><span class="comment">   * the receive would be able to buffer a packet if it did arrive.</span></div>
<div class="line"><a id="l02745" name="l02745"></a><span class="lineno"> 2745</span><span class="comment">   *</span></div>
<div class="line"><a id="l02746" name="l02746"></a><span class="lineno"> 2746</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02747" name="l02747"></a><span class="lineno"> 2747</span><span class="comment">   *        Socket for which we answer the question.</span></div>
<div class="line"><a id="l02748" name="l02748"></a><span class="lineno"> 2748</span><span class="comment">   * @return `true` if should send; `false` if should wait until it becomes `true` and THEN send.</span></div>
<div class="line"><a id="l02749" name="l02749"></a><span class="lineno"> 2749</span><span class="comment">   */</span></div>
<div class="line"><a id="l02750" name="l02750"></a><span class="lineno"> 2750</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">can_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02751" name="l02751"></a><span class="lineno"> 2751</span><span class="comment"></span> </div>
<div class="line"><a id="l02752" name="l02752"></a><span class="lineno"> 2752</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02753" name="l02753"></a><span class="lineno"> 2753</span><span class="comment">   * Implementation of non-blocking sock-&gt;receive() for socket `sock` in all cases except when</span></div>
<div class="line"><a id="l02754" name="l02754"></a><span class="lineno"> 2754</span><span class="comment">   * `sock-&gt;state() == State::S_CLOSED`.</span></div>
<div class="line"><a id="l02755" name="l02755"></a><span class="lineno"> 2755</span><span class="comment">   *</span></div>
<div class="line"><a id="l02756" name="l02756"></a><span class="lineno"> 2756</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l02757" name="l02757"></a><span class="lineno"> 2757</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l02758" name="l02758"></a><span class="lineno"> 2758</span><span class="comment">   *   - `sock-&gt;m_mutex` is locked and just after entering `sock-&gt;receive()`;</span></div>
<div class="line"><a id="l02759" name="l02759"></a><span class="lineno"> 2759</span><span class="comment">   *   - no changes to `*sock` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l02760" name="l02760"></a><span class="lineno"> 2760</span><span class="comment">   *   - `sock-&gt;state() == Stated::S_OPEN` (so `sock` is in #m_socks);</span></div>
<div class="line"><a id="l02761" name="l02761"></a><span class="lineno"> 2761</span><span class="comment">   *   - `rcv_buf_feed_func` is as described below.</span></div>
<div class="line"><a id="l02762" name="l02762"></a><span class="lineno"> 2762</span><span class="comment">   *</span></div>
<div class="line"><a id="l02763" name="l02763"></a><span class="lineno"> 2763</span><span class="comment">   * This method completes the functionality of `sock-&gt;receive()`.</span></div>
<div class="line"><a id="l02764" name="l02764"></a><span class="lineno"> 2764</span><span class="comment">   *</span></div>
<div class="line"><a id="l02765" name="l02765"></a><span class="lineno"> 2765</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02766" name="l02766"></a><span class="lineno"> 2766</span><span class="comment">   *        Socket, which must be in #m_socks, on which `receive()` was called.</span></div>
<div class="line"><a id="l02767" name="l02767"></a><span class="lineno"> 2767</span><span class="comment">   * @param rcv_buf_consume_func</span></div>
<div class="line"><a id="l02768" name="l02768"></a><span class="lineno"> 2768</span><span class="comment">   *        Pointer to function with signature `size_t fn()` that will perform</span></div>
<div class="line"><a id="l02769" name="l02769"></a><span class="lineno"> 2769</span><span class="comment">   *        `sock-&gt;m_rcv_buf.consume_bufs_copy(...)` call, which will consume data from `m_rcv_buf`,</span></div>
<div class="line"><a id="l02770" name="l02770"></a><span class="lineno"> 2770</span><span class="comment">   *        and return the return value of that call (which indicates how many bytes</span></div>
<div class="line"><a id="l02771" name="l02771"></a><span class="lineno"> 2771</span><span class="comment">   *        Socket_buffer::consume_bufs_copy() was able to fit into the user&#39;s data structure).  Doing it this way</span></div>
<div class="line"><a id="l02772" name="l02772"></a><span class="lineno"> 2772</span><span class="comment">   *        prevents this Node::receive() from being a template, which prevents circular dependency</span></div>
<div class="line"><a id="l02773" name="l02773"></a><span class="lineno"> 2773</span><span class="comment">   *        unpleasantness.  See Peer_socket::receive() for details.</span></div>
<div class="line"><a id="l02774" name="l02774"></a><span class="lineno"> 2774</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l02775" name="l02775"></a><span class="lineno"> 2775</span><span class="comment">   *        See Peer_socket::receive().</span></div>
<div class="line"><a id="l02776" name="l02776"></a><span class="lineno"> 2776</span><span class="comment">   * @return See Peer_socket::receive().</span></div>
<div class="line"><a id="l02777" name="l02777"></a><span class="lineno"> 2777</span><span class="comment">   */</span></div>
<div class="line"><a id="l02778" name="l02778"></a><span class="lineno"> 2778</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">receive</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02779" name="l02779"></a><span class="lineno"> 2779</span>                 <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;<span class="keywordtype">size_t</span> ()&gt;&amp; rcv_buf_consume_func,</div>
<div class="line"><a id="l02780" name="l02780"></a><span class="lineno"> 2780</span>                 <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l02781" name="l02781"></a><span class="lineno"> 2781</span><span class="comment"></span> </div>
<div class="line"><a id="l02782" name="l02782"></a><span class="lineno"> 2782</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02783" name="l02783"></a><span class="lineno"> 2783</span><span class="comment">   * Returns `true` if and only if calling sock-&gt;receive() with at least some arguments would return</span></div>
<div class="line"><a id="l02784" name="l02784"></a><span class="lineno"> 2784</span><span class="comment">   * either non-zero (i.e., successfully dequeued received data) or zero and an error (but not</span></div>
<div class="line"><a id="l02785" name="l02785"></a><span class="lineno"> 2785</span><span class="comment">   * zero and NO error).  `sock` will be locked and unlocked; safe to call from any thread.</span></div>
<div class="line"><a id="l02786" name="l02786"></a><span class="lineno"> 2786</span><span class="comment">   *</span></div>
<div class="line"><a id="l02787" name="l02787"></a><span class="lineno"> 2787</span><span class="comment">   * @param sock_as_any</span></div>
<div class="line"><a id="l02788" name="l02788"></a><span class="lineno"> 2788</span><span class="comment">   *        Socket to examine, as an `any` wrapping a Peer_socket::Ptr.</span></div>
<div class="line"><a id="l02789" name="l02789"></a><span class="lineno"> 2789</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02790" name="l02790"></a><span class="lineno"> 2790</span><span class="comment">   */</span></div>
<div class="line"><a id="l02791" name="l02791"></a><span class="lineno"> 2791</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">sock_is_readable</a>(<span class="keyword">const</span> boost::any&amp; sock_as_any) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02792" name="l02792"></a><span class="lineno"> 2792</span><span class="comment"></span> </div>
<div class="line"><a id="l02793" name="l02793"></a><span class="lineno"> 2793</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02794" name="l02794"></a><span class="lineno"> 2794</span><span class="comment">   * Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the</span></div>
<div class="line"><a id="l02795" name="l02795"></a><span class="lineno"> 2795</span><span class="comment">   * user, which would free up space in the Receive buffer, which *possibly* should result in a</span></div>
<div class="line"><a id="l02796" name="l02796"></a><span class="lineno"> 2796</span><span class="comment">   * window update sent to the server, so that it knows it can now send more data.</span></div>
<div class="line"><a id="l02797" name="l02797"></a><span class="lineno"> 2797</span><span class="comment">   *</span></div>
<div class="line"><a id="l02798" name="l02798"></a><span class="lineno"> 2798</span><span class="comment">   * @see Node::receive().</span></div>
<div class="line"><a id="l02799" name="l02799"></a><span class="lineno"> 2799</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02800" name="l02800"></a><span class="lineno"> 2800</span><span class="comment">   *        Socket (whose state is ESTABLISHED or later).</span></div>
<div class="line"><a id="l02801" name="l02801"></a><span class="lineno"> 2801</span><span class="comment">   */</span></div>
<div class="line"><a id="l02802" name="l02802"></a><span class="lineno"> 2802</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">receive_wnd_updated</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02803" name="l02803"></a><span class="lineno"> 2803</span><span class="comment"></span> </div>
<div class="line"><a id="l02804" name="l02804"></a><span class="lineno"> 2804</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02805" name="l02805"></a><span class="lineno"> 2805</span><span class="comment">   * receive_wnd_updated() helper that continues rcv_wnd recovery: that is, sends unsolicited ACK</span></div>
<div class="line"><a id="l02806" name="l02806"></a><span class="lineno"> 2806</span><span class="comment">   * with a rcv_wnd advertisement only and schedules the next iteration of a timer to have this</span></div>
<div class="line"><a id="l02807" name="l02807"></a><span class="lineno"> 2807</span><span class="comment">   * occur again, unless that timer is canceled due to too long a recovery phase or DATA packets</span></div>
<div class="line"><a id="l02808" name="l02808"></a><span class="lineno"> 2808</span><span class="comment">   * arriving from the other side.</span></div>
<div class="line"><a id="l02809" name="l02809"></a><span class="lineno"> 2809</span><span class="comment">   *</span></div>
<div class="line"><a id="l02810" name="l02810"></a><span class="lineno"> 2810</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02811" name="l02811"></a><span class="lineno"> 2811</span><span class="comment">   *        See receive_wnd_updated().</span></div>
<div class="line"><a id="l02812" name="l02812"></a><span class="lineno"> 2812</span><span class="comment">   * @param rcv_wnd</span></div>
<div class="line"><a id="l02813" name="l02813"></a><span class="lineno"> 2813</span><span class="comment">   *        The rcv_wnd (free Receive buffer space) to advertise to the other side.</span></div>
<div class="line"><a id="l02814" name="l02814"></a><span class="lineno"> 2814</span><span class="comment">   */</span></div>
<div class="line"><a id="l02815" name="l02815"></a><span class="lineno"> 2815</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">async_rcv_wnd_recovery</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">size_t</span> rcv_wnd);</div>
<div class="line"><a id="l02816" name="l02816"></a><span class="lineno"> 2816</span><span class="comment"></span> </div>
<div class="line"><a id="l02817" name="l02817"></a><span class="lineno"> 2817</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02818" name="l02818"></a><span class="lineno"> 2818</span><span class="comment">   * Pertaining to the async_rcv_wnd_recovery() mechanism, this handles the event that we have</span></div>
<div class="line"><a id="l02819" name="l02819"></a><span class="lineno"> 2819</span><span class="comment">   * received an acceptable (either into Receive buffer or reassembly queue) DATA packet from the</span></div>
<div class="line"><a id="l02820" name="l02820"></a><span class="lineno"> 2820</span><span class="comment">   * other side.  If we are currently in rcv_wnd recovery, this signifies the recovery &quot;worked&quot; --</span></div>
<div class="line"><a id="l02821" name="l02821"></a><span class="lineno"> 2821</span><span class="comment">   * the sender is sending data again -- so we can now end this phase.</span></div>
<div class="line"><a id="l02822" name="l02822"></a><span class="lineno"> 2822</span><span class="comment">   *</span></div>
<div class="line"><a id="l02823" name="l02823"></a><span class="lineno"> 2823</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02824" name="l02824"></a><span class="lineno"> 2824</span><span class="comment">   *        See receive_wnd_updated().</span></div>
<div class="line"><a id="l02825" name="l02825"></a><span class="lineno"> 2825</span><span class="comment">   */</span></div>
<div class="line"><a id="l02826" name="l02826"></a><span class="lineno"> 2826</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">receive_wnd_recovery_data_received</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02827" name="l02827"></a><span class="lineno"> 2827</span><span class="comment"></span> </div>
<div class="line"><a id="l02828" name="l02828"></a><span class="lineno"> 2828</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02829" name="l02829"></a><span class="lineno"> 2829</span><span class="comment">   * Computes and returns the currently correct rcv_wnd value; that is the amount of space free in</span></div>
<div class="line"><a id="l02830" name="l02830"></a><span class="lineno"> 2830</span><span class="comment">   * Receive buffer for the given socket.  This may only be called from thread W.</span></div>
<div class="line"><a id="l02831" name="l02831"></a><span class="lineno"> 2831</span><span class="comment">   *</span></div>
<div class="line"><a id="l02832" name="l02832"></a><span class="lineno"> 2832</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02833" name="l02833"></a><span class="lineno"> 2833</span><span class="comment">   *        A socket.</span></div>
<div class="line"><a id="l02834" name="l02834"></a><span class="lineno"> 2834</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02835" name="l02835"></a><span class="lineno"> 2835</span><span class="comment">   */</span></div>
<div class="line"><a id="l02836" name="l02836"></a><span class="lineno"> 2836</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">sock_rcv_wnd</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02837" name="l02837"></a><span class="lineno"> 2837</span><span class="comment"></span> </div>
<div class="line"><a id="l02838" name="l02838"></a><span class="lineno"> 2838</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02839" name="l02839"></a><span class="lineno"> 2839</span><span class="comment">   * Placed by receive() onto W during a graceful close, after the Receive buffer had been emptied</span></div>
<div class="line"><a id="l02840" name="l02840"></a><span class="lineno"> 2840</span><span class="comment">   * by the user; determines whether the socket can now proceed to</span></div>
<div class="line"><a id="l02841" name="l02841"></a><span class="lineno"> 2841</span><span class="comment">   * `Peer_socket::m_state == Peer_socket::State::S_CLOSED`</span></div>
<div class="line"><a id="l02842" name="l02842"></a><span class="lineno"> 2842</span><span class="comment">   * and be removed from the Node.</span></div>
<div class="line"><a id="l02843" name="l02843"></a><span class="lineno"> 2843</span><span class="comment">   *</span></div>
<div class="line"><a id="l02844" name="l02844"></a><span class="lineno"> 2844</span><span class="comment">   * @see Node::receive().</span></div>
<div class="line"><a id="l02845" name="l02845"></a><span class="lineno"> 2845</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02846" name="l02846"></a><span class="lineno"> 2846</span><span class="comment">   *        Socket which may possibly now move to `m_state == S_CLOSED`.</span></div>
<div class="line"><a id="l02847" name="l02847"></a><span class="lineno"> 2847</span><span class="comment">   */</span></div>
<div class="line"><a id="l02848" name="l02848"></a><span class="lineno"> 2848</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">receive_emptied_rcv_buf_while_disconnecting</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02849" name="l02849"></a><span class="lineno"> 2849</span><span class="comment"></span> </div>
<div class="line"><a id="l02850" name="l02850"></a><span class="lineno"> 2850</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02851" name="l02851"></a><span class="lineno"> 2851</span><span class="comment">   * Sends a low-level ACK packet, with all accumulated in Peer_socket::m_rcv_pending_acks of `sock` individual packet</span></div>
<div class="line"><a id="l02852" name="l02852"></a><span class="lineno"> 2852</span><span class="comment">   * acknowledgments, to the other side&#39;s UDP endpoint.  If the pending acknowledgments don&#39;t fit</span></div>
<div class="line"><a id="l02853" name="l02853"></a><span class="lineno"> 2853</span><span class="comment">   * into one ACK, more ACKs are generated and sent as necessary.  If there is an error sending or</span></div>
<div class="line"><a id="l02854" name="l02854"></a><span class="lineno"> 2854</span><span class="comment">   * preparing to send, `sock` is closed abruptly (close_connection_immediately()).</span></div>
<div class="line"><a id="l02855" name="l02855"></a><span class="lineno"> 2855</span><span class="comment">   *</span></div>
<div class="line"><a id="l02856" name="l02856"></a><span class="lineno"> 2856</span><span class="comment">   * This may be called either directly or by boost.asio due to delayed ACK timer being triggered.</span></div>
<div class="line"><a id="l02857" name="l02857"></a><span class="lineno"> 2857</span><span class="comment">   * If `sock` is not in Peer_socket::Int_state::S_ESTABLISHED, this does nothing except possibly logging.</span></div>
<div class="line"><a id="l02858" name="l02858"></a><span class="lineno"> 2858</span><span class="comment">   *</span></div>
<div class="line"><a id="l02859" name="l02859"></a><span class="lineno"> 2859</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02860" name="l02860"></a><span class="lineno"> 2860</span><span class="comment">   *        Socket the remote side of which will get the RST.  Method is basically a NOOP unless</span></div>
<div class="line"><a id="l02861" name="l02861"></a><span class="lineno"> 2861</span><span class="comment">   *        state is Peer_socket::Int_state::S_ESTABLISHED.</span></div>
<div class="line"><a id="l02862" name="l02862"></a><span class="lineno"> 2862</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l02863" name="l02863"></a><span class="lineno"> 2863</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l02864" name="l02864"></a><span class="lineno"> 2864</span><span class="comment">   * @param sys_err_code</span></div>
<div class="line"><a id="l02865" name="l02865"></a><span class="lineno"> 2865</span><span class="comment">   *        If invoked via timer trigger, this is boost.asio&#39;s error code.  If invoked directly,</span></div>
<div class="line"><a id="l02866" name="l02866"></a><span class="lineno"> 2866</span><span class="comment">   *        this should be set to the default (success).  Value is handled as follows: assuming</span></div>
<div class="line"><a id="l02867" name="l02867"></a><span class="lineno"> 2867</span><span class="comment">   *        ESTABLISHED state: `operation_aborted` =&gt; NOOP; success or any other error =&gt; attempt to</span></div>
<div class="line"><a id="l02868" name="l02868"></a><span class="lineno"> 2868</span><span class="comment">   *        send ACK(s).</span></div>
<div class="line"><a id="l02869" name="l02869"></a><span class="lineno"> 2869</span><span class="comment">   */</span></div>
<div class="line"><a id="l02870" name="l02870"></a><span class="lineno"> 2870</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a81e50276d0b162f6577adc690e0ef9e0">async_low_lvl_ack_send</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keywordtype">bool</span> defer_delta_check,</div>
<div class="line"><a id="l02871" name="l02871"></a><span class="lineno"> 2871</span>                              <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code = <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>());</div>
<div class="line"><a id="l02872" name="l02872"></a><span class="lineno"> 2872</span><span class="comment"></span> </div>
<div class="line"><a id="l02873" name="l02873"></a><span class="lineno"> 2873</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02874" name="l02874"></a><span class="lineno"> 2874</span><span class="comment">   * Return `true` if and only if there are enough data either in Peer_socket::m_snd_rexmit_q of `sock` (if</span></div>
<div class="line"><a id="l02875" name="l02875"></a><span class="lineno"> 2875</span><span class="comment">   * retransmission is on) or in Peer_socket::m_snd_buf of `sock` to send a DATA packet to the other</span></div>
<div class="line"><a id="l02876" name="l02876"></a><span class="lineno"> 2876</span><span class="comment">   * side.</span></div>
<div class="line"><a id="l02877" name="l02877"></a><span class="lineno"> 2877</span><span class="comment">   *</span></div>
<div class="line"><a id="l02878" name="l02878"></a><span class="lineno"> 2878</span><span class="comment">   * Pre-condition: `sock-&gt;m_mutex` is locked.</span></div>
<div class="line"><a id="l02879" name="l02879"></a><span class="lineno"> 2879</span><span class="comment">   *</span></div>
<div class="line"><a id="l02880" name="l02880"></a><span class="lineno"> 2880</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02881" name="l02881"></a><span class="lineno"> 2881</span><span class="comment">   *        Socket whose retransmission queue and Send buffer to examine.</span></div>
<div class="line"><a id="l02882" name="l02882"></a><span class="lineno"> 2882</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02883" name="l02883"></a><span class="lineno"> 2883</span><span class="comment">   */</span></div>
<div class="line"><a id="l02884" name="l02884"></a><span class="lineno"> 2884</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">snd_deqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02885" name="l02885"></a><span class="lineno"> 2885</span><span class="comment"></span> </div>
<div class="line"><a id="l02886" name="l02886"></a><span class="lineno"> 2886</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02887" name="l02887"></a><span class="lineno"> 2887</span><span class="comment">   * Return `true` if and only if there is enough free space in Peer_socket::m_snd_buf of `sock` to enqueue any given</span></div>
<div class="line"><a id="l02888" name="l02888"></a><span class="lineno"> 2888</span><span class="comment">   * atomic piece of user data.</span></div>
<div class="line"><a id="l02889" name="l02889"></a><span class="lineno"> 2889</span><span class="comment">   *</span></div>
<div class="line"><a id="l02890" name="l02890"></a><span class="lineno"> 2890</span><span class="comment">   * Pre-condition: `sock-&gt;m_mutex` is locked.</span></div>
<div class="line"><a id="l02891" name="l02891"></a><span class="lineno"> 2891</span><span class="comment">   *</span></div>
<div class="line"><a id="l02892" name="l02892"></a><span class="lineno"> 2892</span><span class="comment">   * Currently this simply means that there is space for at least max-block-size bytes (i.e., one</span></div>
<div class="line"><a id="l02893" name="l02893"></a><span class="lineno"> 2893</span><span class="comment">   * maximally large block) in `sock-&gt;m_snd_buf`.</span></div>
<div class="line"><a id="l02894" name="l02894"></a><span class="lineno"> 2894</span><span class="comment">   *</span></div>
<div class="line"><a id="l02895" name="l02895"></a><span class="lineno"> 2895</span><span class="comment">   * Design rationale for the latter: See code.</span></div>
<div class="line"><a id="l02896" name="l02896"></a><span class="lineno"> 2896</span><span class="comment">   *</span></div>
<div class="line"><a id="l02897" name="l02897"></a><span class="lineno"> 2897</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02898" name="l02898"></a><span class="lineno"> 2898</span><span class="comment">   *        Socket whose Send buffer to examine.</span></div>
<div class="line"><a id="l02899" name="l02899"></a><span class="lineno"> 2899</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02900" name="l02900"></a><span class="lineno"> 2900</span><span class="comment">   */</span></div>
<div class="line"><a id="l02901" name="l02901"></a><span class="lineno"> 2901</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">snd_buf_enqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02902" name="l02902"></a><span class="lineno"> 2902</span><span class="comment"></span> </div>
<div class="line"><a id="l02903" name="l02903"></a><span class="lineno"> 2903</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02904" name="l02904"></a><span class="lineno"> 2904</span><span class="comment">   * Return true if and only if there are enough data in Peer_socket::m_rcv_buf of `sock` to give the user some</span></div>
<div class="line"><a id="l02905" name="l02905"></a><span class="lineno"> 2905</span><span class="comment">   * data in a Peer_socket::receive() call.</span></div>
<div class="line"><a id="l02906" name="l02906"></a><span class="lineno"> 2906</span><span class="comment">   *</span></div>
<div class="line"><a id="l02907" name="l02907"></a><span class="lineno"> 2907</span><span class="comment">   * Pre-condition: `sock-&gt;m_mutex` is locked.</span></div>
<div class="line"><a id="l02908" name="l02908"></a><span class="lineno"> 2908</span><span class="comment">   *</span></div>
<div class="line"><a id="l02909" name="l02909"></a><span class="lineno"> 2909</span><span class="comment">   * Currently this simply means that there is at least 1 block of data in `m_rcv_buf`.</span></div>
<div class="line"><a id="l02910" name="l02910"></a><span class="lineno"> 2910</span><span class="comment">   *</span></div>
<div class="line"><a id="l02911" name="l02911"></a><span class="lineno"> 2911</span><span class="comment">   * Design rationale: see snd_buf_deqable().</span></div>
<div class="line"><a id="l02912" name="l02912"></a><span class="lineno"> 2912</span><span class="comment">   *</span></div>
<div class="line"><a id="l02913" name="l02913"></a><span class="lineno"> 2913</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02914" name="l02914"></a><span class="lineno"> 2914</span><span class="comment">   *        Socket whose Receive buffer to examine.</span></div>
<div class="line"><a id="l02915" name="l02915"></a><span class="lineno"> 2915</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l02916" name="l02916"></a><span class="lineno"> 2916</span><span class="comment">   */</span></div>
<div class="line"><a id="l02917" name="l02917"></a><span class="lineno"> 2917</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">rcv_buf_deqable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l02918" name="l02918"></a><span class="lineno"> 2918</span><span class="comment"></span> </div>
<div class="line"><a id="l02919" name="l02919"></a><span class="lineno"> 2919</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02920" name="l02920"></a><span class="lineno"> 2920</span><span class="comment">   * Sets internal state of given socket to the given state and logs a TRACE message about it.</span></div>
<div class="line"><a id="l02921" name="l02921"></a><span class="lineno"> 2921</span><span class="comment">   * Should only be run from thread W; performs no locking.</span></div>
<div class="line"><a id="l02922" name="l02922"></a><span class="lineno"> 2922</span><span class="comment">   *</span></div>
<div class="line"><a id="l02923" name="l02923"></a><span class="lineno"> 2923</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02924" name="l02924"></a><span class="lineno"> 2924</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l02925" name="l02925"></a><span class="lineno"> 2925</span><span class="comment">   * @param new_state</span></div>
<div class="line"><a id="l02926" name="l02926"></a><span class="lineno"> 2926</span><span class="comment">   *        New state.</span></div>
<div class="line"><a id="l02927" name="l02927"></a><span class="lineno"> 2927</span><span class="comment">   */</span></div>
<div class="line"><a id="l02928" name="l02928"></a><span class="lineno"> 2928</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">sock_set_int_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">Peer_socket::Int_state</a> new_state);</div>
<div class="line"><a id="l02929" name="l02929"></a><span class="lineno"> 2929</span><span class="comment"></span> </div>
<div class="line"><a id="l02930" name="l02930"></a><span class="lineno"> 2930</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02931" name="l02931"></a><span class="lineno"> 2931</span><span class="comment">   * Sets Peer_socket::m_state and Peer_socket::m_open_sub_state.  If moving to Peer_socket::State::S_CLOSED, resets</span></div>
<div class="line"><a id="l02932" name="l02932"></a><span class="lineno"> 2932</span><span class="comment">   * the required data to their &quot;undefined&quot; values (e.g., Peer_socket::m_local_port = #S_PORT_ANY).  Thread-safe.</span></div>
<div class="line"><a id="l02933" name="l02933"></a><span class="lineno"> 2933</span><span class="comment">   *</span></div>
<div class="line"><a id="l02934" name="l02934"></a><span class="lineno"> 2934</span><span class="comment">   * @warning Only set `state` = `S_CLOSED` if no more data are in Receive buffer, so that the</span></div>
<div class="line"><a id="l02935" name="l02935"></a><span class="lineno"> 2935</span><span class="comment">   * user can get those data before `S_CLOSED` state.  See Peer_socket::State::S_DISCONNECTING.</span></div>
<div class="line"><a id="l02936" name="l02936"></a><span class="lineno"> 2936</span><span class="comment"></span> </div>
<div class="line"><a id="l02937" name="l02937"></a><span class="lineno"> 2937</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02938" name="l02938"></a><span class="lineno"> 2938</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l02939" name="l02939"></a><span class="lineno"> 2939</span><span class="comment">   * @param state</span></div>
<div class="line"><a id="l02940" name="l02940"></a><span class="lineno"> 2940</span><span class="comment">   *        New Peer_socket::m_state.</span></div>
<div class="line"><a id="l02941" name="l02941"></a><span class="lineno"> 2941</span><span class="comment">   * @param open_sub_state</span></div>
<div class="line"><a id="l02942" name="l02942"></a><span class="lineno"> 2942</span><span class="comment">   *        Ignored if `state != S_OPEN`; otherwise the new value for Peer_socket::m_open_sub_state.</span></div>
<div class="line"><a id="l02943" name="l02943"></a><span class="lineno"> 2943</span><span class="comment">   */</span></div>
<div class="line"><a id="l02944" name="l02944"></a><span class="lineno"> 2944</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">sock_set_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02945" name="l02945"></a><span class="lineno"> 2945</span>                      <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> state,</div>
<div class="line"><a id="l02946" name="l02946"></a><span class="lineno"> 2946</span>                      <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Peer_socket::Open_sub_state</a> open_sub_state = <a class="code hl_enumvalue" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">Peer_socket::Open_sub_state::S_CONNECTED</a>);</div>
<div class="line"><a id="l02947" name="l02947"></a><span class="lineno"> 2947</span><span class="comment"></span> </div>
<div class="line"><a id="l02948" name="l02948"></a><span class="lineno"> 2948</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02949" name="l02949"></a><span class="lineno"> 2949</span><span class="comment">   * Records that thread W shows underlying connection is broken (graceful termination, or error)</span></div>
<div class="line"><a id="l02950" name="l02950"></a><span class="lineno"> 2950</span><span class="comment">   * and sets Peer_socket::m_disconnect_cause and Peer_socket::m_state, Peer_socket::m_open_sub_state accordingly.</span></div>
<div class="line"><a id="l02951" name="l02951"></a><span class="lineno"> 2951</span><span class="comment">   * Optionally also empties the Send and Receive buffers and any other decently memory-consuming structures.</span></div>
<div class="line"><a id="l02952" name="l02952"></a><span class="lineno"> 2952</span><span class="comment">   * Thread-safe.</span></div>
<div class="line"><a id="l02953" name="l02953"></a><span class="lineno"> 2953</span><span class="comment">   *</span></div>
<div class="line"><a id="l02954" name="l02954"></a><span class="lineno"> 2954</span><span class="comment">   * So the mutually exclusive closure scenarios are:</span></div>
<div class="line"><a id="l02955" name="l02955"></a><span class="lineno"> 2955</span><span class="comment">   *   - `sock_disconnect_detected(sock, err_code, false); ...; sock_disconnect_completed(sock);`</span></div>
<div class="line"><a id="l02956" name="l02956"></a><span class="lineno"> 2956</span><span class="comment">   *     Graceful close initiated; ...buffers emptied...; graceful close completed.</span></div>
<div class="line"><a id="l02957" name="l02957"></a><span class="lineno"> 2957</span><span class="comment">   *   - `sock_disconnect_detected(sock, err_code, true);`</span></div>
<div class="line"><a id="l02958" name="l02958"></a><span class="lineno"> 2958</span><span class="comment">   *     Abrupt close, or graceful close when the buffers already happen to be empty.</span></div>
<div class="line"><a id="l02959" name="l02959"></a><span class="lineno"> 2959</span><span class="comment">   *</span></div>
<div class="line"><a id="l02960" name="l02960"></a><span class="lineno"> 2960</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02961" name="l02961"></a><span class="lineno"> 2961</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l02962" name="l02962"></a><span class="lineno"> 2962</span><span class="comment">   * @param disconnect_cause</span></div>
<div class="line"><a id="l02963" name="l02963"></a><span class="lineno"> 2963</span><span class="comment">   *        The cause of the disconnect.</span></div>
<div class="line"><a id="l02964" name="l02964"></a><span class="lineno"> 2964</span><span class="comment">   * @param close</span></div>
<div class="line"><a id="l02965" name="l02965"></a><span class="lineno"> 2965</span><span class="comment">   *        If `true`, the target public state should be the super-final `S_CLOSED`, and the Send and</span></div>
<div class="line"><a id="l02966" name="l02966"></a><span class="lineno"> 2966</span><span class="comment">   *        Receive buffers are cleared; if `false`, the target public state should be the ominous</span></div>
<div class="line"><a id="l02967" name="l02967"></a><span class="lineno"> 2967</span><span class="comment">   *        `S_OPEN`+`S_DISCONNECTING`, and the buffers are left alone.  The caller&#39;s responsibility is</span></div>
<div class="line"><a id="l02968" name="l02968"></a><span class="lineno"> 2968</span><span class="comment">   *        to decide which one it is, but `true` is typically either for an abrupt close (e.g.,</span></div>
<div class="line"><a id="l02969" name="l02969"></a><span class="lineno"> 2969</span><span class="comment">   *        RST) or for a graceful close when buffers are empty; while `false` is typically for a</span></div>
<div class="line"><a id="l02970" name="l02970"></a><span class="lineno"> 2970</span><span class="comment">   *        graceful close before buffers are empty, so that the user can get Receive buffer, and</span></div>
<div class="line"><a id="l02971" name="l02971"></a><span class="lineno"> 2971</span><span class="comment">   *        the Node can send out Send buffer.</span></div>
<div class="line"><a id="l02972" name="l02972"></a><span class="lineno"> 2972</span><span class="comment">   */</span></div>
<div class="line"><a id="l02973" name="l02973"></a><span class="lineno"> 2973</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">sock_disconnect_detected</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l02974" name="l02974"></a><span class="lineno"> 2974</span>                                <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; disconnect_cause, <span class="keywordtype">bool</span> close);</div>
<div class="line"><a id="l02975" name="l02975"></a><span class="lineno"> 2975</span><span class="comment"></span> </div>
<div class="line"><a id="l02976" name="l02976"></a><span class="lineno"> 2976</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02977" name="l02977"></a><span class="lineno"> 2977</span><span class="comment">   * While in `S_OPEN`+`S_DISCONNECTING` state (i.e., after beginning a graceful close with</span></div>
<div class="line"><a id="l02978" name="l02978"></a><span class="lineno"> 2978</span><span class="comment">   * `sock_disconnect_detected(..., false)`, moves the socket to `S_CLOSED` state and clears Receive/Send</span></div>
<div class="line"><a id="l02979" name="l02979"></a><span class="lineno"> 2979</span><span class="comment">   * buffers and any other decently memory-consuming structures.</span></div>
<div class="line"><a id="l02980" name="l02980"></a><span class="lineno"> 2980</span><span class="comment">   *</span></div>
<div class="line"><a id="l02981" name="l02981"></a><span class="lineno"> 2981</span><span class="comment">   * Pre-conditions: state is `S_OPEN`+`S_DISCONNECTING`; Peer_socket::m_disconnect_cause is set to non-success</span></div>
<div class="line"><a id="l02982" name="l02982"></a><span class="lineno"> 2982</span><span class="comment">   * value.</span></div>
<div class="line"><a id="l02983" name="l02983"></a><span class="lineno"> 2983</span><span class="comment">   *</span></div>
<div class="line"><a id="l02984" name="l02984"></a><span class="lineno"> 2984</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02985" name="l02985"></a><span class="lineno"> 2985</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l02986" name="l02986"></a><span class="lineno"> 2986</span><span class="comment">   */</span></div>
<div class="line"><a id="l02987" name="l02987"></a><span class="lineno"> 2987</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">sock_disconnect_completed</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02988" name="l02988"></a><span class="lineno"> 2988</span><span class="comment"></span> </div>
<div class="line"><a id="l02989" name="l02989"></a><span class="lineno"> 2989</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02990" name="l02990"></a><span class="lineno"> 2990</span><span class="comment">   * Helper that clears all non-O(1)-space data structures stored inside `sock`.  Intended to be</span></div>
<div class="line"><a id="l02991" name="l02991"></a><span class="lineno"> 2991</span><span class="comment">   * called from `sock_disconnect_*()`, not anywhere else.  Pre-condition: `sock-&gt;m_mutex` is</span></div>
<div class="line"><a id="l02992" name="l02992"></a><span class="lineno"> 2992</span><span class="comment">   * locked.</span></div>
<div class="line"><a id="l02993" name="l02993"></a><span class="lineno"> 2993</span><span class="comment">   *</span></div>
<div class="line"><a id="l02994" name="l02994"></a><span class="lineno"> 2994</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l02995" name="l02995"></a><span class="lineno"> 2995</span><span class="comment">   *        Socket under consideration.</span></div>
<div class="line"><a id="l02996" name="l02996"></a><span class="lineno"> 2996</span><span class="comment">   */</span></div>
<div class="line"><a id="l02997" name="l02997"></a><span class="lineno"> 2997</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">sock_free_memory</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l02998" name="l02998"></a><span class="lineno"> 2998</span><span class="comment"></span> </div>
<div class="line"><a id="l02999" name="l02999"></a><span class="lineno"> 2999</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03000" name="l03000"></a><span class="lineno"> 3000</span><span class="comment">   * Analogous to validate_options() but checks per-socket options instead of per-Node</span></div>
<div class="line"><a id="l03001" name="l03001"></a><span class="lineno"> 3001</span><span class="comment">   * options.</span></div>
<div class="line"><a id="l03002" name="l03002"></a><span class="lineno"> 3002</span><span class="comment">   *</span></div>
<div class="line"><a id="l03003" name="l03003"></a><span class="lineno"> 3003</span><span class="comment">   * `*prev_opts` is replaced with `opts`.  Leave `prev_opts` as null unless an</span></div>
<div class="line"><a id="l03004" name="l03004"></a><span class="lineno"> 3004</span><span class="comment">   * existing Peer_socket&#39;s options are being changed via Peer_socket::set_options().  Otherwise a</span></div>
<div class="line"><a id="l03005" name="l03005"></a><span class="lineno"> 3005</span><span class="comment">   * Node_options::m_dyn_sock_opts Peer_socket_options is being changed, and that is</span></div>
<div class="line"><a id="l03006" name="l03006"></a><span class="lineno"> 3006</span><span class="comment">   * always allowed (since if a per-socket option were not dynamic in that way, it would simply be a</span></div>
<div class="line"><a id="l03007" name="l03007"></a><span class="lineno"> 3007</span><span class="comment">   * per-Node option instead).</span></div>
<div class="line"><a id="l03008" name="l03008"></a><span class="lineno"> 3008</span><span class="comment">   *</span></div>
<div class="line"><a id="l03009" name="l03009"></a><span class="lineno"> 3009</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l03010" name="l03010"></a><span class="lineno"> 3010</span><span class="comment">   *        New option values to validate.</span></div>
<div class="line"><a id="l03011" name="l03011"></a><span class="lineno"> 3011</span><span class="comment">   * @param prev_opts</span></div>
<div class="line"><a id="l03012" name="l03012"></a><span class="lineno"> 3012</span><span class="comment">   *        null if called from constructor; `&amp;sock-&gt;m_opts` if called from sock-&gt;set_options().</span></div>
<div class="line"><a id="l03013" name="l03013"></a><span class="lineno"> 3013</span><span class="comment">   *        Used to ensure no static per-socket option is being changed.</span></div>
<div class="line"><a id="l03014" name="l03014"></a><span class="lineno"> 3014</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03015" name="l03015"></a><span class="lineno"> 3015</span><span class="comment">   *        After return, `*err_code` is success or: error::Code::S_OPTION_CHECK_FAILED,</span></div>
<div class="line"><a id="l03016" name="l03016"></a><span class="lineno"> 3016</span><span class="comment">   *        error::Code::S_STATIC_OPTION_CHANGED.</span></div>
<div class="line"><a id="l03017" name="l03017"></a><span class="lineno"> 3017</span><span class="comment">   *        If `!err_code`, error::Runtime_error() with that #Error_code is thrown instead.</span></div>
<div class="line"><a id="l03018" name="l03018"></a><span class="lineno"> 3018</span><span class="comment">   * @return `true` on success, `false` on validation error.</span></div>
<div class="line"><a id="l03019" name="l03019"></a><span class="lineno"> 3019</span><span class="comment">   */</span></div>
<div class="line"><a id="l03020" name="l03020"></a><span class="lineno"> 3020</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">sock_validate_options</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* prev_opts,</div>
<div class="line"><a id="l03021" name="l03021"></a><span class="lineno"> 3021</span>                             <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code) <span class="keyword">const</span>;</div>
<div class="line"><a id="l03022" name="l03022"></a><span class="lineno"> 3022</span><span class="comment"></span> </div>
<div class="line"><a id="l03023" name="l03023"></a><span class="lineno"> 3023</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03024" name="l03024"></a><span class="lineno"> 3024</span><span class="comment">   * Thread W implementation of sock-&gt;set_options().  Performs all the needed work to complete</span></div>
<div class="line"><a id="l03025" name="l03025"></a><span class="lineno"> 3025</span><span class="comment">   * `sock-&gt;set_options()` call.</span></div>
<div class="line"><a id="l03026" name="l03026"></a><span class="lineno"> 3026</span><span class="comment">   *</span></div>
<div class="line"><a id="l03027" name="l03027"></a><span class="lineno"> 3027</span><span class="comment">   * Pre-condition: `sock-&gt;state()` is not Peer_socket::State::S_CLOSED.</span></div>
<div class="line"><a id="l03028" name="l03028"></a><span class="lineno"> 3028</span><span class="comment">   *</span></div>
<div class="line"><a id="l03029" name="l03029"></a><span class="lineno"> 3029</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03030" name="l03030"></a><span class="lineno"> 3030</span><span class="comment">   *        See Peer_socket::set_options().</span></div>
<div class="line"><a id="l03031" name="l03031"></a><span class="lineno"> 3031</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l03032" name="l03032"></a><span class="lineno"> 3032</span><span class="comment">   *        See Peer_socket::set_options().</span></div>
<div class="line"><a id="l03033" name="l03033"></a><span class="lineno"> 3033</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03034" name="l03034"></a><span class="lineno"> 3034</span><span class="comment">   *        See Peer_socket::set_options().</span></div>
<div class="line"><a id="l03035" name="l03035"></a><span class="lineno"> 3035</span><span class="comment">   * @return See Peer_socket::set_options().</span></div>
<div class="line"><a id="l03036" name="l03036"></a><span class="lineno"> 3036</span><span class="comment">   */</span></div>
<div class="line"><a id="l03037" name="l03037"></a><span class="lineno"> 3037</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">sock_set_options</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03038" name="l03038"></a><span class="lineno"> 3038</span><span class="comment"></span> </div>
<div class="line"><a id="l03039" name="l03039"></a><span class="lineno"> 3039</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03040" name="l03040"></a><span class="lineno"> 3040</span><span class="comment">   * Implementation of `sock-&gt;info()` for socket `sock` in all cases except when</span></div>
<div class="line"><a id="l03041" name="l03041"></a><span class="lineno"> 3041</span><span class="comment">   * `sock-&gt;state() == Peer_socket::State::S_CLOSED`.  See Peer_socket::info() doc header; this method is the entirety</span></div>
<div class="line"><a id="l03042" name="l03042"></a><span class="lineno"> 3042</span><span class="comment">   * of that method&#39;s implementation after `S_CLOSED` is eliminated as a possibility.</span></div>
<div class="line"><a id="l03043" name="l03043"></a><span class="lineno"> 3043</span><span class="comment">   *</span></div>
<div class="line"><a id="l03044" name="l03044"></a><span class="lineno"> 3044</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l03045" name="l03045"></a><span class="lineno"> 3045</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l03046" name="l03046"></a><span class="lineno"> 3046</span><span class="comment">   *   - `sock-&gt;m_mutex` is locked and just after entering `sock-&gt;info()`;</span></div>
<div class="line"><a id="l03047" name="l03047"></a><span class="lineno"> 3047</span><span class="comment">   *   - no changes to *sock have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l03048" name="l03048"></a><span class="lineno"> 3048</span><span class="comment">   *   - `sock-&gt;state() == Peer_socket::State::S_OPEN`.</span></div>
<div class="line"><a id="l03049" name="l03049"></a><span class="lineno"> 3049</span><span class="comment">   *</span></div>
<div class="line"><a id="l03050" name="l03050"></a><span class="lineno"> 3050</span><span class="comment">   * Post-condition (not exhaustive): `sock-&gt;m_mutex` is unlocked.</span></div>
<div class="line"><a id="l03051" name="l03051"></a><span class="lineno"> 3051</span><span class="comment">   *</span></div>
<div class="line"><a id="l03052" name="l03052"></a><span class="lineno"> 3052</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03053" name="l03053"></a><span class="lineno"> 3053</span><span class="comment">   *        Socket in consideration.</span></div>
<div class="line"><a id="l03054" name="l03054"></a><span class="lineno"> 3054</span><span class="comment">   * @return See Peer_socket::info().</span></div>
<div class="line"><a id="l03055" name="l03055"></a><span class="lineno"> 3055</span><span class="comment">   */</span></div>
<div class="line"><a id="l03056" name="l03056"></a><span class="lineno"> 3056</span>  <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">sock_info</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock);</div>
<div class="line"><a id="l03057" name="l03057"></a><span class="lineno"> 3057</span><span class="comment"></span> </div>
<div class="line"><a id="l03058" name="l03058"></a><span class="lineno"> 3058</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03059" name="l03059"></a><span class="lineno"> 3059</span><span class="comment">   * Given a Peer_socket, copies all stats info (as available via Peer_socket::info()) from various</span></div>
<div class="line"><a id="l03060" name="l03060"></a><span class="lineno"> 3060</span><span class="comment">   * structures into the given stats `struct`.  This can then be logged, given to the user, etc.</span></div>
<div class="line"><a id="l03061" name="l03061"></a><span class="lineno"> 3061</span><span class="comment">   *</span></div>
<div class="line"><a id="l03062" name="l03062"></a><span class="lineno"> 3062</span><span class="comment">   * This should be run from thread W only.</span></div>
<div class="line"><a id="l03063" name="l03063"></a><span class="lineno"> 3063</span><span class="comment">   *</span></div>
<div class="line"><a id="l03064" name="l03064"></a><span class="lineno"> 3064</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03065" name="l03065"></a><span class="lineno"> 3065</span><span class="comment">   *        Socket in consideration.  It can be in any state, but see above.</span></div>
<div class="line"><a id="l03066" name="l03066"></a><span class="lineno"> 3066</span><span class="comment">   * @param stats</span></div>
<div class="line"><a id="l03067" name="l03067"></a><span class="lineno"> 3067</span><span class="comment">   *        All members (direct or indirect) of this `struct` will be filled.</span></div>
<div class="line"><a id="l03068" name="l03068"></a><span class="lineno"> 3068</span><span class="comment">   */</span></div>
<div class="line"><a id="l03069" name="l03069"></a><span class="lineno"> 3069</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">sock_load_info_struct</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock, <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>* stats) <span class="keyword">const</span>;</div>
<div class="line"><a id="l03070" name="l03070"></a><span class="lineno"> 3070</span><span class="comment"></span> </div>
<div class="line"><a id="l03071" name="l03071"></a><span class="lineno"> 3071</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03072" name="l03072"></a><span class="lineno"> 3072</span><span class="comment">   * Constructs the socket pair (connection ID) for the given socket.  For performance, try not to</span></div>
<div class="line"><a id="l03073" name="l03073"></a><span class="lineno"> 3073</span><span class="comment">   * use this, as this is usually already available in most points in Node code and can be passed</span></div>
<div class="line"><a id="l03074" name="l03074"></a><span class="lineno"> 3074</span><span class="comment">   * around to places where it&#39;s not.  However there are situations when one must reconstruct it</span></div>
<div class="line"><a id="l03075" name="l03075"></a><span class="lineno"> 3075</span><span class="comment">   * from a Peer_socket::Ptr alone.</span></div>
<div class="line"><a id="l03076" name="l03076"></a><span class="lineno"> 3076</span><span class="comment">   *</span></div>
<div class="line"><a id="l03077" name="l03077"></a><span class="lineno"> 3077</span><span class="comment">   * Call from thread W only.</span></div>
<div class="line"><a id="l03078" name="l03078"></a><span class="lineno"> 3078</span><span class="comment">   *</span></div>
<div class="line"><a id="l03079" name="l03079"></a><span class="lineno"> 3079</span><span class="comment">   * @todo Could make it a Socket_id constructor instead.</span></div>
<div class="line"><a id="l03080" name="l03080"></a><span class="lineno"> 3080</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03081" name="l03081"></a><span class="lineno"> 3081</span><span class="comment">   *        Source socket.</span></div>
<div class="line"><a id="l03082" name="l03082"></a><span class="lineno"> 3082</span><span class="comment">   * @return Ditto.</span></div>
<div class="line"><a id="l03083" name="l03083"></a><span class="lineno"> 3083</span><span class="comment">   */</span></div>
<div class="line"><a id="l03084" name="l03084"></a><span class="lineno"> 3084</span>  <span class="keyword">static</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock);</div>
<div class="line"><a id="l03085" name="l03085"></a><span class="lineno"> 3085</span><span class="comment"></span> </div>
<div class="line"><a id="l03086" name="l03086"></a><span class="lineno"> 3086</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03087" name="l03087"></a><span class="lineno"> 3087</span><span class="comment">   * Obtain the sequence number for the datum just past the last (latest) In-flight (i.e., sent but</span></div>
<div class="line"><a id="l03088" name="l03088"></a><span class="lineno"> 3088</span><span class="comment">   * neither Acknowledged nor Dropped) packet, for the given socket.  If there are no In-flight</span></div>
<div class="line"><a id="l03089" name="l03089"></a><span class="lineno"> 3089</span><span class="comment">   * packets, returns the default Sequence_number -- which is &lt; all other Sequence_numbers.</span></div>
<div class="line"><a id="l03090" name="l03090"></a><span class="lineno"> 3090</span><span class="comment">   *</span></div>
<div class="line"><a id="l03091" name="l03091"></a><span class="lineno"> 3091</span><span class="comment">   * Note that &quot;last&quot; in this case refers to position in the sequence number space, not time at which packets</span></div>
<div class="line"><a id="l03092" name="l03092"></a><span class="lineno"> 3092</span><span class="comment">   * are sent.  (A packet with a given Sequence_number may be sent several times due to retransmission.)</span></div>
<div class="line"><a id="l03093" name="l03093"></a><span class="lineno"> 3093</span><span class="comment">   *</span></div>
<div class="line"><a id="l03094" name="l03094"></a><span class="lineno"> 3094</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03095" name="l03095"></a><span class="lineno"> 3095</span><span class="comment">   *        Socket whose In-flight packets to examine.</span></div>
<div class="line"><a id="l03096" name="l03096"></a><span class="lineno"> 3096</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l03097" name="l03097"></a><span class="lineno"> 3097</span><span class="comment">   */</span></div>
<div class="line"><a id="l03098" name="l03098"></a><span class="lineno"> 3098</span>  <span class="keyword">static</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">snd_past_last_flying_datum_seq_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock);</div>
<div class="line"><a id="l03099" name="l03099"></a><span class="lineno"> 3099</span><span class="comment"></span> </div>
<div class="line"><a id="l03100" name="l03100"></a><span class="lineno"> 3100</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03101" name="l03101"></a><span class="lineno"> 3101</span><span class="comment">   * Erases (for example if considered Acknowledged or Dropped) a packet `struct` from the</span></div>
<div class="line"><a id="l03102" name="l03102"></a><span class="lineno"> 3102</span><span class="comment">   * &quot;scoreboard&quot; (Peer_socket::m_snd_flying_pkts_by_sent_when) and adjusts all related structures.</span></div>
<div class="line"><a id="l03103" name="l03103"></a><span class="lineno"> 3103</span><span class="comment">   *</span></div>
<div class="line"><a id="l03104" name="l03104"></a><span class="lineno"> 3104</span><span class="comment">   * Note: It does NOT inform `sock-&gt;m_snd_drop_timer` (namely calling Drop_timer::on_packet_no_longer_in_flight()).</span></div>
<div class="line"><a id="l03105" name="l03105"></a><span class="lineno"> 3105</span><span class="comment">   * This is left to the caller; in particular because the timing may not be appropriate for what such a</span></div>
<div class="line"><a id="l03106" name="l03106"></a><span class="lineno"> 3106</span><span class="comment">   * call might trigger (e.g., on-Drop-Timeout actions such as massive retransmission).</span></div>
<div class="line"><a id="l03107" name="l03107"></a><span class="lineno"> 3107</span><span class="comment">   *</span></div>
<div class="line"><a id="l03108" name="l03108"></a><span class="lineno"> 3108</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03109" name="l03109"></a><span class="lineno"> 3109</span><span class="comment">   *        Socket to modify.</span></div>
<div class="line"><a id="l03110" name="l03110"></a><span class="lineno"> 3110</span><span class="comment">   * @param pkt_it</span></div>
<div class="line"><a id="l03111" name="l03111"></a><span class="lineno"> 3111</span><span class="comment">   *        Iterator into `m_snd_flying_pkts_by_sent_when` which will be deleted.</span></div>
<div class="line"><a id="l03112" name="l03112"></a><span class="lineno"> 3112</span><span class="comment">   */</span></div>
<div class="line"><a id="l03113" name="l03113"></a><span class="lineno"> 3113</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">snd_flying_pkts_erase_one</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock, <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a> pkt_it);</div>
<div class="line"><a id="l03114" name="l03114"></a><span class="lineno"> 3114</span><span class="comment"></span> </div>
<div class="line"><a id="l03115" name="l03115"></a><span class="lineno"> 3115</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03116" name="l03116"></a><span class="lineno"> 3116</span><span class="comment">   * Adds a new packet `struct` (presumably representing packet to be sent shortly) to the</span></div>
<div class="line"><a id="l03117" name="l03117"></a><span class="lineno"> 3117</span><span class="comment">   * &quot;scoreboard&quot; (Peer_socket::m_snd_flying_pkts_by_sent_when) and adjusts all related structures as applicable.  Note,</span></div>
<div class="line"><a id="l03118" name="l03118"></a><span class="lineno"> 3118</span><span class="comment">   * however, that mark_data_packet_sent() is NOT called, because we should do that when the DATA</span></div>
<div class="line"><a id="l03119" name="l03119"></a><span class="lineno"> 3119</span><span class="comment">   * packet is actually sent (after pacing, if any).</span></div>
<div class="line"><a id="l03120" name="l03120"></a><span class="lineno"> 3120</span><span class="comment">   *</span></div>
<div class="line"><a id="l03121" name="l03121"></a><span class="lineno"> 3121</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03122" name="l03122"></a><span class="lineno"> 3122</span><span class="comment">   *        Socket to modify.</span></div>
<div class="line"><a id="l03123" name="l03123"></a><span class="lineno"> 3123</span><span class="comment">   * @param seq_num</span></div>
<div class="line"><a id="l03124" name="l03124"></a><span class="lineno"> 3124</span><span class="comment">   *        The first sequence number of the DATA packet.</span></div>
<div class="line"><a id="l03125" name="l03125"></a><span class="lineno"> 3125</span><span class="comment">   * @param sent_pkt</span></div>
<div class="line"><a id="l03126" name="l03126"></a><span class="lineno"> 3126</span><span class="comment">   *        Ref-counted pointer to new packet `struct`.</span></div>
<div class="line"><a id="l03127" name="l03127"></a><span class="lineno"> 3127</span><span class="comment">   */</span></div>
<div class="line"><a id="l03128" name="l03128"></a><span class="lineno"> 3128</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">snd_flying_pkts_push_one</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03129" name="l03129"></a><span class="lineno"> 3129</span>                                <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>&amp; seq_num,</div>
<div class="line"><a id="l03130" name="l03130"></a><span class="lineno"> 3130</span>                                <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Sent_packet::Ptr</a> sent_pkt);</div>
<div class="line"><a id="l03131" name="l03131"></a><span class="lineno"> 3131</span><span class="comment"></span> </div>
<div class="line"><a id="l03132" name="l03132"></a><span class="lineno"> 3132</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03133" name="l03133"></a><span class="lineno"> 3133</span><span class="comment">   * Updates Peer_socket::m_snd_flying_bytes according to an operation (add packets, remove packets)</span></div>
<div class="line"><a id="l03134" name="l03134"></a><span class="lineno"> 3134</span><span class="comment">   * caller is about to undertake or has just undertaken on Peer_socket::m_snd_flying_pkts_by_sent_when (= the</span></div>
<div class="line"><a id="l03135" name="l03135"></a><span class="lineno"> 3135</span><span class="comment">   * scoreboard).  Call this WHENEVER `m_snd_flying_pkts_by_sent_when` is about to be modified (if erasing) or</span></div>
<div class="line"><a id="l03136" name="l03136"></a><span class="lineno"> 3136</span><span class="comment">   * has just been modified (if adding) to ensure `m_snd_flying_bytes` is updated accordingly.</span></div>
<div class="line"><a id="l03137" name="l03137"></a><span class="lineno"> 3137</span><span class="comment">   *</span></div>
<div class="line"><a id="l03138" name="l03138"></a><span class="lineno"> 3138</span><span class="comment">   * @warning This has strong implications for congestion control!  Do not forget.</span></div>
<div class="line"><a id="l03139" name="l03139"></a><span class="lineno"> 3139</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03140" name="l03140"></a><span class="lineno"> 3140</span><span class="comment">   *        Socket to modify.</span></div>
<div class="line"><a id="l03141" name="l03141"></a><span class="lineno"> 3141</span><span class="comment">   * @param pkt_begin</span></div>
<div class="line"><a id="l03142" name="l03142"></a><span class="lineno"> 3142</span><span class="comment">   *        Iterator to first packet that was added or will be removed.</span></div>
<div class="line"><a id="l03143" name="l03143"></a><span class="lineno"> 3143</span><span class="comment">   * @param pkt_end</span></div>
<div class="line"><a id="l03144" name="l03144"></a><span class="lineno"> 3144</span><span class="comment">   *        Iterator one past the last packet that was added or will be removed.</span></div>
<div class="line"><a id="l03145" name="l03145"></a><span class="lineno"> 3145</span><span class="comment">   * @param added</span></div>
<div class="line"><a id="l03146" name="l03146"></a><span class="lineno"> 3146</span><span class="comment">   *        If `true`, the given range of packets was just added (e.g., Sent); if `false`, the given</span></div>
<div class="line"><a id="l03147" name="l03147"></a><span class="lineno"> 3147</span><span class="comment">   *        range of packets is about to be removed (e.g., Dropped or Acknowledged).</span></div>
<div class="line"><a id="l03148" name="l03148"></a><span class="lineno"> 3148</span><span class="comment">   */</span></div>
<div class="line"><a id="l03149" name="l03149"></a><span class="lineno"> 3149</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">snd_flying_pkts_updated</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03150" name="l03150"></a><span class="lineno"> 3150</span>                               <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a> pkt_begin,</div>
<div class="line"><a id="l03151" name="l03151"></a><span class="lineno"> 3151</span>                               <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">Peer_socket::Sent_pkt_ordered_by_when_const_iter</a>&amp; pkt_end,</div>
<div class="line"><a id="l03152" name="l03152"></a><span class="lineno"> 3152</span>                               <span class="keywordtype">bool</span> added);</div>
<div class="line"><a id="l03153" name="l03153"></a><span class="lineno"> 3153</span><span class="comment"></span> </div>
<div class="line"><a id="l03154" name="l03154"></a><span class="lineno"> 3154</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03155" name="l03155"></a><span class="lineno"> 3155</span><span class="comment">   * Checks whether the given sent packet has been retransmitted the maximum number of allowed</span></div>
<div class="line"><a id="l03156" name="l03156"></a><span class="lineno"> 3156</span><span class="comment">   * times; if so then performs rst_and_close_connection_immediately() and returns `false`; otherwise</span></div>
<div class="line"><a id="l03157" name="l03157"></a><span class="lineno"> 3157</span><span class="comment">   * returns `true`.</span></div>
<div class="line"><a id="l03158" name="l03158"></a><span class="lineno"> 3158</span><span class="comment">   *</span></div>
<div class="line"><a id="l03159" name="l03159"></a><span class="lineno"> 3159</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03160" name="l03160"></a><span class="lineno"> 3160</span><span class="comment">   *        Socket to check and possibly close.</span></div>
<div class="line"><a id="l03161" name="l03161"></a><span class="lineno"> 3161</span><span class="comment">   * @param pkt_it</span></div>
<div class="line"><a id="l03162" name="l03162"></a><span class="lineno"> 3162</span><span class="comment">   *        Iterator info Peer_socket::m_snd_flying_pkts_by_sent_when of `sock` for packet in question.  Its</span></div>
<div class="line"><a id="l03163" name="l03163"></a><span class="lineno"> 3163</span><span class="comment">   *        `m_rexmit_id` should not yet be incremented for the potential new retransmission.</span></div>
<div class="line"><a id="l03164" name="l03164"></a><span class="lineno"> 3164</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l03165" name="l03165"></a><span class="lineno"> 3165</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l03166" name="l03166"></a><span class="lineno"> 3166</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l03167" name="l03167"></a><span class="lineno"> 3167</span><span class="comment">   */</span></div>
<div class="line"><a id="l03168" name="l03168"></a><span class="lineno"> 3168</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">ok_to_rexmit_or_close</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03169" name="l03169"></a><span class="lineno"> 3169</span>                             <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">Peer_socket::Sent_pkt_ordered_by_when_iter</a>&amp; pkt_it,</div>
<div class="line"><a id="l03170" name="l03170"></a><span class="lineno"> 3170</span>                             <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l03171" name="l03171"></a><span class="lineno"> 3171</span><span class="comment"></span> </div>
<div class="line"><a id="l03172" name="l03172"></a><span class="lineno"> 3172</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03173" name="l03173"></a><span class="lineno"> 3173</span><span class="comment">   * Logs a verbose state report for the given socket.  This is suitable for calling from</span></div>
<div class="line"><a id="l03174" name="l03174"></a><span class="lineno"> 3174</span><span class="comment">   * perform_regular_infrequent_tasks() and other infrequently executed spots.</span></div>
<div class="line"><a id="l03175" name="l03175"></a><span class="lineno"> 3175</span><span class="comment">   *</span></div>
<div class="line"><a id="l03176" name="l03176"></a><span class="lineno"> 3176</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03177" name="l03177"></a><span class="lineno"> 3177</span><span class="comment">   *        Socket whose state to log.</span></div>
<div class="line"><a id="l03178" name="l03178"></a><span class="lineno"> 3178</span><span class="comment">   */</span></div>
<div class="line"><a id="l03179" name="l03179"></a><span class="lineno"> 3179</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">sock_log_detail</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Peer_socket::Const_ptr</a> sock) <span class="keyword">const</span>;</div>
<div class="line"><a id="l03180" name="l03180"></a><span class="lineno"> 3180</span><span class="comment"></span> </div>
<div class="line"><a id="l03181" name="l03181"></a><span class="lineno"> 3181</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03182" name="l03182"></a><span class="lineno"> 3182</span><span class="comment">   * Assuming `*seq_num` points to the start of data.m_data, increments `*seq_num` to point</span></div>
<div class="line"><a id="l03183" name="l03183"></a><span class="lineno"> 3183</span><span class="comment">   * to the datum just past `data-&gt;m_data`.</span></div>
<div class="line"><a id="l03184" name="l03184"></a><span class="lineno"> 3184</span><span class="comment">   *</span></div>
<div class="line"><a id="l03185" name="l03185"></a><span class="lineno"> 3185</span><span class="comment">   * @param seq_num</span></div>
<div class="line"><a id="l03186" name="l03186"></a><span class="lineno"> 3186</span><span class="comment">   *        Pointer to sequence number to increment.</span></div>
<div class="line"><a id="l03187" name="l03187"></a><span class="lineno"> 3187</span><span class="comment">   * @param data</span></div>
<div class="line"><a id="l03188" name="l03188"></a><span class="lineno"> 3188</span><span class="comment">   *        DATA packet whose `m_data` to examine.</span></div>
<div class="line"><a id="l03189" name="l03189"></a><span class="lineno"> 3189</span><span class="comment">   */</span></div>
<div class="line"><a id="l03190" name="l03190"></a><span class="lineno"> 3190</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a>(<a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num,</div>
<div class="line"><a id="l03191" name="l03191"></a><span class="lineno"> 3191</span>                              boost::shared_ptr&lt;const Data_packet&gt; data);</div>
<div class="line"><a id="l03192" name="l03192"></a><span class="lineno"> 3192</span><span class="comment"></span> </div>
<div class="line"><a id="l03193" name="l03193"></a><span class="lineno"> 3193</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03194" name="l03194"></a><span class="lineno"> 3194</span><span class="comment">   * Assuming `*seq_num` points to the start of some data of the given size, increments</span></div>
<div class="line"><a id="l03195" name="l03195"></a><span class="lineno"> 3195</span><span class="comment">   * `*seq_num` to point to the datum just past that amount of data.</span></div>
<div class="line"><a id="l03196" name="l03196"></a><span class="lineno"> 3196</span><span class="comment">   *</span></div>
<div class="line"><a id="l03197" name="l03197"></a><span class="lineno"> 3197</span><span class="comment">   * @param seq_num</span></div>
<div class="line"><a id="l03198" name="l03198"></a><span class="lineno"> 3198</span><span class="comment">   *        Pointer to sequence number to increment.</span></div>
<div class="line"><a id="l03199" name="l03199"></a><span class="lineno"> 3199</span><span class="comment">   * @param data_size</span></div>
<div class="line"><a id="l03200" name="l03200"></a><span class="lineno"> 3200</span><span class="comment">   *        Data size.</span></div>
<div class="line"><a id="l03201" name="l03201"></a><span class="lineno"> 3201</span><span class="comment">   */</span></div>
<div class="line"><a id="l03202" name="l03202"></a><span class="lineno"> 3202</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">advance_seq_num</a>(<a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num, <span class="keywordtype">size_t</span> data_size);</div>
<div class="line"><a id="l03203" name="l03203"></a><span class="lineno"> 3203</span><span class="comment"></span> </div>
<div class="line"><a id="l03204" name="l03204"></a><span class="lineno"> 3204</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03205" name="l03205"></a><span class="lineno"> 3205</span><span class="comment">   * Given an iterator into a Peer_socket::Sent_pkt_by_sent_when_map or Peer_socket::Recv_pkt_map, gets the range of</span></div>
<div class="line"><a id="l03206" name="l03206"></a><span class="lineno"> 3206</span><span class="comment">   * sequence numbers in the packet represented thereby.</span></div>
<div class="line"><a id="l03207" name="l03207"></a><span class="lineno"> 3207</span><span class="comment">   *</span></div>
<div class="line"><a id="l03208" name="l03208"></a><span class="lineno"> 3208</span><span class="comment">   * @tparam Packet_map_iter</span></div>
<div class="line"><a id="l03209" name="l03209"></a><span class="lineno"> 3209</span><span class="comment">   *         Iterator type (`const` or otherwise) into one of the above-mentioned maps.</span></div>
<div class="line"><a id="l03210" name="l03210"></a><span class="lineno"> 3210</span><span class="comment">   * @param packet_it</span></div>
<div class="line"><a id="l03211" name="l03211"></a><span class="lineno"> 3211</span><span class="comment">   *        A valid, non-`end()` iterator into such a map.</span></div>
<div class="line"><a id="l03212" name="l03212"></a><span class="lineno"> 3212</span><span class="comment">   * @param seq_num_start</span></div>
<div class="line"><a id="l03213" name="l03213"></a><span class="lineno"> 3213</span><span class="comment">   *        If 0, ignored; otherwise the sequence number of the first datum in that packet is placed</span></div>
<div class="line"><a id="l03214" name="l03214"></a><span class="lineno"> 3214</span><span class="comment">   *        there.</span></div>
<div class="line"><a id="l03215" name="l03215"></a><span class="lineno"> 3215</span><span class="comment">   * @param seq_num_end</span></div>
<div class="line"><a id="l03216" name="l03216"></a><span class="lineno"> 3216</span><span class="comment">   *        If 0, ignored; otherwise the sequence number just past the last datum in that packet is</span></div>
<div class="line"><a id="l03217" name="l03217"></a><span class="lineno"> 3217</span><span class="comment">   *        placed there.</span></div>
<div class="line"><a id="l03218" name="l03218"></a><span class="lineno"> 3218</span><span class="comment">   */</span></div>
<div class="line"><a id="l03219" name="l03219"></a><span class="lineno"> 3219</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Packet_map_iter&gt;</div>
<div class="line"><a id="l03220" name="l03220"></a><span class="lineno"> 3220</span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">get_seq_num_range</a>(<span class="keyword">const</span> Packet_map_iter&amp; packet_it,</div>
<div class="line"><a id="l03221" name="l03221"></a><span class="lineno"> 3221</span>                                <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_start, <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number.html">Sequence_number</a>* seq_num_end);</div>
<div class="line"><a id="l03222" name="l03222"></a><span class="lineno"> 3222</span><span class="comment"></span> </div>
<div class="line"><a id="l03223" name="l03223"></a><span class="lineno"> 3223</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03224" name="l03224"></a><span class="lineno"> 3224</span><span class="comment">   * Returns the &quot;order number&quot; to use for Peer_socket::Sent_packet::Sent_when structure corresponding to the next</span></div>
<div class="line"><a id="l03225" name="l03225"></a><span class="lineno"> 3225</span><span class="comment">   * packet to be sent.  This will be higher than the last sent packet&#39;s number.  Make sure you send packets</span></div>
<div class="line"><a id="l03226" name="l03226"></a><span class="lineno"> 3226</span><span class="comment">   * in exactly increasing numeric order of this order number.</span></div>
<div class="line"><a id="l03227" name="l03227"></a><span class="lineno"> 3227</span><span class="comment">   *</span></div>
<div class="line"><a id="l03228" name="l03228"></a><span class="lineno"> 3228</span><span class="comment">   * 0 is reserved and never returned by this.</span></div>
<div class="line"><a id="l03229" name="l03229"></a><span class="lineno"> 3229</span><span class="comment">   *</span></div>
<div class="line"><a id="l03230" name="l03230"></a><span class="lineno"> 3230</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03231" name="l03231"></a><span class="lineno"> 3231</span><span class="comment">   *        Socket to consider.</span></div>
<div class="line"><a id="l03232" name="l03232"></a><span class="lineno"> 3232</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l03233" name="l03233"></a><span class="lineno"> 3233</span><span class="comment">   */</span></div>
<div class="line"><a id="l03234" name="l03234"></a><span class="lineno"> 3234</span>  <span class="keyword">static</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">Peer_socket::order_num_t</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">sock_get_new_snd_order_num</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l03235" name="l03235"></a><span class="lineno"> 3235</span><span class="comment"></span> </div>
<div class="line"><a id="l03236" name="l03236"></a><span class="lineno"> 3236</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03237" name="l03237"></a><span class="lineno"> 3237</span><span class="comment">   * Internal factory used for ALL Peer_socket objects created by this Node (including subclasses).</span></div>
<div class="line"><a id="l03238" name="l03238"></a><span class="lineno"> 3238</span><span class="comment">   *</span></div>
<div class="line"><a id="l03239" name="l03239"></a><span class="lineno"> 3239</span><span class="comment">   * @param opts</span></div>
<div class="line"><a id="l03240" name="l03240"></a><span class="lineno"> 3240</span><span class="comment">   *        See Peer_socket::Peer_socket().</span></div>
<div class="line"><a id="l03241" name="l03241"></a><span class="lineno"> 3241</span><span class="comment">   * @return Pointer to newly constructed socket.</span></div>
<div class="line"><a id="l03242" name="l03242"></a><span class="lineno"> 3242</span><span class="comment">   */</span></div>
<div class="line"><a id="l03243" name="l03243"></a><span class="lineno"> 3243</span>  <span class="keyword">virtual</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">sock_create</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts);</div>
<div class="line"><a id="l03244" name="l03244"></a><span class="lineno"> 3244</span> </div>
<div class="line"><a id="l03245" name="l03245"></a><span class="lineno"> 3245</span>  <span class="comment">// Methods dealing with individual Server_sockets.  Implementations are in server_socket.cpp.</span></div>
<div class="line"><a id="l03246" name="l03246"></a><span class="lineno"> 3246</span><span class="comment"></span> </div>
<div class="line"><a id="l03247" name="l03247"></a><span class="lineno"> 3247</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03248" name="l03248"></a><span class="lineno"> 3248</span><span class="comment">   * Implementation of non-blocking `serv-&gt;accept()` for server socket `serv` in all cases except when</span></div>
<div class="line"><a id="l03249" name="l03249"></a><span class="lineno"> 3249</span><span class="comment">   * `serv-&gt;state() == Server_socket::State::S_CLOSED`.</span></div>
<div class="line"><a id="l03250" name="l03250"></a><span class="lineno"> 3250</span><span class="comment">   *</span></div>
<div class="line"><a id="l03251" name="l03251"></a><span class="lineno"> 3251</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l03252" name="l03252"></a><span class="lineno"> 3252</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l03253" name="l03253"></a><span class="lineno"> 3253</span><span class="comment">   *   - `serv-&gt;m_mutex` is locked and just after entering `serv-&gt;accept()`;</span></div>
<div class="line"><a id="l03254" name="l03254"></a><span class="lineno"> 3254</span><span class="comment">   *   - no changes to `*serv` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l03255" name="l03255"></a><span class="lineno"> 3255</span><span class="comment">   *   - `serv-&gt;state() != Server_socket::State::S_CLOSED` (so `serv` is in `m_servs`).</span></div>
<div class="line"><a id="l03256" name="l03256"></a><span class="lineno"> 3256</span><span class="comment">   *</span></div>
<div class="line"><a id="l03257" name="l03257"></a><span class="lineno"> 3257</span><span class="comment">   * This method completes the functionality of `serv-&gt;accept()`.</span></div>
<div class="line"><a id="l03258" name="l03258"></a><span class="lineno"> 3258</span><span class="comment">   *</span></div>
<div class="line"><a id="l03259" name="l03259"></a><span class="lineno"> 3259</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03260" name="l03260"></a><span class="lineno"> 3260</span><span class="comment">   *        Server socket, which must be in #m_servs, on which Server_socket::accept() was called.</span></div>
<div class="line"><a id="l03261" name="l03261"></a><span class="lineno"> 3261</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03262" name="l03262"></a><span class="lineno"> 3262</span><span class="comment">   *        See Server_socket::accept().</span></div>
<div class="line"><a id="l03263" name="l03263"></a><span class="lineno"> 3263</span><span class="comment">   * @return See Server_socket::accept().</span></div>
<div class="line"><a id="l03264" name="l03264"></a><span class="lineno"> 3264</span><span class="comment">   */</span></div>
<div class="line"><a id="l03265" name="l03265"></a><span class="lineno"> 3265</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567">accept</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03266" name="l03266"></a><span class="lineno"> 3266</span><span class="comment"></span> </div>
<div class="line"><a id="l03267" name="l03267"></a><span class="lineno"> 3267</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03268" name="l03268"></a><span class="lineno"> 3268</span><span class="comment">   * Returns `true` if and only if calling `serv-&gt;accept()` with at least some arguments would return</span></div>
<div class="line"><a id="l03269" name="l03269"></a><span class="lineno"> 3269</span><span class="comment">   * either non-null (i.e., successfully dequeued a connected socket) or null and an error (but not</span></div>
<div class="line"><a id="l03270" name="l03270"></a><span class="lineno"> 3270</span><span class="comment">   * null and NO error).  `serv` will be locked and unlocked; safe to call from any thread.</span></div>
<div class="line"><a id="l03271" name="l03271"></a><span class="lineno"> 3271</span><span class="comment">   *</span></div>
<div class="line"><a id="l03272" name="l03272"></a><span class="lineno"> 3272</span><span class="comment">   * @param serv_as_any</span></div>
<div class="line"><a id="l03273" name="l03273"></a><span class="lineno"> 3273</span><span class="comment">   *        Socket to examine, as an `any` wrapping a Server_socket::Ptr.</span></div>
<div class="line"><a id="l03274" name="l03274"></a><span class="lineno"> 3274</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l03275" name="l03275"></a><span class="lineno"> 3275</span><span class="comment">   */</span></div>
<div class="line"><a id="l03276" name="l03276"></a><span class="lineno"> 3276</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a51b26bff4cdf545f22d8edec7185c5c4">serv_is_acceptable</a>(<span class="keyword">const</span> boost::any&amp; serv_as_any) <span class="keyword">const</span>;</div>
<div class="line"><a id="l03277" name="l03277"></a><span class="lineno"> 3277</span><span class="comment"></span> </div>
<div class="line"><a id="l03278" name="l03278"></a><span class="lineno"> 3278</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03279" name="l03279"></a><span class="lineno"> 3279</span><span class="comment">   * Thread W implementation of listen().  Performs all the needed work, gives the resulting</span></div>
<div class="line"><a id="l03280" name="l03280"></a><span class="lineno"> 3280</span><span class="comment">   * Server_socket to the user thread, and signals that user thread.</span></div>
<div class="line"><a id="l03281" name="l03281"></a><span class="lineno"> 3281</span><span class="comment">   *</span></div>
<div class="line"><a id="l03282" name="l03282"></a><span class="lineno"> 3282</span><span class="comment">   * Pre-condition: We&#39;re in thread W; thread U != W is waiting for us to return having set `*serv`.  Post-condition:</span></div>
<div class="line"><a id="l03283" name="l03283"></a><span class="lineno"> 3283</span><span class="comment">   * `*serv` contains a `Server_socket::Ptr` in a Server_socket::State::S_LISTENING state if</span></div>
<div class="line"><a id="l03284" name="l03284"></a><span class="lineno"> 3284</span><span class="comment">   * `!(*serv)-&gt;m_disconnect_cause`; otherwise an error occurred, and that error is `(*serv)-&gt;m_disconnect_cause`.</span></div>
<div class="line"><a id="l03285" name="l03285"></a><span class="lineno"> 3285</span><span class="comment">   *</span></div>
<div class="line"><a id="l03286" name="l03286"></a><span class="lineno"> 3286</span><span class="comment">   * @param local_port</span></div>
<div class="line"><a id="l03287" name="l03287"></a><span class="lineno"> 3287</span><span class="comment">   *        See listen().</span></div>
<div class="line"><a id="l03288" name="l03288"></a><span class="lineno"> 3288</span><span class="comment">   * @param child_sock_opts</span></div>
<div class="line"><a id="l03289" name="l03289"></a><span class="lineno"> 3289</span><span class="comment">   *        See listen().</span></div>
<div class="line"><a id="l03290" name="l03290"></a><span class="lineno"> 3290</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03291" name="l03291"></a><span class="lineno"> 3291</span><span class="comment">   *        `*serv` shall be set to the resulting Server_socket.  Check `(*serv)-&gt;m_disconnect_cause`.</span></div>
<div class="line"><a id="l03292" name="l03292"></a><span class="lineno"> 3292</span><span class="comment">   */</span></div>
<div class="line"><a id="l03293" name="l03293"></a><span class="lineno"> 3293</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aba411df8746d5fd4db2d28df3a016f5e">listen_worker</a>(<a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* child_sock_opts,</div>
<div class="line"><a id="l03294" name="l03294"></a><span class="lineno"> 3294</span>                     <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>* serv);</div>
<div class="line"><a id="l03295" name="l03295"></a><span class="lineno"> 3295</span><span class="comment"></span> </div>
<div class="line"><a id="l03296" name="l03296"></a><span class="lineno"> 3296</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03297" name="l03297"></a><span class="lineno"> 3297</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed low-level SYN packet delivered to the given</span></div>
<div class="line"><a id="l03298" name="l03298"></a><span class="lineno"> 3298</span><span class="comment">   * server socket.  So it will hopefully create a #m_socks entry, send back a SYN_ACK, etc.</span></div>
<div class="line"><a id="l03299" name="l03299"></a><span class="lineno"> 3299</span><span class="comment">   *</span></div>
<div class="line"><a id="l03300" name="l03300"></a><span class="lineno"> 3300</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03301" name="l03301"></a><span class="lineno"> 3301</span><span class="comment">   *        Server socket in LISTENING state to which this SYN was demuxed.</span></div>
<div class="line"><a id="l03302" name="l03302"></a><span class="lineno"> 3302</span><span class="comment">   * @param syn</span></div>
<div class="line"><a id="l03303" name="l03303"></a><span class="lineno"> 3303</span><span class="comment">   *        Deserialized immutable SYN.</span></div>
<div class="line"><a id="l03304" name="l03304"></a><span class="lineno"> 3304</span><span class="comment">   * @param low_lvl_remote_endpoint</span></div>
<div class="line"><a id="l03305" name="l03305"></a><span class="lineno"> 3305</span><span class="comment">   *        The remote Node address.</span></div>
<div class="line"><a id="l03306" name="l03306"></a><span class="lineno"> 3306</span><span class="comment">   * @return New socket placed into Node socket table; or `Ptr()` on error, wherein no socket was saved.</span></div>
<div class="line"><a id="l03307" name="l03307"></a><span class="lineno"> 3307</span><span class="comment">   */</span></div>
<div class="line"><a id="l03308" name="l03308"></a><span class="lineno"> 3308</span>  <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aaaf5c3b5e6b9f9f1658b60907b36a498">handle_syn_to_listening_server</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv,</div>
<div class="line"><a id="l03309" name="l03309"></a><span class="lineno"> 3309</span>                                                  boost::shared_ptr&lt;const Syn_packet&gt; syn,</div>
<div class="line"><a id="l03310" name="l03310"></a><span class="lineno"> 3310</span>                                                  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a>&amp; low_lvl_remote_endpoint);</div>
<div class="line"><a id="l03311" name="l03311"></a><span class="lineno"> 3311</span><span class="comment"></span> </div>
<div class="line"><a id="l03312" name="l03312"></a><span class="lineno"> 3312</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03313" name="l03313"></a><span class="lineno"> 3313</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed low-level SYN_ACK_ACK packet delivered to the</span></div>
<div class="line"><a id="l03314" name="l03314"></a><span class="lineno"> 3314</span><span class="comment">   * given peer socket in Peer_socket::Int_state::S_SYN_RCVD state.  So it will hopefully finish up establishing</span></div>
<div class="line"><a id="l03315" name="l03315"></a><span class="lineno"> 3315</span><span class="comment">   * connection on our side.</span></div>
<div class="line"><a id="l03316" name="l03316"></a><span class="lineno"> 3316</span><span class="comment">   *</span></div>
<div class="line"><a id="l03317" name="l03317"></a><span class="lineno"> 3317</span><span class="comment">   * @param socket_id</span></div>
<div class="line"><a id="l03318" name="l03318"></a><span class="lineno"> 3318</span><span class="comment">   *        Connection ID (socket pair) identifying the socket in #m_socks.</span></div>
<div class="line"><a id="l03319" name="l03319"></a><span class="lineno"> 3319</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03320" name="l03320"></a><span class="lineno"> 3320</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_SYN_RCVD.</span></div>
<div class="line"><a id="l03321" name="l03321"></a><span class="lineno"> 3321</span><span class="comment">   * @param syn_ack_ack</span></div>
<div class="line"><a id="l03322" name="l03322"></a><span class="lineno"> 3322</span><span class="comment">   *        Deserialized immutable SYN_ACK_ACK.</span></div>
<div class="line"><a id="l03323" name="l03323"></a><span class="lineno"> 3323</span><span class="comment">   */</span></div>
<div class="line"><a id="l03324" name="l03324"></a><span class="lineno"> 3324</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a29d02f9e302c7b06288ff1c644fa8d65">handle_syn_ack_ack_to_syn_rcvd</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Socket_id</a>&amp; <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">socket_id</a>,</div>
<div class="line"><a id="l03325" name="l03325"></a><span class="lineno"> 3325</span>                                      <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03326" name="l03326"></a><span class="lineno"> 3326</span>                                      boost::shared_ptr&lt;const Syn_ack_ack_packet&gt; syn_ack_ack);</div>
<div class="line"><a id="l03327" name="l03327"></a><span class="lineno"> 3327</span><span class="comment"></span> </div>
<div class="line"><a id="l03328" name="l03328"></a><span class="lineno"> 3328</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03329" name="l03329"></a><span class="lineno"> 3329</span><span class="comment">   * Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given</span></div>
<div class="line"><a id="l03330" name="l03330"></a><span class="lineno"> 3330</span><span class="comment">   * peer socket in SYN_RCVD state.  This is legitimate under loss and re-ordering conditions.</span></div>
<div class="line"><a id="l03331" name="l03331"></a><span class="lineno"> 3331</span><span class="comment">   * This will hopefully save the packet for later handling once we have entered ESTABLISHED state.</span></div>
<div class="line"><a id="l03332" name="l03332"></a><span class="lineno"> 3332</span><span class="comment">   *</span></div>
<div class="line"><a id="l03333" name="l03333"></a><span class="lineno"> 3333</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03334" name="l03334"></a><span class="lineno"> 3334</span><span class="comment">   *        Peer socket in Peer_socket::Int_state::S_SYN_RCVD.</span></div>
<div class="line"><a id="l03335" name="l03335"></a><span class="lineno"> 3335</span><span class="comment">   * @param packet</span></div>
<div class="line"><a id="l03336" name="l03336"></a><span class="lineno"> 3336</span><span class="comment">   *        Deserialized packet of type DATA.</span></div>
<div class="line"><a id="l03337" name="l03337"></a><span class="lineno"> 3337</span><span class="comment">   *        (For performance when moving data to Receive buffer, this is modifiable.)</span></div>
<div class="line"><a id="l03338" name="l03338"></a><span class="lineno"> 3338</span><span class="comment">   */</span></div>
<div class="line"><a id="l03339" name="l03339"></a><span class="lineno"> 3339</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c">handle_data_to_syn_rcvd</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock,</div>
<div class="line"><a id="l03340" name="l03340"></a><span class="lineno"> 3340</span>                               boost::shared_ptr&lt;Data_packet&gt; packet);</div>
<div class="line"><a id="l03341" name="l03341"></a><span class="lineno"> 3341</span><span class="comment"></span> </div>
<div class="line"><a id="l03342" name="l03342"></a><span class="lineno"> 3342</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03343" name="l03343"></a><span class="lineno"> 3343</span><span class="comment">   * Handles the transition of the given server socket from `S_LISTENING`/`S_CLOSING` to `S_CLOSED`</span></div>
<div class="line"><a id="l03344" name="l03344"></a><span class="lineno"> 3344</span><span class="comment">   * (including eliminating the given Peer_socket from our data structures).</span></div>
<div class="line"><a id="l03345" name="l03345"></a><span class="lineno"> 3345</span><span class="comment">   *</span></div>
<div class="line"><a id="l03346" name="l03346"></a><span class="lineno"> 3346</span><span class="comment">   * Pre-condition: there is no socket `sock` such that `sock-&gt;m_originating_serv == serv`; i.e., there</span></div>
<div class="line"><a id="l03347" name="l03347"></a><span class="lineno"> 3347</span><span class="comment">   * are no sockets having to do with this server that have not yet been `accept()`ed.</span></div>
<div class="line"><a id="l03348" name="l03348"></a><span class="lineno"> 3348</span><span class="comment">   *</span></div>
<div class="line"><a id="l03349" name="l03349"></a><span class="lineno"> 3349</span><span class="comment">   * Pre-condition: `serv` is in `m_servs`; `serv-&gt;state() != S_OPEN`.</span></div>
<div class="line"><a id="l03350" name="l03350"></a><span class="lineno"> 3350</span><span class="comment">   *</span></div>
<div class="line"><a id="l03351" name="l03351"></a><span class="lineno"> 3351</span><span class="comment">   * Post-condition: `serv-&gt;state() == Server_socket::State::S_CLOSED` (and `serv` is no longer in `m_servs` or any</span></div>
<div class="line"><a id="l03352" name="l03352"></a><span class="lineno"> 3352</span><span class="comment">   * other Node structures, directly or indirectly) with `serv-&gt;m_disconnect_cause` set to `err_code` (or see</span></div>
<div class="line"><a id="l03353" name="l03353"></a><span class="lineno"> 3353</span><span class="comment">   * below).</span></div>
<div class="line"><a id="l03354" name="l03354"></a><span class="lineno"> 3354</span><span class="comment">   *</span></div>
<div class="line"><a id="l03355" name="l03355"></a><span class="lineno"> 3355</span><span class="comment">   * Any server socket that is in #m_servs MUST be eventually closed using this method.  No</span></div>
<div class="line"><a id="l03356" name="l03356"></a><span class="lineno"> 3356</span><span class="comment">   * socket that is not in #m_servs must be passed to this method.  In particular, do not call this</span></div>
<div class="line"><a id="l03357" name="l03357"></a><span class="lineno"> 3357</span><span class="comment">   * method during listen().</span></div>
<div class="line"><a id="l03358" name="l03358"></a><span class="lineno"> 3358</span><span class="comment">   *</span></div>
<div class="line"><a id="l03359" name="l03359"></a><span class="lineno"> 3359</span><span class="comment">   * @param local_port</span></div>
<div class="line"><a id="l03360" name="l03360"></a><span class="lineno"> 3360</span><span class="comment">   *        Flow port of the server to delete.</span></div>
<div class="line"><a id="l03361" name="l03361"></a><span class="lineno"> 3361</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03362" name="l03362"></a><span class="lineno"> 3362</span><span class="comment">   *        Socket to close.</span></div>
<div class="line"><a id="l03363" name="l03363"></a><span class="lineno"> 3363</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03364" name="l03364"></a><span class="lineno"> 3364</span><span class="comment">   *        Why is it being closed?  Server_socket::m_disconnect_cause is set accordingly and logged.</span></div>
<div class="line"><a id="l03365" name="l03365"></a><span class="lineno"> 3365</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l03366" name="l03366"></a><span class="lineno"> 3366</span><span class="comment">   *        Same meaning as in event_set_all_check_delta().</span></div>
<div class="line"><a id="l03367" name="l03367"></a><span class="lineno"> 3367</span><span class="comment">   */</span></div>
<div class="line"><a id="l03368" name="l03368"></a><span class="lineno"> 3368</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#adf6d71af81def2d030f0fef159c1b06d">close_empty_server_immediately</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv,</div>
<div class="line"><a id="l03369" name="l03369"></a><span class="lineno"> 3369</span>                                      <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; err_code, <span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l03370" name="l03370"></a><span class="lineno"> 3370</span><span class="comment"></span> </div>
<div class="line"><a id="l03371" name="l03371"></a><span class="lineno"> 3371</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03372" name="l03372"></a><span class="lineno"> 3372</span><span class="comment">   * Sets Server_socket::m_state.  If moving to `S_CLOSED`, resets the required data to their &quot;undefined&quot; values</span></div>
<div class="line"><a id="l03373" name="l03373"></a><span class="lineno"> 3373</span><span class="comment">   * (e.g., `Server_socket::m_local_port = #S_PORT_ANY`).  Thread-safe.</span></div>
<div class="line"><a id="l03374" name="l03374"></a><span class="lineno"> 3374</span><span class="comment">   *</span></div>
<div class="line"><a id="l03375" name="l03375"></a><span class="lineno"> 3375</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03376" name="l03376"></a><span class="lineno"> 3376</span><span class="comment">   *        Server socket under consideration.</span></div>
<div class="line"><a id="l03377" name="l03377"></a><span class="lineno"> 3377</span><span class="comment">   * @param state</span></div>
<div class="line"><a id="l03378" name="l03378"></a><span class="lineno"> 3378</span><span class="comment">   *        New `m_state`.</span></div>
<div class="line"><a id="l03379" name="l03379"></a><span class="lineno"> 3379</span><span class="comment">   */</span></div>
<div class="line"><a id="l03380" name="l03380"></a><span class="lineno"> 3380</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0bac29a091e1026e5b4f0b5d84a710c7">serv_set_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a> state);</div>
<div class="line"><a id="l03381" name="l03381"></a><span class="lineno"> 3381</span><span class="comment"></span> </div>
<div class="line"><a id="l03382" name="l03382"></a><span class="lineno"> 3382</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03383" name="l03383"></a><span class="lineno"> 3383</span><span class="comment">   * Records that thread W shows this socket is not to listen to incoming connections and is to</span></div>
<div class="line"><a id="l03384" name="l03384"></a><span class="lineno"> 3384</span><span class="comment">   * abort any not-yet-established (i.e., not yet queued) and established-but-unclaimed (i.e.,</span></div>
<div class="line"><a id="l03385" name="l03385"></a><span class="lineno"> 3385</span><span class="comment">   * queued) connections; and sets Server_socket::m_disconnect_cause and Server_socket::m_state in `serv` accordingly.</span></div>
<div class="line"><a id="l03386" name="l03386"></a><span class="lineno"> 3386</span><span class="comment">   * Thread-safe.</span></div>
<div class="line"><a id="l03387" name="l03387"></a><span class="lineno"> 3387</span><span class="comment">   *</span></div>
<div class="line"><a id="l03388" name="l03388"></a><span class="lineno"> 3388</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03389" name="l03389"></a><span class="lineno"> 3389</span><span class="comment">   *        Server socket under consideration.</span></div>
<div class="line"><a id="l03390" name="l03390"></a><span class="lineno"> 3390</span><span class="comment">   * @param disconnect_cause</span></div>
<div class="line"><a id="l03391" name="l03391"></a><span class="lineno"> 3391</span><span class="comment">   *        The cause of the disconnect.</span></div>
<div class="line"><a id="l03392" name="l03392"></a><span class="lineno"> 3392</span><span class="comment">   * @param close</span></div>
<div class="line"><a id="l03393" name="l03393"></a><span class="lineno"> 3393</span><span class="comment">   *        If `true`, the target public state should be the super-final `S_CLOSED`; if false, the target public state</span></div>
<div class="line"><a id="l03394" name="l03394"></a><span class="lineno"> 3394</span><span class="comment">   *        should be the ominous `S_CLOSING`. The caller&#39;s responsibility is to decide which one it</span></div>
<div class="line"><a id="l03395" name="l03395"></a><span class="lineno"> 3395</span><span class="comment">   *        is.</span></div>
<div class="line"><a id="l03396" name="l03396"></a><span class="lineno"> 3396</span><span class="comment">   */</span></div>
<div class="line"><a id="l03397" name="l03397"></a><span class="lineno"> 3397</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2af9ec4f1483cd9a2183286f7dfa9c87">serv_close_detected</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; disconnect_cause, <span class="keywordtype">bool</span> close);</div>
<div class="line"><a id="l03398" name="l03398"></a><span class="lineno"> 3398</span><span class="comment"></span> </div>
<div class="line"><a id="l03399" name="l03399"></a><span class="lineno"> 3399</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03400" name="l03400"></a><span class="lineno"> 3400</span><span class="comment">   * Records that an unestablished socket `sock` (Peer_socket::Int_state::S_SYN_RCVD) has just become established</span></div>
<div class="line"><a id="l03401" name="l03401"></a><span class="lineno"> 3401</span><span class="comment">   * and can be `accept()`ed (Peer_socket::Int_state::S_ESTABLISHED).  Moves `sock` from</span></div>
<div class="line"><a id="l03402" name="l03402"></a><span class="lineno"> 3402</span><span class="comment">   * Server_socket::m_connecting_socks to Server_socket::m_unaccepted_socks (in `serv`).</span></div>
<div class="line"><a id="l03403" name="l03403"></a><span class="lineno"> 3403</span><span class="comment">   * To be called from thread W only.  Thread-safe.</span></div>
<div class="line"><a id="l03404" name="l03404"></a><span class="lineno"> 3404</span><span class="comment">   *</span></div>
<div class="line"><a id="l03405" name="l03405"></a><span class="lineno"> 3405</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03406" name="l03406"></a><span class="lineno"> 3406</span><span class="comment">   *        Server socket under consideration.</span></div>
<div class="line"><a id="l03407" name="l03407"></a><span class="lineno"> 3407</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03408" name="l03408"></a><span class="lineno"> 3408</span><span class="comment">   *        Socket that was just moved to Peer_socket::Int_state::S_ESTABLISHED.</span></div>
<div class="line"><a id="l03409" name="l03409"></a><span class="lineno"> 3409</span><span class="comment">   */</span></div>
<div class="line"><a id="l03410" name="l03410"></a><span class="lineno"> 3410</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#abf0204e999b5dc28ee9b5db6eae9aa1a">serv_peer_socket_acceptable</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l03411" name="l03411"></a><span class="lineno"> 3411</span><span class="comment"></span> </div>
<div class="line"><a id="l03412" name="l03412"></a><span class="lineno"> 3412</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03413" name="l03413"></a><span class="lineno"> 3413</span><span class="comment">   * Records a new (just received SYN) peer socket from the given server socket.  Adds `sock` to</span></div>
<div class="line"><a id="l03414" name="l03414"></a><span class="lineno"> 3414</span><span class="comment">   * Server_socket::m_connecting_socks (in `serv`) and maintains the Peer_socket::m_originating_serv (in `sock`)</span></div>
<div class="line"><a id="l03415" name="l03415"></a><span class="lineno"> 3415</span><span class="comment">   * invariant.  To be called from thread W only.  Thread-safe.</span></div>
<div class="line"><a id="l03416" name="l03416"></a><span class="lineno"> 3416</span><span class="comment">   *</span></div>
<div class="line"><a id="l03417" name="l03417"></a><span class="lineno"> 3417</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03418" name="l03418"></a><span class="lineno"> 3418</span><span class="comment">   *        Server that originated `sock`.</span></div>
<div class="line"><a id="l03419" name="l03419"></a><span class="lineno"> 3419</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03420" name="l03420"></a><span class="lineno"> 3420</span><span class="comment">   *        Socket that was just moved to Peer_socket::Int_state::S_SYN_RCVD.</span></div>
<div class="line"><a id="l03421" name="l03421"></a><span class="lineno"> 3421</span><span class="comment">   */</span></div>
<div class="line"><a id="l03422" name="l03422"></a><span class="lineno"> 3422</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0379c897bdb3e4eddeb759547be78261">serv_peer_socket_init</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l03423" name="l03423"></a><span class="lineno"> 3423</span><span class="comment"></span> </div>
<div class="line"><a id="l03424" name="l03424"></a><span class="lineno"> 3424</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03425" name="l03425"></a><span class="lineno"> 3425</span><span class="comment">   * Records that a `Server_socket`-contained (i.e., currently un-established, or established but not yet accepted</span></div>
<div class="line"><a id="l03426" name="l03426"></a><span class="lineno"> 3426</span><span class="comment">   * by user) Peer_socket is being closed and should be removed from the given Server_socket.  To be</span></div>
<div class="line"><a id="l03427" name="l03427"></a><span class="lineno"> 3427</span><span class="comment">   * called from thread W only.  Thread-safe.</span></div>
<div class="line"><a id="l03428" name="l03428"></a><span class="lineno"> 3428</span><span class="comment">   *</span></div>
<div class="line"><a id="l03429" name="l03429"></a><span class="lineno"> 3429</span><span class="comment">   * If `sock` is not contained in `*serv`, method does nothing.</span></div>
<div class="line"><a id="l03430" name="l03430"></a><span class="lineno"> 3430</span><span class="comment">   *</span></div>
<div class="line"><a id="l03431" name="l03431"></a><span class="lineno"> 3431</span><span class="comment">   * @param serv</span></div>
<div class="line"><a id="l03432" name="l03432"></a><span class="lineno"> 3432</span><span class="comment">   *        Server socket under consideration.</span></div>
<div class="line"><a id="l03433" name="l03433"></a><span class="lineno"> 3433</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03434" name="l03434"></a><span class="lineno"> 3434</span><span class="comment">   *        Socket to remove (moving from `S_SYN_RCVD` or `S_ESTABLISHED` to `S_CLOSED`).</span></div>
<div class="line"><a id="l03435" name="l03435"></a><span class="lineno"> 3435</span><span class="comment">   */</span></div>
<div class="line"><a id="l03436" name="l03436"></a><span class="lineno"> 3436</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">serv_peer_socket_closed</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> serv, <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> sock);</div>
<div class="line"><a id="l03437" name="l03437"></a><span class="lineno"> 3437</span><span class="comment"></span> </div>
<div class="line"><a id="l03438" name="l03438"></a><span class="lineno"> 3438</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03439" name="l03439"></a><span class="lineno"> 3439</span><span class="comment">   * Internal factory used for ALL Server_socket objects created by this Node (including subclasses).</span></div>
<div class="line"><a id="l03440" name="l03440"></a><span class="lineno"> 3440</span><span class="comment">   *</span></div>
<div class="line"><a id="l03441" name="l03441"></a><span class="lineno"> 3441</span><span class="comment">   * @param child_sock_opts</span></div>
<div class="line"><a id="l03442" name="l03442"></a><span class="lineno"> 3442</span><span class="comment">   *        See Server_socket::Server_socket().</span></div>
<div class="line"><a id="l03443" name="l03443"></a><span class="lineno"> 3443</span><span class="comment">   * @return Pointer to newly constructed socket.</span></div>
<div class="line"><a id="l03444" name="l03444"></a><span class="lineno"> 3444</span><span class="comment">   */</span></div>
<div class="line"><a id="l03445" name="l03445"></a><span class="lineno"> 3445</span>  <span class="keyword">virtual</span> <a class="code hl_class" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a0a91542fce634cf6a749c71f225b105a">serv_create</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* child_sock_opts);</div>
<div class="line"><a id="l03446" name="l03446"></a><span class="lineno"> 3446</span> </div>
<div class="line"><a id="l03447" name="l03447"></a><span class="lineno"> 3447</span>  <span class="comment">// Methods dealing with individual Peer_sockets OR Server_sockets (determined via template at compile time).</span></div>
<div class="line"><a id="l03448" name="l03448"></a><span class="lineno"> 3448</span><span class="comment"></span> </div>
<div class="line"><a id="l03449" name="l03449"></a><span class="lineno"> 3449</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03450" name="l03450"></a><span class="lineno"> 3450</span><span class="comment">   * Implementation of core *blocking* transfer methods, namely Peer_socket::sync_send(), Peer_socket::sync_receive(),</span></div>
<div class="line"><a id="l03451" name="l03451"></a><span class="lineno"> 3451</span><span class="comment">   * and Server_socket::sync_accept() for all cases except when `sock-&gt;state() == Peer_socket::State::S_CLOSED`.</span></div>
<div class="line"><a id="l03452" name="l03452"></a><span class="lineno"> 3452</span><span class="comment">   * It is heavily templated and shared among those three implementations to avoid massive</span></div>
<div class="line"><a id="l03453" name="l03453"></a><span class="lineno"> 3453</span><span class="comment">   * copy/pasting, since the basic pattern of the blocking wrapper around Event_set::sync_wait() and</span></div>
<div class="line"><a id="l03454" name="l03454"></a><span class="lineno"> 3454</span><span class="comment">   * a non-blocking operation (Peer_socket::receive(), Peer_socket::send(), Server_socket::accept(), respectively)</span></div>
<div class="line"><a id="l03455" name="l03455"></a><span class="lineno"> 3455</span><span class="comment">   * is the same in all cases.</span></div>
<div class="line"><a id="l03456" name="l03456"></a><span class="lineno"> 3456</span><span class="comment">   *</span></div>
<div class="line"><a id="l03457" name="l03457"></a><span class="lineno"> 3457</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l03458" name="l03458"></a><span class="lineno"> 3458</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l03459" name="l03459"></a><span class="lineno"> 3459</span><span class="comment">   *   - `sock-&gt;m_mutex` is locked;</span></div>
<div class="line"><a id="l03460" name="l03460"></a><span class="lineno"> 3460</span><span class="comment">   *   - no changes to `*sock` have been made since `sock-&gt;m_mutex` was locked;</span></div>
<div class="line"><a id="l03461" name="l03461"></a><span class="lineno"> 3461</span><span class="comment">   *   - `sock-&gt;state()` is OPEN (so `sock` is in #m_socks or #m_servs, depending on socket type at compile time);</span></div>
<div class="line"><a id="l03462" name="l03462"></a><span class="lineno"> 3462</span><span class="comment">   *   - other arguments are as described below.</span></div>
<div class="line"><a id="l03463" name="l03463"></a><span class="lineno"> 3463</span><span class="comment">   *</span></div>
<div class="line"><a id="l03464" name="l03464"></a><span class="lineno"> 3464</span><span class="comment">   * This method completes the functionality of `sock-&gt;sync_send()`, `sock-&gt;sync_receive()`, and</span></div>
<div class="line"><a id="l03465" name="l03465"></a><span class="lineno"> 3465</span><span class="comment">   * `sock-&gt;sync_accept()`.</span></div>
<div class="line"><a id="l03466" name="l03466"></a><span class="lineno"> 3466</span><span class="comment">   *</span></div>
<div class="line"><a id="l03467" name="l03467"></a><span class="lineno"> 3467</span><span class="comment">   * @tparam Socket</span></div>
<div class="line"><a id="l03468" name="l03468"></a><span class="lineno"> 3468</span><span class="comment">   *         Underlying object of the transfer operation (Peer_socket or Server_socket).</span></div>
<div class="line"><a id="l03469" name="l03469"></a><span class="lineno"> 3469</span><span class="comment">   * @tparam Non_blocking_func_ret_type</span></div>
<div class="line"><a id="l03470" name="l03470"></a><span class="lineno"> 3470</span><span class="comment">   *         The return type of the calling transfer operation (`size_t` or Peer_socket::Ptr).</span></div>
<div class="line"><a id="l03471" name="l03471"></a><span class="lineno"> 3471</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03472" name="l03472"></a><span class="lineno"> 3472</span><span class="comment">   *        Socket on which user called `sync_*()`.</span></div>
<div class="line"><a id="l03473" name="l03473"></a><span class="lineno"> 3473</span><span class="comment">   * @param non_blocking_func</span></div>
<div class="line"><a id="l03474" name="l03474"></a><span class="lineno"> 3474</span><span class="comment">   *        When this method believes it should attempt a non-blocking transfer op, it will execute</span></div>
<div class="line"><a id="l03475" name="l03475"></a><span class="lineno"> 3475</span><span class="comment">   *        `non_blocking_func()`.</span></div>
<div class="line"><a id="l03476" name="l03476"></a><span class="lineno"> 3476</span><span class="comment">   *        If `non_blocking_func.empty()`, do not call `non_blocking_func()` --</span></div>
<div class="line"><a id="l03477" name="l03477"></a><span class="lineno"> 3477</span><span class="comment">   *        return indicating no error so far, and let them do actual operation, if they want; we just tell them it</span></div>
<div class="line"><a id="l03478" name="l03478"></a><span class="lineno"> 3478</span><span class="comment">   *        should be ready for them.  This is known</span></div>
<div class="line"><a id="l03479" name="l03479"></a><span class="lineno"> 3479</span><span class="comment">   *        as `null_buffers` mode or reactor pattern mode.  Otherwise, do the successful operation and then</span></div>
<div class="line"><a id="l03480" name="l03480"></a><span class="lineno"> 3480</span><span class="comment">   *        return.  This is arguably more typical.</span></div>
<div class="line"><a id="l03481" name="l03481"></a><span class="lineno"> 3481</span><span class="comment">   * @param would_block_ret_val</span></div>
<div class="line"><a id="l03482" name="l03482"></a><span class="lineno"> 3482</span><span class="comment">   *        The value that `non_blocking_func()` returns to indicate it was unable to perform the</span></div>
<div class="line"><a id="l03483" name="l03483"></a><span class="lineno"> 3483</span><span class="comment">   *        non-blocking operation (i.e., no data/sockets available).</span></div>
<div class="line"><a id="l03484" name="l03484"></a><span class="lineno"> 3484</span><span class="comment">   * @param ev_type</span></div>
<div class="line"><a id="l03485" name="l03485"></a><span class="lineno"> 3485</span><span class="comment">   *        Event type applicable to the type of operation this is.  See Event_set::Event_type doc header.</span></div>
<div class="line"><a id="l03486" name="l03486"></a><span class="lineno"> 3486</span><span class="comment">   * @param wait_until</span></div>
<div class="line"><a id="l03487" name="l03487"></a><span class="lineno"> 3487</span><span class="comment">   *        See `max_wait` argument on the originating `sync_*()` method.  This is absolute timeout time point</span></div>
<div class="line"><a id="l03488" name="l03488"></a><span class="lineno"> 3488</span><span class="comment">   *        derived from it; zero-valued if no timeout.</span></div>
<div class="line"><a id="l03489" name="l03489"></a><span class="lineno"> 3489</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03490" name="l03490"></a><span class="lineno"> 3490</span><span class="comment">   *        See this argument on the originating `sync_*()` method.</span></div>
<div class="line"><a id="l03491" name="l03491"></a><span class="lineno"> 3491</span><span class="comment">   *        However, unlike that calling method&#39;s user-facing API, the present sync_op() method</span></div>
<div class="line"><a id="l03492" name="l03492"></a><span class="lineno"> 3492</span><span class="comment">   *        does NOT allow null `err_code` (behavior undefined if `err_code` is null).</span></div>
<div class="line"><a id="l03493" name="l03493"></a><span class="lineno"> 3493</span><span class="comment">   *        Corollary: we will NOT throw Runtime_error().</span></div>
<div class="line"><a id="l03494" name="l03494"></a><span class="lineno"> 3494</span><span class="comment">   * @return The value that the calling `sync_*()` method should return to its caller.</span></div>
<div class="line"><a id="l03495" name="l03495"></a><span class="lineno"> 3495</span><span class="comment">   *         Corner/special case: If `non_blocking_func.empty()` (a/k/a &quot;reactor pattern&quot; mode), then</span></div>
<div class="line"><a id="l03496" name="l03496"></a><span class="lineno"> 3496</span><span class="comment">   *         this will always return `would_block_ret_val`; the caller shall interpret</span></div>
<div class="line"><a id="l03497" name="l03497"></a><span class="lineno"> 3497</span><span class="comment">   *         `bool(*err_code) == false` as meaning the socket has reached the desired state in time and without</span></div>
<div class="line"><a id="l03498" name="l03498"></a><span class="lineno"> 3498</span><span class="comment">   *         error.  In that special case, as of this writing, you can&#39;t just return this return value, since it&#39;s</span></div>
<div class="line"><a id="l03499" name="l03499"></a><span class="lineno"> 3499</span><span class="comment">   *         always a zero/null/whatever.</span></div>
<div class="line"><a id="l03500" name="l03500"></a><span class="lineno"> 3500</span><span class="comment">   */</span></div>
<div class="line"><a id="l03501" name="l03501"></a><span class="lineno"> 3501</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Socket, <span class="keyword">typename</span> Non_blocking_func_ret_type&gt;</div>
<div class="line"><a id="l03502" name="l03502"></a><span class="lineno"> 3502</span>  Non_blocking_func_ret_type <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">sync_op</a>(<span class="keyword">typename</span> Socket::Ptr sock,</div>
<div class="line"><a id="l03503" name="l03503"></a><span class="lineno"> 3503</span>                                     <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;Non_blocking_func_ret_type ()&gt;&amp; non_blocking_func,</div>
<div class="line"><a id="l03504" name="l03504"></a><span class="lineno"> 3504</span>                                     Non_blocking_func_ret_type would_block_ret_val,</div>
<div class="line"><a id="l03505" name="l03505"></a><span class="lineno"> 3505</span>                                     <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type,</div>
<div class="line"><a id="l03506" name="l03506"></a><span class="lineno"> 3506</span>                                     <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until,</div>
<div class="line"><a id="l03507" name="l03507"></a><span class="lineno"> 3507</span>                                     <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03508" name="l03508"></a><span class="lineno"> 3508</span><span class="comment"></span> </div>
<div class="line"><a id="l03509" name="l03509"></a><span class="lineno"> 3509</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03510" name="l03510"></a><span class="lineno"> 3510</span><span class="comment">   * Helper method that checks whether the given Peer_socket or Server_socket is CLOSED; if so, it</span></div>
<div class="line"><a id="l03511" name="l03511"></a><span class="lineno"> 3511</span><span class="comment">   * sets `*err_code` to the reason it was closed (which is in `sock-&gt;m_disconnect`) and returns `false`;</span></div>
<div class="line"><a id="l03512" name="l03512"></a><span class="lineno"> 3512</span><span class="comment">   * otherwise it returns `true` and leaves `*err_code` untouched.  This exists to improve code reuse, as</span></div>
<div class="line"><a id="l03513" name="l03513"></a><span class="lineno"> 3513</span><span class="comment">   * this is a frequent operation for both socket types.</span></div>
<div class="line"><a id="l03514" name="l03514"></a><span class="lineno"> 3514</span><span class="comment">   *</span></div>
<div class="line"><a id="l03515" name="l03515"></a><span class="lineno"> 3515</span><span class="comment">   * Pre- and post-conditions: `sock-&gt;m_mutex` is locked.</span></div>
<div class="line"><a id="l03516" name="l03516"></a><span class="lineno"> 3516</span><span class="comment">   *</span></div>
<div class="line"><a id="l03517" name="l03517"></a><span class="lineno"> 3517</span><span class="comment">   * @tparam Socket_ptr</span></div>
<div class="line"><a id="l03518" name="l03518"></a><span class="lineno"> 3518</span><span class="comment">   *         Peer_socket::Ptr or Server_socket::Ptr.</span></div>
<div class="line"><a id="l03519" name="l03519"></a><span class="lineno"> 3519</span><span class="comment">   * @param sock</span></div>
<div class="line"><a id="l03520" name="l03520"></a><span class="lineno"> 3520</span><span class="comment">   *        The socket in question.</span></div>
<div class="line"><a id="l03521" name="l03521"></a><span class="lineno"> 3521</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03522" name="l03522"></a><span class="lineno"> 3522</span><span class="comment">   *        `*err_code` is set to `sock-&gt;m_disconnect_cause` if socket is closed.</span></div>
<div class="line"><a id="l03523" name="l03523"></a><span class="lineno"> 3523</span><span class="comment">   * @return `true` if state is not CLOSED; otherwise `false`.</span></div>
<div class="line"><a id="l03524" name="l03524"></a><span class="lineno"> 3524</span><span class="comment">   */</span></div>
<div class="line"><a id="l03525" name="l03525"></a><span class="lineno"> 3525</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Socket_ptr&gt;</div>
<div class="line"><a id="l03526" name="l03526"></a><span class="lineno"> 3526</span>  <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">ensure_sock_open</a>(Socket_ptr sock, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03527" name="l03527"></a><span class="lineno"> 3527</span> </div>
<div class="line"><a id="l03528" name="l03528"></a><span class="lineno"> 3528</span>  <span class="comment">// Methods dealing with individual Event_sets.  Implementations are in event_set.cpp.</span></div>
<div class="line"><a id="l03529" name="l03529"></a><span class="lineno"> 3529</span><span class="comment"></span> </div>
<div class="line"><a id="l03530" name="l03530"></a><span class="lineno"> 3530</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03531" name="l03531"></a><span class="lineno"> 3531</span><span class="comment">   * Implementation of Event_set::async_wait() when `Event_set::state() == Event_set::State::S_INACTIVE`.</span></div>
<div class="line"><a id="l03532" name="l03532"></a><span class="lineno"> 3532</span><span class="comment">   *</span></div>
<div class="line"><a id="l03533" name="l03533"></a><span class="lineno"> 3533</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l03534" name="l03534"></a><span class="lineno"> 3534</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l03535" name="l03535"></a><span class="lineno"> 3535</span><span class="comment">   *   - `event_set-&gt;m_mutex` is locked and just after entering async_wait();</span></div>
<div class="line"><a id="l03536" name="l03536"></a><span class="lineno"> 3536</span><span class="comment">   *   - no changes to `*event_set` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l03537" name="l03537"></a><span class="lineno"> 3537</span><span class="comment">   *   - `event_set-&gt;state() == Event_set::State::S_INACTIVE` (so `event_set` is in #m_event_sets);</span></div>
<div class="line"><a id="l03538" name="l03538"></a><span class="lineno"> 3538</span><span class="comment">   *   - on_event is as originally passed into async_wait().</span></div>
<div class="line"><a id="l03539" name="l03539"></a><span class="lineno"> 3539</span><span class="comment">   *</span></div>
<div class="line"><a id="l03540" name="l03540"></a><span class="lineno"> 3540</span><span class="comment">   * This method completes the functionality of `event_set-&gt;async_wait()`.</span></div>
<div class="line"><a id="l03541" name="l03541"></a><span class="lineno"> 3541</span><span class="comment">   *</span></div>
<div class="line"><a id="l03542" name="l03542"></a><span class="lineno"> 3542</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03543" name="l03543"></a><span class="lineno"> 3543</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03544" name="l03544"></a><span class="lineno"> 3544</span><span class="comment">   * @param on_event</span></div>
<div class="line"><a id="l03545" name="l03545"></a><span class="lineno"> 3545</span><span class="comment">   *        See Event_set::async_wait().</span></div>
<div class="line"><a id="l03546" name="l03546"></a><span class="lineno"> 3546</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03547" name="l03547"></a><span class="lineno"> 3547</span><span class="comment">   *        See Event_set::async_wait().</span></div>
<div class="line"><a id="l03548" name="l03548"></a><span class="lineno"> 3548</span><span class="comment">   * @return See Event_set::async_wait().</span></div>
<div class="line"><a id="l03549" name="l03549"></a><span class="lineno"> 3549</span><span class="comment">   */</span></div>
<div class="line"><a id="l03550" name="l03550"></a><span class="lineno"> 3550</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f">event_set_async_wait</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set, <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Event_set::Event_handler</a>&amp; on_event,</div>
<div class="line"><a id="l03551" name="l03551"></a><span class="lineno"> 3551</span>                            <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03552" name="l03552"></a><span class="lineno"> 3552</span><span class="comment"></span> </div>
<div class="line"><a id="l03553" name="l03553"></a><span class="lineno"> 3553</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03554" name="l03554"></a><span class="lineno"> 3554</span><span class="comment">   * Helper placed by event_set_async_wait() onto thread W to invoke event_set_check_baseline() but first ensure</span></div>
<div class="line"><a id="l03555" name="l03555"></a><span class="lineno"> 3555</span><span class="comment">   * that the `Event_set event_set` has not exited Event_set::State::S_WAITING (which would make any checking for</span></div>
<div class="line"><a id="l03556" name="l03556"></a><span class="lineno"> 3556</span><span class="comment">   * active events nonsense).  If it has exited that state, does nothing.  (That situation is possible due to</span></div>
<div class="line"><a id="l03557" name="l03557"></a><span class="lineno"> 3557</span><span class="comment">   * concurrently deleting the overarching Node (IIRC) and maybe other similar races.)</span></div>
<div class="line"><a id="l03558" name="l03558"></a><span class="lineno"> 3558</span><span class="comment">   *</span></div>
<div class="line"><a id="l03559" name="l03559"></a><span class="lineno"> 3559</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03560" name="l03560"></a><span class="lineno"> 3560</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03561" name="l03561"></a><span class="lineno"> 3561</span><span class="comment">   */</span></div>
<div class="line"><a id="l03562" name="l03562"></a><span class="lineno"> 3562</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a4a21e69d3ae442b2cc06220514de364a">event_set_check_baseline_assuming_state</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set);<span class="comment"></span></div>
<div class="line"><a id="l03563" name="l03563"></a><span class="lineno"> 3563</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03564" name="l03564"></a><span class="lineno"> 3564</span><span class="comment">   * Checks each desired (Event_set::m_want) event in `event_set`; any that holds true is saved into `event_set`</span></div>
<div class="line"><a id="l03565" name="l03565"></a><span class="lineno"> 3565</span><span class="comment">   * (Event_set::m_can).  This is the exhaustive, or &quot;baseline,&quot; check.  This should only be performed when</span></div>
<div class="line"><a id="l03566" name="l03566"></a><span class="lineno"> 3566</span><span class="comment">   * necessary, as it is typically slower than checking individual active sockets against the</span></div>
<div class="line"><a id="l03567" name="l03567"></a><span class="lineno"> 3567</span><span class="comment">   * Event_set (&quot;delta&quot; check).</span></div>
<div class="line"><a id="l03568" name="l03568"></a><span class="lineno"> 3568</span><span class="comment">   *</span></div>
<div class="line"><a id="l03569" name="l03569"></a><span class="lineno"> 3569</span><span class="comment">   * This check is skipped if `Event_set::m_baseline_check_pending == false` (for `event_set`).</span></div>
<div class="line"><a id="l03570" name="l03570"></a><span class="lineno"> 3570</span><span class="comment">   *</span></div>
<div class="line"><a id="l03571" name="l03571"></a><span class="lineno"> 3571</span><span class="comment">   * See Event_set::async_wait() giant internal comment for context on all of the above.</span></div>
<div class="line"><a id="l03572" name="l03572"></a><span class="lineno"> 3572</span><span class="comment">   *</span></div>
<div class="line"><a id="l03573" name="l03573"></a><span class="lineno"> 3573</span><span class="comment">   * Pre-conditions: `event_set` state is Event_set::State::S_WAITING; `event_set-&gt;m_mutex` is locked.</span></div>
<div class="line"><a id="l03574" name="l03574"></a><span class="lineno"> 3574</span><span class="comment">   *</span></div>
<div class="line"><a id="l03575" name="l03575"></a><span class="lineno"> 3575</span><span class="comment">   * This method, unlike most, is intended to be called from either W or U != W.  All actions it</span></div>
<div class="line"><a id="l03576" name="l03576"></a><span class="lineno"> 3576</span><span class="comment">   * takes are on non-W-exclusive data (namely, actions on: `event_set`; and non-W-exclusive data in</span></div>
<div class="line"><a id="l03577" name="l03577"></a><span class="lineno"> 3577</span><span class="comment">   * Peer_socket and Server_socket, namely their state() and Receive/Send/Accept structures).</span></div>
<div class="line"><a id="l03578" name="l03578"></a><span class="lineno"> 3578</span><span class="comment">   *</span></div>
<div class="line"><a id="l03579" name="l03579"></a><span class="lineno"> 3579</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03580" name="l03580"></a><span class="lineno"> 3580</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03581" name="l03581"></a><span class="lineno"> 3581</span><span class="comment">   * @return `true` if and only if the check was performed; `false` returned if</span></div>
<div class="line"><a id="l03582" name="l03582"></a><span class="lineno"> 3582</span><span class="comment">   *         `!event_set-&gt;m_baseline_check_pending`.</span></div>
<div class="line"><a id="l03583" name="l03583"></a><span class="lineno"> 3583</span><span class="comment">   */</span></div>
<div class="line"><a id="l03584" name="l03584"></a><span class="lineno"> 3584</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8">event_set_check_baseline</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set);</div>
<div class="line"><a id="l03585" name="l03585"></a><span class="lineno"> 3585</span><span class="comment"></span> </div>
<div class="line"><a id="l03586" name="l03586"></a><span class="lineno"> 3586</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03587" name="l03587"></a><span class="lineno"> 3587</span><span class="comment">   * Check whether given Event_set contains any active sockets (Event_set::m_can); if so, signals the user (who</span></div>
<div class="line"><a id="l03588" name="l03588"></a><span class="lineno"> 3588</span><span class="comment">   * previously called `async_wait()` to set all this in motion): set state back to Event_set::State::S_INACTIVE from</span></div>
<div class="line"><a id="l03589" name="l03589"></a><span class="lineno"> 3589</span><span class="comment">   * Event_set::State::S_WAITING; calls the handler passed to `async_wait()`; forgets handler.  If no active sockets,</span></div>
<div class="line"><a id="l03590" name="l03590"></a><span class="lineno"> 3590</span><span class="comment">   * does nothing.</span></div>
<div class="line"><a id="l03591" name="l03591"></a><span class="lineno"> 3591</span><span class="comment">   *</span></div>
<div class="line"><a id="l03592" name="l03592"></a><span class="lineno"> 3592</span><span class="comment">   * Pre-conditions: same as event_set_check_baseline().</span></div>
<div class="line"><a id="l03593" name="l03593"></a><span class="lineno"> 3593</span><span class="comment">   *</span></div>
<div class="line"><a id="l03594" name="l03594"></a><span class="lineno"> 3594</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03595" name="l03595"></a><span class="lineno"> 3595</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03596" name="l03596"></a><span class="lineno"> 3596</span><span class="comment">   */</span></div>
<div class="line"><a id="l03597" name="l03597"></a><span class="lineno"> 3597</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#afdefbbb3c3b9f2f2866f6b4c770fa62d">event_set_fire_if_got_events</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set);</div>
<div class="line"><a id="l03598" name="l03598"></a><span class="lineno"> 3598</span><span class="comment"></span> </div>
<div class="line"><a id="l03599" name="l03599"></a><span class="lineno"> 3599</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03600" name="l03600"></a><span class="lineno"> 3600</span><span class="comment">   * For each WAITING Event_set within the Node: checks for any events that hold, and if any do</span></div>
<div class="line"><a id="l03601" name="l03601"></a><span class="lineno"> 3601</span><span class="comment">   * hold, signals the user (calls handler, goes to INACTIVE, etc.).  The logic for how it does so</span></div>
<div class="line"><a id="l03602" name="l03602"></a><span class="lineno"> 3602</span><span class="comment">   * is complex.  For background, please see Event_set::async_wait() giant internal comment first.</span></div>
<div class="line"><a id="l03603" name="l03603"></a><span class="lineno"> 3603</span><span class="comment">   * Then read on here.</span></div>
<div class="line"><a id="l03604" name="l03604"></a><span class="lineno"> 3604</span><span class="comment">   *</span></div>
<div class="line"><a id="l03605" name="l03605"></a><span class="lineno"> 3605</span><span class="comment">   * For each WAITING Event_set: If baseline check (event_set_check_baseline()) is still required</span></div>
<div class="line"><a id="l03606" name="l03606"></a><span class="lineno"> 3606</span><span class="comment">   * and hasn&#39;t been performed, perform it.  Otherwise, for efficiency perform a &quot;delta&quot; check,</span></div>
<div class="line"><a id="l03607" name="l03607"></a><span class="lineno"> 3607</span><span class="comment">   * wherein EVERY active (for all definitions of active: Readable, Writable, Acceptable) socket</span></div>
<div class="line"><a id="l03608" name="l03608"></a><span class="lineno"> 3608</span><span class="comment">   * detected since the last baseline check is checked against the desired event/socket pairs in the</span></div>
<div class="line"><a id="l03609" name="l03609"></a><span class="lineno"> 3609</span><span class="comment">   * Event_set.  Any socket in both sets (active + desired) is saved in `event_set-&gt;m_can`.  If</span></div>
<div class="line"><a id="l03610" name="l03610"></a><span class="lineno"> 3610</span><span class="comment">   * either the baseline or delta check yields at least one active event, signal user (call handler,</span></div>
<div class="line"><a id="l03611" name="l03611"></a><span class="lineno"> 3611</span><span class="comment">   * go INACTIVE, etc.).</span></div>
<div class="line"><a id="l03612" name="l03612"></a><span class="lineno"> 3612</span><span class="comment">   *</span></div>
<div class="line"><a id="l03613" name="l03613"></a><span class="lineno"> 3613</span><span class="comment">   * For the delta check just described, how does it know which sockets have been active since the</span></div>
<div class="line"><a id="l03614" name="l03614"></a><span class="lineno"> 3614</span><span class="comment">   * last check?  Answer: `Node::m_sock_events` members (NOTE: not the same as `Event_set::m_can`, though</span></div>
<div class="line"><a id="l03615" name="l03615"></a><span class="lineno"> 3615</span><span class="comment">   * they are related).  See #m_sock_events doc header for details.</span></div>
<div class="line"><a id="l03616" name="l03616"></a><span class="lineno"> 3616</span><span class="comment">   *</span></div>
<div class="line"><a id="l03617" name="l03617"></a><span class="lineno"> 3617</span><span class="comment">   * @param defer_delta_check</span></div>
<div class="line"><a id="l03618" name="l03618"></a><span class="lineno"> 3618</span><span class="comment">   *        Set to `true` if and only if you know, for a FACT, that within a non-blocking amount of</span></div>
<div class="line"><a id="l03619" name="l03619"></a><span class="lineno"> 3619</span><span class="comment">   *        time `event_set_all_check_delta(false)` will be called.  For example, you may know</span></div>
<div class="line"><a id="l03620" name="l03620"></a><span class="lineno"> 3620</span><span class="comment">   *        `event_set_all_check_delta(false)` will be called within the present boost.asio handler.</span></div>
<div class="line"><a id="l03621" name="l03621"></a><span class="lineno"> 3621</span><span class="comment">   *        Then this method will only log and not perform the actual check, deferring to the</span></div>
<div class="line"><a id="l03622" name="l03622"></a><span class="lineno"> 3622</span><span class="comment">   *        promised `event_set_all_check_delta(false)` call, by which point more events may have been</span></div>
<div class="line"><a id="l03623" name="l03623"></a><span class="lineno"> 3623</span><span class="comment">   *        detected in #m_sock_events.</span></div>
<div class="line"><a id="l03624" name="l03624"></a><span class="lineno"> 3624</span><span class="comment">   */</span></div>
<div class="line"><a id="l03625" name="l03625"></a><span class="lineno"> 3625</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">event_set_all_check_delta</a>(<span class="keywordtype">bool</span> defer_delta_check);</div>
<div class="line"><a id="l03626" name="l03626"></a><span class="lineno"> 3626</span><span class="comment"></span> </div>
<div class="line"><a id="l03627" name="l03627"></a><span class="lineno"> 3627</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03628" name="l03628"></a><span class="lineno"> 3628</span><span class="comment">   * Implementation of Event_set::close() when `Event_set::state() != Event_set::State::S_CLOSED` for `event_set`.</span></div>
<div class="line"><a id="l03629" name="l03629"></a><span class="lineno"> 3629</span><span class="comment">   *</span></div>
<div class="line"><a id="l03630" name="l03630"></a><span class="lineno"> 3630</span><span class="comment">   * Pre-conditions:</span></div>
<div class="line"><a id="l03631" name="l03631"></a><span class="lineno"> 3631</span><span class="comment">   *   - current thread is not W;</span></div>
<div class="line"><a id="l03632" name="l03632"></a><span class="lineno"> 3632</span><span class="comment">   *   - `event_set-&gt;m_mutex` is locked and just after entering async_wait();</span></div>
<div class="line"><a id="l03633" name="l03633"></a><span class="lineno"> 3633</span><span class="comment">   *   - no changes to `*event_set` have been made since `m_mutex` was locked;</span></div>
<div class="line"><a id="l03634" name="l03634"></a><span class="lineno"> 3634</span><span class="comment">   *   - `event_set-&gt;state() != Event_set::State::S_CLOSED` (so `event_set` is in #m_event_sets).</span></div>
<div class="line"><a id="l03635" name="l03635"></a><span class="lineno"> 3635</span><span class="comment">   *</span></div>
<div class="line"><a id="l03636" name="l03636"></a><span class="lineno"> 3636</span><span class="comment">   * This method completes the functionality of `event_set-&gt;close()`.</span></div>
<div class="line"><a id="l03637" name="l03637"></a><span class="lineno"> 3637</span><span class="comment">   *</span></div>
<div class="line"><a id="l03638" name="l03638"></a><span class="lineno"> 3638</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03639" name="l03639"></a><span class="lineno"> 3639</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03640" name="l03640"></a><span class="lineno"> 3640</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l03641" name="l03641"></a><span class="lineno"> 3641</span><span class="comment">   *        See Event_set::close().</span></div>
<div class="line"><a id="l03642" name="l03642"></a><span class="lineno"> 3642</span><span class="comment">   */</span></div>
<div class="line"><a id="l03643" name="l03643"></a><span class="lineno"> 3643</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a44ee0d42d38f3b98d032dee1549f8c4c">event_set_close</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code);</div>
<div class="line"><a id="l03644" name="l03644"></a><span class="lineno"> 3644</span><span class="comment"></span> </div>
<div class="line"><a id="l03645" name="l03645"></a><span class="lineno"> 3645</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03646" name="l03646"></a><span class="lineno"> 3646</span><span class="comment">   * The guts of event_set_close_worker_check_state(): same thing, but assumes</span></div>
<div class="line"><a id="l03647" name="l03647"></a><span class="lineno"> 3647</span><span class="comment">   * `Event_set::state() == Event_set::State::S_CLOSED`, and Event_set::m_mutex is locked (for `event_set`).</span></div>
<div class="line"><a id="l03648" name="l03648"></a><span class="lineno"> 3648</span><span class="comment">   * May be called directly from thread W assuming those pre-conditions holds.</span></div>
<div class="line"><a id="l03649" name="l03649"></a><span class="lineno"> 3649</span><span class="comment">   *</span></div>
<div class="line"><a id="l03650" name="l03650"></a><span class="lineno"> 3650</span><span class="comment">   * @param event_set</span></div>
<div class="line"><a id="l03651" name="l03651"></a><span class="lineno"> 3651</span><span class="comment">   *        Event_set in question.</span></div>
<div class="line"><a id="l03652" name="l03652"></a><span class="lineno"> 3652</span><span class="comment">   */</span></div>
<div class="line"><a id="l03653" name="l03653"></a><span class="lineno"> 3653</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6727ca42e15c8627c1ed3d94e6dd7a53">event_set_close_worker</a>(<a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set);</div>
<div class="line"><a id="l03654" name="l03654"></a><span class="lineno"> 3654</span><span class="comment"></span> </div>
<div class="line"><a id="l03655" name="l03655"></a><span class="lineno"> 3655</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03656" name="l03656"></a><span class="lineno"> 3656</span><span class="comment">   * Thread W implementation of interrupt_all_waits().  Performs all the needed work, which is to</span></div>
<div class="line"><a id="l03657" name="l03657"></a><span class="lineno"> 3657</span><span class="comment">   * trigger any WAITING Event_set objects to fire their on-event callbacks, with the Boolean argument set</span></div>
<div class="line"><a id="l03658" name="l03658"></a><span class="lineno"> 3658</span><span class="comment">   * to `true`, indicating interrupted wait.</span></div>
<div class="line"><a id="l03659" name="l03659"></a><span class="lineno"> 3659</span><span class="comment">   *</span></div>
<div class="line"><a id="l03660" name="l03660"></a><span class="lineno"> 3660</span><span class="comment">   * Pre-condition: We&#39;re in thread W.</span></div>
<div class="line"><a id="l03661" name="l03661"></a><span class="lineno"> 3661</span><span class="comment">   */</span></div>
<div class="line"><a id="l03662" name="l03662"></a><span class="lineno"> 3662</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca">interrupt_all_waits_worker</a>();</div>
<div class="line"><a id="l03663" name="l03663"></a><span class="lineno"> 3663</span><span class="comment"></span> </div>
<div class="line"><a id="l03664" name="l03664"></a><span class="lineno"> 3664</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03665" name="l03665"></a><span class="lineno"> 3665</span><span class="comment">   * `signal_set` handler, executed on SIGINT and SIGTERM, if user has enabled this feature:</span></div>
<div class="line"><a id="l03666" name="l03666"></a><span class="lineno"> 3666</span><span class="comment">   * causes interrupt_all_waits_worker() to occur on thread W.</span></div>
<div class="line"><a id="l03667" name="l03667"></a><span class="lineno"> 3667</span><span class="comment">   *</span></div>
<div class="line"><a id="l03668" name="l03668"></a><span class="lineno"> 3668</span><span class="comment">   * Pre-condition: We&#39;re in thread W [sic].</span></div>
<div class="line"><a id="l03669" name="l03669"></a><span class="lineno"> 3669</span><span class="comment">   *</span></div>
<div class="line"><a id="l03670" name="l03670"></a><span class="lineno"> 3670</span><span class="comment">   * @param sys_err_code</span></div>
<div class="line"><a id="l03671" name="l03671"></a><span class="lineno"> 3671</span><span class="comment">   *        boost.asio error code indicating the circumstances of the callback executing.</span></div>
<div class="line"><a id="l03672" name="l03672"></a><span class="lineno"> 3672</span><span class="comment">   *        It is unusual for this to be truthy.</span></div>
<div class="line"><a id="l03673" name="l03673"></a><span class="lineno"> 3673</span><span class="comment">   * @param sig_number</span></div>
<div class="line"><a id="l03674" name="l03674"></a><span class="lineno"> 3674</span><span class="comment">   *        Signal number of the signal that was detected.</span></div>
<div class="line"><a id="l03675" name="l03675"></a><span class="lineno"> 3675</span><span class="comment">   */</span></div>
<div class="line"><a id="l03676" name="l03676"></a><span class="lineno"> 3676</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ae996cab95eb139d00f0d430093e64a5f">interrupt_all_waits_internal_sig_handler</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&amp; sys_err_code, <span class="keywordtype">int</span> sig_number);</div>
<div class="line"><a id="l03677" name="l03677"></a><span class="lineno"> 3677</span> </div>
<div class="line"><a id="l03678" name="l03678"></a><span class="lineno"> 3678</span>  <span class="comment">// Constants.</span></div>
<div class="line"><a id="l03679" name="l03679"></a><span class="lineno"> 3679</span><span class="comment"></span> </div>
<div class="line"><a id="l03680" name="l03680"></a><span class="lineno"> 3680</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03681" name="l03681"></a><span class="lineno"> 3681</span><span class="comment">   * For a given unacknowledged sent packet P, the maximum number of times any individual packet</span></div>
<div class="line"><a id="l03682" name="l03682"></a><span class="lineno"> 3682</span><span class="comment">   * with higher sequence numbers than P may be acknowledged before P is considered Dropped (i.e.,</span></div>
<div class="line"><a id="l03683" name="l03683"></a><span class="lineno"> 3683</span><span class="comment">   * we give up on it).  If we enable retransmission, that would trigger Fast Retransmit, using TCP&#39;s</span></div>
<div class="line"><a id="l03684" name="l03684"></a><span class="lineno"> 3684</span><span class="comment">   * terminology.</span></div>
<div class="line"><a id="l03685" name="l03685"></a><span class="lineno"> 3685</span><span class="comment">   */</span></div>
<div class="line"><a id="l03686" name="l03686"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271"> 3686</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">Peer_socket::Sent_packet::ack_count_t</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</a>;</div>
<div class="line"><a id="l03687" name="l03687"></a><span class="lineno"> 3687</span><span class="comment"></span> </div>
<div class="line"><a id="l03688" name="l03688"></a><span class="lineno"> 3688</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03689" name="l03689"></a><span class="lineno"> 3689</span><span class="comment">   * Time interval between performing &quot;infrequent periodic tasks,&quot; such as stat logging.  This</span></div>
<div class="line"><a id="l03690" name="l03690"></a><span class="lineno"> 3690</span><span class="comment">   * should be large enough to ensure that the tasks being performed incur no significant processor</span></div>
<div class="line"><a id="l03691" name="l03691"></a><span class="lineno"> 3691</span><span class="comment">   * use.</span></div>
<div class="line"><a id="l03692" name="l03692"></a><span class="lineno"> 3692</span><span class="comment">   */</span></div>
<div class="line"><a id="l03693" name="l03693"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a2f97b363281b79ef4f399789442c84de"> 3693</a></span>  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a2f97b363281b79ef4f399789442c84de">S_REGULAR_INFREQUENT_TASKS_PERIOD</a>;</div>
<div class="line"><a id="l03694" name="l03694"></a><span class="lineno"> 3694</span> </div>
<div class="line"><a id="l03695" name="l03695"></a><span class="lineno"> 3695</span>  <span class="comment">// Data.</span></div>
<div class="line"><a id="l03696" name="l03696"></a><span class="lineno"> 3696</span><span class="comment"></span> </div>
<div class="line"><a id="l03697" name="l03697"></a><span class="lineno"> 3697</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03698" name="l03698"></a><span class="lineno"> 3698</span><span class="comment">   * This Node&#39;s global set of options.  Initialized at construction; can be subsequently</span></div>
<div class="line"><a id="l03699" name="l03699"></a><span class="lineno"> 3699</span><span class="comment">   * modified by set_options(), although only the dynamic members of this may be modified.</span></div>
<div class="line"><a id="l03700" name="l03700"></a><span class="lineno"> 3700</span><span class="comment">   *</span></div>
<div class="line"><a id="l03701" name="l03701"></a><span class="lineno"> 3701</span><span class="comment">   * Accessed from thread W and user thread U != W.  Protected by #m_opts_mutex.  When reading, do</span></div>
<div class="line"><a id="l03702" name="l03702"></a><span class="lineno"> 3702</span><span class="comment">   * NOT access without locking (which is encapsulated in opt()).</span></div>
<div class="line"><a id="l03703" name="l03703"></a><span class="lineno"> 3703</span><span class="comment">   */</span></div>
<div class="line"><a id="l03704" name="l03704"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3"> 3704</a></span>  <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">m_opts</a>;</div>
<div class="line"><a id="l03705" name="l03705"></a><span class="lineno"> 3705</span><span class="comment"></span> </div>
<div class="line"><a id="l03706" name="l03706"></a><span class="lineno"> 3706</span><span class="comment">  /// The mutex protecting #m_opts.</span></div>
<div class="line"><a id="l03707" name="l03707"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4"> 3707</a></span><span class="comment"></span>  <span class="keyword">mutable</span> <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">Options_mutex</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4">m_opts_mutex</a>;</div>
<div class="line"><a id="l03708" name="l03708"></a><span class="lineno"> 3708</span><span class="comment"></span> </div>
<div class="line"><a id="l03709" name="l03709"></a><span class="lineno"> 3709</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03710" name="l03710"></a><span class="lineno"> 3710</span><span class="comment">   * The object used to simulate stuff like packet loss and latency via local means directly in the</span></div>
<div class="line"><a id="l03711" name="l03711"></a><span class="lineno"> 3711</span><span class="comment">   * code.  If 0, no such simulation is performed.  `shared_ptr&lt;&gt;` used for basic auto-`delete` convenience.</span></div>
<div class="line"><a id="l03712" name="l03712"></a><span class="lineno"> 3712</span><span class="comment">   */</span></div>
<div class="line"><a id="l03713" name="l03713"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a43472c3277cdf5e3f28d4f4f51e3bcc0"> 3713</a></span>  boost::shared_ptr&lt;Net_env_simulator&gt; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a43472c3277cdf5e3f28d4f4f51e3bcc0">m_net_env_sim</a>;</div>
<div class="line"><a id="l03714" name="l03714"></a><span class="lineno"> 3714</span><span class="comment"></span> </div>
<div class="line"><a id="l03715" name="l03715"></a><span class="lineno"> 3715</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03716" name="l03716"></a><span class="lineno"> 3716</span><span class="comment">   * The main loop engine, functioning in the single-threaded-but-asynchronous callback-based</span></div>
<div class="line"><a id="l03717" name="l03717"></a><span class="lineno"> 3717</span><span class="comment">   * &quot;reactor&quot; style (or is it &quot;proactor&quot;?).  The Node constructor creates a single new thread W, which then places</span></div>
<div class="line"><a id="l03718" name="l03718"></a><span class="lineno"> 3718</span><span class="comment">   * some callbacks onto this guy and invoke `m_task_engine.run()`, at which point the main loop</span></div>
<div class="line"><a id="l03719" name="l03719"></a><span class="lineno"> 3719</span><span class="comment">   * begins in thread W.</span></div>
<div class="line"><a id="l03720" name="l03720"></a><span class="lineno"> 3720</span><span class="comment">   *</span></div>
<div class="line"><a id="l03721" name="l03721"></a><span class="lineno"> 3721</span><span class="comment">   * Thus, per boost.asio&#39;s model, any work items (functions) placed</span></div>
<div class="line"><a id="l03722" name="l03722"></a><span class="lineno"> 3722</span><span class="comment">   * onto #m_task_engine (e.g.: `post(m_task_engine, do_something_fn);`) will execute in thread W,</span></div>
<div class="line"><a id="l03723" name="l03723"></a><span class="lineno"> 3723</span><span class="comment">   * as it&#39;s the one invoking `run()` at the time -- even if the placing itself is done on some</span></div>
<div class="line"><a id="l03724" name="l03724"></a><span class="lineno"> 3724</span><span class="comment">   * other thread, such as a user thread U.  An example of the latter is a Peer_socket::send() implementation</span></div>
<div class="line"><a id="l03725" name="l03725"></a><span class="lineno"> 3725</span><span class="comment">   * might write to the socket&#39;s internal Send buffer in thread U, check whether it&#39;s currently possible</span></div>
<div class="line"><a id="l03726" name="l03726"></a><span class="lineno"> 3726</span><span class="comment">   * to send over the wire, and if and only if the answer is yes, `post(m_task_engine, S)`, where S</span></div>
<div class="line"><a id="l03727" name="l03727"></a><span class="lineno"> 3727</span><span class="comment">   * is a function/functor (created via lambdas usually) that will perform the hairy needed Node/socket</span></div>
<div class="line"><a id="l03728" name="l03728"></a><span class="lineno"> 3728</span><span class="comment">   * work on thread W.</span></div>
<div class="line"><a id="l03729" name="l03729"></a><span class="lineno"> 3729</span><span class="comment">   *</span></div>
<div class="line"><a id="l03730" name="l03730"></a><span class="lineno"> 3730</span><span class="comment">   * All threads may access this (no mutex required, as explicitly announced in boost.asio docs).</span></div>
<div class="line"><a id="l03731" name="l03731"></a><span class="lineno"> 3731</span><span class="comment">   *</span></div>
<div class="line"><a id="l03732" name="l03732"></a><span class="lineno"> 3732</span><span class="comment">   * Adding more threads that would call `m_task_engine.run()` would create a thread pool.  With &quot;strands&quot; one</span></div>
<div class="line"><a id="l03733" name="l03733"></a><span class="lineno"> 3733</span><span class="comment">   * can avoid concurrency in this situation.  An intelligent combination of those two concepts can lead to efficient</span></div>
<div class="line"><a id="l03734" name="l03734"></a><span class="lineno"> 3734</span><span class="comment">   * multi-core use without complex and/or inefficient locking.  This is non-trivial.</span></div>
<div class="line"><a id="l03735" name="l03735"></a><span class="lineno"> 3735</span><span class="comment">   *</span></div>
<div class="line"><a id="l03736" name="l03736"></a><span class="lineno"> 3736</span><span class="comment">   * @see Class Node doc header for to-do items regarding efficient multi-core use and how that relates to</span></div>
<div class="line"><a id="l03737" name="l03737"></a><span class="lineno"> 3737</span><span class="comment">   * using an #m_task_engine thread pool and/or strands.</span></div>
<div class="line"><a id="l03738" name="l03738"></a><span class="lineno"> 3738</span><span class="comment">   */</span></div>
<div class="line"><a id="l03739" name="l03739"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29"> 3739</a></span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>;</div>
<div class="line"><a id="l03740" name="l03740"></a><span class="lineno"> 3740</span><span class="comment"></span> </div>
<div class="line"><a id="l03741" name="l03741"></a><span class="lineno"> 3741</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03742" name="l03742"></a><span class="lineno"> 3742</span><span class="comment">   * The UDP socket used to receive low-level packets (to assemble into application layer data) and send them</span></div>
<div class="line"><a id="l03743" name="l03743"></a><span class="lineno"> 3743</span><span class="comment">   * (vice versa).</span></div>
<div class="line"><a id="l03744" name="l03744"></a><span class="lineno"> 3744</span><span class="comment">   *</span></div>
<div class="line"><a id="l03745" name="l03745"></a><span class="lineno"> 3745</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03746" name="l03746"></a><span class="lineno"> 3746</span><span class="comment">   *</span></div>
<div class="line"><a id="l03747" name="l03747"></a><span class="lineno"> 3747</span><span class="comment">   * Access to this may be highly contentious in high-traffic situations.  Since only thread W accesses this, and that</span></div>
<div class="line"><a id="l03748" name="l03748"></a><span class="lineno"> 3748</span><span class="comment">   * thread does the vast bulk of the work of the entire Node, at least one known problem is that the internal OS</span></div>
<div class="line"><a id="l03749" name="l03749"></a><span class="lineno"> 3749</span><span class="comment">   * UDP receive buffer may be exceeded, as we may not read datagrams off this socket quickly enough.</span></div>
<div class="line"><a id="l03750" name="l03750"></a><span class="lineno"> 3750</span><span class="comment">   *</span></div>
<div class="line"><a id="l03751" name="l03751"></a><span class="lineno"> 3751</span><span class="comment">   * @see Class Node doc header for to-do items regarding the aforementioned UDP receive buffer overflow problem.</span></div>
<div class="line"><a id="l03752" name="l03752"></a><span class="lineno"> 3752</span><span class="comment">   */</span></div>
<div class="line"><a id="l03753" name="l03753"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89"> 3753</a></span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">Udp_socket</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89">m_low_lvl_sock</a>;</div>
<div class="line"><a id="l03754" name="l03754"></a><span class="lineno"> 3754</span><span class="comment"></span> </div>
<div class="line"><a id="l03755" name="l03755"></a><span class="lineno"> 3755</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03756" name="l03756"></a><span class="lineno"> 3756</span><span class="comment">   * After we bind #m_low_lvl_sock to a UDP endpoint, this is a copy of that endpoint.  Thus it</span></div>
<div class="line"><a id="l03757" name="l03757"></a><span class="lineno"> 3757</span><span class="comment">   * should contain the actual local address and port (even if user specified 0 for the latter,</span></div>
<div class="line"><a id="l03758" name="l03758"></a><span class="lineno"> 3758</span><span class="comment">   * say).</span></div>
<div class="line"><a id="l03759" name="l03759"></a><span class="lineno"> 3759</span><span class="comment">   *</span></div>
<div class="line"><a id="l03760" name="l03760"></a><span class="lineno"> 3760</span><span class="comment">   * This is equal to `Udp_endpoint()` until the constructor exits.  After the constructor exits, its</span></div>
<div class="line"><a id="l03761" name="l03761"></a><span class="lineno"> 3761</span><span class="comment">   * value never changes, therefore all threads can access it without mutex.  If the constructor</span></div>
<div class="line"><a id="l03762" name="l03762"></a><span class="lineno"> 3762</span><span class="comment">   * fails to bind, this remains equal to `Udp_endpoint()` forever.</span></div>
<div class="line"><a id="l03763" name="l03763"></a><span class="lineno"> 3763</span><span class="comment">   */</span></div>
<div class="line"><a id="l03764" name="l03764"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aee89be07daf7d024921381a4bafe1289"> 3764</a></span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aee89be07daf7d024921381a4bafe1289">m_low_lvl_endpoint</a>;</div>
<div class="line"><a id="l03765" name="l03765"></a><span class="lineno"> 3765</span><span class="comment"></span> </div>
<div class="line"><a id="l03766" name="l03766"></a><span class="lineno"> 3766</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03767" name="l03767"></a><span class="lineno"> 3767</span><span class="comment">   * OS-reported #m_low_lvl_sock UDP receive buffer maximum size, obtained right after we</span></div>
<div class="line"><a id="l03768" name="l03768"></a><span class="lineno"> 3768</span><span class="comment">   * OS-set that setting and never changed subsequently.  Note the OS may not respect whatever value we</span></div>
<div class="line"><a id="l03769" name="l03769"></a><span class="lineno"> 3769</span><span class="comment">   * passed into the OS socket option setting call, or it may respect it but only approximately.</span></div>
<div class="line"><a id="l03770" name="l03770"></a><span class="lineno"> 3770</span><span class="comment">   */</span></div>
<div class="line"><a id="l03771" name="l03771"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1"> 3771</a></span>  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">m_low_lvl_max_buf_size</a>;</div>
<div class="line"><a id="l03772" name="l03772"></a><span class="lineno"> 3772</span><span class="comment"></span> </div>
<div class="line"><a id="l03773" name="l03773"></a><span class="lineno"> 3773</span><span class="comment">  /// Stores incoming raw packet data; re-used repeatedly for possible performance gains.</span></div>
<div class="line"><a id="l03774" name="l03774"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#acea4db94c4fb86ddaa2502c2d7e128ea"> 3774</a></span><span class="comment"></span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">util::Blob</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#acea4db94c4fb86ddaa2502c2d7e128ea">m_packet_data</a>;</div>
<div class="line"><a id="l03775" name="l03775"></a><span class="lineno"> 3775</span><span class="comment"></span> </div>
<div class="line"><a id="l03776" name="l03776"></a><span class="lineno"> 3776</span><span class="comment">  /// Flow port space for both client and server sockets.  All threads may access this.</span></div>
<div class="line"><a id="l03777" name="l03777"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011"> 3777</a></span><span class="comment"></span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Port__space.html">Port_space</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">m_ports</a>;</div>
<div class="line"><a id="l03778" name="l03778"></a><span class="lineno"> 3778</span><span class="comment"></span> </div>
<div class="line"><a id="l03779" name="l03779"></a><span class="lineno"> 3779</span><span class="comment">  /// Sequence number generator (at least to generate ISNs).  Only thread W can access this.</span></div>
<div class="line"><a id="l03780" name="l03780"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a8938c4a091edf1c1c77e2cc8f505f0ff"> 3780</a></span><span class="comment"></span>  <a class="code hl_class" href="classflow_1_1net__flow_1_1Sequence__number_1_1Generator.html">Sequence_number::Generator</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a8938c4a091edf1c1c77e2cc8f505f0ff">m_seq_num_generator</a>;</div>
<div class="line"><a id="l03781" name="l03781"></a><span class="lineno"> 3781</span><span class="comment"></span> </div>
<div class="line"><a id="l03782" name="l03782"></a><span class="lineno"> 3782</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03783" name="l03783"></a><span class="lineno"> 3783</span><span class="comment">   * Random number generator for picking security tokens; seeded on time at Node construction and generates</span></div>
<div class="line"><a id="l03784" name="l03784"></a><span class="lineno"> 3784</span><span class="comment">   * integers from the entire range.  (Not thread-safe.  Use only in thread W.)</span></div>
<div class="line"><a id="l03785" name="l03785"></a><span class="lineno"> 3785</span><span class="comment">   */</span></div>
<div class="line"><a id="l03786" name="l03786"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ae536f016607677a945ad42034a21e82a"> 3786</a></span>  <a class="code hl_class" href="classflow_1_1util_1_1Rnd__gen__uniform__range.html">util::Rnd_gen_uniform_range&lt;Peer_socket::security_token_t&gt;</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ae536f016607677a945ad42034a21e82a">m_rnd_security_tokens</a>;</div>
<div class="line"><a id="l03787" name="l03787"></a><span class="lineno"> 3787</span><span class="comment"></span> </div>
<div class="line"><a id="l03788" name="l03788"></a><span class="lineno"> 3788</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03789" name="l03789"></a><span class="lineno"> 3789</span><span class="comment">   * The peer-to-peer connections this Node is currently tracking.  Their states are not Peer_socket::State::S_CLOSED.</span></div>
<div class="line"><a id="l03790" name="l03790"></a><span class="lineno"> 3790</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03791" name="l03791"></a><span class="lineno"> 3791</span><span class="comment">   */</span></div>
<div class="line"><a id="l03792" name="l03792"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a"> 3792</a></span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">Socket_id_to_socket_map</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">m_socks</a>;</div>
<div class="line"><a id="l03793" name="l03793"></a><span class="lineno"> 3793</span><span class="comment"></span> </div>
<div class="line"><a id="l03794" name="l03794"></a><span class="lineno"> 3794</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03795" name="l03795"></a><span class="lineno"> 3795</span><span class="comment">   * The server sockets this Node is currently tracking.  Their states are not Server_socket::State::S_CLOSED.</span></div>
<div class="line"><a id="l03796" name="l03796"></a><span class="lineno"> 3796</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03797" name="l03797"></a><span class="lineno"> 3797</span><span class="comment">   */</span></div>
<div class="line"><a id="l03798" name="l03798"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df"> 3798</a></span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">Port_to_server_map</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">m_servs</a>;</div>
<div class="line"><a id="l03799" name="l03799"></a><span class="lineno"> 3799</span><span class="comment"></span> </div>
<div class="line"><a id="l03800" name="l03800"></a><span class="lineno"> 3800</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03801" name="l03801"></a><span class="lineno"> 3801</span><span class="comment">   * Every Event_set to have been returned by event_set_create() and not subsequently reached</span></div>
<div class="line"><a id="l03802" name="l03802"></a><span class="lineno"> 3802</span><span class="comment">   * Event_set::State::S_CLOSED.  Only thread W can access this.</span></div>
<div class="line"><a id="l03803" name="l03803"></a><span class="lineno"> 3803</span><span class="comment">   */</span></div>
<div class="line"><a id="l03804" name="l03804"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b"> 3804</a></span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">Event_sets</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b">m_event_sets</a>;</div>
<div class="line"><a id="l03805" name="l03805"></a><span class="lineno"> 3805</span><span class="comment"></span> </div>
<div class="line"><a id="l03806" name="l03806"></a><span class="lineno"> 3806</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03807" name="l03807"></a><span class="lineno"> 3807</span><span class="comment">   * All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at</span></div>
<div class="line"><a id="l03808" name="l03808"></a><span class="lineno"> 3808</span><span class="comment">   * any point since the last time #m_sock_events&#39;s contained sets were cleared (which happens initially and after each</span></div>
<div class="line"><a id="l03809" name="l03809"></a><span class="lineno"> 3809</span><span class="comment">   * event_set_all_check_delta() call).  EVERY piece of code in thread W to potentially set a</span></div>
<div class="line"><a id="l03810" name="l03810"></a><span class="lineno"> 3810</span><span class="comment">   * socket&#39;s status to &quot;ready&quot; (e.g.: DATA received, error detected) MUST add that socket&#39;s handle</span></div>
<div class="line"><a id="l03811" name="l03811"></a><span class="lineno"> 3811</span><span class="comment">   * to this data structure.  This enables the Event_set machinery to efficiently but thoroughly</span></div>
<div class="line"><a id="l03812" name="l03812"></a><span class="lineno"> 3812</span><span class="comment">   * detect every event in which the Event_set user is interested.  The theory behind this is</span></div>
<div class="line"><a id="l03813" name="l03813"></a><span class="lineno"> 3813</span><span class="comment">   * described in the giant comment inside Event_set::async_wait().</span></div>
<div class="line"><a id="l03814" name="l03814"></a><span class="lineno"> 3814</span><span class="comment">   *</span></div>
<div class="line"><a id="l03815" name="l03815"></a><span class="lineno"> 3815</span><span class="comment">   * This maps Event_set::Event_type `enum` members to Event_set::Sockets socket sets, exactly the same way</span></div>
<div class="line"><a id="l03816" name="l03816"></a><span class="lineno"> 3816</span><span class="comment">   * Event_set::m_can and Event_set::m_want are set up.</span></div>
<div class="line"><a id="l03817" name="l03817"></a><span class="lineno"> 3817</span><span class="comment">   *</span></div>
<div class="line"><a id="l03818" name="l03818"></a><span class="lineno"> 3818</span><span class="comment">   * A question arises: why use this set to store such active sockets?  Why not just call</span></div>
<div class="line"><a id="l03819" name="l03819"></a><span class="lineno"> 3819</span><span class="comment">   * event_set_all_check_delta() EVERY time we see a socket is now Readable, etc., thus handling it right</span></div>
<div class="line"><a id="l03820" name="l03820"></a><span class="lineno"> 3820</span><span class="comment">   * away and not needing to store it?  Answer: we could.  However, we want to collect as many</span></div>
<div class="line"><a id="l03821" name="l03821"></a><span class="lineno"> 3821</span><span class="comment">   * possibly active events as possible, without blocking, before performing the check.  That way</span></div>
<div class="line"><a id="l03822" name="l03822"></a><span class="lineno"> 3822</span><span class="comment">   * the user is informed of as many events as possible, instead of the very first one (when there</span></div>
<div class="line"><a id="l03823" name="l03823"></a><span class="lineno"> 3823</span><span class="comment">   * could be hundreds more; for example if hundreds of DATA packets have arrived simultaneously).</span></div>
<div class="line"><a id="l03824" name="l03824"></a><span class="lineno"> 3824</span><span class="comment">   * The theory behind this is also discussed in Event_set::async_wait() giant comment.  So we</span></div>
<div class="line"><a id="l03825" name="l03825"></a><span class="lineno"> 3825</span><span class="comment">   * insert into #m_sock_events and defer `event_set_all_check_delta(false)` to the end of the current</span></div>
<div class="line"><a id="l03826" name="l03826"></a><span class="lineno"> 3826</span><span class="comment">   * boost.asio handler, since we know we won&#39;t block (sleep) until the handler exits.</span></div>
<div class="line"><a id="l03827" name="l03827"></a><span class="lineno"> 3827</span><span class="comment">   *</span></div>
<div class="line"><a id="l03828" name="l03828"></a><span class="lineno"> 3828</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03829" name="l03829"></a><span class="lineno"> 3829</span><span class="comment">   */</span></div>
<div class="line"><a id="l03830" name="l03830"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab"> 3830</a></span>  <a class="code hl_class" href="classflow_1_1util_1_1Linked__hash__map.html">Event_set::Ev_type_to_socks_map</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">m_sock_events</a>;</div>
<div class="line"><a id="l03831" name="l03831"></a><span class="lineno"> 3831</span><span class="comment"></span> </div>
<div class="line"><a id="l03832" name="l03832"></a><span class="lineno"> 3832</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03833" name="l03833"></a><span class="lineno"> 3833</span><span class="comment">   * Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() (async part)</span></div>
<div class="line"><a id="l03834" name="l03834"></a><span class="lineno"> 3834</span><span class="comment">   * call, by the time perform_accumulated_on_recv_tasks() is called, this stores exactly those sockets for which</span></div>
<div class="line"><a id="l03835" name="l03835"></a><span class="lineno"> 3835</span><span class="comment">   * possible ACK sending tasks have been accumulated during the low_lvl_recv_and_handle()/etc.</span></div>
<div class="line"><a id="l03836" name="l03836"></a><span class="lineno"> 3836</span><span class="comment">   * call.  The idea is that, for efficiency and reduced overhead,</span></div>
<div class="line"><a id="l03837" name="l03837"></a><span class="lineno"> 3837</span><span class="comment">   * all simultaneously available incoming data are examined first, and some tasks are accumulated</span></div>
<div class="line"><a id="l03838" name="l03838"></a><span class="lineno"> 3838</span><span class="comment">   * to perform at the end.  For example, all DATA packets to be acknowledged at the same time are</span></div>
<div class="line"><a id="l03839" name="l03839"></a><span class="lineno"> 3839</span><span class="comment">   * collected and then sent in as few ACKs as possible.</span></div>
<div class="line"><a id="l03840" name="l03840"></a><span class="lineno"> 3840</span><span class="comment">   *</span></div>
<div class="line"><a id="l03841" name="l03841"></a><span class="lineno"> 3841</span><span class="comment">   * Details on the acks to potentially send are stored within that Peer_socket itself (e.g.,</span></div>
<div class="line"><a id="l03842" name="l03842"></a><span class="lineno"> 3842</span><span class="comment">   * Peer_socket::m_rcv_pending_acks).</span></div>
<div class="line"><a id="l03843" name="l03843"></a><span class="lineno"> 3843</span><span class="comment">   *</span></div>
<div class="line"><a id="l03844" name="l03844"></a><span class="lineno"> 3844</span><span class="comment">   * This should be added to throughout the method, used in perform_accumulated_on_recv_tasks(), and</span></div>
<div class="line"><a id="l03845" name="l03845"></a><span class="lineno"> 3845</span><span class="comment">   * then cleared for the next run.</span></div>
<div class="line"><a id="l03846" name="l03846"></a><span class="lineno"> 3846</span><span class="comment">   *</span></div>
<div class="line"><a id="l03847" name="l03847"></a><span class="lineno"> 3847</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03848" name="l03848"></a><span class="lineno"> 3848</span><span class="comment">   */</span></div>
<div class="line"><a id="l03849" name="l03849"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb"> 3849</a></span>  boost::unordered_set&lt;Peer_socket::Ptr&gt; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb">m_socks_with_accumulated_pending_acks</a>;</div>
<div class="line"><a id="l03850" name="l03850"></a><span class="lineno"> 3850</span><span class="comment"></span> </div>
<div class="line"><a id="l03851" name="l03851"></a><span class="lineno"> 3851</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03852" name="l03852"></a><span class="lineno"> 3852</span><span class="comment">   * Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() call,</span></div>
<div class="line"><a id="l03853" name="l03853"></a><span class="lineno"> 3853</span><span class="comment">   * by the time perform_accumulated_on_recv_tasks() is called, this stores exactly those sockets for which</span></div>
<div class="line"><a id="l03854" name="l03854"></a><span class="lineno"> 3854</span><span class="comment">   * possible incoming-ACK handling tasks have been accumulated during the low_lvl_recv_and_handle()/etc.</span></div>
<div class="line"><a id="l03855" name="l03855"></a><span class="lineno"> 3855</span><span class="comment">   * call.  The idea is that, for congestion control robustness,</span></div>
<div class="line"><a id="l03856" name="l03856"></a><span class="lineno"> 3856</span><span class="comment">   * all simultaneously available acknowledgments and rcv_wnd updates are collected first, and then</span></div>
<div class="line"><a id="l03857" name="l03857"></a><span class="lineno"> 3857</span><span class="comment">   * they&#39;re all handled together at the end.</span></div>
<div class="line"><a id="l03858" name="l03858"></a><span class="lineno"> 3858</span><span class="comment">   *</span></div>
<div class="line"><a id="l03859" name="l03859"></a><span class="lineno"> 3859</span><span class="comment">   * Details on the acks to potentially send are stored within that Peer_socket</span></div>
<div class="line"><a id="l03860" name="l03860"></a><span class="lineno"> 3860</span><span class="comment">   * itself (Peer_socket::m_rcv_acked_packets scan all).</span></div>
<div class="line"><a id="l03861" name="l03861"></a><span class="lineno"> 3861</span><span class="comment">   *</span></div>
<div class="line"><a id="l03862" name="l03862"></a><span class="lineno"> 3862</span><span class="comment">   * This should be added to throughout the method, used in perform_accumulated_on_recv_tasks(), and</span></div>
<div class="line"><a id="l03863" name="l03863"></a><span class="lineno"> 3863</span><span class="comment">   * then cleared for the next run.</span></div>
<div class="line"><a id="l03864" name="l03864"></a><span class="lineno"> 3864</span><span class="comment">   *</span></div>
<div class="line"><a id="l03865" name="l03865"></a><span class="lineno"> 3865</span><span class="comment">   * Only thread W can access this.</span></div>
<div class="line"><a id="l03866" name="l03866"></a><span class="lineno"> 3866</span><span class="comment">   */</span></div>
<div class="line"><a id="l03867" name="l03867"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f"> 3867</a></span>  boost::unordered_set&lt;Peer_socket::Ptr&gt; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f">m_socks_with_accumulated_acks</a>;</div>
<div class="line"><a id="l03868" name="l03868"></a><span class="lineno"> 3868</span><span class="comment"></span> </div>
<div class="line"><a id="l03869" name="l03869"></a><span class="lineno"> 3869</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03870" name="l03870"></a><span class="lineno"> 3870</span><span class="comment">   * For debugging, when we detect loss of data we&#39;d sent, we log the corresponding socket&#39;s state;</span></div>
<div class="line"><a id="l03871" name="l03871"></a><span class="lineno"> 3871</span><span class="comment">   * this is the last time this was done for any socket (or epoch if never).  It&#39;s used to</span></div>
<div class="line"><a id="l03872" name="l03872"></a><span class="lineno"> 3872</span><span class="comment">   * throttle such messages, since they are CPU-intensive and disk-intensive (when logging to disk).</span></div>
<div class="line"><a id="l03873" name="l03873"></a><span class="lineno"> 3873</span><span class="comment">   */</span></div>
<div class="line"><a id="l03874" name="l03874"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a3b5004700cb085c6a2806f39426b0ea0"> 3874</a></span>  <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a3b5004700cb085c6a2806f39426b0ea0">m_last_loss_sock_log_when</a>;</div>
<div class="line"><a id="l03875" name="l03875"></a><span class="lineno"> 3875</span><span class="comment"></span> </div>
<div class="line"><a id="l03876" name="l03876"></a><span class="lineno"> 3876</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03877" name="l03877"></a><span class="lineno"> 3877</span><span class="comment">   * Promise that thread W sets to truthy `Error_code` if it fails to initialize or falsy once event loop is running.</span></div>
<div class="line"><a id="l03878" name="l03878"></a><span class="lineno"> 3878</span><span class="comment">   * The truthy payload can be returned or thrown inside an error::Runtime_exception if desired.</span></div>
<div class="line"><a id="l03879" name="l03879"></a><span class="lineno"> 3879</span><span class="comment">   */</span></div>
<div class="line"><a id="l03880" name="l03880"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90"> 3880</a></span>  boost::promise&lt;Error_code&gt; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90">m_event_loop_ready</a>;</div>
<div class="line"><a id="l03881" name="l03881"></a><span class="lineno"> 3881</span><span class="comment"></span> </div>
<div class="line"><a id="l03882" name="l03882"></a><span class="lineno"> 3882</span><span class="comment">  /// The future object through which the non-W thread waits for #m_event_loop_ready to be set to success/failure.</span></div>
<div class="line"><a id="l03883" name="l03883"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a61f87144f19e908ffb981f3bff91938e"> 3883</a></span><span class="comment"></span>  boost::unique_future&lt;Error_code&gt; <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a61f87144f19e908ffb981f3bff91938e">m_event_loop_ready_result</a>;</div>
<div class="line"><a id="l03884" name="l03884"></a><span class="lineno"> 3884</span><span class="comment"></span> </div>
<div class="line"><a id="l03885" name="l03885"></a><span class="lineno"> 3885</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03886" name="l03886"></a><span class="lineno"> 3886</span><span class="comment">   * Signal set which we may or may not be using to trap SIGINT and SIGTERM in order to auto-fire</span></div>
<div class="line"><a id="l03887" name="l03887"></a><span class="lineno"> 3887</span><span class="comment">   * interrupt_all_waits().  `add()` is called on it at initialization if and only if that feature is enabled</span></div>
<div class="line"><a id="l03888" name="l03888"></a><span class="lineno"> 3888</span><span class="comment">   * by the user via `Node_options`.  Otherwise this object just does nothing for the Node&#39;s lifetime.</span></div>
<div class="line"><a id="l03889" name="l03889"></a><span class="lineno"> 3889</span><span class="comment">   */</span></div>
<div class="line"><a id="l03890" name="l03890"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#abecf0f8111af82fa081c71fda490608a"> 3890</a></span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">Signal_set</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#abecf0f8111af82fa081c71fda490608a">m_signal_set</a>;</div>
<div class="line"><a id="l03891" name="l03891"></a><span class="lineno"> 3891</span><span class="comment"></span> </div>
<div class="line"><a id="l03892" name="l03892"></a><span class="lineno"> 3892</span><span class="comment">  /// Worker thread (= thread W).  Other members should be initialized before this to avoid race condition.</span></div>
<div class="line"><a id="l03893" name="l03893"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3"> 3893</a></span><span class="comment"></span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">util::Thread</a> <a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3">m_worker</a>;</div>
<div class="line"><a id="l03894" name="l03894"></a><span class="lineno"> 3894</span>}; <span class="comment">// class Node</span></div>
<div class="line"><a id="l03895" name="l03895"></a><span class="lineno"> 3895</span><span class="comment"></span> </div>
<div class="line"><a id="l03896" name="l03896"></a><span class="lineno"> 3896</span><span class="comment">/**</span></div>
<div class="line"><a id="l03897" name="l03897"></a><span class="lineno"> 3897</span><span class="comment"> * @private</span></div>
<div class="line"><a id="l03898" name="l03898"></a><span class="lineno"> 3898</span><span class="comment"> *</span></div>
<div class="line"><a id="l03899" name="l03899"></a><span class="lineno"> 3899</span><span class="comment"> * The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to</span></div>
<div class="line"><a id="l03900" name="l03900"></a><span class="lineno"> 3900</span><span class="comment"> * a port in this Node.  Its (unmodifiable after initialization) fields are to be constructed via direct</span></div>
<div class="line"><a id="l03901" name="l03901"></a><span class="lineno"> 3901</span><span class="comment"> * initialization (assuming the defaults are unacceptable).</span></div>
<div class="line"><a id="l03902" name="l03902"></a><span class="lineno"> 3902</span><span class="comment"> */</span></div>
<div class="line"><a id="l03903" name="l03903"></a><span class="lineno"><a class="line" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html"> 3903</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a></div>
<div class="line"><a id="l03904" name="l03904"></a><span class="lineno"> 3904</span>{</div>
<div class="line"><a id="l03905" name="l03905"></a><span class="lineno"> 3905</span>  <span class="comment">// Data.</span></div>
<div class="line"><a id="l03906" name="l03906"></a><span class="lineno"> 3906</span><span class="comment"></span> </div>
<div class="line"><a id="l03907" name="l03907"></a><span class="lineno"> 3907</span><span class="comment">  /// The other side of the connection.</span></div>
<div class="line"><a id="l03908" name="l03908"></a><span class="lineno"><a class="line" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#a23527fa6deadda111d7c4c194a0ce177"> 3908</a></span><span class="comment"></span>  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> <a class="code hl_variable" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#a23527fa6deadda111d7c4c194a0ce177">m_remote_endpoint</a> = <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>();<span class="comment"></span></div>
<div class="line"><a id="l03909" name="l03909"></a><span class="lineno"> 3909</span><span class="comment">  /// This side of the connection (within this Node).</span></div>
<div class="line"><a id="l03910" name="l03910"></a><span class="lineno"><a class="line" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#aefe916d29cee30dbc344532603aa9336"> 3910</a></span><span class="comment"></span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> <a class="code hl_variable" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#aefe916d29cee30dbc344532603aa9336">m_local_port</a> = <a class="code hl_variable" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">S_PORT_ANY</a>;</div>
<div class="line"><a id="l03911" name="l03911"></a><span class="lineno"> 3911</span> </div>
<div class="line"><a id="l03912" name="l03912"></a><span class="lineno"> 3912</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l03913" name="l03913"></a><span class="lineno"> 3913</span><span class="comment"></span> </div>
<div class="line"><a id="l03914" name="l03914"></a><span class="lineno"> 3914</span><span class="comment">  /**</span></div>
<div class="line"><a id="l03915" name="l03915"></a><span class="lineno"> 3915</span><span class="comment">   * Hash value of this Socket_id for `unordered&lt;&gt;`.</span></div>
<div class="line"><a id="l03916" name="l03916"></a><span class="lineno"> 3916</span><span class="comment">   * @return Ditto.</span></div>
<div class="line"><a id="l03917" name="l03917"></a><span class="lineno"> 3917</span><span class="comment">   */</span></div>
<div class="line"><a id="l03918" name="l03918"></a><span class="lineno"> 3918</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#a4f4e052de75d02fb4610df872be06186">hash</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l03919" name="l03919"></a><span class="lineno"> 3919</span>};</div>
<div class="line"><a id="l03920" name="l03920"></a><span class="lineno"> 3920</span> </div>
<div class="line"><a id="l03921" name="l03921"></a><span class="lineno"> 3921</span><span class="comment">// Free functions: in *_fwd.hpp.</span></div>
<div class="line"><a id="l03922" name="l03922"></a><span class="lineno"> 3922</span> </div>
<div class="line"><a id="l03923" name="l03923"></a><span class="lineno"> 3923</span><span class="comment">// However the following refer to inner type(s) and hence must be declared here and not _fwd.hpp.</span></div>
<div class="line"><a id="l03924" name="l03924"></a><span class="lineno"> 3924</span><span class="comment"></span> </div>
<div class="line"><a id="l03925" name="l03925"></a><span class="lineno"> 3925</span><span class="comment">/**</span></div>
<div class="line"><a id="l03926" name="l03926"></a><span class="lineno"> 3926</span><span class="comment"> * @internal</span></div>
<div class="line"><a id="l03927" name="l03927"></a><span class="lineno"> 3927</span><span class="comment"> *</span></div>
<div class="line"><a id="l03928" name="l03928"></a><span class="lineno"> 3928</span><span class="comment"> * Free function that returns socket_id.hash(); has to be a free function named `hash_value()` for</span></div>
<div class="line"><a id="l03929" name="l03929"></a><span class="lineno"> 3929</span><span class="comment"> * boost.hash to pick it up.</span></div>
<div class="line"><a id="l03930" name="l03930"></a><span class="lineno"> 3930</span><span class="comment"> *</span></div>
<div class="line"><a id="l03931" name="l03931"></a><span class="lineno"> 3931</span><span class="comment"> * @relatesalso Node::Socket_id</span></div>
<div class="line"><a id="l03932" name="l03932"></a><span class="lineno"> 3932</span><span class="comment"> *</span></div>
<div class="line"><a id="l03933" name="l03933"></a><span class="lineno"> 3933</span><span class="comment"> * @param socket_id</span></div>
<div class="line"><a id="l03934" name="l03934"></a><span class="lineno"> 3934</span><span class="comment"> *        Socket ID to hash.</span></div>
<div class="line"><a id="l03935" name="l03935"></a><span class="lineno"> 3935</span><span class="comment"> * @return socket_id.hash().</span></div>
<div class="line"><a id="l03936" name="l03936"></a><span class="lineno"> 3936</span><span class="comment"> */</span></div>
<div class="line"><a id="l03937" name="l03937"></a><span class="lineno"> 3937</span><span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceflow_1_1net__flow.html#a152200ba9432e5ca229e41a1c5d9d226">hash_value</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a>&amp; socket_id);</div>
<div class="line"><a id="l03938" name="l03938"></a><span class="lineno"> 3938</span><span class="comment"></span> </div>
<div class="line"><a id="l03939" name="l03939"></a><span class="lineno"> 3939</span><span class="comment">/**</span></div>
<div class="line"><a id="l03940" name="l03940"></a><span class="lineno"> 3940</span><span class="comment"> * @internal</span></div>
<div class="line"><a id="l03941" name="l03941"></a><span class="lineno"> 3941</span><span class="comment"> *</span></div>
<div class="line"><a id="l03942" name="l03942"></a><span class="lineno"> 3942</span><span class="comment"> * Whether `lhs` is equal to `rhs`.</span></div>
<div class="line"><a id="l03943" name="l03943"></a><span class="lineno"> 3943</span><span class="comment"> *</span></div>
<div class="line"><a id="l03944" name="l03944"></a><span class="lineno"> 3944</span><span class="comment"> * @relatesalso Node::Socket_id</span></div>
<div class="line"><a id="l03945" name="l03945"></a><span class="lineno"> 3945</span><span class="comment"> * @param lhs</span></div>
<div class="line"><a id="l03946" name="l03946"></a><span class="lineno"> 3946</span><span class="comment"> *        Object to compare.</span></div>
<div class="line"><a id="l03947" name="l03947"></a><span class="lineno"> 3947</span><span class="comment"> * @param rhs</span></div>
<div class="line"><a id="l03948" name="l03948"></a><span class="lineno"> 3948</span><span class="comment"> *        Object to compare.</span></div>
<div class="line"><a id="l03949" name="l03949"></a><span class="lineno"> 3949</span><span class="comment"> * @return See above.</span></div>
<div class="line"><a id="l03950" name="l03950"></a><span class="lineno"> 3950</span><span class="comment"> */</span></div>
<div class="line"><a id="l03951" name="l03951"></a><span class="lineno"> 3951</span><span class="keywordtype">bool</span> <a class="code hl_function" href="namespaceflow_1_1net__flow.html#a8504aeca20f41a8f2b98ae04803a600e">operator==</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a>&amp; lhs, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">Node::Socket_id</a>&amp; rhs);</div>
<div class="line"><a id="l03952" name="l03952"></a><span class="lineno"> 3952</span> </div>
<div class="line"><a id="l03953" name="l03953"></a><span class="lineno"> 3953</span><span class="comment">// Template implementations.</span></div>
<div class="line"><a id="l03954" name="l03954"></a><span class="lineno"> 3954</span> </div>
<div class="line"><a id="l03955" name="l03955"></a><span class="lineno"> 3955</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a id="l03956" name="l03956"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2"> 3956</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">Node::sync_connect_with_metadata</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l03957" name="l03957"></a><span class="lineno"> 3957</span>                                                  <span class="keyword">const</span> boost::chrono::duration&lt;Rep, Period&gt;&amp; max_wait,</div>
<div class="line"><a id="l03958" name="l03958"></a><span class="lineno"> 3958</span>                                                  <span class="keyword">const</span> boost::asio::const_buffer&amp; serialized_metadata,</div>
<div class="line"><a id="l03959" name="l03959"></a><span class="lineno"> 3959</span>                                                  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code,</div>
<div class="line"><a id="l03960" name="l03960"></a><span class="lineno"> 3960</span>                                                  <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts)</div>
<div class="line"><a id="l03961" name="l03961"></a><span class="lineno"> 3961</span>{</div>
<div class="line"><a id="l03962" name="l03962"></a><span class="lineno"> 3962</span>  assert(max_wait.count() &gt; 0);</div>
<div class="line"><a id="l03963" name="l03963"></a><span class="lineno"> 3963</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">sync_connect_impl</a>(to, <a class="code hl_function" href="namespaceflow_1_1util.html#aa60d3ba517b5f5cf408faa92d269256a">util::chrono_duration_to_fine_duration</a>(max_wait), serialized_metadata, err_code, opts);</div>
<div class="line"><a id="l03964" name="l03964"></a><span class="lineno"> 3964</span>}</div>
<div class="line"><a id="l03965" name="l03965"></a><span class="lineno"> 3965</span> </div>
<div class="line"><a id="l03966" name="l03966"></a><span class="lineno"> 3966</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a id="l03967" name="l03967"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5"> 3967</a></span><a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">Node::sync_connect</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a>&amp; to,</div>
<div class="line"><a id="l03968" name="l03968"></a><span class="lineno"> 3968</span>                                    <span class="keyword">const</span> boost::chrono::duration&lt;Rep, Period&gt;&amp; max_wait,</div>
<div class="line"><a id="l03969" name="l03969"></a><span class="lineno"> 3969</span>                                    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code, <span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* opts)</div>
<div class="line"><a id="l03970" name="l03970"></a><span class="lineno"> 3970</span>{</div>
<div class="line"><a id="l03971" name="l03971"></a><span class="lineno"> 3971</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a>(to, max_wait,</div>
<div class="line"><a id="l03972" name="l03972"></a><span class="lineno"> 3972</span>                                    boost::asio::buffer(&amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a>, <span class="keyword">sizeof</span>(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a>)),</div>
<div class="line"><a id="l03973" name="l03973"></a><span class="lineno"> 3973</span>                                    err_code, opts);</div>
<div class="line"><a id="l03974" name="l03974"></a><span class="lineno"> 3974</span>}</div>
<div class="line"><a id="l03975" name="l03975"></a><span class="lineno"> 3975</span> </div>
<div class="line"><a id="l03976" name="l03976"></a><span class="lineno"> 3976</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Socket, <span class="keyword">typename</span> Non_blocking_func_ret_type&gt;</div>
<div class="line"><a id="l03977" name="l03977"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae"> 3977</a></span>Non_blocking_func_ret_type <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">Node::sync_op</a>(<span class="keyword">typename</span> Socket::Ptr sock,</div>
<div class="line"><a id="l03978" name="l03978"></a><span class="lineno"> 3978</span>                                         <span class="keyword">const</span> <a class="code hl_class" href="classflow_1_1Function.html">Function</a>&lt;Non_blocking_func_ret_type ()&gt;&amp; non_blocking_func,</div>
<div class="line"><a id="l03979" name="l03979"></a><span class="lineno"> 3979</span>                                         Non_blocking_func_ret_type would_block_ret_val,</div>
<div class="line"><a id="l03980" name="l03980"></a><span class="lineno"> 3980</span>                                         <a class="code hl_enumeration" href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">Event_set::Event_type</a> ev_type,</div>
<div class="line"><a id="l03981" name="l03981"></a><span class="lineno"> 3981</span>                                         <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>&amp; wait_until,</div>
<div class="line"><a id="l03982" name="l03982"></a><span class="lineno"> 3982</span>                                         <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)</div>
<div class="line"><a id="l03983" name="l03983"></a><span class="lineno"> 3983</span>{</div>
<div class="line"><a id="l03984" name="l03984"></a><span class="lineno"> 3984</span>  <span class="keyword">using </span>boost::adopt_lock;</div>
<div class="line"><a id="l03985" name="l03985"></a><span class="lineno"> 3985</span>  <span class="keyword">using </span>boost::chrono::milliseconds;</div>
<div class="line"><a id="l03986" name="l03986"></a><span class="lineno"> 3986</span>  <span class="keyword">using </span>boost::chrono::round;</div>
<div class="line"><a id="l03987" name="l03987"></a><span class="lineno"> 3987</span> </div>
<div class="line"><a id="l03988" name="l03988"></a><span class="lineno"> 3988</span>  <span class="comment">// We are in user thread U != W.</span></div>
<div class="line"><a id="l03989" name="l03989"></a><span class="lineno"> 3989</span> </div>
<div class="line"><a id="l03990" name="l03990"></a><span class="lineno"> 3990</span>  {</div>
<div class="line"><a id="l03991" name="l03991"></a><span class="lineno"> 3991</span>    <span class="comment">/* WARNING!!!  sock-&gt;m_mutex is locked, but WE must unlock it before returning!  Can&#39;t leave that</span></div>
<div class="line"><a id="l03992" name="l03992"></a><span class="lineno"> 3992</span><span class="comment">     * to the caller, because we must unlock at a specific point below, right before sync_wait()ing.</span></div>
<div class="line"><a id="l03993" name="l03993"></a><span class="lineno"> 3993</span><span class="comment">     * Use a Lock_guard that adopts an already-locked mutex. */</span></div>
<div class="line"><a id="l03994" name="l03994"></a><span class="lineno"> 3994</span>    <span class="keyword">typename</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">Socket::Lock_guard</a> lock(sock-&gt;m_mutex, adopt_lock);</div>
<div class="line"><a id="l03995" name="l03995"></a><span class="lineno"> 3995</span> </div>
<div class="line"><a id="l03996" name="l03996"></a><span class="lineno"> 3996</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a>())</div>
<div class="line"><a id="l03997" name="l03997"></a><span class="lineno"> 3997</span>    {</div>
<div class="line"><a id="l03998" name="l03998"></a><span class="lineno"> 3998</span>      <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">error::Code::S_NODE_NOT_RUNNING</a>);</div>
<div class="line"><a id="l03999" name="l03999"></a><span class="lineno"> 3999</span>      <span class="keywordflow">return</span> would_block_ret_val;</div>
<div class="line"><a id="l04000" name="l04000"></a><span class="lineno"> 4000</span>    }</div>
<div class="line"><a id="l04001" name="l04001"></a><span class="lineno"> 4001</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l04002" name="l04002"></a><span class="lineno"> 4002</span> </div>
<div class="line"><a id="l04003" name="l04003"></a><span class="lineno"> 4003</span>    <span class="comment">/* Unlock.  Why?  Simply because we can&#39;t forbid other threads from accessing sock while we</span></div>
<div class="line"><a id="l04004" name="l04004"></a><span class="lineno"> 4004</span><span class="comment">     * shamelessly block (in sync_wait()).  */</span></div>
<div class="line"><a id="l04005" name="l04005"></a><span class="lineno"> 4005</span>  } <span class="comment">// Lock.</span></div>
<div class="line"><a id="l04006" name="l04006"></a><span class="lineno"> 4006</span> </div>
<div class="line"><a id="l04007" name="l04007"></a><span class="lineno"> 4007</span>  <span class="comment">/* This is actually pretty simple.  We create an Event_set with just the one event we care</span></div>
<div class="line"><a id="l04008" name="l04008"></a><span class="lineno"> 4008</span><span class="comment">   * about (e.g., sock is Writable) and sync_wait() for it.  Then we invoke non_blocking_func()</span></div>
<div class="line"><a id="l04009" name="l04009"></a><span class="lineno"> 4009</span><span class="comment">   * (e.g., Node::send()) once that event holds. So, create Event_set. */</span></div>
<div class="line"><a id="l04010" name="l04010"></a><span class="lineno"> 4010</span> </div>
<div class="line"><a id="l04011" name="l04011"></a><span class="lineno"> 4011</span>  <span class="comment">/* Note that we assume &quot;this&quot; remains valid throughout this method until we start sleeping</span></div>
<div class="line"><a id="l04012" name="l04012"></a><span class="lineno"> 4012</span><span class="comment">   * (sync_wait()).  This is explicitly guaranteed by the &quot;Thread safety&quot; note in class Node doc</span></div>
<div class="line"><a id="l04013" name="l04013"></a><span class="lineno"> 4013</span><span class="comment">   * header (which says that Node deletion is allowed only once a blocking operation&#39;s sleep has</span></div>
<div class="line"><a id="l04014" name="l04014"></a><span class="lineno"> 4014</span><span class="comment">   * been entered). */</span></div>
<div class="line"><a id="l04015" name="l04015"></a><span class="lineno"> 4015</span> </div>
<div class="line"><a id="l04016" name="l04016"></a><span class="lineno"> 4016</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> event_set = <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">event_set_create</a>(err_code);</div>
<div class="line"><a id="l04017" name="l04017"></a><span class="lineno"> 4017</span>  <span class="keywordflow">if</span> (!event_set)</div>
<div class="line"><a id="l04018" name="l04018"></a><span class="lineno"> 4018</span>  {</div>
<div class="line"><a id="l04019" name="l04019"></a><span class="lineno"> 4019</span>    <span class="keywordflow">return</span> would_block_ret_val; <span class="comment">// *err_code is set.  This is pretty weird but nothing we can do.</span></div>
<div class="line"><a id="l04020" name="l04020"></a><span class="lineno"> 4020</span>  }</div>
<div class="line"><a id="l04021" name="l04021"></a><span class="lineno"> 4021</span>  <span class="comment">// else event_set ready.</span></div>
<div class="line"><a id="l04022" name="l04022"></a><span class="lineno"> 4022</span> </div>
<div class="line"><a id="l04023" name="l04023"></a><span class="lineno"> 4023</span>  <span class="comment">// We must clean up event_set at any return point below.</span></div>
<div class="line"><a id="l04024" name="l04024"></a><span class="lineno"> 4024</span>  <a class="code hl_typedef" href="namespaceflow_1_1util.html#ab22fd89e165a9e6deaa174bc0dfdc8de">util::Auto_cleanup</a> cleanup = <a class="code hl_function" href="namespaceflow_1_1util.html#a09a032f8e1e77a3afc0b7df115a773e1">util::setup_auto_cleanup</a>([&amp;]()</div>
<div class="line"><a id="l04025" name="l04025"></a><span class="lineno"> 4025</span>  {</div>
<div class="line"><a id="l04026" name="l04026"></a><span class="lineno"> 4026</span>    <span class="comment">// Eat any error when closing Event_set, as it&#39;s unlikely and not interesting to user.</span></div>
<div class="line"><a id="l04027" name="l04027"></a><span class="lineno"> 4027</span>    <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> dummy_prevents_throw;</div>
<div class="line"><a id="l04028" name="l04028"></a><span class="lineno"> 4028</span>    event_set-&gt;close(&amp;dummy_prevents_throw);</div>
<div class="line"><a id="l04029" name="l04029"></a><span class="lineno"> 4029</span>  });</div>
<div class="line"><a id="l04030" name="l04030"></a><span class="lineno"> 4030</span> </div>
<div class="line"><a id="l04031" name="l04031"></a><span class="lineno"> 4031</span>  <span class="comment">// We care about just this event, ev_type.</span></div>
<div class="line"><a id="l04032" name="l04032"></a><span class="lineno"> 4032</span>  <span class="keywordflow">if</span> (!(event_set-&gt;add_wanted_socket&lt;Socket&gt;(sock, ev_type, err_code)))</div>
<div class="line"><a id="l04033" name="l04033"></a><span class="lineno"> 4033</span>  {</div>
<div class="line"><a id="l04034" name="l04034"></a><span class="lineno"> 4034</span>    <span class="keywordflow">return</span> would_block_ret_val; <span class="comment">// *err_code is set.  Node must have shut down or something.</span></div>
<div class="line"><a id="l04035" name="l04035"></a><span class="lineno"> 4035</span>  }</div>
<div class="line"><a id="l04036" name="l04036"></a><span class="lineno"> 4036</span>  <span class="comment">// else go ahead and wait.</span></div>
<div class="line"><a id="l04037" name="l04037"></a><span class="lineno"> 4037</span> </div>
<div class="line"><a id="l04038" name="l04038"></a><span class="lineno"> 4038</span>  Non_blocking_func_ret_type op_result;</div>
<div class="line"><a id="l04039" name="l04039"></a><span class="lineno"> 4039</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> timeout_given = wait_until != <a class="code hl_typedef" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">Fine_time_pt</a>();</div>
<div class="line"><a id="l04040" name="l04040"></a><span class="lineno"> 4040</span>  <span class="keywordflow">do</span></div>
<div class="line"><a id="l04041" name="l04041"></a><span class="lineno"> 4041</span>  {</div>
<div class="line"><a id="l04042" name="l04042"></a><span class="lineno"> 4042</span>    <span class="comment">// We may have to call sync_wait() repeatedly; if timeout is given we must give less and less time each time.</span></div>
<div class="line"><a id="l04043" name="l04043"></a><span class="lineno"> 4043</span>    <span class="keywordtype">bool</span> wait_result;</div>
<div class="line"><a id="l04044" name="l04044"></a><span class="lineno"> 4044</span>    <span class="keywordflow">if</span> (timeout_given)</div>
<div class="line"><a id="l04045" name="l04045"></a><span class="lineno"> 4045</span>    {</div>
<div class="line"><a id="l04046" name="l04046"></a><span class="lineno"> 4046</span>      <span class="comment">// Negative is OK but cleaner to clamp it to 0.</span></div>
<div class="line"><a id="l04047" name="l04047"></a><span class="lineno"> 4047</span>      <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">Fine_duration</a> time_remaining = std::max(Fine_duration::zero(), wait_until - Fine_clock::now());</div>
<div class="line"><a id="l04048" name="l04048"></a><span class="lineno"> 4048</span> </div>
<div class="line"><a id="l04049" name="l04049"></a><span class="lineno"> 4049</span>      <span class="comment">/* Do NOT log.  We have waited already, so `this` Node may have been deleted, so get_logger() may be undefined!</span></div>
<div class="line"><a id="l04050" name="l04050"></a><span class="lineno"> 4050</span><span class="comment">       * @todo I don&#39;t like this.  Want to log it.  Maybe get rid of the allowing for `this` deletion during wait.</span></div>
<div class="line"><a id="l04051" name="l04051"></a><span class="lineno"> 4051</span><span class="comment">       * We don&#39;t allow it in async_*() case for instance. */</span></div>
<div class="line"><a id="l04052" name="l04052"></a><span class="lineno"> 4052</span>      <span class="comment">/* FLOW_LOG_TRACE(&quot;Waiting again; timeout reduced &quot;</span></div>
<div class="line"><a id="l04053" name="l04053"></a><span class="lineno"> 4053</span><span class="comment">       *                &quot;to [&quot; &lt;&lt; round&lt;milliseconds&gt;(time_remaining) &lt;&lt; &quot;] = [&quot; &lt;&lt; time_remaining &lt;&lt; &quot;].&quot;); */</span></div>
<div class="line"><a id="l04054" name="l04054"></a><span class="lineno"> 4054</span> </div>
<div class="line"><a id="l04055" name="l04055"></a><span class="lineno"> 4055</span>      <span class="comment">// Perform the wait until event detected, time_remaining expires, or wait is interrupted (a-la EINTR).</span></div>
<div class="line"><a id="l04056" name="l04056"></a><span class="lineno"> 4056</span>      wait_result = event_set-&gt;sync_wait(time_remaining, err_code);</div>
<div class="line"><a id="l04057" name="l04057"></a><span class="lineno"> 4057</span>    }</div>
<div class="line"><a id="l04058" name="l04058"></a><span class="lineno"> 4058</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l04059" name="l04059"></a><span class="lineno"> 4059</span>    {</div>
<div class="line"><a id="l04060" name="l04060"></a><span class="lineno"> 4060</span>      <span class="comment">// No timeout given.  Perform the wait until event detected, or wait is interrupted (a-la EINTR).</span></div>
<div class="line"><a id="l04061" name="l04061"></a><span class="lineno"> 4061</span>      wait_result = event_set-&gt;sync_wait(err_code);</div>
<div class="line"><a id="l04062" name="l04062"></a><span class="lineno"> 4062</span>    }</div>
<div class="line"><a id="l04063" name="l04063"></a><span class="lineno"> 4063</span> </div>
<div class="line"><a id="l04064" name="l04064"></a><span class="lineno"> 4064</span>    <span class="keywordflow">if</span> (!wait_result)</div>
<div class="line"><a id="l04065" name="l04065"></a><span class="lineno"> 4065</span>    {</div>
<div class="line"><a id="l04066" name="l04066"></a><span class="lineno"> 4066</span>      <span class="comment">/* *err_code is set.  Node must have shut down or something; or, maybe more likely, S_WAIT_INTERRUPTED</span></div>
<div class="line"><a id="l04067" name="l04067"></a><span class="lineno"> 4067</span><span class="comment">       * or S_WAIT_USER_TIMEOUT occurred.  In all cases, it&#39;s correct to pass it on to our caller. */</span></div>
<div class="line"><a id="l04068" name="l04068"></a><span class="lineno"> 4068</span>      <span class="keywordflow">return</span> would_block_ret_val;</div>
<div class="line"><a id="l04069" name="l04069"></a><span class="lineno"> 4069</span>    }</div>
<div class="line"><a id="l04070" name="l04070"></a><span class="lineno"> 4070</span>    <span class="comment">// else sync_wait() has returned success.</span></div>
<div class="line"><a id="l04071" name="l04071"></a><span class="lineno"> 4071</span> </div>
<div class="line"><a id="l04072" name="l04072"></a><span class="lineno"> 4072</span>    <span class="comment">// Warning: &quot;this&quot; may be have been deleted by any point below this line, unless specifically guaranteed.</span></div>
<div class="line"><a id="l04073" name="l04073"></a><span class="lineno"> 4073</span> </div>
<div class="line"><a id="l04074" name="l04074"></a><span class="lineno"> 4074</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04075" name="l04075"></a><span class="lineno"> 4075</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> active = event_set-&gt;events_detected(err_code);</div>
<div class="line"><a id="l04076" name="l04076"></a><span class="lineno"> 4076</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04077" name="l04077"></a><span class="lineno"> 4077</span>    assert(active); <span class="comment">// Inactive but no error, so it must have been a timeout -- but that should&#39;ve been error.</span></div>
<div class="line"><a id="l04078" name="l04078"></a><span class="lineno"> 4078</span> </div>
<div class="line"><a id="l04079" name="l04079"></a><span class="lineno"> 4079</span>    <span class="comment">/* OK.  sync_wait() reports event is ready (sock is active, e.g., Writable).  Try to perform</span></div>
<div class="line"><a id="l04080" name="l04080"></a><span class="lineno"> 4080</span><span class="comment">     * non-blocking operation (e.g., Node::send()).  We must lock again (to access m_node again,</span></div>
<div class="line"><a id="l04081" name="l04081"></a><span class="lineno"> 4081</span><span class="comment">     * plus it&#39;s a pre-condition of the non-blocking operation (e.g., Node::send()).  In the</span></div>
<div class="line"><a id="l04082" name="l04082"></a><span class="lineno"> 4082</span><span class="comment">     * meantime sock may have gotten closed. Ensure that&#39;s not so (another pre-condition).</span></div>
<div class="line"><a id="l04083" name="l04083"></a><span class="lineno"> 4083</span><span class="comment">     *</span></div>
<div class="line"><a id="l04084" name="l04084"></a><span class="lineno"> 4084</span><span class="comment">     * Alternatively, in null_buffers mode, they want us to basically do a glorified sync_wait() for</span></div>
<div class="line"><a id="l04085" name="l04085"></a><span class="lineno"> 4085</span><span class="comment">     * one of the 3 events, depending on ev_type, and just return without performing any non_blocking_func();</span></div>
<div class="line"><a id="l04086" name="l04086"></a><span class="lineno"> 4086</span><span class="comment">     * in fact this mode is indicated by non_blocking_func.empty(). */</span></div>
<div class="line"><a id="l04087" name="l04087"></a><span class="lineno"> 4087</span> </div>
<div class="line"><a id="l04088" name="l04088"></a><span class="lineno"> 4088</span>    {</div>
<div class="line"><a id="l04089" name="l04089"></a><span class="lineno"> 4089</span>      <span class="keyword">typename</span> <a class="code hl_typedef" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">Socket::Lock_guard</a> lock(sock-&gt;m_mutex);</div>
<div class="line"><a id="l04090" name="l04090"></a><span class="lineno"> 4090</span>      <span class="keywordflow">if</span> (sock-&gt;m_state == Socket::State::S_CLOSED) <span class="comment">// As in the invoker of this method....</span></div>
<div class="line"><a id="l04091" name="l04091"></a><span class="lineno"> 4091</span>      {</div>
<div class="line"><a id="l04092" name="l04092"></a><span class="lineno"> 4092</span>        assert(sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l04093" name="l04093"></a><span class="lineno"> 4093</span>        *err_code = sock-&gt;m_disconnect_cause;</div>
<div class="line"><a id="l04094" name="l04094"></a><span class="lineno"> 4094</span>        <span class="comment">// Do NOT log.  &quot;this&quot; Node may have been deleted, so get_logger() may be undefined!</span></div>
<div class="line"><a id="l04095" name="l04095"></a><span class="lineno"> 4095</span> </div>
<div class="line"><a id="l04096" name="l04096"></a><span class="lineno"> 4096</span>        <span class="keywordflow">return</span> would_block_ret_val;</div>
<div class="line"><a id="l04097" name="l04097"></a><span class="lineno"> 4097</span>      }</div>
<div class="line"><a id="l04098" name="l04098"></a><span class="lineno"> 4098</span>      <span class="comment">// else do it.  Note that `this` is guaranteed to still exist if sock-&gt;m_state is not CLOSED.</span></div>
<div class="line"><a id="l04099" name="l04099"></a><span class="lineno"> 4099</span> </div>
<div class="line"><a id="l04100" name="l04100"></a><span class="lineno"> 4100</span>      <span class="keywordflow">if</span> (non_blocking_func.empty())</div>
<div class="line"><a id="l04101" name="l04101"></a><span class="lineno"> 4101</span>      {</div>
<div class="line"><a id="l04102" name="l04102"></a><span class="lineno"> 4102</span>        <a class="code hl_define" href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a>(<span class="stringliteral">&quot;Sync op of type [&quot;</span> &lt;&lt; ev_type &lt;&lt; <span class="stringliteral">&quot;] with Event_set [&quot;</span> &lt;&lt; event_set &lt;&lt; <span class="stringliteral">&quot;] in reactor pattern &quot;</span></div>
<div class="line"><a id="l04103" name="l04103"></a><span class="lineno"> 4103</span>                         <span class="stringliteral">&quot;mode on object [&quot;</span> &lt;&lt; sock &lt;&lt; <span class="stringliteral">&quot;] successful; returning without non-blocking op.&quot;</span>);</div>
<div class="line"><a id="l04104" name="l04104"></a><span class="lineno"> 4104</span>        assert(!*err_code); <span class="comment">// In reactor pattern mode: No error &lt;=&gt; yes, socket is in desired state now.</span></div>
<div class="line"><a id="l04105" name="l04105"></a><span class="lineno"> 4105</span>        <span class="keywordflow">return</span> would_block_ret_val;</div>
<div class="line"><a id="l04106" name="l04106"></a><span class="lineno"> 4106</span>      }</div>
<div class="line"><a id="l04107" name="l04107"></a><span class="lineno"> 4107</span> </div>
<div class="line"><a id="l04108" name="l04108"></a><span class="lineno"> 4108</span>      op_result = non_blocking_func(); <span class="comment">// send(), receive(), accept(), etc.</span></div>
<div class="line"><a id="l04109" name="l04109"></a><span class="lineno"> 4109</span>    } <span class="comment">// Lock.</span></div>
<div class="line"><a id="l04110" name="l04110"></a><span class="lineno"> 4110</span>    <span class="comment">// Cannot log below this line for aforementioned reasons.  Also cannot log in subsequent iterations!</span></div>
<div class="line"><a id="l04111" name="l04111"></a><span class="lineno"> 4111</span> </div>
<div class="line"><a id="l04112" name="l04112"></a><span class="lineno"> 4112</span>    <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04113" name="l04113"></a><span class="lineno"> 4113</span>    {</div>
<div class="line"><a id="l04114" name="l04114"></a><span class="lineno"> 4114</span>      <span class="comment">// *err_code is set.  Any number of errors possible here; error on socket =&gt; socket is active.</span></div>
<div class="line"><a id="l04115" name="l04115"></a><span class="lineno"> 4115</span>      <span class="keywordflow">return</span> would_block_ret_val;</div>
<div class="line"><a id="l04116" name="l04116"></a><span class="lineno"> 4116</span>    }</div>
<div class="line"><a id="l04117" name="l04117"></a><span class="lineno"> 4117</span>    <span class="comment">// else no error.</span></div>
<div class="line"><a id="l04118" name="l04118"></a><span class="lineno"> 4118</span> </div>
<div class="line"><a id="l04119" name="l04119"></a><span class="lineno"> 4119</span>    <span class="comment">/* If op_result &gt; 0, then data was transferred (enqueued to Send buffer, dequeued from Receive</span></div>
<div class="line"><a id="l04120" name="l04120"></a><span class="lineno"> 4120</span><span class="comment">     * buffer or Accept queue, etc.); cool.  If op_result == 0, sock is still not active.  How</span></div>
<div class="line"><a id="l04121" name="l04121"></a><span class="lineno"> 4121</span><span class="comment">     * is that possible if sync_wait() returned non-zero events?  Because some jerk in another</span></div>
<div class="line"><a id="l04122" name="l04122"></a><span class="lineno"> 4122</span><span class="comment">     * thread may also be non_blocking_func()ing at the same time.  In that case we must try again</span></div>
<div class="line"><a id="l04123" name="l04123"></a><span class="lineno"> 4123</span><span class="comment">     * (must not return would_block_ret_val and no error).  (And give less time, if timeout was</span></div>
<div class="line"><a id="l04124" name="l04124"></a><span class="lineno"> 4124</span><span class="comment">     * provided.) */</span></div>
<div class="line"><a id="l04125" name="l04125"></a><span class="lineno"> 4125</span> </div>
<div class="line"><a id="l04126" name="l04126"></a><span class="lineno"> 4126</span>    <span class="comment">// Do NOT log as explained.  @todo I don&#39;t like this.  See similar @todo above.</span></div>
<div class="line"><a id="l04127" name="l04127"></a><span class="lineno"> 4127</span>    <span class="comment">/* if (op_result == would_block_ret_val)</span></div>
<div class="line"><a id="l04128" name="l04128"></a><span class="lineno"> 4128</span><span class="comment">     * {</span></div>
<div class="line"><a id="l04129" name="l04129"></a><span class="lineno"> 4129</span><span class="comment">     *   // Rare/interesting enough for INFO.</span></div>
<div class="line"><a id="l04130" name="l04130"></a><span class="lineno"> 4130</span><span class="comment">     *   FLOW_LOG_INFO(&#39;[&#39; &lt;&lt; sock &lt;&lt; &quot;] got Active status &quot;</span></div>
<div class="line"><a id="l04131" name="l04131"></a><span class="lineno"> 4131</span><span class="comment">     *                &quot;but the non-blocking operation still returned would-block.  Another thread is interfering?&quot;);</span></div>
<div class="line"><a id="l04132" name="l04132"></a><span class="lineno"> 4132</span><span class="comment">     * } */</span></div>
<div class="line"><a id="l04133" name="l04133"></a><span class="lineno"> 4133</span>  }</div>
<div class="line"><a id="l04134" name="l04134"></a><span class="lineno"> 4134</span>  <span class="keywordflow">while</span> (op_result == would_block_ret_val);</div>
<div class="line"><a id="l04135" name="l04135"></a><span class="lineno"> 4135</span> </div>
<div class="line"><a id="l04136" name="l04136"></a><span class="lineno"> 4136</span>  <span class="comment">// Excellent.  At least some data was transferred (e.g., enqueued on Send buffer).  *err_code is success.</span></div>
<div class="line"><a id="l04137" name="l04137"></a><span class="lineno"> 4137</span>  <span class="keywordflow">return</span> op_result;</div>
<div class="line"><a id="l04138" name="l04138"></a><span class="lineno"> 4138</span>} <span class="comment">// Node::sync_op()</span></div>
<div class="line"><a id="l04139" name="l04139"></a><span class="lineno"> 4139</span> </div>
<div class="line"><a id="l04140" name="l04140"></a><span class="lineno"> 4140</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Socket_ptr&gt;</div>
<div class="line"><a id="l04141" name="l04141"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0"> 4141</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">Node::ensure_sock_open</a>(Socket_ptr sock, <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code) <span class="comment">// Static.</span></div>
<div class="line"><a id="l04142" name="l04142"></a><span class="lineno"> 4142</span>{</div>
<div class="line"><a id="l04143" name="l04143"></a><span class="lineno"> 4143</span>  <span class="comment">// Pre-condition: sock is suitably locked.  We are in thread U != W or W.</span></div>
<div class="line"><a id="l04144" name="l04144"></a><span class="lineno"> 4144</span> </div>
<div class="line"><a id="l04145" name="l04145"></a><span class="lineno"> 4145</span>  <span class="keywordflow">if</span> (sock-&gt;m_state == Socket_ptr::element_type::State::S_CLOSED)</div>
<div class="line"><a id="l04146" name="l04146"></a><span class="lineno"> 4146</span>  {</div>
<div class="line"><a id="l04147" name="l04147"></a><span class="lineno"> 4147</span>    <span class="comment">// CLOSED socket -- Node has disowned us.</span></div>
<div class="line"><a id="l04148" name="l04148"></a><span class="lineno"> 4148</span>    assert(!sock-&gt;m_node);</div>
<div class="line"><a id="l04149" name="l04149"></a><span class="lineno"> 4149</span>    assert(sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l04150" name="l04150"></a><span class="lineno"> 4150</span> </div>
<div class="line"><a id="l04151" name="l04151"></a><span class="lineno"> 4151</span>    <span class="comment">// Mark (already-determined) error in *err_code and log.</span></div>
<div class="line"><a id="l04152" name="l04152"></a><span class="lineno"> 4152</span>    <a class="code hl_define" href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95">FLOW_LOG_SET_CONTEXT</a>(sock-&gt;get_logger(), sock-&gt;get_log_component()); <span class="comment">// Static, so must do &lt;--that to log this--v.</span></div>
<div class="line"><a id="l04153" name="l04153"></a><span class="lineno"> 4153</span>    <a class="code hl_define" href="error_2error_8hpp.html#adc17094d4b9421abd04b90caab8b8e72">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a>(sock-&gt;m_disconnect_cause);</div>
<div class="line"><a id="l04154" name="l04154"></a><span class="lineno"> 4154</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04155" name="l04155"></a><span class="lineno"> 4155</span>  }</div>
<div class="line"><a id="l04156" name="l04156"></a><span class="lineno"> 4156</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04157" name="l04157"></a><span class="lineno"> 4157</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04158" name="l04158"></a><span class="lineno"> 4158</span>} <span class="comment">// Node::ensure_sock_open()</span></div>
<div class="line"><a id="l04159" name="l04159"></a><span class="lineno"> 4159</span> </div>
<div class="line"><a id="l04160" name="l04160"></a><span class="lineno"> 4160</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Opt_type&gt;</div>
<div class="line"><a id="l04161" name="l04161"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b"> 4161</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b">Node::validate_static_option</a>(<span class="keyword">const</span> Opt_type&amp; new_val, <span class="keyword">const</span> Opt_type&amp; old_val, <span class="keyword">const</span> std::string&amp; opt_id,</div>
<div class="line"><a id="l04162" name="l04162"></a><span class="lineno"> 4162</span>                                  <a class="code hl_typedef" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>* err_code)<span class="keyword"> const</span></div>
<div class="line"><a id="l04163" name="l04163"></a><span class="lineno"> 4163</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04164" name="l04164"></a><span class="lineno"> 4164</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l04165" name="l04165"></a><span class="lineno"> 4165</span> </div>
<div class="line"><a id="l04166" name="l04166"></a><span class="lineno"> 4166</span>  <span class="keywordflow">if</span> (new_val != old_val)</div>
<div class="line"><a id="l04167" name="l04167"></a><span class="lineno"> 4167</span>  {</div>
<div class="line"><a id="l04168" name="l04168"></a><span class="lineno"> 4168</span>    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; opt_id_nice = <a class="code hl_function" href="structflow_1_1net__flow_1_1Node__options.html#aacfe6175ac39447c107413853e578459">Node_options::opt_id_to_str</a>(opt_id);</div>
<div class="line"><a id="l04169" name="l04169"></a><span class="lineno"> 4169</span>    <a class="code hl_define" href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a>(<span class="stringliteral">&quot;Option [&quot;</span> &lt;&lt; opt_id_nice &lt;&lt; <span class="stringliteral">&quot;] is static, but attempted to change &quot;</span></div>
<div class="line"><a id="l04170" name="l04170"></a><span class="lineno"> 4170</span>                     <span class="stringliteral">&quot;from [&quot;</span> &lt;&lt; old_val &lt;&lt; <span class="stringliteral">&quot;] to [&quot;</span> &lt;&lt; new_val &lt;&lt; <span class="stringliteral">&quot;].  Ignoring entire option set.&quot;</span>);</div>
<div class="line"><a id="l04171" name="l04171"></a><span class="lineno"> 4171</span>    <a class="code hl_define" href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a>(<a class="code hl_enumvalue" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58">error::Code::S_STATIC_OPTION_CHANGED</a>);</div>
<div class="line"><a id="l04172" name="l04172"></a><span class="lineno"> 4172</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04173" name="l04173"></a><span class="lineno"> 4173</span>  }</div>
<div class="line"><a id="l04174" name="l04174"></a><span class="lineno"> 4174</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04175" name="l04175"></a><span class="lineno"> 4175</span> </div>
<div class="line"><a id="l04176" name="l04176"></a><span class="lineno"> 4176</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04177" name="l04177"></a><span class="lineno"> 4177</span>}</div>
<div class="line"><a id="l04178" name="l04178"></a><span class="lineno"> 4178</span> </div>
<div class="line"><a id="l04179" name="l04179"></a><span class="lineno"> 4179</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Opt_type&gt;</div>
<div class="line"><a id="l04180" name="l04180"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595"> 4180</a></span>Opt_type <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">Node::opt</a>(<span class="keyword">const</span> Opt_type&amp; opt_val_ref)<span class="keyword"> const</span></div>
<div class="line"><a id="l04181" name="l04181"></a><span class="lineno"> 4181</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04182" name="l04182"></a><span class="lineno"> 4182</span>  <span class="comment">/* They&#39;ve given the REFERENCE to the value they want to read.  Another thread may write to that</span></div>
<div class="line"><a id="l04183" name="l04183"></a><span class="lineno"> 4183</span><span class="comment">   * value concurrently.  Therefore, acquire ownership of the enclosing m_opts.  Copy the value.  Unlock.</span></div>
<div class="line"><a id="l04184" name="l04184"></a><span class="lineno"> 4184</span><span class="comment">   * Then return the copy.  Most options are small (typically primitive types, typically integers;</span></div>
<div class="line"><a id="l04185" name="l04185"></a><span class="lineno"> 4185</span><span class="comment">   * or boost.chrono time values which are internally also usually just integers), so the copy</span></div>
<div class="line"><a id="l04186" name="l04186"></a><span class="lineno"> 4186</span><span class="comment">   * should not be a big deal. */</span></div>
<div class="line"><a id="l04187" name="l04187"></a><span class="lineno"> 4187</span> </div>
<div class="line"><a id="l04188" name="l04188"></a><span class="lineno"> 4188</span>  <a class="code hl_typedef" href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">Options_lock</a> lock(<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4">m_opts_mutex</a>);</div>
<div class="line"><a id="l04189" name="l04189"></a><span class="lineno"> 4189</span>  <span class="keywordflow">return</span> opt_val_ref;</div>
<div class="line"><a id="l04190" name="l04190"></a><span class="lineno"> 4190</span>}</div>
<div class="line"><a id="l04191" name="l04191"></a><span class="lineno"> 4191</span> </div>
<div class="line"><a id="l04192" name="l04192"></a><span class="lineno"> 4192</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Peer_socket_impl_type&gt;</div>
<div class="line"><a id="l04193" name="l04193"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c"> 4193</a></span><a class="code hl_class" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">Node::sock_create_forward_plus_ctor_args</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&amp; opts)</div>
<div class="line"><a id="l04194" name="l04194"></a><span class="lineno"> 4194</span>{</div>
<div class="line"><a id="l04195" name="l04195"></a><span class="lineno"> 4195</span>  <span class="keywordflow">return</span> <span class="keyword">new</span> Peer_socket_impl_type(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), &amp;<a class="code hl_variable" href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">m_task_engine</a>, opts);</div>
<div class="line"><a id="l04196" name="l04196"></a><span class="lineno"> 4196</span>}</div>
<div class="line"><a id="l04197" name="l04197"></a><span class="lineno"> 4197</span> </div>
<div class="line"><a id="l04198" name="l04198"></a><span class="lineno"> 4198</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Server_socket_impl_type&gt;</div>
<div class="line"><a id="l04199" name="l04199"></a><span class="lineno"><a class="line" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a"> 4199</a></span><a class="code hl_class" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a>* <a class="code hl_function" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">Node::serv_create_forward_plus_ctor_args</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>* child_sock_opts)</div>
<div class="line"><a id="l04200" name="l04200"></a><span class="lineno"> 4200</span>{</div>
<div class="line"><a id="l04201" name="l04201"></a><span class="lineno"> 4201</span>  <span class="keywordflow">return</span> <span class="keyword">new</span> Server_socket_impl_type(<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), child_sock_opts);</div>
<div class="line"><a id="l04202" name="l04202"></a><span class="lineno"> 4202</span>}</div>
<div class="line"><a id="l04203" name="l04203"></a><span class="lineno"> 4203</span> </div>
<div class="line"><a id="l04204" name="l04204"></a><span class="lineno"> 4204</span>} <span class="comment">// namespace flow::net_flow</span></div>
<div class="ttc" id="aclassflow_1_1Function_html"><div class="ttname"><a href="classflow_1_1Function.html">flow::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00506">common.hpp:506</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></div><div class="ttdoc">Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l01627">log.hpp:1628</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_af4db395042b065b00398cd59845dcb4d"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">flow::log::Log_context::get_logger</a></div><div class="ttdeci">Logger * get_logger() const</div><div class="ttdoc">Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> <a href="log_8cpp_source.html#l00223">log.cpp:223</a></div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Logger_html"><div class="ttname"><a href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a></div><div class="ttdoc">Interface that the user should implement, passing the implementing Logger into logging classes (Flow'...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l01296">log.hpp:1300</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html">flow::net_flow::Event_set</a></div><div class="ttdoc">A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8hpp_source.html#l00247">event_set.hpp:254</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Event__set_html_a19cc3a286c8a11c986d2a59ec1e39a71"><div class="ttname"><a href="classflow_1_1net__flow_1_1Event__set.html#a19cc3a286c8a11c986d2a59ec1e39a71">flow::net_flow::Event_set::Event_type</a></div><div class="ttdeci">Event_type</div><div class="ttdoc">Type of event or condition of interest supported by class Event_set.</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8hpp_source.html#l00306">event_set.hpp:307</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Net__env__simulator_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Net__env__simulator.html">flow::net_flow::Net_env_simulator</a></div><div class="ttdoc">Objects of this class can be fed to Node to make it internally simulate network conditions like loss,...</div><div class="ttdef"><b>Definition:</b> <a href="net__env__simulator_8hpp_source.html#l00067">net_env_simulator.hpp:70</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html">flow::net_flow::Node</a></div><div class="ttdoc">An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00933">node.hpp:937</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a00124a034c8fdac6f300900bdfcc8cfe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a00124a034c8fdac6f300900bdfcc8cfe">flow::net_flow::Node::snd_flying_pkts_updated</a></div><div class="ttdeci">void snd_flying_pkts_updated(Peer_socket::Ptr sock, Peer_socket::Sent_pkt_ordered_by_when_const_iter pkt_begin, const Peer_socket::Sent_pkt_ordered_by_when_const_iter &amp;pkt_end, bool added)</div><div class="ttdoc">Updates Peer_socket::m_snd_flying_bytes according to an operation (add packets, remove packets) calle...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03890">peer_socket.cpp:3890</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0055a25892990585561e69ceb02214d5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0055a25892990585561e69ceb02214d5">flow::net_flow::Node::low_lvl_packet_sent</a></div><div class="ttdeci">void low_lvl_packet_sent(Peer_socket::Ptr sock, Low_lvl_packet::Const_ptr packet, size_t bytes_expected_transferred, const Error_code &amp;sys_err_code, size_t bytes_transferred)</div><div class="ttdoc">Completion handler for async_low_lvl_packet_send_impl(); called when the packet is either successfull...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00497">low_lvl_io.cpp:497</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0379c897bdb3e4eddeb759547be78261"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0379c897bdb3e4eddeb759547be78261">flow::net_flow::Node::serv_peer_socket_init</a></div><div class="ttdeci">void serv_peer_socket_init(Server_socket::Ptr serv, Peer_socket::Ptr sock)</div><div class="ttdoc">Records a new (just received SYN) peer socket from the given server socket.</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00850">server_socket.cpp:850</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a055ee380cf87f83c06d7380821c4679e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a055ee380cf87f83c06d7380821c4679e">flow::net_flow::Node::categorize_individual_ack</a></div><div class="ttdeci">bool categorize_individual_ack(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, Ack_packet::Individual_ack::Const_ptr ack, bool *dupe_or_late, Peer_socket::Sent_pkt_ordered_by_when_iter *acked_pkt_it)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that categorizes the given accumulated individual ackno...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02551">peer_socket.cpp:2551</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a06e4cea2eefa1b06975864f09740c96b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a06e4cea2eefa1b06975864f09740c96b">flow::net_flow::Node::handle_data_to_established</a></div><div class="ttdeci">void handle_data_to_established(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet, bool syn_rcvd_qd_packet)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00560">peer_socket.cpp:560</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0756fc7301d0cfa66f19e681a9c60c06"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0756fc7301d0cfa66f19e681a9c60c06">flow::net_flow::Node::sock_is_writable</a></div><div class="ttdeci">bool sock_is_writable(const boost::any &amp;sock_as_any) const</div><div class="ttdoc">Returns true if and only if calling sock-&gt;send() with at least some arguments would return either non...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04719">peer_socket.cpp:4719</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a07ad769737db60dd637365010b80f4f3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a07ad769737db60dd637365010b80f4f3">flow::net_flow::Node::sock_info</a></div><div class="ttdeci">Peer_socket_info sock_info(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Implementation of sock-&gt;info() for socket sock in all cases except when sock-&gt;state() == Peer_socket:...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06344">peer_socket.cpp:6344</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a08a5752bf3848f31abbe753be47c1fcf"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a08a5752bf3848f31abbe753be47c1fcf">flow::net_flow::Node::async_no_sock_low_lvl_packet_send</a></div><div class="ttdeci">void async_no_sock_low_lvl_packet_send(const util::Udp_endpoint &amp;low_lvl_remote_endpoint, Low_lvl_packet::Const_ptr packet)</div><div class="ttdoc">async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00313">low_lvl_io.cpp:313</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a08cf95363b26c0c676979437e34db357"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a08cf95363b26c0c676979437e34db357">flow::net_flow::Node::receive_wnd_updated</a></div><div class="ttdeci">void receive_wnd_updated(Peer_socket::Ptr sock)</div><div class="ttdoc">Placed by receive() onto W if it has dequeued data from Receive buffer and given it to the user,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05269">peer_socket.cpp:5269</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0a91542fce634cf6a749c71f225b105a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0a91542fce634cf6a749c71f225b105a">flow::net_flow::Node::serv_create</a></div><div class="ttdeci">virtual Server_socket * serv_create(const Peer_socket_options *child_sock_opts)</div><div class="ttdoc">Internal factory used for ALL Server_socket objects created by this Node (including subclasses).</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00873">server_socket.cpp:873</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0bac29a091e1026e5b4f0b5d84a710c7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0bac29a091e1026e5b4f0b5d84a710c7">flow::net_flow::Node::serv_set_state</a></div><div class="ttdeci">void serv_set_state(Server_socket::Ptr serv, Server_socket::State state)</div><div class="ttdoc">Sets Server_socket::m_state.</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00414">server_socket.cpp:414</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0db2bb587e0407077b11368df075f0ff"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0db2bb587e0407077b11368df075f0ff">flow::net_flow::Node::async_sock_low_lvl_packet_send</a></div><div class="ttdeci">void async_sock_low_lvl_packet_send(Peer_socket::Ptr sock, Low_lvl_packet::Const_ptr &amp;&amp;packet, bool delayed_by_pacing)</div><div class="ttdoc">async_low_lvl_packet_send_impl() wrapper to call when packet is to be sent to the remote side of the ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00307">low_lvl_io.cpp:307</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0ea53f6b451895e8efcdc68ba8770a43"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0ea53f6b451895e8efcdc68ba8770a43">flow::net_flow::Node::sock_track_new_data_after_gap_rexmit_off</a></div><div class="ttdeci">void sock_track_new_data_after_gap_rexmit_off(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Data_packet &gt; packet, size_t data_size, bool *slide, size_t *slide_size)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01244">peer_socket.cpp:1244</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0f9f88761fc18c4f9e0d5f4dd6b4bc95"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0f9f88761fc18c4f9e0d5f4dd6b4bc95">flow::net_flow::Node::sock_data_to_reassembly_q_unless_overflow</a></div><div class="ttdeci">bool sock_data_to_reassembly_q_unless_overflow(Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register the given DATA packet as an out-of-orde...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01320">peer_socket.cpp:1320</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a0fba26db0055a969f3869014bc5c2bfc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a0fba26db0055a969f3869014bc5c2bfc">flow::net_flow::Node::perform_accumulated_on_recv_tasks</a></div><div class="ttdeci">void perform_accumulated_on_recv_tasks()</div><div class="ttdoc">Performs all tasks to be performed at the end of low_lvl_recv_and_handle() or async part of async_wai...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00375">node.cpp:375</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a109a118ca312e94686595ea08dac7ad0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a109a118ca312e94686595ea08dac7ad0">flow::net_flow::Node::ensure_sock_open</a></div><div class="ttdeci">static bool ensure_sock_open(Socket_ptr sock, Error_code *err_code)</div><div class="ttdoc">Helper method that checks whether the given Peer_socket or Server_socket is CLOSED; if so,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04141">node.hpp:4141</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a10a92f11a2c9f218cdd9a55f282e79b1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a10a92f11a2c9f218cdd9a55f282e79b1">flow::net_flow::Node::send_worker</a></div><div class="ttdeci">void send_worker(Peer_socket::Ptr sock, bool defer_delta_check)</div><div class="ttdoc">Thread W implemention of send(): synchronously or asynchronously send the contents of sock-&gt;m_snd_buf...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04798">peer_socket.cpp:4798</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1124027c715d674f113f2d961e4c6861"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">flow::net_flow::Node::interrupt_all_waits</a></div><div class="ttdeci">void interrupt_all_waits(Error_code *err_code=0)</div><div class="ttdoc">Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01392">event_set.cpp:1392</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a136d9ccd25634cee2955ea79ae829006"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a136d9ccd25634cee2955ea79ae829006">flow::net_flow::Node::handle_accumulated_acks</a></div><div class="ttdeci">void handle_accumulated_acks(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that handles any incoming acknowledgments and rcv_wnd u...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02061">peer_socket.cpp:2061</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a159b9c2b9a8a969f5e3715341c433aec"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">flow::net_flow::Node::options</a></div><div class="ttdeci">Node_options options() const</div><div class="ttdoc">Copies this Node's option set and returns that copy.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01107">node.cpp:1107</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1699dfdaf3e5ebe1b1d715a9c306d116"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1699dfdaf3e5ebe1b1d715a9c306d116">flow::net_flow::Node::handle_incoming</a></div><div class="ttdeci">void handle_incoming(util::Blob *packet_data, const util::Udp_endpoint &amp;low_lvl_remote_endpoint)</div><div class="ttdoc">Handles a just-received, not-yet-deserialized low-level packet.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00426">node.cpp:426</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a16c53c4848ea976b075a0b56f33eb118"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">flow::net_flow::Node::~Node</a></div><div class="ttdeci">~Node() override</div><div class="ttdoc">Destroys Node.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00139">node.cpp:139</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a192d4b95b9f8a5c3d08b1e5486eb6f78"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a192d4b95b9f8a5c3d08b1e5486eb6f78">flow::net_flow::Node::async_rcv_wnd_recovery</a></div><div class="ttdeci">void async_rcv_wnd_recovery(Peer_socket::Ptr sock, size_t rcv_wnd)</div><div class="ttdoc">receive_wnd_updated() helper that continues rcv_wnd recovery: that is, sends unsolicited ACK with a r...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05403">peer_socket.cpp:5403</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1bfde94f7d529ea8e6c26b560abfa9c7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1bfde94f7d529ea8e6c26b560abfa9c7">flow::net_flow::Node::log_accumulated_acks</a></div><div class="ttdeci">void log_accumulated_acks(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Helper of handle_accumulated_acks() that logs the about-to-be-handled accumulated individual acknowle...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03272">peer_socket.cpp:3272</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1c2fe94f0b1064d35ce99c58bc95dc0f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1c2fe94f0b1064d35ce99c58bc95dc0f">flow::net_flow::Node::Signal_set</a></div><div class="ttdeci">boost::asio::signal_set Signal_set</div><div class="ttdoc">Short-hand for a signal set.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01433">node.hpp:1433</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1d5f13062bec6730db533cc1e89bf515"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1d5f13062bec6730db533cc1e89bf515">flow::net_flow::Node::sock_free_memory</a></div><div class="ttdeci">void sock_free_memory(Peer_socket::Ptr sock)</div><div class="ttdoc">Helper that clears all non-O(1)-space data structures stored inside sock.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06174">peer_socket.cpp:6174</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a1ecd7c03349fcb26b9692d300a759463"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a1ecd7c03349fcb26b9692d300a759463">flow::net_flow::Node::S_NUM_PORTS</a></div><div class="ttdeci">static const size_t &amp; S_NUM_PORTS</div><div class="ttdoc">Total number of Flow ports in the port space, including S_PORT_ANY.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00942">node.hpp:942</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2195fb7d86acfaf340b3e7e59e7e10e8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2195fb7d86acfaf340b3e7e59e7e10e8">flow::net_flow::Node::event_set_check_baseline</a></div><div class="ttdeci">bool event_set_check_baseline(Event_set::Ptr event_set)</div><div class="ttdoc">Checks each desired (Event_set::m_want) event in event_set; any that holds true is saved into event_s...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01017">event_set.cpp:1017</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2336fae98b318ab73e7268e9a242bf09"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2336fae98b318ab73e7268e9a242bf09">flow::net_flow::Node::sock_load_info_struct</a></div><div class="ttdeci">void sock_load_info_struct(Peer_socket::Const_ptr sock, Peer_socket_info *stats) const</div><div class="ttdoc">Given a Peer_socket, copies all stats info (as available via Peer_socket::info()) from various struct...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06388">peer_socket.cpp:6388</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a24785d3e04e0a9cd5daca43bc867e5aa"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a24785d3e04e0a9cd5daca43bc867e5aa">flow::net_flow::Node::log_snd_window</a></div><div class="ttdeci">void log_snd_window(Peer_socket::Const_ptr sock, bool force_verbose_info_logging=false) const</div><div class="ttdoc">Logs TRACE or DATA messages thats show the detailed state of the sending sequence number space.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03641">peer_socket.cpp:3641</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2565b7c0bd82cad86eb168b62f8ffd9d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2565b7c0bd82cad86eb168b62f8ffd9d">flow::net_flow::Node::send_worker_check_state</a></div><div class="ttdeci">void send_worker_check_state(Peer_socket::Ptr sock)</div><div class="ttdoc">Helper placed by send() onto W to invoke send_worker() but ensures that the socket has not entered so...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04753">peer_socket.cpp:4753</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a266ec5d00a44bc48caf37444eb2b43a1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a266ec5d00a44bc48caf37444eb2b43a1">flow::net_flow::Node::m_low_lvl_max_buf_size</a></div><div class="ttdeci">size_t m_low_lvl_max_buf_size</div><div class="ttdoc">OS-reported m_low_lvl_sock UDP receive buffer maximum size, obtained right after we OS-set that setti...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03771">node.hpp:3771</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2779cc2429651696df1bca8de73534f3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">flow::net_flow::Node::set_options</a></div><div class="ttdeci">bool set_options(const Node_options &amp;opts, Error_code *err_code=0)</div><div class="ttdoc">Dynamically replaces the current options set (options()) with the given options set.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01054">node.cpp:1054</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a287eae1113865dba06c103cf023404ae"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a287eae1113865dba06c103cf023404ae">flow::net_flow::Node::sync_sock_low_lvl_rst_send</a></div><div class="ttdeci">void sync_sock_low_lvl_rst_send(Peer_socket::Ptr sock)</div><div class="ttdoc">Sends an RST to the other side of the given socket, synchronously.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l01045">low_lvl_io.cpp:1045</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2983d0d8a4d4eb5c3402f63f68ef44d8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2983d0d8a4d4eb5c3402f63f68ef44d8">flow::net_flow::Node::mark_data_packet_sent</a></div><div class="ttdeci">void mark_data_packet_sent(Peer_socket::Ptr sock, const Sequence_number &amp;seq_num)</div><div class="ttdoc">Performs important book-keeping based on the event &quot;DATA packet was sent to destination....</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00422">low_lvl_io.cpp:422</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a29d02f9e302c7b06288ff1c644fa8d65"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a29d02f9e302c7b06288ff1c644fa8d65">flow::net_flow::Node::handle_syn_ack_ack_to_syn_rcvd</a></div><div class="ttdeci">void handle_syn_ack_ack_to_syn_rcvd(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, boost::shared_ptr&lt; const Syn_ack_ack_packet &gt; syn_ack_ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed low-level SYN_ACK_ACK packet delivered to the given p...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00583">server_socket.cpp:583</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2a4dc3d8e294bbc8423e111f52e414ae"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2a4dc3d8e294bbc8423e111f52e414ae">flow::net_flow::Node::sync_op</a></div><div class="ttdeci">Non_blocking_func_ret_type sync_op(typename Socket::Ptr sock, const Function&lt; Non_blocking_func_ret_type()&gt; &amp;non_blocking_func, Non_blocking_func_ret_type would_block_ret_val, Event_set::Event_type ev_type, const Fine_time_pt &amp;wait_until, Error_code *err_code)</div><div class="ttdoc">Implementation of core blocking transfer methods, namely Peer_socket::sync_send(),...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03977">node.hpp:3977</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2af9ec4f1483cd9a2183286f7dfa9c87"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2af9ec4f1483cd9a2183286f7dfa9c87">flow::net_flow::Node::serv_close_detected</a></div><div class="ttdeci">void serv_close_detected(Server_socket::Ptr serv, const Error_code &amp;disconnect_cause, bool close)</div><div class="ttdoc">Records that thread W shows this socket is not to listen to incoming connections and is to abort any ...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00766">server_socket.cpp:766</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a2f97b363281b79ef4f399789442c84de"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a2f97b363281b79ef4f399789442c84de">flow::net_flow::Node::S_REGULAR_INFREQUENT_TASKS_PERIOD</a></div><div class="ttdeci">static const Fine_duration S_REGULAR_INFREQUENT_TASKS_PERIOD</div><div class="ttdoc">Time interval between performing &quot;infrequent periodic tasks,&quot; such as stat logging.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03693">node.hpp:3693</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a31d9838b735786bfed40fc1c437808d7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a31d9838b735786bfed40fc1c437808d7">flow::net_flow::Node::sock_max_packets_after_unrecvd_packet</a></div><div class="ttdeci">size_t sock_max_packets_after_unrecvd_packet(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Computes and returns the max size for Peer_socket::m_rcv_packets_with_gaps for sock.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01556">peer_socket.cpp:1556</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a31edf238c1b21a409ea807c66c1b22f0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a31edf238c1b21a409ea807c66c1b22f0">flow::net_flow::Node::async_sock_low_lvl_packet_send_paced</a></div><div class="ttdeci">bool async_sock_low_lvl_packet_send_paced(const Peer_socket::Ptr &amp;sock, Low_lvl_packet::Ptr &amp;&amp;packet, Error_code *err_code)</div><div class="ttdoc">Begins the process of asynchronously sending the given low-level packet to the remote Node specified ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00605">low_lvl_io.cpp:605</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3326b5bdc85b43232f55e2b2ec1dbe60"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3326b5bdc85b43232f55e2b2ec1dbe60">flow::net_flow::Node::categorize_pkts_as_dropped_on_acks</a></div><div class="ttdeci">Peer_socket::Sent_pkt_ordered_by_when_iter categorize_pkts_as_dropped_on_acks(Peer_socket::Ptr sock, const boost::unordered_set&lt; Peer_socket::order_num_t &gt; &amp;flying_now_acked_pkts)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that determines the range of In-flight packets that sho...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02942">peer_socket.cpp:2942</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3574d50742fa0b1230c049f4b29fd3dc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3574d50742fa0b1230c049f4b29fd3dc">flow::net_flow::Node::rcv_get_first_gap_info</a></div><div class="ttdeci">void rcv_get_first_gap_info(Peer_socket::Const_ptr sock, bool *first_gap_exists, Sequence_number *seq_num_after_first_gap)</div><div class="ttdoc">Helper for handle_data_to_established() that gets simple info about Peer_socket::m_rcv_packets_with_g...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01569">peer_socket.cpp:1569</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a382b607fa2e482886f2fd75edc36b8b7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a382b607fa2e482886f2fd75edc36b8b7">flow::net_flow::Node::snd_deqable</a></div><div class="ttdeci">bool snd_deqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there are enough data either in Peer_socket::m_snd_rexmit_q of sock (if re...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06080">peer_socket.cpp:6080</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3b5004700cb085c6a2806f39426b0ea0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3b5004700cb085c6a2806f39426b0ea0">flow::net_flow::Node::m_last_loss_sock_log_when</a></div><div class="ttdeci">Fine_time_pt m_last_loss_sock_log_when</div><div class="ttdoc">For debugging, when we detect loss of data we'd sent, we log the corresponding socket's state; this i...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03874">node.hpp:3874</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3c2cd6a6c328a2d5381308258d35d95d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">flow::net_flow::Node::listen</a></div><div class="ttdeci">Server_socket::Ptr listen(flow_port_t local_port, Error_code *err_code=0, const Peer_socket_options *child_sock_opts=0)</div><div class="ttdoc">Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00144">server_socket.cpp:144</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3f9cf4d7160b3e27b3b0131fc4507ce7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3f9cf4d7160b3e27b3b0131fc4507ce7">flow::net_flow::Node::cancel_timers</a></div><div class="ttdeci">void cancel_timers(Peer_socket::Ptr sock)</div><div class="ttdoc">Cancel any timers and scheduled tasks active in the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04453">peer_socket.cpp:4453</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a3fd57a0d025a78cbeccfd8a15a983575"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a3fd57a0d025a78cbeccfd8a15a983575">flow::net_flow::Node::sock_pacing_time_slice_end</a></div><div class="ttdeci">void sock_pacing_time_slice_end(Peer_socket::Ptr sock, const Error_code &amp;sys_err_code)</div><div class="ttdoc">async_sock_low_lvl_packet_send_paced() pacing helper: If sock_pacing_process_q() ran out of the last ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00969">low_lvl_io.cpp:969</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a40595ee69bfb87fd64005bc8443329dc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a40595ee69bfb87fd64005bc8443329dc">flow::net_flow::Node::sock_rcv_buf_now_readable</a></div><div class="ttdeci">void sock_rcv_buf_now_readable(Peer_socket::Ptr sock, bool syn_rcvd_qd_packet)</div><div class="ttdoc">Helper for handle_data_to_established() that assumes the given's socket Receive buffer is currently r...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01210">peer_socket.cpp:1210</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a43472c3277cdf5e3f28d4f4f51e3bcc0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a43472c3277cdf5e3f28d4f4f51e3bcc0">flow::net_flow::Node::m_net_env_sim</a></div><div class="ttdeci">boost::shared_ptr&lt; Net_env_simulator &gt; m_net_env_sim</div><div class="ttdoc">The object used to simulate stuff like packet loss and latency via local means directly in the code.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03713">node.hpp:3713</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4368247d07e930bdd07ab8d2425c6de8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4368247d07e930bdd07ab8d2425c6de8">flow::net_flow::Node::async_wait_latency_then_handle_incoming</a></div><div class="ttdeci">void async_wait_latency_then_handle_incoming(const Fine_duration &amp;latency, util::Blob *packet_data, const util::Udp_endpoint &amp;low_lvl_remote_endpoint)</div><div class="ttdoc">Sets up handle_incoming(packet_data, low_lvl_remote_endpoint) to be called asynchronously after a spe...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00255">low_lvl_io.cpp:255</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a43af576c6156f5d69682e664d9ff3922"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a43af576c6156f5d69682e664d9ff3922">flow::net_flow::Node::snd_flying_pkts_erase_one</a></div><div class="ttdeci">void snd_flying_pkts_erase_one(Peer_socket::Ptr sock, Peer_socket::Sent_pkt_ordered_by_when_iter pkt_it)</div><div class="ttdoc">Erases (for example if considered Acknowledged or Dropped) a packet struct from the &quot;scoreboard&quot; (Pee...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03787">peer_socket.cpp:3787</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a43c42121d48a55a43a48e3a84bd10595"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a43c42121d48a55a43a48e3a84bd10595">flow::net_flow::Node::opt</a></div><div class="ttdeci">Opt_type opt(const Opt_type &amp;opt_val_ref) const</div><div class="ttdoc">Obtain a copy of the value of a given option in a thread-safe manner.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04180">node.hpp:4180</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a446ee7115c70cbcd48e3897d32fc0276"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a446ee7115c70cbcd48e3897d32fc0276">flow::net_flow::Node::sock_validate_options</a></div><div class="ttdeci">bool sock_validate_options(const Peer_socket_options &amp;opts, const Peer_socket_options *prev_opts, Error_code *err_code) const</div><div class="ttdoc">Analogous to validate_options() but checks per-socket options instead of per-Node options.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06245">peer_socket.cpp:6245</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a449ef757abee4c5d12f8fc62a5ca66b4"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a449ef757abee4c5d12f8fc62a5ca66b4">flow::net_flow::Node::m_opts_mutex</a></div><div class="ttdeci">Options_mutex m_opts_mutex</div><div class="ttdoc">The mutex protecting m_opts.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03707">node.hpp:3707</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a44af106f110963a465065a7ea19185a3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a44af106f110963a465065a7ea19185a3">flow::net_flow::Node::Timer_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; util::Timer &gt; Timer_ptr</div><div class="ttdoc">boost.asio timer wrapped in a ref-counted pointer.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01430">node.hpp:1430</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a44ee0d42d38f3b98d032dee1549f8c4c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a44ee0d42d38f3b98d032dee1549f8c4c">flow::net_flow::Node::event_set_close</a></div><div class="ttdeci">void event_set_close(Event_set::Ptr event_set, Error_code *err_code)</div><div class="ttdoc">Implementation of Event_set::close() when Event_set::state() != Event_set::State::S_CLOSED for event_...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01273">event_set.cpp:1273</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a45583714bc147300158f074ecacce0fd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a45583714bc147300158f074ecacce0fd">flow::net_flow::Node::handle_accumulated_pending_acks</a></div><div class="ttdeci">void handle_accumulated_pending_acks(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that handles any additional individual outgoing acknowl...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01638">peer_socket.cpp:1638</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a45b05340098b0eb66f88a6a7e5f3d36f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a45b05340098b0eb66f88a6a7e5f3d36f">flow::net_flow::Node::receive_wnd_recovery_data_received</a></div><div class="ttdeci">void receive_wnd_recovery_data_received(Peer_socket::Ptr sock)</div><div class="ttdoc">Pertaining to the async_rcv_wnd_recovery() mechanism, this handles the event that we have received an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05491">peer_socket.cpp:5491</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a479dfcb7944cb6571af51f1feed2656d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a479dfcb7944cb6571af51f1feed2656d">flow::net_flow::Node::sock_get_new_snd_order_num</a></div><div class="ttdeci">static Peer_socket::order_num_t sock_get_new_snd_order_num(Peer_socket::Ptr sock)</div><div class="ttdoc">Returns the &quot;order number&quot; to use for Peer_socket::Sent_packet::Sent_when structure corresponding to ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06500">peer_socket.cpp:6500</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4903f254cff9d2605ace404174203138"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4903f254cff9d2605ace404174203138">flow::net_flow::Node::Options_mutex</a></div><div class="ttdeci">Peer_socket::Options_mutex Options_mutex</div><div class="ttdoc">Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01436">node.hpp:1436</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a49e2786f5d1eeb068a828902a631a39a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a49e2786f5d1eeb068a828902a631a39a">flow::net_flow::Node::sync_connect_impl</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect_impl(const Remote_endpoint &amp;to, const Fine_duration &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code, const Peer_socket_options *opts)</div><div class="ttdoc">Implementation core of sync_connect*() that gets rid of templated or missing arguments thereof.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04212">peer_socket.cpp:4212</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4a21e69d3ae442b2cc06220514de364a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4a21e69d3ae442b2cc06220514de364a">flow::net_flow::Node::event_set_check_baseline_assuming_state</a></div><div class="ttdeci">void event_set_check_baseline_assuming_state(Event_set::Ptr event_set)</div><div class="ttdoc">Helper placed by event_set_async_wait() onto thread W to invoke event_set_check_baseline() but first ...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l00989">event_set.cpp:989</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4bd7b471dd6cd3e3570930b48d30e577"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">flow::net_flow::Node::max_block_size</a></div><div class="ttdeci">size_t max_block_size() const</div><div class="ttdoc">The maximum number of bytes of user data per received or sent block on connections generated from thi...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01112">node.cpp:1112</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4cb3dcb90f1dfc44a4343c0e89ce6b83"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">flow::net_flow::Node::local_low_lvl_endpoint</a></div><div class="ttdeci">const util::Udp_endpoint &amp; local_low_lvl_endpoint() const</div><div class="ttdoc">Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sendi...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00369">node.cpp:369</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a4f175a1923aeef5eee39bd726e88c93a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a4f175a1923aeef5eee39bd726e88c93a">flow::net_flow::Node::Udp_socket</a></div><div class="ttdeci">boost::asio::ip::udp::socket Udp_socket</div><div class="ttdoc">Short-hand for UDP socket.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01427">node.hpp:1427</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a51b26bff4cdf545f22d8edec7185c5c4"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a51b26bff4cdf545f22d8edec7185c5c4">flow::net_flow::Node::serv_is_acceptable</a></div><div class="ttdeci">bool serv_is_acceptable(const boost::any &amp;serv_as_any) const</div><div class="ttdoc">Returns true if and only if calling serv-&gt;accept() with at least some arguments would return either n...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00342">server_socket.cpp:342</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a52a3e10ef08b93daf87ea5f0f1e87062"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a52a3e10ef08b93daf87ea5f0f1e87062">flow::net_flow::Node::snd_flying_pkts_push_one</a></div><div class="ttdeci">void snd_flying_pkts_push_one(Peer_socket::Ptr sock, const Sequence_number &amp;seq_num, Peer_socket::Sent_packet::Ptr sent_pkt)</div><div class="ttdoc">Adds a new packet struct (presumably representing packet to be sent shortly) to the &quot;scoreboard&quot; (Pee...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03824">peer_socket.cpp:3824</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a5b056ed753b832458f44f537acfe86d7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a5b056ed753b832458f44f537acfe86d7">flow::net_flow::Node::worker_run</a></div><div class="ttdeci">void worker_run(const util::Udp_endpoint low_lvl_endpoint)</div><div class="ttdoc">Worker thread W (main event loop) body.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00151">node.cpp:151</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a5bca5c11ac5a4763fed6ce146fe733e7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a5bca5c11ac5a4763fed6ce146fe733e7">flow::net_flow::Node::create_syn</a></div><div class="ttdeci">Syn_packet::Ptr create_syn(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Helper that creates a new SYN packet object to the extent that is suitable for immediately passing to...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05817">peer_socket.cpp:5817</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a61f87144f19e908ffb981f3bff91938e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a61f87144f19e908ffb981f3bff91938e">flow::net_flow::Node::m_event_loop_ready_result</a></div><div class="ttdeci">boost::unique_future&lt; Error_code &gt; m_event_loop_ready_result</div><div class="ttdoc">The future object through which the non-W thread waits for m_event_loop_ready to be set to success/fa...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03883">node.hpp:3883</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a62e1f8e6da36d7cd3ad905924aea376c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a62e1f8e6da36d7cd3ad905924aea376c">flow::net_flow::Node::sock_pacing_new_packet_ready</a></div><div class="ttdeci">bool sock_pacing_new_packet_ready(Peer_socket::Ptr sock, Low_lvl_packet::Ptr packet, Error_code *err_code)</div><div class="ttdoc">async_sock_low_lvl_packet_send_paced() pacing helper: Handles a DATA or ACK packet that was just pass...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00649">low_lvl_io.cpp:649</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6461124e5bc3e59083e172e26029e632"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6461124e5bc3e59083e172e26029e632">flow::net_flow::Node::close_abruptly</a></div><div class="ttdeci">void close_abruptly(Peer_socket::Ptr sock, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;close_abruptly() for socket sock in all cases except when sock-&gt;...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05621">peer_socket.cpp:5621</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a663f1fd8b524ffe63dfa6b7ca76b1a43"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a663f1fd8b524ffe63dfa6b7ca76b1a43">flow::net_flow::Node::get_seq_num_range</a></div><div class="ttdeci">static void get_seq_num_range(const Packet_map_iter &amp;packet_it, Sequence_number *seq_num_start, Sequence_number *seq_num_end)</div><div class="ttdoc">Given an iterator into a Peer_socket::Sent_pkt_by_sent_when_map or Peer_socket::Recv_pkt_map,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06485">peer_socket.cpp:6485</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6725d69ea1a6457d88abb63cef6e6bb2"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">flow::net_flow::Node::sync_connect_with_metadata</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect_with_metadata(const Remote_endpoint &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03956">node.hpp:3956</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6727ca42e15c8627c1ed3d94e6dd7a53"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6727ca42e15c8627c1ed3d94e6dd7a53">flow::net_flow::Node::event_set_close_worker</a></div><div class="ttdeci">void event_set_close_worker(Event_set::Ptr event_set)</div><div class="ttdoc">The guts of event_set_close_worker_check_state(): same thing, but assumes Event_set::state() == Event...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01332">event_set.cpp:1332</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6bcd840049c57150cdaa5c59d22c488b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6bcd840049c57150cdaa5c59d22c488b">flow::net_flow::Node::create_syn_ack</a></div><div class="ttdeci">Syn_ack_packet::Ptr create_syn_ack(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Like create_syn() but for SYN_ACK.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05832">peer_socket.cpp:5832</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a6daaa6a5a7d0b7e5a2266dd9db400c01"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a6daaa6a5a7d0b7e5a2266dd9db400c01">flow::net_flow::Node::sock_create</a></div><div class="ttdeci">virtual Peer_socket * sock_create(const Peer_socket_options &amp;opts)</div><div class="ttdoc">Internal factory used for ALL Peer_socket objects created by this Node (including subclasses).</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06506">peer_socket.cpp:6506</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a70d124ba678e2ab72f8c6d28140ca137"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a70d124ba678e2ab72f8c6d28140ca137">flow::net_flow::Node::snd_buf_enqable</a></div><div class="ttdeci">bool snd_buf_enqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there is enough free space in Peer_socket::m_snd_buf of sock to enqueue an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06086">peer_socket.cpp:6086</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7395ac534047f06629962ad19b3fa657"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7395ac534047f06629962ad19b3fa657">flow::net_flow::Node::can_send</a></div><div class="ttdeci">bool can_send(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Answers the perennial question of congestion and flow control: assuming there is a DATA packet to sen...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05045">peer_socket.cpp:5045</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a74a6a82a1390a76e985593969fb47184"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a74a6a82a1390a76e985593969fb47184">flow::net_flow::Node::async_no_sock_low_lvl_rst_send</a></div><div class="ttdeci">void async_no_sock_low_lvl_rst_send(Low_lvl_packet::Const_ptr causing_packet, const util::Udp_endpoint &amp;low_lvl_remote_endpoint)</div><div class="ttdoc">Sends an RST to the given UDP endpoint in response to the given incoming low-level packet that came f...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00586">low_lvl_io.cpp:586</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a74adc7d61419f4beb7941d418a31a648"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a74adc7d61419f4beb7941d418a31a648">flow::net_flow::Node::sock_slide_rcv_next_seq_num</a></div><div class="ttdeci">void sock_slide_rcv_next_seq_num(Peer_socket::Ptr sock, size_t slide_size, bool reassembly_in_progress)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to register a set of received DATA packet data as i...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01471">peer_socket.cpp:1471</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a755c329b9e0f2b8edb2e5b900bd2a337"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a755c329b9e0f2b8edb2e5b900bd2a337">flow::net_flow::Node::sock_log_detail</a></div><div class="ttdeci">void sock_log_detail(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Logs a verbose state report for the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06441">peer_socket.cpp:6441</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7a79b2d15dd3dd1ffe1cdb0fa8e8d36c">flow::net_flow::Node::Port_to_server_map</a></div><div class="ttdeci">boost::unordered_map&lt; flow_port_t, Server_socket::Ptr &gt; Port_to_server_map</div><div class="ttdoc">A map from the local Flow port to the local Server_socket listening on that port.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01453">node.hpp:1453</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7aadcad6c19587cd0d788570194b2afd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd">flow::net_flow::Node::S_NUM_EPHEMERAL_PORTS</a></div><div class="ttdeci">static const size_t &amp; S_NUM_EPHEMERAL_PORTS</div><div class="ttdoc">Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00951">node.hpp:951</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7bea132db0e45ea01b9a6bd22fd0fadb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7bea132db0e45ea01b9a6bd22fd0fadb">flow::net_flow::Node::m_socks_with_accumulated_pending_acks</a></div><div class="ttdeci">boost::unordered_set&lt; Peer_socket::Ptr &gt; m_socks_with_accumulated_pending_acks</div><div class="ttdoc">Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() (...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03849">node.hpp:3849</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7d9f418a3c99197e58f71ce2fff2997f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7d9f418a3c99197e58f71ce2fff2997f">flow::net_flow::Node::m_socks_with_accumulated_acks</a></div><div class="ttdeci">boost::unordered_set&lt; Peer_socket::Ptr &gt; m_socks_with_accumulated_acks</div><div class="ttdoc">Within a given low_lvl_recv_and_handle() or async part of async_wait_latency_then_handle_incoming() c...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03867">node.hpp:3867</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a7e9629b88c4cd0b337a51c2363893908"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a7e9629b88c4cd0b337a51c2363893908">flow::net_flow::Node::hash_value</a></div><div class="ttdeci">friend size_t hash_value(const Socket_id &amp;socket_id)</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01162">node.cpp:1162</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a80d58cfa8fad00a116a38f76ccb2b868"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a80d58cfa8fad00a116a38f76ccb2b868">flow::net_flow::Node::advance_seq_num</a></div><div class="ttdeci">static void advance_seq_num(Sequence_number *seq_num, boost::shared_ptr&lt; const Data_packet &gt; data)</div><div class="ttdoc">Assuming *seq_num points to the start of data.m_data, increments *seq_num to point to the datum just ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06462">peer_socket.cpp:6462</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a81e50276d0b162f6577adc690e0ef9e0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a81e50276d0b162f6577adc690e0ef9e0">flow::net_flow::Node::async_low_lvl_ack_send</a></div><div class="ttdeci">void async_low_lvl_ack_send(Peer_socket::Ptr sock, bool defer_delta_check, const Error_code &amp;sys_err_code=Error_code())</div><div class="ttdoc">Sends a low-level ACK packet, with all accumulated in Peer_socket::m_rcv_pending_acks of sock individ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05863">peer_socket.cpp:5863</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a837d37e6eb06fb6df4666bac327d20f8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a837d37e6eb06fb6df4666bac327d20f8">flow::net_flow::Node::snd_past_last_flying_datum_seq_num</a></div><div class="ttdeci">static Sequence_number snd_past_last_flying_datum_seq_num(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Obtain the sequence number for the datum just past the last (latest) In-flight (i....</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03766">peer_socket.cpp:3766</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a84b7e03ae7b13dae0f59db1475e46fd3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a84b7e03ae7b13dae0f59db1475e46fd3">flow::net_flow::Node::m_worker</a></div><div class="ttdeci">util::Thread m_worker</div><div class="ttdoc">Worker thread (= thread W). Other members should be initialized before this to avoid race condition.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03893">node.hpp:3893</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8938c4a091edf1c1c77e2cc8f505f0ff"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8938c4a091edf1c1c77e2cc8f505f0ff">flow::net_flow::Node::m_seq_num_generator</a></div><div class="ttdeci">Sequence_number::Generator m_seq_num_generator</div><div class="ttdoc">Sequence number generator (at least to generate ISNs). Only thread W can access this.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03780">node.hpp:3780</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a893c8393930110e2aa0823583e37cabd"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">flow::net_flow::Node::connect</a></div><div class="ttdeci">Peer_socket::Ptr connect(const Remote_endpoint &amp;to, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">Initiates an active connect to the specified remote Flow server.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03950">peer_socket.cpp:3950</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8a4ddf81ddbeab1f740940c4cc0d3625"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8a4ddf81ddbeab1f740940c4cc0d3625">flow::net_flow::Node::event_set_all_check_delta</a></div><div class="ttdeci">void event_set_all_check_delta(bool defer_delta_check)</div><div class="ttdoc">For each WAITING Event_set within the Node: checks for any events that hold, and if any do hold,...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01129">event_set.cpp:1129</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8a6c02bf520a16df4028bd3c88732a8d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8a6c02bf520a16df4028bd3c88732a8d">flow::net_flow::Node::serv_peer_socket_closed</a></div><div class="ttdeci">void serv_peer_socket_closed(Server_socket::Ptr serv, Peer_socket::Ptr sock)</div><div class="ttdoc">Records that a Server_socket-contained (i.e., currently un-established, or established but not yet ac...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00786">server_socket.cpp:786</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8aa99dc4800a49b7b958b585717eb50b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8aa99dc4800a49b7b958b585717eb50b">flow::net_flow::Node::validate_static_option</a></div><div class="ttdeci">bool validate_static_option(const Opt_type &amp;new_val, const Opt_type &amp;old_val, const std::string &amp;opt_id, Error_code *err_code) const</div><div class="ttdoc">Helper that compares new_val to old_val and, if they are not equal, logs and returns an error; used t...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04161">node.hpp:4161</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8cae2884eaf67d77c9f8cf56b31e4c4b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8cae2884eaf67d77c9f8cf56b31e4c4b">flow::net_flow::Node::rcv_buf_deqable</a></div><div class="ttdeci">bool rcv_buf_deqable(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Return true if and only if there are enough data in Peer_socket::m_rcv_buf of sock to give the user s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06103">peer_socket.cpp:6103</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a8ece1750c8f0bee297af113f8808b7a6"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a8ece1750c8f0bee297af113f8808b7a6">flow::net_flow::Node::async_acknowledge_packet</a></div><div class="ttdeci">void async_acknowledge_packet(Peer_socket::Ptr sock, const Sequence_number &amp;seq_num, unsigned int rexmit_id, size_t data_size)</div><div class="ttdoc">Causes an acknowledgment of the given received packet to be included in a future Ack_packet sent to t...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01581">peer_socket.cpp:1581</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a90244d69d550370158bbe843ab595a7a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a90244d69d550370158bbe843ab595a7a">flow::net_flow::Node::m_socks</a></div><div class="ttdeci">Socket_id_to_socket_map m_socks</div><div class="ttdoc">The peer-to-peer connections this Node is currently tracking.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03792">node.hpp:3792</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a90ecbad1ff3a8d2fe4b3ad1c474f7513"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a90ecbad1ff3a8d2fe4b3ad1c474f7513">flow::net_flow::Node::handle_incoming_with_simulation</a></div><div class="ttdeci">unsigned int handle_incoming_with_simulation(util::Blob *packet_data, const util::Udp_endpoint &amp;low_lvl_remote_endpoint, bool is_sim_duplicate_packet=false)</div><div class="ttdoc">Helper for low_lvl_recv_and_handle() that calls handle_incoming() on the not-yet-deserialized low-lev...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00187">low_lvl_io.cpp:187</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a9511f3ba50d19f2c32a8de94f0a306e8"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a9511f3ba50d19f2c32a8de94f0a306e8">flow::net_flow::Node::validate_option_check</a></div><div class="ttdeci">bool validate_option_check(bool check, const std::string &amp;check_str, Error_code *err_code) const</div><div class="ttdoc">Helper that, if the given condition is false, logs and returns an error; used to check for option val...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01093">node.cpp:1093</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a96b593d90c246cb2e35fc6a0834e6876"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876">flow::net_flow::Node::S_FIRST_SERVICE_PORT</a></div><div class="ttdeci">static const flow_port_t &amp; S_FIRST_SERVICE_PORT</div><div class="ttdoc">The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00957">node.hpp:957</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a97c8679c70ac9c7dda394fdf335aaed7"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a97c8679c70ac9c7dda394fdf335aaed7">flow::net_flow::Node::Options_lock</a></div><div class="ttdeci">Peer_socket::Options_lock Options_lock</div><div class="ttdoc">Short-hand for lock that acquires exclusive access to an Options_mutex.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01439">node.hpp:1439</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a9909cd2b2a77c57da9e35fcef0f8a4e5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a9909cd2b2a77c57da9e35fcef0f8a4e5">flow::net_flow::Node::low_lvl_recv_and_handle</a></div><div class="ttdeci">void low_lvl_recv_and_handle(Error_code sys_err_code)</div><div class="ttdoc">Handles the pre-condition that m_low_lvl_sock has a UDP packet available for reading,...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00046">low_lvl_io.cpp:46</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a99561404e8389fef08fa4ac5c16a7f36"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a99561404e8389fef08fa4ac5c16a7f36">flow::net_flow::Node::operator==</a></div><div class="ttdeci">friend bool operator==(const Socket_id &amp;lhs, const Socket_id &amp;rhs)</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01157">node.cpp:1157</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a99836ffb51eaefa4d2cc21770461cd97"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a99836ffb51eaefa4d2cc21770461cd97">flow::net_flow::Node::socket_id</a></div><div class="ttdeci">static Socket_id socket_id(Peer_socket::Const_ptr sock)</div><div class="ttdoc">Constructs the socket pair (connection ID) for the given socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06074">peer_socket.cpp:6074</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a9b9e0224c17190e99debdfd81640bf89"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a9b9e0224c17190e99debdfd81640bf89">flow::net_flow::Node::m_low_lvl_sock</a></div><div class="ttdeci">Udp_socket m_low_lvl_sock</div><div class="ttdoc">The UDP socket used to receive low-level packets (to assemble into application layer data) and send t...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03753">node.hpp:3753</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_a9f302fe63e36f72931e1a759b0aaaed4"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#a9f302fe63e36f72931e1a759b0aaaed4">flow::net_flow::Node::async_low_lvl_packet_send_impl</a></div><div class="ttdeci">void async_low_lvl_packet_send_impl(const util::Udp_endpoint &amp;low_lvl_remote_endpoint, Low_lvl_packet::Const_ptr packet, bool delayed_by_pacing, Peer_socket::Ptr sock)</div><div class="ttdoc">Takes given low-level packet structure, serializes it, and initiates asynchronous send of these data ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00321">low_lvl_io.cpp:321</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa0f9ebea458490c37a38760c8335506c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa0f9ebea458490c37a38760c8335506c">flow::net_flow::Node::handle_syn_ack_to_syn_sent</a></div><div class="ttdeci">void handle_syn_ack_to_syn_sent(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; syn_ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed low-level SYN_ACK packet delivered to the given peer ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00474">peer_socket.cpp:474</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa18a14a4749f34d07c71bb2a1214d65f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa18a14a4749f34d07c71bb2a1214d65f">flow::net_flow::Node::event_set_async_wait</a></div><div class="ttdeci">bool event_set_async_wait(Event_set::Ptr event_set, const Event_set::Event_handler &amp;on_event, Error_code *err_code)</div><div class="ttdoc">Implementation of Event_set::async_wait() when Event_set::state() == Event_set::State::S_INACTIVE.</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l00917">event_set.cpp:917</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa19d1f49638ef8ce8883e7477a06d3fc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa19d1f49638ef8ce8883e7477a06d3fc">flow::net_flow::Node::send</a></div><div class="ttdeci">size_t send(Peer_socket::Ptr sock, const Function&lt; size_t(size_t max_data_size)&gt; &amp;snd_buf_feed_func, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;send() for socket sock in all cases except when sock-&gt;state() ==...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04526">peer_socket.cpp:4526</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa1b913c5c759a465a9fcaa637ddaea99"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99">flow::net_flow::Node::S_NUM_SERVICE_PORTS</a></div><div class="ttdeci">static const size_t &amp; S_NUM_SERVICE_PORTS</div><div class="ttdoc">Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00945">node.hpp:945</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa1d1021e099c70c1a6e192e65f86debf"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf">flow::net_flow::Node::S_FIRST_EPHEMERAL_PORT</a></div><div class="ttdeci">static const flow_port_t &amp; S_FIRST_EPHEMERAL_PORT</div><div class="ttdoc">The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00963">node.hpp:963</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa1d9656e9e1480021c87530ec6dbebbe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa1d9656e9e1480021c87530ec6dbebbe">flow::net_flow::Node::sock_set_int_state</a></div><div class="ttdeci">void sock_set_int_state(Peer_socket::Ptr sock, Peer_socket::Int_state new_state)</div><div class="ttdoc">Sets internal state of given socket to the given state and logs a TRACE message about it.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06109">peer_socket.cpp:6109</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa42efbce8c5ea908a253fca2e9b2a02c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">flow::net_flow::Node::sock_create_forward_plus_ctor_args</a></div><div class="ttdeci">Peer_socket * sock_create_forward_plus_ctor_args(const Peer_socket_options &amp;opts)</div><div class="ttdoc">Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04193">node.hpp:4193</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa440f6ff5442c58323bec7a2304b0d90"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa440f6ff5442c58323bec7a2304b0d90">flow::net_flow::Node::m_event_loop_ready</a></div><div class="ttdeci">boost::promise&lt; Error_code &gt; m_event_loop_ready</div><div class="ttdoc">Promise that thread W sets to truthy Error_code if it fails to initialize or falsy once event loop is...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03880">node.hpp:3880</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa44feae2c97b4bc1fe1f14f83e932d84"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa44feae2c97b4bc1fe1f14f83e932d84">flow::net_flow::Node::sock_is_readable</a></div><div class="ttdeci">bool sock_is_readable(const boost::any &amp;sock_as_any) const</div><div class="ttdoc">Returns true if and only if calling sock-&gt;receive() with at least some arguments would return either ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05239">peer_socket.cpp:5239</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa5f7c019665d9dd91af0ad6431f8f97d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa5f7c019665d9dd91af0ad6431f8f97d">flow::net_flow::Node::async_sock_low_lvl_packet_send_or_close_immediately</a></div><div class="ttdeci">bool async_sock_low_lvl_packet_send_or_close_immediately(const Peer_socket::Ptr &amp;sock, Low_lvl_packet::Ptr &amp;&amp;packet, bool defer_delta_check)</div><div class="ttdoc">Similar to async_sock_low_lvl_packet_send_paced() except it also calls close_connection_immediately(s...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l01019">low_lvl_io.cpp:1019</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aa894fd58b246c2a8d6c7c7d25a8748cb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aa894fd58b246c2a8d6c7c7d25a8748cb">flow::net_flow::Node::this_thread_init_logger_setup</a></div><div class="ttdeci">log::Logger * this_thread_init_logger_setup(const std::string &amp;thread_type, log::Logger *logger=0)</div><div class="ttdoc">Helper to invoke for each thread in which this Node executes, whether or not it starts that thread,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00113">node.cpp:113</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aaaf5c3b5e6b9f9f1658b60907b36a498"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aaaf5c3b5e6b9f9f1658b60907b36a498">flow::net_flow::Node::handle_syn_to_listening_server</a></div><div class="ttdeci">Peer_socket::Ptr handle_syn_to_listening_server(Server_socket::Ptr serv, boost::shared_ptr&lt; const Syn_packet &gt; syn, const util::Udp_endpoint &amp;low_lvl_remote_endpoint)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed low-level SYN packet delivered to the given server so...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00433">server_socket.cpp:433</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aab414ebd0e2d27f02ed51270dab90c45"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aab414ebd0e2d27f02ed51270dab90c45">flow::net_flow::Node::sock_data_to_rcv_buf_unless_overflow</a></div><div class="ttdeci">bool sock_data_to_rcv_buf_unless_overflow(Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet)</div><div class="ttdoc">Helper for handle_data_to_established() that aims to pass the payload of the given DATA packet to the...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01133">peer_socket.cpp:1133</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aadea4a9941c6138d9c025401b1f85ceb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aadea4a9941c6138d9c025401b1f85ceb">flow::net_flow::Node::sock_set_options</a></div><div class="ttdeci">bool sock_set_options(Peer_socket::Ptr sock, const Peer_socket_options &amp;opts, Error_code *err_code)</div><div class="ttdoc">Thread W implementation of sock-&gt;set_options().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06197">peer_socket.cpp:6197</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aae148cec361b59237996a4b30c6624b5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">flow::net_flow::Node::running</a></div><div class="ttdeci">bool running() const</div><div class="ttdoc">Returns true if and only if the Node is operating.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00420">node.cpp:420</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aae28990628a86a07327f49973f2390df"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aae28990628a86a07327f49973f2390df">flow::net_flow::Node::m_servs</a></div><div class="ttdeci">Port_to_server_map m_servs</div><div class="ttdoc">The server sockets this Node is currently tracking.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03798">node.hpp:3798</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aaf0acf9de5f151727a43acce180a5e49"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aaf0acf9de5f151727a43acce180a5e49">flow::net_flow::Node::sock_pacing_process_q</a></div><div class="ttdeci">bool sock_pacing_process_q(Peer_socket::Ptr sock, Error_code *err_code, bool executing_after_delay)</div><div class="ttdoc">async_sock_low_lvl_packet_send_paced() pacing helper: Given that we are currently in the pacing time ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00849">low_lvl_io.cpp:849</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab0026feecdb74eda904d00d2c7016bab"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab0026feecdb74eda904d00d2c7016bab">flow::net_flow::Node::m_sock_events</a></div><div class="ttdeci">Event_set::Ev_type_to_socks_map m_sock_events</div><div class="ttdoc">All sockets that have been detected to be &quot;ready&quot; (by the Event_set doc header definition) at any poi...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03830">node.hpp:3830</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab13749ccdf4ab44445f21c77296ffa13"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">flow::net_flow::Node::S_DEFAULT_CONN_METADATA</a></div><div class="ttdeci">static const uint8_t S_DEFAULT_CONN_METADATA</div><div class="ttdoc">Type and value to supply as user-supplied metadata in SYN, if user chooses to use [[a]sync_]connect()...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01403">node.hpp:1403</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab2595f47710ddb06cfb22b6710b7286e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab2595f47710ddb06cfb22b6710b7286e">flow::net_flow::Node::validate_options</a></div><div class="ttdeci">const Node_options &amp; validate_options(const Node_options &amp;opts, bool init, Error_code *err_code) const</div><div class="ttdoc">Given a new set of Node_options intended to replace (or initialize) a Node's m_opts,...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00980">node.cpp:980</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab330b19f4039bab074251111789b568a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">flow::net_flow::Node::serv_create_forward_plus_ctor_args</a></div><div class="ttdeci">Server_socket * serv_create_forward_plus_ctor_args(const Peer_socket_options *child_sock_opts)</div><div class="ttdoc">Like sock_create_forward_plus_ctor_args() but for Server_sockets.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l04199">node.hpp:4199</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab427ebc124a6233ae48a7562662a6e81"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab427ebc124a6233ae48a7562662a6e81">flow::net_flow::Node::setup_drop_timer</a></div><div class="ttdeci">void setup_drop_timer(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Creates a new Drop Timer and saves it to sock-&gt;m_snd_drop_timer.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04504">peer_socket.cpp:4504</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ab515b28350c43635728d6de0e37ccb94"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ab515b28350c43635728d6de0e37ccb94">flow::net_flow::Node::handle_ack_to_established</a></div><div class="ttdeci">void handle_ack_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Ack_packet &gt; ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, low-level ACK packet delivered to the given peer soc...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01990">peer_socket.cpp:1990</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aba2e6fc905dbeef3ea9e31bf844f8da5"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">flow::net_flow::Node::sync_connect</a></div><div class="ttdeci">Peer_socket::Ptr sync_connect(const Remote_endpoint &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">The blocking (synchronous) version of connect().</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03967">node.hpp:3967</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aba411df8746d5fd4db2d28df3a016f5e"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aba411df8746d5fd4db2d28df3a016f5e">flow::net_flow::Node::listen_worker</a></div><div class="ttdeci">void listen_worker(flow_port_t local_port, const Peer_socket_options *child_sock_opts, Server_socket::Ptr *serv)</div><div class="ttdoc">Thread W implementation of listen().</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00218">server_socket.cpp:218</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abb3d760b3c880b41e5a4ee7f2c13fd81"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abb3d760b3c880b41e5a4ee7f2c13fd81">flow::net_flow::Node::handle_syn_ack_to_established</a></div><div class="ttdeci">void handle_syn_ack_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; syn_ack)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, duplicate (equal to already-received SYN_ACK) low-le...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00539">peer_socket.cpp:539</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abecf0f8111af82fa081c71fda490608a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abecf0f8111af82fa081c71fda490608a">flow::net_flow::Node::m_signal_set</a></div><div class="ttdeci">Signal_set m_signal_set</div><div class="ttdoc">Signal set which we may or may not be using to trap SIGINT and SIGTERM in order to auto-fire interrup...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03890">node.hpp:3890</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abf0204e999b5dc28ee9b5db6eae9aa1a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abf0204e999b5dc28ee9b5db6eae9aa1a">flow::net_flow::Node::serv_peer_socket_acceptable</a></div><div class="ttdeci">void serv_peer_socket_acceptable(Server_socket::Ptr serv, Peer_socket::Ptr sock)</div><div class="ttdoc">Records that an unestablished socket sock (Peer_socket::Int_state::S_SYN_RCVD) has just become establ...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00838">server_socket.cpp:838</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abf80b7de1398e93d1d4289ef5bf2ae2c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abf80b7de1398e93d1d4289ef5bf2ae2c">flow::net_flow::Node::handle_data_to_syn_rcvd</a></div><div class="ttdeci">void handle_data_to_syn_rcvd(Peer_socket::Ptr sock, boost::shared_ptr&lt; Data_packet &gt; packet)</div><div class="ttdoc">Handles a just-deserialized, just-demultiplexed, low-level DATA packet delivered to the given peer so...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00701">server_socket.cpp:701</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_abfc902bc41381d21f4ca2d4073bb617c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#abfc902bc41381d21f4ca2d4073bb617c">flow::net_flow::Node::Socket_id_to_socket_map</a></div><div class="ttdeci">boost::unordered_map&lt; Socket_id, Peer_socket::Ptr &gt; Socket_id_to_socket_map</div><div class="ttdoc">A map from the connection ID (= remote-local socket pair) to the local Peer_socket that is the local ...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01450">node.hpp:1450</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac1485c07049d4bee70ad4ef2fc07bf12"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac1485c07049d4bee70ad4ef2fc07bf12">flow::net_flow::Node::setup_connection_timers</a></div><div class="ttdeci">void setup_connection_timers(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, bool initial)</div><div class="ttdoc">Assuming we've just sent SYN or SYN_ACK, sets up an asynchronous scheduled task to fire within some a...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04329">peer_socket.cpp:4329</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac2fdb686165aae42f474cc655fca80c0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac2fdb686165aae42f474cc655fca80c0">flow::net_flow::Node::log_rcv_window</a></div><div class="ttdeci">void log_rcv_window(Peer_socket::Const_ptr sock, bool force_verbose_info_logging=false) const</div><div class="ttdoc">Logs TRACE or DATA messages that show the detailed state of the receiving sequence number space.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l01904">peer_socket.cpp:1904</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac397d3fd163f1456b7bb370a3cff951c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac397d3fd163f1456b7bb370a3cff951c">flow::net_flow::Node::sock_rcv_wnd</a></div><div class="ttdeci">size_t sock_rcv_wnd(Peer_socket::Const_ptr sock) const</div><div class="ttdoc">Computes and returns the currently correct rcv_wnd value; that is the amount of space free in Receive...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05524">peer_socket.cpp:5524</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac3c67514c259404de3f27a8cae8b0567"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac3c67514c259404de3f27a8cae8b0567">flow::net_flow::Node::accept</a></div><div class="ttdeci">Peer_socket::Ptr accept(Server_socket::Ptr serv, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking serv-&gt;accept() for server socket serv in all cases except when serv-&gt;s...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00300">server_socket.cpp:300</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac619d1a96cc62d223f990ee6a3c909ff"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac619d1a96cc62d223f990ee6a3c909ff">flow::net_flow::Node::connect_worker</a></div><div class="ttdeci">void connect_worker(const Remote_endpoint &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, const Peer_socket_options *opts, Peer_socket::Ptr *sock)</div><div class="ttdoc">Thread W implementation of connect().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04011">peer_socket.cpp:4011</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac910f24e5a176c4aa01992b08b62146a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac910f24e5a176c4aa01992b08b62146a">flow::net_flow::Node::drop_pkts_on_acks</a></div><div class="ttdeci">bool drop_pkts_on_acks(Peer_socket::Ptr sock, const Peer_socket::Sent_pkt_ordered_by_when_iter &amp;last_dropped_pkt_it, size_t *cong_ctl_dropped_pkts, size_t *cong_ctl_dropped_bytes, size_t *dropped_pkts, size_t *dropped_bytes, std::vector&lt; Peer_socket::order_num_t &gt; *pkts_marked_to_drop)</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that acts on the determination made by categorize_pkts_...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03108">peer_socket.cpp:3108</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ac9f6edfb36abcd0402c4bd75b595f271"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ac9f6edfb36abcd0402c4bd75b595f271">flow::net_flow::Node::S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</a></div><div class="ttdeci">static const Peer_socket::Sent_packet::ack_count_t S_MAX_LATER_ACKS_BEFORE_CONSIDERING_DROPPED</div><div class="ttdoc">For a given unacknowledged sent packet P, the maximum number of times any individual packet with high...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03686">node.hpp:3686</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_acaf55766783893827061fd85cab2634f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#acaf55766783893827061fd85cab2634f">flow::net_flow::Node::async_low_lvl_syn_ack_ack_send_or_close_immediately</a></div><div class="ttdeci">bool async_low_lvl_syn_ack_ack_send_or_close_immediately(const Peer_socket::Ptr &amp;sock, boost::shared_ptr&lt; const Syn_ack_packet &gt; &amp;syn_ack)</div><div class="ttdoc">Helper to create, fully fill out, and asynchronously send via async_sock_low_lvl_packet_send_or_close...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05845">peer_socket.cpp:5845</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_acd93ba39d6a9cdee60c2ad7da1085902"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">flow::net_flow::Node::Node</a></div><div class="ttdeci">Node(log::Logger *logger, const util::Udp_endpoint &amp;low_lvl_endpoint, Net_env_simulator *net_env_sim=0, Error_code *err_code=0, const Node_options &amp;opts=Node_options())</div><div class="ttdoc">Constructs Node.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l00040">node.cpp:40</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_acea4db94c4fb86ddaa2502c2d7e128ea"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#acea4db94c4fb86ddaa2502c2d7e128ea">flow::net_flow::Node::m_packet_data</a></div><div class="ttdeci">util::Blob m_packet_data</div><div class="ttdoc">Stores incoming raw packet data; re-used repeatedly for possible performance gains.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03774">node.hpp:3774</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_acfbd969c7a16b2ea8bb7f0db6fa454df"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#acfbd969c7a16b2ea8bb7f0db6fa454df">flow::net_flow::Node::sock_categorize_data_to_established</a></div><div class="ttdeci">Error_code sock_categorize_data_to_established(Peer_socket::Ptr sock, boost::shared_ptr&lt; const Data_packet &gt; packet, bool *dupe, bool *slide, size_t *slide_size)</div><div class="ttdoc">Helper for handle_data_to_established() that categorizes the DATA packet received as either illegal; ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l00825">peer_socket.cpp:825</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad03aa88df3d1d3981454ee3356e868c1"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad03aa88df3d1d3981454ee3356e868c1">flow::net_flow::Node::async_sock_low_lvl_rst_send</a></div><div class="ttdeci">void async_sock_low_lvl_rst_send(Peer_socket::Ptr sock)</div><div class="ttdoc">Sends an RST to the other side of the given socket asynchronously when possible.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l01033">low_lvl_io.cpp:1033</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad100464cf0126dbbad39bde1c90a774f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">flow::net_flow::Node::event_set_create</a></div><div class="ttdeci">Event_set::Ptr event_set_create(Error_code *err_code=0)</div><div class="ttdoc">Creates a new Event_set in Event_set::State::S_INACTIVE state with no sockets/events stored; returns ...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l00881">event_set.cpp:881</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad2840a7a95f16b7e222e449e3d6b9aca"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad2840a7a95f16b7e222e449e3d6b9aca">flow::net_flow::Node::interrupt_all_waits_worker</a></div><div class="ttdeci">void interrupt_all_waits_worker()</div><div class="ttdoc">Thread W implementation of interrupt_all_waits().</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01421">event_set.cpp:1421</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad502e0a992a79b71af42a9cdc20a4280"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad502e0a992a79b71af42a9cdc20a4280">flow::net_flow::Node::sock_set_state</a></div><div class="ttdeci">void sock_set_state(Peer_socket::Ptr sock, Peer_socket::State state, Peer_socket::Open_sub_state open_sub_state=Peer_socket::Open_sub_state::S_CONNECTED)</div><div class="ttdoc">Sets Peer_socket::m_state and Peer_socket::m_open_sub_state.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06118">peer_socket.cpp:6118</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ad608f9bbe76426f4fbf4bf5af908e4e0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ad608f9bbe76426f4fbf4bf5af908e4e0">flow::net_flow::Node::receive_emptied_rcv_buf_while_disconnecting</a></div><div class="ttdeci">void receive_emptied_rcv_buf_while_disconnecting(Peer_socket::Ptr sock)</div><div class="ttdoc">Placed by receive() onto W during a graceful close, after the Receive buffer had been emptied by the ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05557">peer_socket.cpp:5557</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ada9357f6ce9d5fc249b1cc176afdc471"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ada9357f6ce9d5fc249b1cc176afdc471">flow::net_flow::Node::sock_disconnect_detected</a></div><div class="ttdeci">void sock_disconnect_detected(Peer_socket::Ptr sock, const Error_code &amp;disconnect_cause, bool close)</div><div class="ttdoc">Records that thread W shows underlying connection is broken (graceful termination,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06140">peer_socket.cpp:6140</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_addbb96858fd7b3c9ddd7c6fe8078809c"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#addbb96858fd7b3c9ddd7c6fe8078809c">flow::net_flow::Node::receive</a></div><div class="ttdeci">size_t receive(Peer_socket::Ptr sock, const Function&lt; size_t()&gt; &amp;rcv_buf_consume_func, Error_code *err_code)</div><div class="ttdoc">Implementation of non-blocking sock-&gt;receive() for socket sock in all cases except when sock-&gt;state()...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05089">peer_socket.cpp:5089</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_addd654cb6b1ccff34ddccbe5226be8f0"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#addd654cb6b1ccff34ddccbe5226be8f0">flow::net_flow::Node::handle_connection_rexmit_timer_event</a></div><div class="ttdeci">void handle_connection_rexmit_timer_event(const Socket_id &amp;socket_id, Peer_socket::Ptr sock)</div><div class="ttdoc">Handles the triggering of the retransmit timer wait set up by setup_connection_timers(); it will re-s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l04408">peer_socket.cpp:4408</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade08f0457943f803c23b55649139c0d3"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade08f0457943f803c23b55649139c0d3">flow::net_flow::Node::m_opts</a></div><div class="ttdeci">Node_options m_opts</div><div class="ttdoc">This Node's global set of options.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03704">node.hpp:3704</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade12d2ebbd88b62432089a3a071b9514"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade12d2ebbd88b62432089a3a071b9514">flow::net_flow::Node::async_low_lvl_recv</a></div><div class="ttdeci">void async_low_lvl_recv()</div><div class="ttdoc">Registers so that during the current or next m_task_engine.run(), the latter will wait for a receivab...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00031">low_lvl_io.cpp:31</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade49e7bc7202a0adf33fec2d93d1b177"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade49e7bc7202a0adf33fec2d93d1b177">flow::net_flow::Node::close_connection_immediately</a></div><div class="ttdeci">void close_connection_immediately(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, const Error_code &amp;err_code, bool defer_delta_check)</div><div class="ttdoc">A thread W method that handles the transition of the given socket from OPEN (any sub-state) to CLOSED...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05689">peer_socket.cpp:5689</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ade529b5452c9fe363ae468346e662ceb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ade529b5452c9fe363ae468346e662ceb">flow::net_flow::Node::sock_disconnect_completed</a></div><div class="ttdeci">void sock_disconnect_completed(Peer_socket::Ptr sock)</div><div class="ttdoc">While in S_OPEN+S_DISCONNECTING state (i.e., after beginning a graceful close with sock_disconnect_de...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l06161">peer_socket.cpp:6161</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_adeccd8c86fcd54733e42593629fad96b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#adeccd8c86fcd54733e42593629fad96b">flow::net_flow::Node::compute_rtt_on_ack</a></div><div class="ttdeci">Fine_duration compute_rtt_on_ack(Peer_socket::Sent_packet::Const_ptr flying_pkt, const Fine_time_pt &amp;time_now, Ack_packet::Individual_ack::Const_ptr ack, const Peer_socket::Sent_packet::Sent_when **sent_when) const</div><div class="ttdoc">Helper of perform_accumulated_on_recv_tasks() that computes the RTT implied by a given individual ack...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l02876">peer_socket.cpp:2876</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_adf6d71af81def2d030f0fef159c1b06d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#adf6d71af81def2d030f0fef159c1b06d">flow::net_flow::Node::close_empty_server_immediately</a></div><div class="ttdeci">void close_empty_server_immediately(const flow_port_t local_port, Server_socket::Ptr serv, const Error_code &amp;err_code, bool defer_delta_check)</div><div class="ttdoc">Handles the transition of the given server socket from S_LISTENING/S_CLOSING to S_CLOSED (including e...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8cpp_source.html#l00364">server_socket.cpp:364</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae43345472c4f41933a9c16d114cc937b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae43345472c4f41933a9c16d114cc937b">flow::net_flow::Node::m_event_sets</a></div><div class="ttdeci">Event_sets m_event_sets</div><div class="ttdoc">Every Event_set to have been returned by event_set_create() and not subsequently reached Event_set::S...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03804">node.hpp:3804</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae536f016607677a945ad42034a21e82a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae536f016607677a945ad42034a21e82a">flow::net_flow::Node::m_rnd_security_tokens</a></div><div class="ttdeci">util::Rnd_gen_uniform_range&lt; Peer_socket::security_token_t &gt; m_rnd_security_tokens</div><div class="ttdoc">Random number generator for picking security tokens; seeded on time at Node construction and generate...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03786">node.hpp:3786</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae996cab95eb139d00f0d430093e64a5f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae996cab95eb139d00f0d430093e64a5f">flow::net_flow::Node::interrupt_all_waits_internal_sig_handler</a></div><div class="ttdeci">void interrupt_all_waits_internal_sig_handler(const Error_code &amp;sys_err_code, int sig_number)</div><div class="ttdoc">signal_set handler, executed on SIGINT and SIGTERM, if user has enabled this feature: causes interrup...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01456">event_set.cpp:1456</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae9a0e5492b9ea005cc12c20c8e7cec9a"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">flow::net_flow::Node::connect_with_metadata</a></div><div class="ttdeci">Peer_socket::Ptr connect_with_metadata(const Remote_endpoint &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, Error_code *err_code=0, const Peer_socket_options *opts=0)</div><div class="ttdoc">Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03957">peer_socket.cpp:3957</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_ae9b88eadca41228fe6a671f2f14ead0b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#ae9b88eadca41228fe6a671f2f14ead0b">flow::net_flow::Node::new_round_trip_time_sample</a></div><div class="ttdeci">void new_round_trip_time_sample(Peer_socket::Ptr sock, Fine_duration round_trip_time)</div><div class="ttdoc">Handles a just-computed new RTT (round trip time) measurement for an individual packet earlier sent: ...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03503">peer_socket.cpp:3503</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aee8466d9c810da5edea443d665b24dcb"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aee8466d9c810da5edea443d665b24dcb">flow::net_flow::Node::perform_regular_infrequent_tasks</a></div><div class="ttdeci">void perform_regular_infrequent_tasks(bool reschedule)</div><div class="ttdoc">Performs low-priority tasks that should be run on an infrequent, regular basis, such as stat logging ...</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01117">node.cpp:1117</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aee89be07daf7d024921381a4bafe1289"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aee89be07daf7d024921381a4bafe1289">flow::net_flow::Node::m_low_lvl_endpoint</a></div><div class="ttdeci">util::Udp_endpoint m_low_lvl_endpoint</div><div class="ttdoc">After we bind m_low_lvl_sock to a UDP endpoint, this is a copy of that endpoint.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03764">node.hpp:3764</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_af39d69abde4efa88d5d40e1c529c1a25"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#af39d69abde4efa88d5d40e1c529c1a25">flow::net_flow::Node::ok_to_rexmit_or_close</a></div><div class="ttdeci">bool ok_to_rexmit_or_close(Peer_socket::Ptr sock, const Peer_socket::Sent_pkt_ordered_by_when_iter &amp;pkt_it, bool defer_delta_check)</div><div class="ttdoc">Checks whether the given sent packet has been retransmitted the maximum number of allowed times; if s...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03927">peer_socket.cpp:3927</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_af5597a417d03e2bed87cd772ef5cef29"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#af5597a417d03e2bed87cd772ef5cef29">flow::net_flow::Node::m_task_engine</a></div><div class="ttdeci">util::Task_engine m_task_engine</div><div class="ttdoc">The main loop engine, functioning in the single-threaded-but-asynchronous callback-based &quot;reactor&quot; st...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03739">node.hpp:3739</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afb88dafa8ec5c1b412de86dfdccd9c8f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afb88dafa8ec5c1b412de86dfdccd9c8f">flow::net_flow::Node::sock_pacing_new_time_slice</a></div><div class="ttdeci">void sock_pacing_new_time_slice(Peer_socket::Ptr sock, const Fine_time_pt &amp;now)</div><div class="ttdoc">async_sock_low_lvl_packet_send_paced() pacing helper: Resets the socket's Send_pacing_data structure ...</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__io_8cpp_source.html#l00765">low_lvl_io.cpp:765</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afd6388a362531ada956a864fefff6011"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afd6388a362531ada956a864fefff6011">flow::net_flow::Node::m_ports</a></div><div class="ttdeci">Port_space m_ports</div><div class="ttdoc">Flow port space for both client and server sockets. All threads may access this.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03777">node.hpp:3777</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afdefbbb3c3b9f2f2866f6b4c770fa62d"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afdefbbb3c3b9f2f2866f6b4c770fa62d">flow::net_flow::Node::event_set_fire_if_got_events</a></div><div class="ttdeci">void event_set_fire_if_got_events(Event_set::Ptr event_set)</div><div class="ttdoc">Check whether given Event_set contains any active sockets (Event_set::m_can); if so,...</div><div class="ttdef"><b>Definition:</b> <a href="event__set_8cpp_source.html#l01084">event_set.cpp:1084</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_afe70a0c32695e417e7a09e0ba773f151"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#afe70a0c32695e417e7a09e0ba773f151">flow::net_flow::Node::rst_and_close_connection_immediately</a></div><div class="ttdeci">void rst_and_close_connection_immediately(const Socket_id &amp;socket_id, Peer_socket::Ptr sock, const Error_code &amp;err_code, bool defer_delta_check)</div><div class="ttdoc">Asynchronously send RST to the other side of the given socket and close_connection_immediately().</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l05809">peer_socket.cpp:5809</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_aff19033bff73d4f51766a9575c01f883"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#aff19033bff73d4f51766a9575c01f883">flow::net_flow::Node::Event_sets</a></div><div class="ttdeci">boost::unordered_set&lt; Event_set::Ptr &gt; Event_sets</div><div class="ttdoc">A set of Event_set objects.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l01456">node.hpp:1456</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Node_html_affbc6abb1e344c6e98d3ac8068a54670"><div class="ttname"><a href="classflow_1_1net__flow_1_1Node.html#affbc6abb1e344c6e98d3ac8068a54670">flow::net_flow::Node::drop_timer_action</a></div><div class="ttdeci">void drop_timer_action(Peer_socket::Ptr sock, bool drop_all_packets)</div><div class="ttdoc">Handles a Drop_timer (Peer_socket::m_snd_drop_timer) event in ESTABLISHED state by dropping the speci...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8cpp_source.html#l03323">peer_socket.cpp:3323</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html">flow::net_flow::Peer_socket</a></div><div class="ttdoc">A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00215">peer_socket.hpp:223</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a1e1379f9a0269d6990f26bf1da045657"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a1e1379f9a0269d6990f26bf1da045657">flow::net_flow::Peer_socket::Options_mutex</a></div><div class="ttdeci">util::Mutex_non_recursive Options_mutex</div><div class="ttdoc">Short-hand for high-performance, non-reentrant, exclusive mutex used to lock m_opts.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00885">peer_socket.hpp:885</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6a9bb727c8982f24bcf978c10c2c7345"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">flow::net_flow::Peer_socket::State</a></div><div class="ttdeci">State</div><div class="ttdoc">State of a Peer_socket.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00228">peer_socket.hpp:229</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">flow::net_flow::Peer_socket::Open_sub_state</a></div><div class="ttdeci">Open_sub_state</div><div class="ttdoc">The sub-state of a Peer_socket when state is State::S_OPEN.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00237">peer_socket.hpp:238</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">flow::net_flow::Peer_socket::Open_sub_state::S_CONNECTED</a></div><div class="ttdeci">@ S_CONNECTED</div><div class="ttdoc">This Peer_socket was created through a passive connect (Node::accept() and the like) or an active con...</div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a797a524b73e2626fcfefe1be64f4d481"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a797a524b73e2626fcfefe1be64f4d481">flow::net_flow::Peer_socket::order_num_t</a></div><div class="ttdeci">Sequence_number::seq_num_t order_num_t</div><div class="ttdoc">Short-hand for order number type. 0 is reserved. Caution: Keep in sync with Drop_timer::packet_id_t.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00905">peer_socket.hpp:905</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a9537860c2c2a7380a45a525e5121880f"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a9537860c2c2a7380a45a525e5121880f">flow::net_flow::Peer_socket::Int_state</a></div><div class="ttdeci">Int_state</div><div class="ttdoc">The state of the socket (and the connection from this end's point of view) for the internal state mac...</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00913">peer_socket.hpp:914</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_a98c6729b318f28b61e144f8a9b1f4dfc"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#a98c6729b318f28b61e144f8a9b1f4dfc">flow::net_flow::Peer_socket::Options_lock</a></div><div class="ttdeci">util::Lock_guard&lt; Options_mutex &gt; Options_lock</div><div class="ttdoc">Short-hand for lock that acquires exclusive access to an Options_mutex.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00888">peer_socket.hpp:888</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ab7dc3b752b67295c82919c2f87aed60b"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ab7dc3b752b67295c82919c2f87aed60b">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_iter</a></div><div class="ttdeci">Sent_pkt_by_sent_when_map::iterator Sent_pkt_ordered_by_when_iter</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_sent_when iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00946">peer_socket.hpp:946</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Peer__socket_html_ac974bdce3d2035d2af69078837f59482"><div class="ttname"><a href="classflow_1_1net__flow_1_1Peer__socket.html#ac974bdce3d2035d2af69078837f59482">flow::net_flow::Peer_socket::Sent_pkt_ordered_by_when_const_iter</a></div><div class="ttdeci">Sent_pkt_by_sent_when_map::const_iterator Sent_pkt_ordered_by_when_const_iter</div><div class="ttdoc">Short-hand for m_snd_flying_pkts_by_sent_when const iterator type.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l00943">peer_socket.hpp:943</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Port__space_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Port__space.html">flow::net_flow::Port_space</a></div><div class="ttdoc">Internal net_flow class that maintains the available Flow-protocol port space, somewhat similarly to ...</div><div class="ttdef"><b>Definition:</b> <a href="port__space_8hpp_source.html#l00091">port_space.hpp:94</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Sequence__number_1_1Generator_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Sequence__number_1_1Generator.html">flow::net_flow::Sequence_number::Generator</a></div><div class="ttdoc">An object of this type generates a series of initial sequence numbers (ISN) that are meant to be suff...</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8hpp_source.html#l00370">seq_num.hpp:373</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Sequence__number_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Sequence__number.html">flow::net_flow::Sequence_number</a></div><div class="ttdoc">An internal net_flow sequence number identifying a piece of data.</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8hpp_source.html#l00125">seq_num.hpp:126</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Server__socket_html"><div class="ttname"><a href="classflow_1_1net__flow_1_1Server__socket.html">flow::net_flow::Server_socket</a></div><div class="ttdoc">A server socket able to listen on a single Flow port for incoming connections and return peer sockets...</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8hpp_source.html#l00118">server_socket.hpp:126</a></div></div>
<div class="ttc" id="aclassflow_1_1net__flow_1_1Server__socket_html_a8bc789b851677a47d7c0a1aa0c69a997"><div class="ttname"><a href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">flow::net_flow::Server_socket::State</a></div><div class="ttdeci">State</div><div class="ttdoc">State of a Server_socket.</div><div class="ttdef"><b>Definition:</b> <a href="server__socket_8hpp_source.html#l00131">server_socket.hpp:132</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Linked__hash__map_html"><div class="ttname"><a href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map&lt; Event_type, Sockets &gt;</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Null__interface_html"><div class="ttname"><a href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></div><div class="ttdoc">An empty interface, consisting of nothing but a default virtual destructor, intended as a boiler-plat...</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00044">util.hpp:45</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Rnd__gen__uniform__range_html"><div class="ttname"><a href="classflow_1_1util_1_1Rnd__gen__uniform__range.html">flow::util::Rnd_gen_uniform_range&lt; Peer_socket::security_token_t &gt;</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_aa4f1af88393042e60159a3a67f0accbc"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;::Ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Peer_socket &gt; Ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00118">shared_ptr_alias_holder.hpp:118</a></div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Shared__ptr__alias__holder_html_aef7998db71c60eeb5d1e3d1a97c14886"><div class="ttname"><a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Low_lvl_packet &gt; &gt;::Const_ptr</a></div><div class="ttdeci">Const_target_ptr Const_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to immutable values of type Target_type::element_type (a-la T cons...</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__alias__holder_8hpp_source.html#l00120">shared_ptr_alias_holder.hpp:120</a></div></div>
<div class="ttc" id="adetail_2net__flow__fwd_8hpp_html"><div class="ttname"><a href="detail_2net__flow__fwd_8hpp.html">net_flow_fwd.hpp</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_ab6b8ed79012c994cfc381e0b92c066fd"><div class="ttname"><a href="error_2error_8hpp.html#ab6b8ed79012c994cfc381e0b92c066fd">FLOW_ERROR_EMIT_ERROR</a></div><div class="ttdeci">#define FLOW_ERROR_EMIT_ERROR(ARG_val)</div><div class="ttdoc">Sets *err_code to ARG_val and logs a warning about the error using FLOW_LOG_WARNING().</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00202">error.hpp:202</a></div></div>
<div class="ttc" id="aerror_2error_8hpp_html_adc17094d4b9421abd04b90caab8b8e72"><div class="ttname"><a href="error_2error_8hpp.html#adc17094d4b9421abd04b90caab8b8e72">FLOW_ERROR_EMIT_ERROR_LOG_INFO</a></div><div class="ttdeci">#define FLOW_ERROR_EMIT_ERROR_LOG_INFO(ARG_val)</div><div class="ttdoc">Identical to FLOW_ERROR_EMIT_ERROR(), but the message logged has flow::log::Sev::S_INFO severity inst...</div><div class="ttdef"><b>Definition:</b> <a href="error_2error_8hpp_source.html#l00218">error.hpp:218</a></div></div>
<div class="ttc" id="aevent__set_8hpp_html"><div class="ttname"><a href="event__set_8hpp.html">event_set.hpp</a></div></div>
<div class="ttc" id="alog_8hpp_html"><div class="ttname"><a href="log_8hpp.html">log.hpp</a></div></div>
<div class="ttc" id="alog_8hpp_html_a626c7dc4d3b4dc0b32a8aac8624d66bc"><div class="ttname"><a href="log_8hpp.html#a626c7dc4d3b4dc0b32a8aac8624d66bc">FLOW_LOG_WARNING</a></div><div class="ttdeci">#define FLOW_LOG_WARNING(ARG_stream_fragment)</div><div class="ttdoc">Logs a WARNING message into flow::log::Logger *get_logger() with flow::log::Component get_log_compone...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00152">log.hpp:152</a></div></div>
<div class="ttc" id="alog_8hpp_html_ae4b5d4fdd2eb052615620879dd74af95"><div class="ttname"><a href="log_8hpp.html#ae4b5d4fdd2eb052615620879dd74af95">FLOW_LOG_SET_CONTEXT</a></div><div class="ttdeci">#define FLOW_LOG_SET_CONTEXT(ARG_logger_ptr, ARG_component_payload)</div><div class="ttdoc">For the rest of the block within which this macro is instantiated, causes all FLOW_LOG_....</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00405">log.hpp:405</a></div></div>
<div class="ttc" id="alog_8hpp_html_affcf2e4c496ce3f42adf981669c623b8"><div class="ttname"><a href="log_8hpp.html#affcf2e4c496ce3f42adf981669c623b8">FLOW_LOG_TRACE</a></div><div class="ttdeci">#define FLOW_LOG_TRACE(ARG_stream_fragment)</div><div class="ttdoc">Logs a TRACE message into flow::log::Logger *get_logger() with flow::log::Component get_log_component...</div><div class="ttdef"><b>Definition:</b> <a href="log_8hpp_source.html#l00227">log.hpp:227</a></div></div>
<div class="ttc" id="alow__lvl__packet_8hpp_html"><div class="ttname"><a href="low__lvl__packet_8hpp.html">low_lvl_packet.hpp</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58">flow::net_flow::error::Code::S_STATIC_OPTION_CHANGED</a></div><div class="ttdeci">@ S_STATIC_OPTION_CHANGED</div><div class="ttdoc">When setting options, tried to set an unchangeable (static) option.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_1_1error_html_a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e"><div class="ttname"><a href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e">flow::net_flow::error::Code::S_NODE_NOT_RUNNING</a></div><div class="ttdeci">@ S_NODE_NOT_RUNNING</div><div class="ttdoc">Node not running.</div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html"><div class="ttname"><a href="namespaceflow_1_1net__flow.html">flow::net_flow</a></div><div class="ttdoc">Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...</div><div class="ttdef"><b>Definition:</b> <a href="asio_2node_8cpp_source.html#l00024">node.cpp:25</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a079d8cd87a68d1c5f04c6bce71f0061d"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow::net_flow::flow_port_t</a></div><div class="ttdeci">uint16_t flow_port_t</div><div class="ttdoc">Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).</div><div class="ttdef"><b>Definition:</b> <a href="net__flow__fwd_8hpp_source.html#l00054">net_flow_fwd.hpp:54</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a152200ba9432e5ca229e41a1c5d9d226"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a152200ba9432e5ca229e41a1c5d9d226">flow::net_flow::hash_value</a></div><div class="ttdeci">size_t hash_value(const Sequence_number &amp;seq_num)</div><div class="ttdoc">Free function that returns seq_num.hash(); has to be a free function named hash_value for boost....</div><div class="ttdef"><b>Definition:</b> <a href="seq__num_8cpp_source.html#l00275">seq_num.cpp:275</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a8504aeca20f41a8f2b98ae04803a600e"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a8504aeca20f41a8f2b98ae04803a600e">flow::net_flow::operator==</a></div><div class="ttdeci">bool operator==(const Remote_endpoint &amp;lhs, const Remote_endpoint &amp;rhs)</div><div class="ttdoc">Whether lhs is equal to rhs.</div><div class="ttdef"><b>Definition:</b> <a href="endpoint_8cpp_source.html#l00060">endpoint.cpp:60</a></div></div>
<div class="ttc" id="anamespaceflow_1_1net__flow_html_a9dd0c9d8de00fab78d8b0a3f50dad2a9"><div class="ttname"><a href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9">flow::net_flow::S_PORT_ANY</a></div><div class="ttdeci">const flow_port_t S_PORT_ANY</div><div class="ttdoc">Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...</div><div class="ttdef"><b>Definition:</b> <a href="port__space_8cpp_source.html#l00033">port_space.cpp:33</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a09a032f8e1e77a3afc0b7df115a773e1"><div class="ttname"><a href="namespaceflow_1_1util.html#a09a032f8e1e77a3afc0b7df115a773e1">flow::util::setup_auto_cleanup</a></div><div class="ttdeci">Auto_cleanup setup_auto_cleanup(const Cleanup_func &amp;func)</div><div class="ttdoc">Provides a way to execute arbitrary (cleanup) code at the exit of the current block.</div><div class="ttdef"><b>Definition:</b> <a href="util_2util_8hpp_source.html#l00282">util.hpp:282</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_a5d2247b715da63e4b960909561b90ae7"><div class="ttname"><a href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">flow::util::Lock_guard</a></div><div class="ttdeci">boost::unique_lock&lt; Mutex &gt; Lock_guard</div><div class="ttdoc">Short-hand for advanced-capability RAII lock guard for any mutex, ensuring exclusive ownership of tha...</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00259">util_fwd.hpp:259</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_aa60d3ba517b5f5cf408faa92d269256a"><div class="ttname"><a href="namespaceflow_1_1util.html#aa60d3ba517b5f5cf408faa92d269256a">flow::util::chrono_duration_to_fine_duration</a></div><div class="ttdeci">Fine_duration chrono_duration_to_fine_duration(const boost::chrono::duration&lt; Rep, Period &gt; &amp;dur)</div><div class="ttdoc">Helper that takes a non-negative duration of arbitrary precision/period and converts it to Fine_durat...</div><div class="ttdef"><b>Definition:</b> <a href="util_2detail_2util_8hpp_source.html#l00031">util.hpp:31</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_ab22fd89e165a9e6deaa174bc0dfdc8de"><div class="ttname"><a href="namespaceflow_1_1util.html#ab22fd89e165a9e6deaa174bc0dfdc8de">flow::util::Auto_cleanup</a></div><div class="ttdeci">boost::shared_ptr&lt; void &gt; Auto_cleanup</div><div class="ttdoc">Helper type for setup_auto_cleanup().</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00199">util_fwd.hpp:199</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_adf23368210219716b6fd22d15b765cb6"><div class="ttname"><a href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">flow::util::Task_engine</a></div><div class="ttdeci">boost::asio::io_service Task_engine</div><div class="ttdoc">Short-hand for boost.asio event service, the central class of boost.asio.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00129">util_fwd.hpp:129</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_af030c3119f060a9630afca31098a78a5"><div class="ttname"><a href="namespaceflow_1_1util.html#af030c3119f060a9630afca31098a78a5">flow::util::Thread</a></div><div class="ttdeci">boost::thread Thread</div><div class="ttdoc">Short-hand for standard thread class.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00078">util_fwd.hpp:78</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_af09888b3a8feaff209b6625e493bc338"><div class="ttname"><a href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338">flow::util::Blob</a></div><div class="ttdeci">Blob_with_log_context&lt;&gt; Blob</div><div class="ttdoc">A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...</div><div class="ttdef"><b>Definition:</b> <a href="blob__fwd_8hpp_source.html#l00060">blob_fwd.hpp:60</a></div></div>
<div class="ttc" id="anamespaceflow_1_1util_html_af1b28edb7bad743c1c77f6b982cc3196"><div class="ttname"><a href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">flow::util::Udp_endpoint</a></div><div class="ttdeci">boost::asio::ip::udp::endpoint Udp_endpoint</div><div class="ttdoc">Short-hand for the UDP endpoint (IP/port) type.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00202">util_fwd.hpp:202</a></div></div>
<div class="ttc" id="anamespaceflow_html_a29eaaa9d0fac4ce87d8b969222dbed09"><div class="ttname"><a href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">flow::Error_code</a></div><div class="ttdeci">boost::system::error_code Error_code</div><div class="ttdoc">Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00502">common.hpp:502</a></div></div>
<div class="ttc" id="anamespaceflow_html_a48799f1263cdeedec125be51a3db2b79"><div class="ttname"><a href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">flow::Fine_duration</a></div><div class="ttdeci">Fine_clock::duration Fine_duration</div><div class="ttdoc">A high-res time duration as computed from two Fine_time_pts.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00410">common.hpp:410</a></div></div>
<div class="ttc" id="anamespaceflow_html_a9d9cc2eeb10d398cff5591d446b763b8"><div class="ttname"><a href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">flow::Fine_time_pt</a></div><div class="ttdeci">Fine_clock::time_point Fine_time_pt</div><div class="ttdoc">A high-res time point as returned by Fine_clock::now() and suitable for precise time math in general.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00407">common.hpp:407</a></div></div>
<div class="ttc" id="anamespaceflow_html_ae02da22c4a101eaab447511c905e4f32"><div class="ttname"><a href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">flow::uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">Byte. Best way to represent a byte of binary data. This is 8 bits on all modern systems.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00385">common.hpp:385</a></div></div>
<div class="ttc" id="anet__env__simulator_8hpp_html"><div class="ttname"><a href="net__env__simulator_8hpp.html">net_env_simulator.hpp</a></div></div>
<div class="ttc" id="anet__flow_2error_2error_8hpp_html"><div class="ttname"><a href="net__flow_2error_2error_8hpp.html">error.hpp</a></div></div>
<div class="ttc" id="anet__flow__fwd_8hpp_html"><div class="ttname"><a href="net__flow__fwd_8hpp.html">net_flow_fwd.hpp</a></div></div>
<div class="ttc" id="apeer__socket_8hpp_html"><div class="ttname"><a href="peer__socket_8hpp.html">peer_socket.hpp</a></div></div>
<div class="ttc" id="aport__space_8hpp_html"><div class="ttname"><a href="port__space_8hpp.html">port_space.hpp</a></div></div>
<div class="ttc" id="aserver__socket_8hpp_html"><div class="ttname"><a href="server__socket_8hpp.html">server_socket.hpp</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack_html_a55bebcb04b4cc192e38023e58bfd761c"><div class="ttname"><a href="structflow_1_1net__flow_1_1Ack__packet_1_1Individual__ack.html#a55bebcb04b4cc192e38023e58bfd761c">flow::net_flow::Ack_packet::Individual_ack::Const_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; const Individual_ack &gt; Const_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to immutable objects of this class.</div><div class="ttdef"><b>Definition:</b> <a href="low__lvl__packet_8hpp_source.html#l01203">low_lvl_packet.hpp:1203</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node_1_1Socket__id_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html">flow::net_flow::Node::Socket_id</a></div><div class="ttdoc">The data nugget uniquely identifying a peer-to-peer connection from a remote endpoint to a port in th...</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03903">node.hpp:3904</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node_1_1Socket__id_html_a23527fa6deadda111d7c4c194a0ce177"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#a23527fa6deadda111d7c4c194a0ce177">flow::net_flow::Node::Socket_id::m_remote_endpoint</a></div><div class="ttdeci">const Remote_endpoint m_remote_endpoint</div><div class="ttdoc">The other side of the connection.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03908">node.hpp:3908</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node_1_1Socket__id_html_a4f4e052de75d02fb4610df872be06186"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#a4f4e052de75d02fb4610df872be06186">flow::net_flow::Node::Socket_id::hash</a></div><div class="ttdeci">size_t hash() const</div><div class="ttdoc">Hash value of this Socket_id for unordered&lt;&gt;.</div><div class="ttdef"><b>Definition:</b> <a href="node_8cpp_source.html#l01147">node.cpp:1147</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node_1_1Socket__id_html_aefe916d29cee30dbc344532603aa9336"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node_1_1Socket__id.html#aefe916d29cee30dbc344532603aa9336">flow::net_flow::Node::Socket_id::m_local_port</a></div><div class="ttdeci">const flow_port_t m_local_port</div><div class="ttdoc">This side of the connection (within this Node).</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l03910">node.hpp:3910</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node__options_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node__options.html">flow::net_flow::Node_options</a></div><div class="ttdoc">A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00448">options.hpp:449</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node__options_html_aacfe6175ac39447c107413853e578459"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node__options.html#aacfe6175ac39447c107413853e578459">flow::net_flow::Node_options::opt_id_to_str</a></div><div class="ttdeci">static std::string opt_id_to_str(const std::string &amp;opt_id)</div><div class="ttdoc">Helper that, for a given option m_blah, takes something like &quot;m_blah_blah&quot; and returns the similar mo...</div><div class="ttdef"><b>Definition:</b> <a href="options_8cpp_source.html#l00160">options.cpp:160</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_1_1Sent__when.html">flow::net_flow::Peer_socket::Sent_packet::Sent_when</a></div><div class="ttdoc">Data store to keep timing related info when a packet is sent out.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02282">peer_socket.hpp:2283</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet_html_a7913f73b4e2f164ca51ebb505b63c1f2"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket_1_1Sent__packet.html#a7913f73b4e2f164ca51ebb505b63c1f2">flow::net_flow::Peer_socket::Sent_packet::ack_count_t</a></div><div class="ttdeci">uint16_t ack_count_t</div><div class="ttdoc">Type used for m_acks_after_me.</div><div class="ttdef"><b>Definition:</b> <a href="peer__socket_8hpp_source.html#l02193">peer_socket.hpp:2193</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__info_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__info.html">flow::net_flow::Peer_socket_info</a></div><div class="ttdoc">A data store that keeps stats about the a Peer_socket connection.</div><div class="ttdef"><b>Definition:</b> <a href="info_8hpp_source.html#l00455">info.hpp:456</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Peer__socket__options_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Peer__socket__options.html">flow::net_flow::Peer_socket_options</a></div><div class="ttdoc">A set of low-level options affecting a single Peer_socket.</div><div class="ttdef"><b>Definition:</b> <a href="options_8hpp_source.html#l00035">options.hpp:36</a></div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Remote__endpoint_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Remote__endpoint.html">flow::net_flow::Remote_endpoint</a></div><div class="ttdoc">Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...</div><div class="ttdef"><b>Definition:</b> <a href="endpoint_8hpp_source.html#l00092">endpoint.hpp:93</a></div></div>
<div class="ttc" id="autil_2util_8hpp_html"><div class="ttname"><a href="util_2util_8hpp.html">util.hpp</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 00:12:45 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
