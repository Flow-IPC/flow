<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Node_options Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structflow_1_1net__flow_1_1Node__options-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Node_options Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A set of low-level options affecting a single Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, including <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects and other objects subsequently generated by that Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  
 <a href="structflow_1_1net__flow_1_1Node__options.html#details">More...</a></p>

<p><code>#include &lt;options.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Node_options:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Node__options__coll__graph.svg" width="176" height="143"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af93781c0e8136a82e41080701719d996"><td class="memItemLeft" align="right" valign="top"><a id="af93781c0e8136a82e41080701719d996" name="af93781c0e8136a82e41080701719d996"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Options_description</b> = <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#ad65db0c4fdf22bf5723dc3018174b4aa">Peer_socket_options::Options_description</a></td></tr>
<tr class="memdesc:af93781c0e8136a82e41080701719d996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for boost.program_options config options description. See <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1" title="Modifies a boost.program_options options description object to enable subsequent parsing of a command...">setup_config_parsing()</a>. <br /></td></tr>
<tr class="separator:af93781c0e8136a82e41080701719d996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6733e4efbec3ed97b2460bf50d7cc67c"><td class="memItemLeft" align="right" valign="top"><a id="a6733e4efbec3ed97b2460bf50d7cc67c" name="a6733e4efbec3ed97b2460bf50d7cc67c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Fine_duration</b> = <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a78cbfb464f3251f63a06c753c986d277">Peer_socket_options::Fine_duration</a></td></tr>
<tr class="memdesc:a6733e4efbec3ed97b2460bf50d7cc67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time duration, with fine precision. <br /></td></tr>
<tr class="separator:a6733e4efbec3ed97b2460bf50d7cc67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e19fc9671473ace300d457f7334dc31"><td class="memItemLeft" align="right" valign="top"><a id="a5e19fc9671473ace300d457f7334dc31" name="a5e19fc9671473ace300d457f7334dc31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node_options</b> ()</td></tr>
<tr class="memdesc:a5e19fc9671473ace300d457f7334dc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> with values equal to those used by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> when the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> creator chooses not to supply custom options. <br /></td></tr>
<tr class="separator:a5e19fc9671473ace300d457f7334dc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5819e60ed58aafb496e39962c89215f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1">setup_config_parsing</a> (<a class="el" href="structflow_1_1net__flow_1_1Node__options.html#af93781c0e8136a82e41080701719d996">Options_description</a> *opts_desc)</td></tr>
<tr class="memdesc:a5819e60ed58aafb496e39962c89215f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a boost.program_options options description object to enable subsequent parsing of a command line or config file into the data members of this object, as well printing a help message about these options to an <code>ostream</code>.  <a href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1">More...</a><br /></td></tr>
<tr class="separator:a5819e60ed58aafb496e39962c89215f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aea7861f3c7739f8e588293d16a2de447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#aea7861f3c7739f8e588293d16a2de447">m_st_capture_interrupt_signals_internally</a></td></tr>
<tr class="memdesc:aea7861f3c7739f8e588293d16a2de447"><td class="mdescLeft">&#160;</td><td class="mdescRight">If and only if this is <code>true</code>, the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will detect SIGINT and SIGTERM (or your OS's version thereof); upon seeing such a signal, it will fire <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a>, which will interrupt all blocking operations, conceptually similarly to POSIX's <code>EINTR</code>.  <a href="structflow_1_1net__flow_1_1Node__options.html#aea7861f3c7739f8e588293d16a2de447">More...</a><br /></td></tr>
<tr class="separator:aea7861f3c7739f8e588293d16a2de447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78baaf1a911c8d490a13278422307e8a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a78baaf1a911c8d490a13278422307e8a">m_st_low_lvl_max_buf_size</a></td></tr>
<tr class="memdesc:a78baaf1a911c8d490a13278422307e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max size to ask the OS to set our UDP socket's receive buffer to in order to minimize loss if we can't process datagrams fast enough.  <a href="structflow_1_1net__flow_1_1Node__options.html#a78baaf1a911c8d490a13278422307e8a">More...</a><br /></td></tr>
<tr class="separator:a78baaf1a911c8d490a13278422307e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef8889be34024b07eff3211a3213d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a6733e4efbec3ed97b2460bf50d7cc67c">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#abef8889be34024b07eff3211a3213d5f">m_st_timer_min_period</a></td></tr>
<tr class="memdesc:abef8889be34024b07eff3211a3213d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time period such that the boost.asio timer implementation for this platform is able to accurately able to schedule events within this time period or greater.  <a href="structflow_1_1net__flow_1_1Node__options.html#abef8889be34024b07eff3211a3213d5f">More...</a><br /></td></tr>
<tr class="separator:abef8889be34024b07eff3211a3213d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cb19cf77ac787103ac616f4415eaf9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a99cb19cf77ac787103ac616f4415eaf9">m_dyn_max_packets_per_main_loop_iteration</a></td></tr>
<tr class="memdesc:a99cb19cf77ac787103ac616f4415eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UDP net-stack may deliver 2 or more datagrams to the Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> at the same time.  <a href="structflow_1_1net__flow_1_1Node__options.html#a99cb19cf77ac787103ac616f4415eaf9">More...</a><br /></td></tr>
<tr class="separator:a99cb19cf77ac787103ac616f4415eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c732d10914f406cc43a2c20cc800c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a88c732d10914f406cc43a2c20cc800c6">m_dyn_low_lvl_max_packet_size</a></td></tr>
<tr class="memdesc:a88c732d10914f406cc43a2c20cc800c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any incoming low-level (UDP) packet will be truncated to this size.  <a href="structflow_1_1net__flow_1_1Node__options.html#a88c732d10914f406cc43a2c20cc800c6">More...</a><br /></td></tr>
<tr class="separator:a88c732d10914f406cc43a2c20cc800c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad041b807fddff912fd6f302abeb88a2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#ad041b807fddff912fd6f302abeb88a2f">m_dyn_guarantee_one_low_lvl_in_buf_per_socket</a></td></tr>
<tr class="memdesc:ad041b807fddff912fd6f302abeb88a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This very inside-baseball setting controls the allocation/copy behavior of the UDP receive-deserialize operation sequence.  <a href="structflow_1_1net__flow_1_1Node__options.html#ad041b807fddff912fd6f302abeb88a2f">More...</a><br /></td></tr>
<tr class="separator:ad041b807fddff912fd6f302abeb88a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b56a75a4b6dba57daeef79b0b880f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a71b56a75a4b6dba57daeef79b0b880f7">m_dyn_sock_opts</a></td></tr>
<tr class="memdesc:a71b56a75a4b6dba57daeef79b0b880f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of per-Peer_socket options in this per-Node set of options.  <a href="structflow_1_1net__flow_1_1Node__options.html#a71b56a75a4b6dba57daeef79b0b880f7">More...</a><br /></td></tr>
<tr class="separator:a71b56a75a4b6dba57daeef79b0b880f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A set of low-level options affecting a single Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, including <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects and other objects subsequently generated by that Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Typically these values can be left at defaults, and thus the <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> user normally need not deal with these objects. However, if low-level tuning of Flow internals is needed, you can use this <code>struct</code>.</p>
<p >This is just a simple <code>struct</code> with a couple of utilities to serialize (to <code>ostream</code>) and deserialize (from a config file or command line) the values in the <code>struct</code>; it is not connected to any other object (for example, it can exist with no <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>).</p>
<p >You may read from and write to members of this <code>struct</code> at will, and no checking will be performed; moreover, doing so will have no effect other than the field being read or written.</p>
<p >Fields are validated and potentially take effect, however, when you pass a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> object to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> always copies the given <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> and never saves a reference to it. All of that applies equally to <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>.</p>
<p ><a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> contains a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a71b56a75a4b6dba57daeef79b0b880f7" title="The set of per-Peer_socket options in this per-Node set of options.">m_dyn_sock_opts</a> (a very similar, in spirit, <code>struct</code>) within it. Options stored within that are per-<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">flow::net_flow::Peer_socket</a> options. For example, <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a78baaf1a911c8d490a13278422307e8a" title="The max size to ask the OS to set our UDP socket&#39;s receive buffer to in order to minimize loss if we ...">m_st_low_lvl_max_buf_size</a> applies to the entire <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> at all times and is stored directly in <code>*this</code> (as there is only one UDP buffer for the entire <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>); whereas max-block-size can be different for each individual <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and is thus stored in <code>this-&gt;m_dyn_sock_opts</code>. See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> for how per-socket options are distributed to subsequent sockets as connections are made.</p>
<p >The <code>struct</code>, when default-constructed, contains sane default values as used by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> when not provided with a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> object. Alternatively, you can get a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s existing set of options via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">Node::options()</a>.</p>
<p >After obtaining a <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> either way, you may assign values to it manually.</p>
<p >Alternatively, you can fill it parsing a config file or command line using boost.program_options (which makes it a snap) with the help of <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1" title="Modifies a boost.program_options options description object to enable subsequent parsing of a command...">Node_options::setup_config_parsing()</a>, which will provide a program_options-suitable <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#af93781c0e8136a82e41080701719d996" title="Short-hand for boost.program_options config options description. See setup_config_parsing().">Options_description</a> object to enable this parsing. You may conversely print <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#af93781c0e8136a82e41080701719d996" title="Short-hand for boost.program_options config options description. See setup_config_parsing().">Options_description</a> to an <code>ostream</code> (e.g., <code>cout</code>) for full help text on the meaning of each option and the defaults.</p>
<p >You may also print a filled <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> itself to an <code>ostream</code> for the current settings stored in that object.</p>
<h3>Thready safety</h3>
<p >Same as any <code>struct</code> with no locking done therein.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> constructor, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">Node::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>. </dd>
<dd>
<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">Peer_socket::options()</a>. </dd>
<dd>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5819e60ed58aafb496e39962c89215f1" name="a5819e60ed58aafb496e39962c89215f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5819e60ed58aafb496e39962c89215f1">&#9670;&nbsp;</a></span>setup_config_parsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node_options::setup_config_parsing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#af93781c0e8136a82e41080701719d996">Options_description</a> *&#160;</td>
          <td class="paramname"><em>opts_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies a boost.program_options options description object to enable subsequent parsing of a command line or config file into the data members of this object, as well printing a help message about these options to an <code>ostream</code>. </p>
<p >In particular, after executing this method:</p>
<ul>
<li>If you output <code>*opts_desc</code> to an <code>ostream</code>, the <code>ostream</code> will get a detailed description of each option, its symbolic name (for config file or command line), and its value if the config file or command line omits this option (the default). This default will equal to the value of that particular option in a default-constructed <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>.</li>
<li>If you perform something like the following code snippet, then <code>*this</code> will now be filled with values parsed from <code>ifstream F</code> (and default values for any omitted values):</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>opts = boost::program_options;</div>
<div class="line"><a class="code hl_struct" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> flow_opts;</div>
<div class="line">opts::options_description opts_desc;</div>
<div class="line">std::ifstream F(...);</div>
<div class="line">flow_opts.<a class="code hl_function" href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1">setup_config_parsing</a>(&amp;opts_desc);</div>
<div class="line">opts::variables_map cfg_vars;</div>
<div class="line">opts::store(opts::parse_config_file(F, *opts_desc), cfg_vars);</div>
<div class="line">opts::notify(cfg_vars);</div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node__options_html"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node__options.html">flow::net_flow::Node_options</a></div><div class="ttdoc">A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...</div><div class="ttdef"><b>Definition:</b> options.hpp:449</div></div>
<div class="ttc" id="astructflow_1_1net__flow_1_1Node__options_html_a5819e60ed58aafb496e39962c89215f1"><div class="ttname"><a href="structflow_1_1net__flow_1_1Node__options.html#a5819e60ed58aafb496e39962c89215f1">flow::net_flow::Node_options::setup_config_parsing</a></div><div class="ttdeci">void setup_config_parsing(Options_description *opts_desc)</div><div class="ttdoc">Modifies a boost.program_options options description object to enable subsequent parsing of a command...</div><div class="ttdef"><b>Definition:</b> options.cpp:146</div></div>
</div><!-- fragment --><p >Note the default values will come from the current values inside <code>*this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts_desc</td><td>The <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#af93781c0e8136a82e41080701719d996" title="Short-hand for boost.program_options config options description. See setup_config_parsing().">Options_description</a> object into which to load the help information, defaults, and mapping to members of <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad041b807fddff912fd6f302abeb88a2f" name="ad041b807fddff912fd6f302abeb88a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad041b807fddff912fd6f302abeb88a2f">&#9670;&nbsp;</a></span>m_dyn_guarantee_one_low_lvl_in_buf_per_socket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Node_options::m_dyn_guarantee_one_low_lvl_in_buf_per_socket</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This very inside-baseball setting controls the allocation/copy behavior of the UDP receive-deserialize operation sequence. </p>
<p >When enabled, there is exactly one input buffer large enough to hold any one serialized incoming packet; any deserialized data (including DATA and ACK payloads) are stored in separately allocated per-packet buffers; and and the input buffer is repeatedly reused without reallocation. When disabled, however, at least some packet types (most notably DATA) will use the zero-copy principle, having the deserializer take ownership of the input buffer and access pieces inside it as post-deserialization values (most notably the DATA payload); in this case the input buffer has to be reallocated between UDP reads. As of this writing the former behavior seems to be somewhat faster, especially if low-lvl-max-packet-size is unnecessarily large; but arguably the zero-copy behavior may become faster if some implementation details related to this change. So this switch seemed worth keeping. </p>

</div>
</div>
<a id="a88c732d10914f406cc43a2c20cc800c6" name="a88c732d10914f406cc43a2c20cc800c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c732d10914f406cc43a2c20cc800c6">&#9670;&nbsp;</a></span>m_dyn_low_lvl_max_packet_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node_options::m_dyn_low_lvl_max_packet_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Any incoming low-level (UDP) packet will be truncated to this size. </p>
<p >This should be well above per-socket max-block-size (# of bytes of user payload per DATA packet). There will only be one buffer of this size in memory at a time, so no need to be too stingy, but on the other hand certain allocation/deallocation behavior may cause performance drops if this unnecessarily large. </p>

</div>
</div>
<a id="a99cb19cf77ac787103ac616f4415eaf9" name="a99cb19cf77ac787103ac616f4415eaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cb19cf77ac787103ac616f4415eaf9">&#9670;&nbsp;</a></span>m_dyn_max_packets_per_main_loop_iteration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flow::net_flow::Node_options::m_dyn_max_packets_per_main_loop_iteration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The UDP net-stack may deliver 2 or more datagrams to the Flow <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> at the same time. </p>
<p >To lower overhead and increase efficiency, Flow will process all such datagrams &ndash; and any more that may arrive during this processing &ndash; before preparing any resulting outgoing messages, such as acknowledgments or more data packets. In high-speed conditions this may result in excessive burstiness of outgoing traffic. This option's value places a limit on the number of datagrams to process before constructing and sending any resulting outgoing messages to prevent this burstiness. If 0, there is no limit. </p>

</div>
</div>
<a id="a71b56a75a4b6dba57daeef79b0b880f7" name="a71b56a75a4b6dba57daeef79b0b880f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b56a75a4b6dba57daeef79b0b880f7">&#9670;&nbsp;</a></span>m_dyn_sock_opts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> flow::net_flow::Node_options::m_dyn_sock_opts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of per-Peer_socket options in this per-Node set of options. </p>
<p >This represents the per-socket options each subsequent socket generated in the corresponding <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will get, unless user specifies a custom set of such options.</p>
<p >Note that, in the context of the per-Node options set, this is dynamic; any per-socket option (even a static one) must be changeable in the global per-Node options set, as otherwise it would just be a regular per-Node data member in <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a>, as it could never change anyway, so no point in having it be per-Peer_socket. </p>

</div>
</div>
<a id="aea7861f3c7739f8e588293d16a2de447" name="aea7861f3c7739f8e588293d16a2de447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7861f3c7739f8e588293d16a2de447">&#9670;&nbsp;</a></span>m_st_capture_interrupt_signals_internally</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Node_options::m_st_capture_interrupt_signals_internally</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If and only if this is <code>true</code>, the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will detect SIGINT and SIGTERM (or your OS's version thereof); upon seeing such a signal, it will fire <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a>, which will interrupt all blocking operations, conceptually similarly to POSIX's <code>EINTR</code>. </p>
<p >If this is <code>true</code>, the user may register their own signal handler(s) (for any purpose whatsoever) using <code>boost::asio::signal_set</code>. However, behavior is undefined if the program registers signal handlers via any other API, such as <code>sigaction()</code> or <code>signal()</code>. If you need to set up such a non-<code>signal_set</code> signal handler, AND you require <code>EINTR</code>-like behavior, then (1) set this option to <code>false</code>; (2) trap SIGINT and SIGTERM yourself; (3) in your handlers for the latter, simply call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a>. Similarly, if you want custom behavior regarding <a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861" title="Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blo...">Node::interrupt_all_waits()</a>, feel free to call it whenever you want (not necessarily even from a signal handler), and set this to <code>false</code>. However, if a typical, common-sense behavior is what you're after &ndash; and either don't need additional signal handling or are OK with using <code>signal_set</code> for it &ndash; then setting this to <code>true</code> is a good option. </p>

</div>
</div>
<a id="a78baaf1a911c8d490a13278422307e8a" name="a78baaf1a911c8d490a13278422307e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78baaf1a911c8d490a13278422307e8a">&#9670;&nbsp;</a></span>m_st_low_lvl_max_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node_options::m_st_low_lvl_max_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The max size to ask the OS to set our UDP socket's receive buffer to in order to minimize loss if we can't process datagrams fast enough. </p>
<p >This should be as high as possible while being "acceptable" in terms of memory. However, the OS will probably have its own limit and may well pick a limit that is the minimum of that limit and this value. </p>

</div>
</div>
<a id="abef8889be34024b07eff3211a3213d5f" name="abef8889be34024b07eff3211a3213d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef8889be34024b07eff3211a3213d5f">&#9670;&nbsp;</a></span>m_st_timer_min_period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html#a6733e4efbec3ed97b2460bf50d7cc67c">Fine_duration</a> flow::net_flow::Node_options::m_st_timer_min_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A time period such that the boost.asio timer implementation for this platform is able to accurately able to schedule events within this time period or greater. </p>
<p >If you select 0, the code will decide what this value is based on the platform, but its logic for this may or may not be correct (actually it will probably be correct but possibly too conservative [large], causing timer coarseness in mechanisms like the rather critical packet pacing). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>net_flow/<a class="el" href="options_8hpp.html">options.hpp</a></li>
<li>net_flow/<a class="el" href="options_8cpp.html">options.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 9 2024 07:06:13 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
