<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::log::Async_file_logger Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1log.html">log</a></li><li class="navelem"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html">Async_file_logger</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classflow_1_1log_1_1Async__file__logger-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::log::Async_file_logger Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An implementation of <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> that logs messages to a given file-system path but never blocks any logging thread for file I/O; suitable for heavy-duty file logging.  
 <a href="classflow_1_1log_1_1Async__file__logger.html#details">More...</a></p>

<p><code>#include &lt;async_file_logger.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::log::Async_file_logger:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Async__file__logger__inherit__graph.svg" width="391" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::log::Async_file_logger:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1log_1_1Async__file__logger__coll__graph.svg" width="527" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html">Throttling_cfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls behavior of the throttling algorithm as described in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> doc header Throttling section.  <a href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec2b1796c81b020cacea493e21e19562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aec2b1796c81b020cacea493e21e19562">Async_file_logger</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *backup_logger_ptr, <a class="el" href="classflow_1_1log_1_1Config.html">Config</a> *config, const fs::path &amp;log_path, bool capture_rotate_signals_internally)</td></tr>
<tr class="memdesc:aec2b1796c81b020cacea493e21e19562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs logger to subsequently log to the given file-system path.  <a href="classflow_1_1log_1_1Async__file__logger.html#aec2b1796c81b020cacea493e21e19562">More...</a><br /></td></tr>
<tr class="separator:aec2b1796c81b020cacea493e21e19562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48ec685cc9951a37bb670dd92fe1f4e"><td class="memItemLeft" align="right" valign="top"><a id="ae48ec685cc9951a37bb670dd92fe1f4e" name="ae48ec685cc9951a37bb670dd92fe1f4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Async_file_logger</b> () override</td></tr>
<tr class="memdesc:ae48ec685cc9951a37bb670dd92fe1f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes out anything buffered, returns resources/closes output file(s); then returns. <br /></td></tr>
<tr class="separator:ae48ec685cc9951a37bb670dd92fe1f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139ac22e5953e52e03648860a15e3fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd">should_log</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> sev, const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;component) const override</td></tr>
<tr class="memdesc:ad139ac22e5953e52e03648860a15e3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements interface method by returning <code>true</code> if the severity and component (which is allowed to be null) indicate it should; and if so potentially applies the throttling algorithm's result as well.  <a href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd">More...</a><br /></td></tr>
<tr class="separator:ad139ac22e5953e52e03648860a15e3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd773546633aec017f2041feb3a75dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#afd773546633aec017f2041feb3a75dd3">logs_asynchronously</a> () const override</td></tr>
<tr class="memdesc:afd773546633aec017f2041feb3a75dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements interface method by returning <code>true</code>, indicating that this <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> may need the contents of <code>*metadata</code> and <code>msg</code> passed to <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> even after that method returns.  <a href="classflow_1_1log_1_1Async__file__logger.html#afd773546633aec017f2041feb3a75dd3">More...</a><br /></td></tr>
<tr class="separator:afd773546633aec017f2041feb3a75dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa557c0f55c1044161acc8fb54c115a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e">do_log</a> (<a class="el" href="structflow_1_1log_1_1Msg__metadata.html">Msg_metadata</a> *metadata, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> msg) override</td></tr>
<tr class="memdesc:aa557c0f55c1044161acc8fb54c115a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements interface method by asynchronously logging the message and some subset of the metadata in a fashion controlled by <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4" title="Reference to the config object passed to constructor.">m_config</a>.  <a href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e">More...</a><br /></td></tr>
<tr class="separator:aa557c0f55c1044161acc8fb54c115a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf956d63042cbc0800680996adabfa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aaaf956d63042cbc0800680996adabfa2">log_flush_and_reopen</a> (bool async=true)</td></tr>
<tr class="memdesc:aaaf956d63042cbc0800680996adabfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the log at the file-system path to be flushed/closed (if needed) and re-opened; this will happen as soon as possible but may occur asynchronously after this method exits, unless directed otherwise via <code>async</code> argument.  <a href="classflow_1_1log_1_1Async__file__logger.html#aaaf956d63042cbc0800680996adabfa2">More...</a><br /></td></tr>
<tr class="separator:aaaf956d63042cbc0800680996adabfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2080e8abfc2cd9580c84626ae205010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html">Throttling_cfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010">throttling_cfg</a> () const</td></tr>
<tr class="memdesc:ac2080e8abfc2cd9580c84626ae205010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor returning a copy of the current set of throttling knobs.  <a href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010">More...</a><br /></td></tr>
<tr class="separator:ac2080e8abfc2cd9580c84626ae205010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cff0d6857a8295e41f90d5e9cab711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711">throttling_active</a> () const</td></tr>
<tr class="memdesc:a83cff0d6857a8295e41f90d5e9cab711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the throttling feature is currently in effect.  <a href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711">More...</a><br /></td></tr>
<tr class="separator:a83cff0d6857a8295e41f90d5e9cab711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41893a27e7d36c96c224b24420e26dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a41893a27e7d36c96c224b24420e26dca">throttling_cfg</a> (bool active, const <a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html">Throttling_cfg</a> &amp;cfg)</td></tr>
<tr class="memdesc:a41893a27e7d36c96c224b24420e26dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator that sets the throttling knobs.  <a href="classflow_1_1log_1_1Async__file__logger.html#a41893a27e7d36c96c224b24420e26dca">More...</a><br /></td></tr>
<tr class="separator:a41893a27e7d36c96c224b24420e26dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Logger"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Logger')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a></td></tr>
<tr class="memitem:ac8a2e7a33fe3fbc0c29ead62ed98c022 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">should_log</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a> sev, const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;component) const =0</td></tr>
<tr class="memdesc:ac8a2e7a33fe3fbc0c29ead62ed98c022 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given attributes of a hypothetical message that would be logged, return <code>true</code> if that message should be logged and <code>false</code> otherwise (e.g., if the verbosity of the message is above the current configured verbosity threshold for the <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> specified).  <a href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">More...</a><br /></td></tr>
<tr class="separator:ac8a2e7a33fe3fbc0c29ead62ed98c022 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04868e2a384e60a349ecba8340cd731 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#ae04868e2a384e60a349ecba8340cd731">logs_asynchronously</a> () const =0</td></tr>
<tr class="memdesc:ae04868e2a384e60a349ecba8340cd731 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must return <code>true</code> if <a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2" title="Given a message and its severity, logs that message and possibly severity WITHOUT checking whether it...">do_log()</a> at least sometimes logs the given message and metadata (e.g., time stamp) after <a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2" title="Given a message and its severity, logs that message and possibly severity WITHOUT checking whether it...">do_log()</a> returns; <code>false</code> if this never occurs (i.e., it logs synchronously, always).  <a href="classflow_1_1log_1_1Logger.html#ae04868e2a384e60a349ecba8340cd731">More...</a><br /></td></tr>
<tr class="separator:ae04868e2a384e60a349ecba8340cd731 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934667f16dd6ca0841e521296ab3a6e2 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2">do_log</a> (<a class="el" href="structflow_1_1log_1_1Msg__metadata.html">Msg_metadata</a> *metadata, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> msg)=0</td></tr>
<tr class="memdesc:a934667f16dd6ca0841e521296ab3a6e2 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a message and its severity, logs that message and possibly severity WITHOUT checking whether it should be logged (i.e., without performing logic that <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022" title="Given attributes of a hypothetical message that would be logged, return true if that message should b...">should_log()</a> performs).  <a href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2">More...</a><br /></td></tr>
<tr class="separator:a934667f16dd6ca0841e521296ab3a6e2 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ead44c19a7b15111b2f77656a2ea31 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#ad6ead44c19a7b15111b2f77656a2ea31">this_thread_ostream</a> () const</td></tr>
<tr class="memdesc:ad6ead44c19a7b15111b2f77656a2ea31 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream dedicated to the executing thread and <code>this</code> <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a>, so that the caller can apply state-setting formatters to it.  <a href="classflow_1_1log_1_1Logger.html#ad6ead44c19a7b15111b2f77656a2ea31">More...</a><br /></td></tr>
<tr class="separator:ad6ead44c19a7b15111b2f77656a2ea31 inherit pub_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Unique__id__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Unique__id__holder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">flow::util::Unique_id_holder</a></td></tr>
<tr class="memitem:a90705293787069f52372638d5450ef52 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top"><a id="a90705293787069f52372638d5450ef52" name="a90705293787069f52372638d5450ef52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Unique_id_holder</b> ()</td></tr>
<tr class="memdesc:a90705293787069f52372638d5450ef52 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safely construct an ID whose value is different from any other object of this class, past or future. <br /></td></tr>
<tr class="separator:a90705293787069f52372638d5450ef52 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb06f3132d6a6d1d0c509cbd50b9f768 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#abb06f3132d6a6d1d0c509cbd50b9f768">Unique_id_holder</a> (const <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">Unique_id_holder</a> &amp;)</td></tr>
<tr class="memdesc:abb06f3132d6a6d1d0c509cbd50b9f768 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">This copy constructor is identical in behavior to <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#a90705293787069f52372638d5450ef52" title="Thread-safely construct an ID whose value is different from any other object of this class,...">Unique_id_holder()</a>, the default ctor.  <a href="classflow_1_1util_1_1Unique__id__holder.html#abb06f3132d6a6d1d0c509cbd50b9f768">More...</a><br /></td></tr>
<tr class="separator:abb06f3132d6a6d1d0c509cbd50b9f768 inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24742b697933e623df30056aebbebfae inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#a24742b697933e623df30056aebbebfae">unique_id</a> () const</td></tr>
<tr class="memdesc:a24742b697933e623df30056aebbebfae inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw unique ID identifying this object as well as any object of a derived type.  <a href="classflow_1_1util_1_1Unique__id__holder.html#a24742b697933e623df30056aebbebfae">More...</a><br /></td></tr>
<tr class="separator:a24742b697933e623df30056aebbebfae inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6bab931f868d2a2e933d94f7540b1c inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">Unique_id_holder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#abb6bab931f868d2a2e933d94f7540b1c">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">Unique_id_holder</a> &amp;) const</td></tr>
<tr class="memdesc:abb6bab931f868d2a2e933d94f7540b1c inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assignment operator is a <code>const</code> no-op.  <a href="classflow_1_1util_1_1Unique__id__holder.html#abb6bab931f868d2a2e933d94f7540b1c">More...</a><br /></td></tr>
<tr class="separator:abb6bab931f868d2a2e933d94f7540b1c inherit pub_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4b6dcf5c791e32c517c41c935fba29a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4">m_config</a></td></tr>
<tr class="memdesc:a4b6dcf5c791e32c517c41c935fba29a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the config object passed to constructor.  <a href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4">More...</a><br /></td></tr>
<tr class="separator:a4b6dcf5c791e32c517c41c935fba29a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Unique__id__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Unique__id__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">flow::util::Unique_id_holder</a></td></tr>
<tr class="memitem:af9cbe2432658aac398498e0a7e96405f inherit pub_types_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top"><a id="af9cbe2432658aac398498e0a7e96405f" name="af9cbe2432658aac398498e0a7e96405f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>id_t</b> = uint64_t</td></tr>
<tr class="memdesc:af9cbe2432658aac398498e0a7e96405f inherit pub_types_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw integer type to uniquely identify a thing. 64-bit width should make overflow extremely hard to reach. <br /></td></tr>
<tr class="separator:af9cbe2432658aac398498e0a7e96405f inherit pub_types_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1log_1_1Logger"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1log_1_1Logger')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Logger.html">flow::log::Logger</a></td></tr>
<tr class="memitem:a5600c71ccaa294650c7d34b596d90bf5 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#a5600c71ccaa294650c7d34b596d90bf5">this_thread_set_logged_nickname</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> thread_nickname=<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>(), <a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger_ptr=0, bool also_set_os_name=true)</td></tr>
<tr class="memdesc:a5600c71ccaa294650c7d34b596d90bf5 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or unsets the current thread's logging-worthy string name; optionally sets the OS thread name (such as visible in <code>top</code> output).  <a href="classflow_1_1log_1_1Logger.html#a5600c71ccaa294650c7d34b596d90bf5">More...</a><br /></td></tr>
<tr class="separator:a5600c71ccaa294650c7d34b596d90bf5 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93541a6407b8705a76c7a161c5289b10 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#a93541a6407b8705a76c7a161c5289b10">this_thread_logged_name_os_manip</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a93541a6407b8705a76c7a161c5289b10 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ostream</code> manipulator function that, if output via <code>operator&lt;&lt;</code> to an <code>ostream</code>, will cause the current thread's logging-worthy string name to be output to that stream.  <a href="classflow_1_1log_1_1Logger.html#a93541a6407b8705a76c7a161c5289b10">More...</a><br /></td></tr>
<tr class="separator:a93541a6407b8705a76c7a161c5289b10 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1a0283764e5f85abf00c7cee4c4e19 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#a2d1a0283764e5f85abf00c7cee4c4e19">set_thread_info_in_msg_metadata</a> (<a class="el" href="structflow_1_1log_1_1Msg__metadata.html">Msg_metadata</a> *msg_metadata)</td></tr>
<tr class="memdesc:a2d1a0283764e5f85abf00c7cee4c4e19 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads <code>msg_metadata-&gt;m_call_thread_nickname</code> (if set) or else <code>msg_metadata-&gt;m_call_thread_id</code>, based on whether/how <a class="el" href="classflow_1_1log_1_1Logger.html#a5600c71ccaa294650c7d34b596d90bf5" title="Sets or unsets the current thread&#39;s logging-worthy string name; optionally sets the OS thread name (s...">this_thread_set_logged_nickname()</a> was last called in the current thread.  <a href="classflow_1_1log_1_1Logger.html#a2d1a0283764e5f85abf00c7cee4c4e19">More...</a><br /></td></tr>
<tr class="separator:a2d1a0283764e5f85abf00c7cee4c4e19 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea9da10a13d3b422ba7162a13d7eeb1 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Logger.html#a1ea9da10a13d3b422ba7162a13d7eeb1">set_thread_info</a> (std::string *call_thread_nickname, <a class="el" href="namespaceflow_1_1util.html#a0a4e7b2d3107bd630e0dc0c0b8f2e4de">flow::util::Thread_id</a> *call_thread_id)</td></tr>
<tr class="memdesc:a1ea9da10a13d3b422ba7162a13d7eeb1 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1log_1_1Logger.html#a2d1a0283764e5f85abf00c7cee4c4e19" title="Loads msg_metadata-&gt;m_call_thread_nickname (if set) or else msg_metadata-&gt;m_call_thread_id,...">set_thread_info_in_msg_metadata()</a> but targets the given two variables as opposed to a <a class="el" href="structflow_1_1log_1_1Msg__metadata.html" title="Simple data store containing all of the information generated at every logging call site by flow::log...">Msg_metadata</a>.  <a href="classflow_1_1log_1_1Logger.html#a1ea9da10a13d3b422ba7162a13d7eeb1">More...</a><br /></td></tr>
<tr class="separator:a1ea9da10a13d3b422ba7162a13d7eeb1 inherit pub_static_methods_classflow_1_1log_1_1Logger"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Unique__id__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Unique__id__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html">flow::util::Unique_id_holder</a></td></tr>
<tr class="memitem:a50489177a7731618ca130468c3872748 inherit pub_static_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#af9cbe2432658aac398498e0a7e96405f">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#a50489177a7731618ca130468c3872748">create_unique_id</a> ()</td></tr>
<tr class="memdesc:a50489177a7731618ca130468c3872748 inherit pub_static_methods_classflow_1_1util_1_1Unique__id__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code><a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#a90705293787069f52372638d5450ef52" title="Thread-safely construct an ID whose value is different from any other object of this class,...">Unique_id_holder()</a>.<a class="el" href="classflow_1_1util_1_1Unique__id__holder.html#a24742b697933e623df30056aebbebfae" title="Raw unique ID identifying this object as well as any object of a derived type.">unique_id()</a></code>; useful when all you want is the unique integer itself.  <a href="classflow_1_1util_1_1Unique__id__holder.html#a50489177a7731618ca130468c3872748">More...</a><br /></td></tr>
<tr class="separator:a50489177a7731618ca130468c3872748 inherit pub_static_methods_classflow_1_1util_1_1Unique__id__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pro_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An implementation of <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> that logs messages to a given file-system path but never blocks any logging thread for file I/O; suitable for heavy-duty file logging. </p>
<p >Protects against garbling due to simultaneous logging from multiple threads.</p>
<p >For file logging, the two out-of-the-box <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a></code>s currently suitable are this <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> and <a class="el" href="classflow_1_1log_1_1Simple__ostream__logger.html" title="An implementation of Logger that logs messages to the given ostreams (e.g., cout or an ofstream for a...">Simple_ostream_logger</a>. Vaguely speaking, <a class="el" href="classflow_1_1log_1_1Simple__ostream__logger.html" title="An implementation of Logger that logs messages to the given ostreams (e.g., cout or an ofstream for a...">Simple_ostream_logger</a> is suitable for console (<code>cout</code>, <code>cerr</code>) output; and, in a pinch outside of a heavy-duty production/server environment, for file (<code>ofstream</code>) output. For heavy-duty file logging one should use this <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a>. The primary reason is performance; this is discussed in the <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> class doc header; note <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> logs asynchronously. A secondary reason is additional file-logging-specific utilities &ndash; such as rotation &ndash; are now or in the future going to be in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a>, as its purpose is heavy-duty file logging specifically.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Lacking feature: Compress-as-you-log in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a>. So, optionally, when characters are actually written out to file-system, gzip/zip/whatever them instead of writing plain text. (This is possible at least for gzip.) Background: It is common-place to compress a log file after it has been rotated (e.g., around rotation time: F.log.1.gz -&gt; F.log.2.gz, F.log -&gt; F.log.1 -&gt; F.log.1.gz). It is more space-efficient (at least), however, to write to F.log.gz directly already in compressed form; then rotation requires only renaming (e.g.: F.log.1.gz -&gt; F.log.2.gz, F.log.gz [already gzipped from the start] -&gt; F.log.1.gz).</dd></dl>
<h3>Throttling</h3>
<p >By default this feature is disabled, but one can enable/disable/configure it at will via <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator. For example a viable tactic is to call it once right after construction, before any logging via <code>*this</code>; then call it subsequently in case of dynamic config update.</p>
<p >Throttling deals with the following potential problem which can occur under very heavy <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> throughput (lots of calls being made per unit time, probably from many threads); in practice this would typically only happen if one sets effective verbosity to <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b" title="Message indicates any condition that may occur with great frequency (thus verbose if logged).">Sev::S_TRACE</a> or more-verbose &ndash; as <code>S_INFO</code>-or-less-verbose means <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> should be preventing <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> from being called frequently. For example one might enable TRACE logging temporarily in production to see some details, causing a heavy <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> execution rate. (That said, if your code does INFO-level logging too often, it could happen then too. The official <em>convention</em> is to log INFO-or-more-severe messages only if this would not meaningfully affect the overall perf and responsiveness of the system; but sometimes mistakes are made.)</p>
<p >Internally each <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> call pushes this <em>log request</em> into a central (per <code>*this</code>) queue of log requests; a single (per <code>*this</code>) background thread is always popping this queue ASAP, writing the message to the file, etc., until the queue is emptied; then it sleeps until it becomes non-empty; and so on. If many threads are pushing messages faster than this thread can get through them, then more and more RAM is used to store the enqueued messages. If the throughput doesn't decrease in time, letting this central thread catch up, then the RAM use might cause swapping and eventually out-of-memory (congestive collapse). To be clear, unless congestive collapse is in fact reached, the system is self-correcting, in that given a respite from the log-requests (<a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> calls), the queue size <em>will</em> get down to zero, as will the corresponding memory use. However, if this does not occur early enough, congestive collapse occurs.</p>
<p >Throttling is a safeguard against this. It works as follows. There's a limit H in bytes. We start at Not-Throttling state. If the memory use M grows beyond H, we enter Throttling state. In this state, we reject incoming log requests &ndash; thus letting the system deal with just logging-to-file what it has queued up (in FIFO fashion, naturally) &ndash; until no more such queued-up requests remain. Once the queue is empty, we re-enter Not-Throttling state. In other words beyond a certain total memory use, we throttle; then to exit this state total memory use has to go down to 0, before we un-throttle. The idea is to encourage a sawtooth <code>/\/\/\</code> memory-use pattern when subjected to a firehose of log requests.</p>
<dl class="section note"><dt>Note</dt><dd>An earlier functional design contemplated having a limit L (smaller than H; e.g., picture L = 50% of H), so that mem-use would need to merely get down to L to re-enter Not-Throttling state. However, upon prototyping this, it became clear this hardly improved the experience, instead making it rather confusing to understand in action. E.g., if there's a firehose going at full-blast, and you're fighting it by turning off the fire-hose and letting water drain, but then turn it on again once the container is 50% full, then the draining will "fight" the filling again, potentially losing quite decisively. Trying to then read resulting logs is messy and strange, depending on the 2 rates relative to each other. By comparison, the fill-drain-fill-drain <code>/\/\/\</code> pattern is straightforward to understand; and one can cleanly point out the minima and maxima with log messages. Plus, less configuration/tuning with little to no functional loss = a good thing.</dd></dl>
<p>The particular mechanic of throttling is as follows. If throttling is enabled during a particular call to <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a>, and if and only if <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> would return <code>true</code> based on considerations excluding the throttling feature, then:</p>
<ul>
<li><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> returns <code>true</code> in Not-Throttling state;</li>
<li><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> returns <code>false</code> in Throttling state;</li>
</ul>
<p >Since standard <code>FLOW_LOG_*</code> macros avoid <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> (or even the evaluation of the message &ndash; which is itself quite expensive, possibly quite a bit more expensive than the <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a>) if <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> returns <code>false</code> for a given log call site, during Throttling state enqueuing of messages is blocked (letting the logging-to-file thread catch up). <code><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> == false</code> is how we turn off the firehose.</p>
<p >M starts at 0. Each <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> (queued-up log request) increments M based on the memory-use estimate of the message+metadata passed to <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a>; then it enqueues the log request. Each time the background thread actually writes out the queued-up message+metadata, it decrements M by the same value by which it was incremented in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a>; accordingly the log-request's memory is freed.</p>
<p >This algorithm (computing M via increments and decrements; setting state to Throttling or Not-Throttling) is carried out at all times. However, <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> consults the state (Throttling versus Not-Throttling), if and only if the throttling feature is enabled at that time. If it is not, that state is simply ignored, and <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> only makes the usual <a class="el" href="classflow_1_1log_1_1Config.html" title="Class used to configure the filtering and logging behavior of Loggers; its use in your custom Loggers...">Config</a> verbosity check(s); if that results in <code>true</code> then the message is enqueued. Therefore one can enable throttling at any time and count on its having immediate effect based on actual memory use at that time.</p>
<p >The limit H can also be reconfigured at any time. Essentially <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator takes 2 orthogonal sets of info: 1, whether throttling is to be possible at all (whether Throttling versus Not-Throttling affects <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> from now on); and 2, the limit H which controls the policy about setting the state (Throttling versus Not-Throttling). (2) affects the algorithm that computes that binary state; whereas (1) affects whether that binary state actually controls whether to prevent logging to save memory or not.</p>
<p >If H is modified, the binary state is reinitialized: it is set to Throttling if and only if memory use M at that time exceeds H; else to Not-Throttling. The state prior to the <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator call does not matter in this situation; it is overwritten. This avoids various annoying corner cases and ambiguities around config updates.</p>
<p >Lastly: Initially throttling is disabled, while a certain default value of H is assumed. Hence the above algorithm is active but has no effect, unless you call <code>throttling_cfg(true, ...)</code> to make it have effect and/or change H. You may use <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> accessor and <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a> to get a copy of the current config values.</p>
<h3>Thread safety</h3>
<p >As noted above, simultaneous logging from multiple threads is safe from output corruption, in that simultaneous <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> calls for the same <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> targeting the same stream will log serially to each other. However, if some other code or process writes to the same file, then all bets are off &ndash; so don't.</p>
<p >See thread safety notes and to-dos regarding <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4" title="Reference to the config object passed to constructor.">m_config</a> in <a class="el" href="classflow_1_1log_1_1Simple__ostream__logger.html" title="An implementation of Logger that logs messages to the given ostreams (e.g., cout or an ofstream for a...">Simple_ostream_logger</a> doc header. These apply here also.</p>
<p ><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator does not add any thread safety restrictions: it can be called concurrently with any other method, including <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a>, <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a>, same-named accessor, and <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a>. There is one formal exception: it must not be called concurrently with itself.</p>
<p >There are no other mutable data (state), so that's that.</p>
<h3>Throttling: Functional design rationale notes</h3>
<p >The throttling feature could have been designed differently (in terms of how it should act, functionally speaking), and a couple of questions tend to come up, so let's answer here.</p><ul>
<li>Why have the throttling algorithm always-on, even when <code>!throttling_active()</code> &ndash; which is default at that? Could save cycles otherwise, no? Answer: To begin with, the counting of the memory used (M) should be accurate in case it is (e.g.) high, and one changes <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a> to <code>true</code>. Still, couldn't some things be skipped &ndash; namely perhaps determining whether state is Throttling or Not-Throttling and logging about it &ndash; when <code>!throttling_active()</code>? Answer: Yes, and that might be a decent change in the future, as internally it might be possible to skip some mutex work in that situation which could be a small optimization. It is basically simpler to think about and implement the existing way. (More notes on this in internal comments.)</li>
<li>Why not get rid of <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a> knob entirely? E.g., <a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html#a7a30343e388c65594d06baed25b1aaa9" title="The throttling algorithm will go from Not-Throttling to Throttling state if and only if the current m...">Async_file_logger::Throttling_cfg::m_hi_limit</a> (H) could just be set to a huge value to have an apparently similar effect to <code>!throttling_active()</code>. (The knob could still exist cosmetically speaking but just have the aforementioned effect.) Answer: I (ygoldfel) first thought similarly, while others specified otherwise; but I quickly came around to agreeing with them. It is nice to log about crossing the threshold H even without responding to it by throttling; it could be a signal for a user to look into enabling the feature. Granted, we could also log at every 500k increment, or something like that; but the present setup seemed like a nice balance between power and simplicity.</li>
</ul>
<p >All in all, these choices are defensible but not necessarily the only good ones. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec2b1796c81b020cacea493e21e19562" name="aec2b1796c81b020cacea493e21e19562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2b1796c81b020cacea493e21e19562">&#9670;&nbsp;</a></span>Async_file_logger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::log::Async_file_logger::Async_file_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td>
          <td class="paramname"><em>backup_logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>log_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capture_rotate_signals_internally</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs logger to subsequently log to the given file-system path. </p>
<p >It will append.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Consider adding <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> constructor option to overwrite the file instead of appending.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Controls behavior of this <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a>. In particular, it affects <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> logic (verbosity default and per-component) and output format (such as time stamp format). See thread safety notes in class doc header. This is saved in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4" title="Reference to the config object passed to constructor.">m_config</a>. </td></tr>
    <tr><td class="paramname">log_path</td><td>File-system path to which to write subsequently. Note that no writing occurs until the first <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> call. </td></tr>
    <tr><td class="paramname">backup_logger_ptr</td><td>The <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> to use for <code>*this</code> to log <em>about</em> its logging operations to the actual intended file-system path; or null to not log such things anywhere. If you do not pass in null, but ensure <code>backup_logger_ptr-&gt;<a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a></code> lets through nothing more than <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7" title="Message indicates a not-&quot;bad&quot; condition that is not frequent enough to be of severity Sev::S_TRACE.">Sev::S_INFO</a></code> severity messages for <code>Flow_log_component::S_LOG</code>, then you can expect a reasonable amount of useful output that will not affect performance. Tip: null is a reasonable value. A <a class="el" href="classflow_1_1log_1_1Simple__ostream__logger.html" title="An implementation of Logger that logs messages to the given ostreams (e.g., cout or an ofstream for a...">Simple_ostream_logger</a> logging to <code>cout</code> and <code>cerr</code> (or only <code>cout</code>) is also a good choice, arguably better than null. Lastly, setting verbosity to <code>INFO</code> for <code>*backup_logger_ptr</code> is typically a better choice than <code>TRACE</code> in practice. </td></tr>
    <tr><td class="paramname">capture_rotate_signals_internally</td><td>If and only if this is <code>true</code>, <code>*this</code> will detect SIGHUP (or your OS's version thereof); upon seeing such a signal, it will fire the equivalent of <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aaaf956d63042cbc0800680996adabfa2" title="Causes the log at the file-system path to be flushed/closed (if needed) and re-opened; this will happ...">log_flush_and_reopen()</a>, as needed for classic log rotation. (The idea is: If we are writing to path F, then your outside log rotation tool will rename F -&gt; F.1 [and F.1 -&gt; F.2, etc.]; even as we continue writing to the underlying file after it has been renamed; then the tool sends SIGHUP; we flush/close what is really F.1; reopen at the real path F again, which will create it anew post-rotation.) If <code>false</code> then you'd have to do it yourself if desired. If this is <code>true</code>, the user may register their own signal handler(s) (for any purpose whatsoever) using <code>boost::asio::signal_set</code>. However, behavior is undefined if the program registers signal handlers via any other API, such as <code>sigaction()</code> or <code>signal()</code>. If you need to set up such a non-<code>signal_set</code> signal handler, AND you require rotation behavior, then (1) set this option to <code>false</code>; (2) trap SIGHUP yourself; (3) in your handlers for the latter, simply call <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aaaf956d63042cbc0800680996adabfa2" title="Causes the log at the file-system path to be flushed/closed (if needed) and re-opened; this will happ...">log_flush_and_reopen()</a>. However, if typical, common-sense behavior is what you're after &ndash; and either don't need additional signal handling or are OK with using <code>signal_set</code> for it &ndash; then setting this to <code>true</code> is a good option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa557c0f55c1044161acc8fb54c115a3e" name="aa557c0f55c1044161acc8fb54c115a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa557c0f55c1044161acc8fb54c115a3e">&#9670;&nbsp;</a></span>do_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Async_file_logger::do_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structflow_1_1log_1_1Msg__metadata.html">Msg_metadata</a> *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements interface method by asynchronously logging the message and some subset of the metadata in a fashion controlled by <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a4b6dcf5c791e32c517c41c935fba29a4" title="Reference to the config object passed to constructor.">m_config</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>All information to potentially log in addition to <code>msg</code>. </td></tr>
    <tr><td class="paramname">msg</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classflow_1_1log_1_1Logger.html#a934667f16dd6ca0841e521296ab3a6e2">flow::log::Logger</a>.</p>

</div>
</div>
<a id="aaaf956d63042cbc0800680996adabfa2" name="aaaf956d63042cbc0800680996adabfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf956d63042cbc0800680996adabfa2">&#9670;&nbsp;</a></span>log_flush_and_reopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Async_file_logger::log_flush_and_reopen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the log at the file-system path to be flushed/closed (if needed) and re-opened; this will happen as soon as possible but may occur asynchronously after this method exits, unless directed otherwise via <code>async</code> argument. </p>
<h3>Uses</h3>
<p >Flushing: <code>log_flush_and_reopen(false)</code> is a reasonable and safe way to flush anything buffered in memory to the file. Naturally, for performance, it should not be done frequently. For example this might be useful in the event of an abnormal termination (<code>abort()</code>, etc.), in the signal handler before exiting program.</p>
<p >Rotation: <code>log_flush_and_reopen(true)</code> is useful for rotation purposes; however, you need not do this manually if you decided to (properly) use the <code>capture_rotate_signals_internally == true</code> option in <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> constructor; the procedure will occur on receiving the proper signal automatically.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><code>Async_file_logger::log_flush_and_reopen(true)</code> is great for flushing, such as in an abort-signal handler, but providing just the flushing part without the reopening might be useful. At the moment we've left it this way, due to the vague feeling that closing the file upon flushing it is somehow more final and thus safer (in terms of accomplishing its goal) in an abort-signal scenario. Feelings aren't very scientific though.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">async</td><td>If <code>true</code>, the operation will execute ASAP but asynchronously, the method exiting immediately; else it will complete fully before this method returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd773546633aec017f2041feb3a75dd3" name="afd773546633aec017f2041feb3a75dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd773546633aec017f2041feb3a75dd3">&#9670;&nbsp;</a></span>logs_asynchronously()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::log::Async_file_logger::logs_asynchronously </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements interface method by returning <code>true</code>, indicating that this <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> may need the contents of <code>*metadata</code> and <code>msg</code> passed to <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#aa557c0f55c1044161acc8fb54c115a3e" title="Implements interface method by asynchronously logging the message and some subset of the metadata in ...">do_log()</a> even after that method returns. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p>Implements <a class="el" href="classflow_1_1log_1_1Logger.html#ae04868e2a384e60a349ecba8340cd731">flow::log::Logger</a>.</p>

</div>
</div>
<a id="ad139ac22e5953e52e03648860a15e3fd" name="ad139ac22e5953e52e03648860a15e3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139ac22e5953e52e03648860a15e3fd">&#9670;&nbsp;</a></span>should_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::log::Async_file_logger::should_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements interface method by returning <code>true</code> if the severity and component (which is allowed to be null) indicate it should; and if so potentially applies the throttling algorithm's result as well. </p>
<p >As of this writing not thread-safe against changes to <code>*m_config</code> (but thread-safe agains <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator).</p>
<p >Throttling comes into play if and only if: 1, <code>sev</code> and <code>component</code> indicate <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> should return <code>true</code> in the first place; and 2, <code><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a> == true</code>. In that case the throttling alogorithm's current output (Throttling versus Not-Throttling state) is consulted to determine whether to return <code>true</code> or <code>false</code>. (See Throttling section of class doc header.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Severity of the message. </td></tr>
    <tr><td class="paramname">component</td><td><a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> of the message. Reminder: <code>component.empty() == true</code> is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p>Implements <a class="el" href="classflow_1_1log_1_1Logger.html#ac8a2e7a33fe3fbc0c29ead62ed98c022">flow::log::Logger</a>.</p>

</div>
</div>
<a id="a83cff0d6857a8295e41f90d5e9cab711" name="a83cff0d6857a8295e41f90d5e9cab711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cff0d6857a8295e41f90d5e9cab711">&#9670;&nbsp;</a></span>throttling_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::log::Async_file_logger::throttling_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the throttling feature is currently in effect. </p>
<p >That is: can the throttling computations actually affect <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> output? (It is <em>not</em> about whether log lines are actually being rejected due to throttling right now.) Please see <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> doc header Throttling section for more info.</p>
<p >If <code>true</code> <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> will potentially consider Throttling versus Not-Throttling state; else it will ignore it. If <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator is never called, then this shall be <code>false</code> (feature inactive by default).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> accessor also.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac2080e8abfc2cd9580c84626ae205010" name="ac2080e8abfc2cd9580c84626ae205010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2080e8abfc2cd9580c84626ae205010">&#9670;&nbsp;</a></span>throttling_cfg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html">Async_file_logger::Throttling_cfg</a> flow::log::Async_file_logger::throttling_cfg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor returning a copy of the current set of throttling knobs. </p>
<p >Please see <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> doc header Throttling section for description of their meanings in the algorithm.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1log_1_1Async__file__logger.html#a83cff0d6857a8295e41f90d5e9cab711" title="Whether the throttling feature is currently in effect.">throttling_active()</a> also.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current knobs controlling the behavior of the algorithm that determines Throttling versus Not-Throttling state. If <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ac2080e8abfc2cd9580c84626ae205010" title="Accessor returning a copy of the current set of throttling knobs.">throttling_cfg()</a> mutator is never called, then the values therein will be some valid defaults. </dd></dl>

</div>
</div>
<a id="a41893a27e7d36c96c224b24420e26dca" name="a41893a27e7d36c96c224b24420e26dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41893a27e7d36c96c224b24420e26dca">&#9670;&nbsp;</a></span>throttling_cfg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::log::Async_file_logger::throttling_cfg </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1log_1_1Async__file__logger_1_1Throttling__cfg.html">Throttling_cfg</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutator that sets the throttling knobs. </p>
<p >Please see <a class="el" href="classflow_1_1log_1_1Async__file__logger.html" title="An implementation of Logger that logs messages to a given file-system path but never blocks any loggi...">Async_file_logger</a> doc header Throttling section for description of their meanings in the algorithm.</p>
<h3>Thread safety</h3>
<p >It is okay to call concurrently with any other method on the same <code>*this</code>, except it must not be called concurrently with itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>Whether the feature shall be in effect (if <a class="el" href="classflow_1_1log_1_1Async__file__logger.html#ad139ac22e5953e52e03648860a15e3fd" title="Implements interface method by returning true if the severity and component (which is allowed to be n...">should_log()</a> will potentially consider Throttling versus Not-Throttling state; else it will ignore it). </td></tr>
    <tr><td class="paramname">cfg</td><td>The new values for knobs controlling the behavior of the algorithm that determines Throttling versus Not-Throttling state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4b6dcf5c791e32c517c41c935fba29a4" name="a4b6dcf5c791e32c517c41c935fba29a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6dcf5c791e32c517c41c935fba29a4">&#9670;&nbsp;</a></span>m_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1log_1_1Config.html">Config</a>* const flow::log::Async_file_logger::m_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to the config object passed to constructor. </p>
<p >Note that object is mutable; see notes on thread safety. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>log/<a class="el" href="async__file__logger_8hpp.html">async_file_logger.hpp</a></li>
<li>log/<a class="el" href="async__file__logger_8cpp.html">async_file_logger.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 7 2025 05:46:45 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
