<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classflow_1_1net__flow_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer.  
 <a href="classflow_1_1net__flow_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;node.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node__inherit__graph.svg" width="331" height="191"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Node:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Node__coll__graph.svg" width="331" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd93ba39d6a9cdee60c2ad7da1085902"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">Node</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger, const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;low_lvl_endpoint, <a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *net_env_sim=0, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts=<a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>())</td></tr>
<tr class="memdesc:acd93ba39d6a9cdee60c2ad7da1085902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902">More...</a><br /></td></tr>
<tr class="separator:acd93ba39d6a9cdee60c2ad7da1085902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c53c4848ea976b075a0b56f33eb118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">~Node</a> () override</td></tr>
<tr class="memdesc:a16c53c4848ea976b075a0b56f33eb118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118">More...</a><br /></td></tr>
<tr class="separator:a16c53c4848ea976b075a0b56f33eb118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae148cec361b59237996a4b30c6624b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">running</a> () const</td></tr>
<tr class="memdesc:aae148cec361b59237996a4b30c6624b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is operating.  <a href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5">More...</a><br /></td></tr>
<tr class="separator:aae148cec361b59237996a4b30c6624b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">local_low_lvl_endpoint</a> () const</td></tr>
<tr class="memdesc:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="classflow_1_1net__flow_1_1Node.html#a4cb3dcb90f1dfc44a4343c0e89ce6b83">More...</a><br /></td></tr>
<tr class="separator:a4cb3dcb90f1dfc44a4343c0e89ce6b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c8393930110e2aa0823583e37cabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a893c8393930110e2aa0823583e37cabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an active connect to the specified remote Flow server.  <a href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd">More...</a><br /></td></tr>
<tr class="separator:a893c8393930110e2aa0823583e37cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but sends, as part of the connection handshake, the user-supplied metadata, which the other side can access via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> after accepting the connection.  <a href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a">More...</a><br /></td></tr>
<tr class="separator:ae9a0e5492b9ea005cc12c20c8e7cec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>.  <a href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5">More...</a><br /></td></tr>
<tr class="separator:aba2e6fc905dbeef3ea9e31bf844f8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (blocking connect, with supplied metadata).  <a href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2">More...</a><br /></td></tr>
<tr class="separator:a6725d69ea1a6457d88abb63cef6e6bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">sync_connect</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect(to, duration::max(), err_code, opt)s</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#ac094b83973fd9af8b45d8f4cb3c14e35">More...</a><br /></td></tr>
<tr class="separator:ac094b83973fd9af8b45d8f4cb3c14e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1043586a0e6413b1118d6c090bf89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">sync_connect_with_metadata</a> (const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;to, const boost::asio::const_buffer &amp;serialized_metadata, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *opts=0)</td></tr>
<tr class="memdesc:a6db1043586a0e6413b1118d6c090bf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2" title="A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...">sync_connect_with_metadata()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Node.html#a6db1043586a0e6413b1118d6c090bf89">More...</a><br /></td></tr>
<tr class="separator:a6db1043586a0e6413b1118d6c090bf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2cd6a6c328a2d5381308258d35d95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">listen</a> (<a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> local_port, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts=0)</td></tr>
<tr class="memdesc:a3c2cd6a6c328a2d5381308258d35d95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a server on the given local Flow port and returns <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which can be used to accept subsequent incoming connections to this server.  <a href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d">More...</a><br /></td></tr>
<tr class="separator:a3c2cd6a6c328a2d5381308258d35d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100464cf0126dbbad39bde1c90a774f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">event_set_create</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ad100464cf0126dbbad39bde1c90a774f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> state with no sockets/events stored; returns this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>.  <a href="classflow_1_1net__flow_1_1Node.html#ad100464cf0126dbbad39bde1c90a774f">More...</a><br /></td></tr>
<tr class="separator:ad100464cf0126dbbad39bde1c90a774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1124027c715d674f113f2d961e4c6861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">interrupt_all_waits</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a1124027c715d674f113f2d961e4c6861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blocking operation's outcome was being interrupted.  <a href="classflow_1_1net__flow_1_1Node.html#a1124027c715d674f113f2d961e4c6861">More...</a><br /></td></tr>
<tr class="separator:a1124027c715d674f113f2d961e4c6861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779cc2429651696df1bca8de73534f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">set_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2779cc2429651696df1bca8de73534f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>) with the given options set.  <a href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3">More...</a><br /></td></tr>
<tr class="separator:a2779cc2429651696df1bca8de73534f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b9c2b9a8a969f5e3715341c433aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">options</a> () const</td></tr>
<tr class="memdesc:a159b9c2b9a8a969f5e3715341c433aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s option set and returns that copy.  <a href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec">More...</a><br /></td></tr>
<tr class="separator:a159b9c2b9a8a969f5e3715341c433aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7b471dd6cd3e3570930b48d30e577"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">max_block_size</a> () const</td></tr>
<tr class="memdesc:a4bd7b471dd6cd3e3570930b48d30e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes of user data per received or sent block on connections generated from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, unless this value is overridden in the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (or friend).  <a href="classflow_1_1net__flow_1_1Node.html#a4bd7b471dd6cd3e3570930b48d30e577">More...</a><br /></td></tr>
<tr class="separator:a4bd7b471dd6cd3e3570930b48d30e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1ecd7c03349fcb26b9692d300a759463"><td class="memItemLeft" align="right" valign="top"><a id="a1ecd7c03349fcb26b9692d300a759463" name="a1ecd7c03349fcb26b9692d300a759463"></a>
static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_NUM_PORTS</b> = Port_space::S_NUM_PORTS</td></tr>
<tr class="memdesc:a1ecd7c03349fcb26b9692d300a759463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow ports in the port space, including <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>. <br /></td></tr>
<tr class="separator:a1ecd7c03349fcb26b9692d300a759463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b913c5c759a465a9fcaa637ddaea99"><td class="memItemLeft" align="right" valign="top"><a id="aa1b913c5c759a465a9fcaa637ddaea99" name="aa1b913c5c759a465a9fcaa637ddaea99"></a>
static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_NUM_SERVICE_PORTS</b> = Port_space::S_NUM_SERVICE_PORTS</td></tr>
<tr class="memdesc:aa1b913c5c759a465a9fcaa637ddaea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "service" ports (ones that can be reserved by number with <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>). <br /></td></tr>
<tr class="separator:aa1b913c5c759a465a9fcaa637ddaea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aadcad6c19587cd0d788570194b2afd"><td class="memItemLeft" align="right" valign="top"><a id="a7aadcad6c19587cd0d788570194b2afd" name="a7aadcad6c19587cd0d788570194b2afd"></a>
static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_NUM_EPHEMERAL_PORTS</b> = Port_space::S_NUM_EPHEMERAL_PORTS</td></tr>
<tr class="memdesc:a7aadcad6c19587cd0d788570194b2afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of Flow "ephemeral" ports (ones reserved locally at random with <code>Node::listen(S_PORT_ANY)</code> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>). <br /></td></tr>
<tr class="separator:a7aadcad6c19587cd0d788570194b2afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b593d90c246cb2e35fc6a0834e6876"><td class="memItemLeft" align="right" valign="top"><a id="a96b593d90c246cb2e35fc6a0834e6876" name="a96b593d90c246cb2e35fc6a0834e6876"></a>
static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_FIRST_SERVICE_PORT</b> = Port_space::S_FIRST_SERVICE_PORT</td></tr>
<tr class="memdesc:a96b593d90c246cb2e35fc6a0834e6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest service port, making the range of service ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">S_NUM_SERVICE_PORTS</a> - 1]. <br /></td></tr>
<tr class="separator:a96b593d90c246cb2e35fc6a0834e6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1021e099c70c1a6e192e65f86debf"><td class="memItemLeft" align="right" valign="top"><a id="aa1d1021e099c70c1a6e192e65f86debf" name="aa1d1021e099c70c1a6e192e65f86debf"></a>
static const <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_FIRST_EPHEMERAL_PORT</b> = Port_space::S_FIRST_EPHEMERAL_PORT</td></tr>
<tr class="memdesc:aa1d1021e099c70c1a6e192e65f86debf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">S_NUM_EPHEMERAL_PORTS</a> - 1]. <br /></td></tr>
<tr class="separator:aa1d1021e099c70c1a6e192e65f86debf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memTemplParams" colspan="2">template&lt;typename Peer_socket_impl_type &gt; </td></tr>
<tr class="memitem:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">sock_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to newly created <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or sub-instance like <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>, depending on the template parameter.  <a href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c">More...</a><br /></td></tr>
<tr class="separator:aa42efbce8c5ea908a253fca2e9b2a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a"><td class="memTemplParams" colspan="2">template&lt;typename Server_socket_impl_type &gt; </td></tr>
<tr class="memitem:ab330b19f4039bab074251111789b568a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">serv_create_forward_plus_ctor_args</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts)</td></tr>
<tr class="memdesc:ab330b19f4039bab074251111789b568a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c" title="Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...">sock_create_forward_plus_ctor_args()</a> but for Server_sockets.  <a href="classflow_1_1net__flow_1_1Node.html#ab330b19f4039bab074251111789b568a">More...</a><br /></td></tr>
<tr class="separator:ab330b19f4039bab074251111789b568a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ab13749ccdf4ab44445f21c77296ffa13"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">S_DEFAULT_CONN_METADATA</a> = 0</td></tr>
<tr class="memdesc:ab13749ccdf4ab44445f21c77296ffa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type and value to supply as user-supplied metadata in SYN, if user chooses to use <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a></code> instead of <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a></code>.  <a href="classflow_1_1net__flow_1_1Node.html#ab13749ccdf4ab44445f21c77296ffa13">More...</a><br /></td></tr>
<tr class="separator:ab13749ccdf4ab44445f21c77296ffa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a distinct IP address and UDP port; and (2) it speaks the Flow protocol over a UDP transport layer. </p>
<p >Here we summarize class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and its entire containing Flow module <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>.</p>
<p >See also flow::asio::Node, a subclass that allows for full use of our API (its superclass) and turns our sockets into boost.asio I/O objects, able to participate with ease in all boost.asio event loops. If you're already very familiar with <code>boost::asio::ip::tcp</code>, you can skip to the <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> doc header. If not, recommend becoming comfortable with the asio-less API, then read the forementioned <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> doc header.</p>
<p >The flow::asio::Node class doc header (as of this writing) includes a compact summary of all network operations supported by the entire hierarchy and hence deserves a look for your convenience.</p>
<h2>Using <a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a>, starting with the present class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> </h2>
<p ><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is an important and central class of the <code>netflow</code> Flow module and thus deserves some semi-philosophical discussion, namely what makes a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> &ndash; why the name? Let's delve into the 2 aforementioned properties of a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.</p>
<h3>A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has a distinct IP address and UDP port: <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a></h3>
<p >A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> binds to an IP address and UDP port, both of which are given (with the usual ephemeral port and IP address&lt;-&gt;interface(s) nomenclature) as an argument at <a class="el" href="classflow_1_1net__flow_1_1Node.html#acd93ba39d6a9cdee60c2ad7da1085902" title="Constructs Node.">Node::Node()</a> construction and can never change over the lifetime of the object. The IP and port together are a <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>, which is a <code>using</code>-alias of boost.asio's <code>boost::asio::ip::udp::endpoint</code> . In the same network (e.g., the Internet) no two <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects (even in separate processes; even on different machines) may be alive (as defined by <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">Node::running()</a> == true</code>) with constructor-provided <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> objects <code>R1</code> and <code>R2</code> such that <code>R1 == R2</code>. In particular, if <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> exists, with <code>n1.running()</code> and <code>n1.local_low_lvl_endpoint() == R1</code>, and on the same machine one attempts to construct <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n2(R2)</code>, such that <code>R1 == R2</code> (their IPs and ports are equal), then <code>n2</code> will fail to properly construct, hence <code>n2.running() == false</code> will be the case, probably due to port-already-bound OS error. (There are counter-examples with NAT'ed IP addresses and special values 0.0.0.0 and port 0, but please just ignore those and other pedantic objections and take the spirit of what I am saying. Ultimately, the point is:</p>
<p ><em>A successfully constructed (<code><a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> == true</code>) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> occupies the same IP-and-UDP "real estate" as would a a mere successfully bound UDP socket.</em></p>
<p >So all that was a long, overbearing way to emphasize that a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> binds to an IP address and UDP port, and a single such combo may have at most one <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> on it (unless it has <code>!running()</code>). <em>That's why it is called a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></em>: it's a node on the network, especially on Internet.</p>
<h3>A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> speaks the <em>Flow network protocol</em> to other, remote Nodes</h3>
<p >If <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> is successfully constructed, and <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n2</code> is as well, the two can communicate via a new protocol implemented by this Flow module. This protocol is capable of working with stream (TCP-like) sockets implemented on top of UDP in a manner analogous to how an OS's net-stack implements TCP over IP. So one could call this Flow/UDP. One can talk Flow/UDP to another Flow/UDP endpoint (a/k/a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>) only; no compatibility with any other protocol is supported. (This isn't, for example, an improvement to one side of TCP that is still compatible with legacy TCPs on the other end; though that is a fertile area for research in its own right.) The socket can also operate in unreliable, message boundary-preserving mode, controllable via a Flow-protocol-native socket option; in which case reliability is the responsibility of the <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> user. By default, though, it's like TCP: message bounds are not preserved; reliability is guaranteed inside the protocol. <code>n1</code> and <code>n2</code> can be local in the same process, or local in the same machine, or remote in the same overall network &ndash; as long as one is routable to the other, they can talk.</p>
<p >For practical purposes, it's important to have idea of a single <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s "weight." Is it light-weight like a UDP or TCP socket? Is it heavy-weight like an Apache server instance? The answer is that it's MUCH close to the former: it is fairly light-weight. As of this writing, internally, it stores a table of peer and server sockets (of which there could be a handful or tons, depending on the user's own API calls prior); and uses at least one dedicated worker thread (essentially not visible to the user but conceptually similar to a UDP or TCP stack user's view of the kernel: it does stuff for one in the background &ndash; for example it can wait for incoming connections, if asked). So, a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is an intricate but fairly light-weight object that stores socket tables (proportional in size to the sockets currently required by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s user) and roughly a single worker thread performing low-level I/O and other minimally CPU-intensive tasks. A <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can get busy if a high-bandwidth network is sending or receiving intense traffic, as is the case for any TCP or UDP net-stack. In fact, a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> can be seen as a little Flow-protocol stack implemented on top of UDP transport. (Historical note: <code>class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code> used to be <code>class Stack</code>, but this implied a heavy weight and misleadingly discouraged multiple constructions in the same program; all that ultimately caused the renaming to <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.)</p>
<h3>Essential properties of Flow network protocol (Flow ports, mux/demuxing)</h3>
<p >A single <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> supports 0 or more (an arbitrary # of) peer-to-peer connections to other <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s. Moreover, given two <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s <code>n1</code> and <code>n2</code>, there can similarly be 0 or more peer-to-peer connections running between the two. In order to allow this, a port (and therefore multiplexing/demultiplexing) system is a feature of Flow protocol. (Whether this features is necessary or even desirable is slightly controversial and not a settled matter &ndash; a to-do on this topic can be found below.)</p>
<p >More specifically, think of a <em>given</em> <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code> as analogous (in terms of is multiplexing capabilities) to one TCP stack running on a one-interface machine. To recap the TCP port-addressing scheme (assuming only 1 interface): The TCP stack has approximately 2^16 (~65k) ports available. One may create and "bind" a server "socket" to (more or less, for our discussion) any 1 of these ports. Let's say a server socket is bound to port P1. If a remote TCP stack successfully connects to such a server-bound port, this results in a passively-connected client "socket," which &ndash; also &ndash; is bound to P1 (bear with me as to how this is possible). Finally, the TCP stack's user may bind an <em>actively</em> connecting client "socket" to another port P2 (P2 =/= P1; as P1 is reserved to that server and passively connected clients from that server). Recall that we're contriving a situation where there is only one other remote stack, so suppose there is the remote, 1-interface TCP stack. Now, let's say a packet arrives along an established connection from this stack. How does our local TCP stack determine to which connection this belongs? This is "demultiplexing." If the packet contains the info "destination port: P2," then that clearly belongs to the actively-connected client we mentioned earlier... but what if it's "dest. port: P1"? This could belong to any number of connections originally passive-connected by incoming server connection requests to port P1. Answer: the packet also contains a "source TCP port" field. So the <em>connection ID</em> (a/k/a <em>socket ID</em>) consists of BOTH pieces of data: (1) destination (local) port; (2) source (remote) port. (Recall that, symmetrically, the remote TCP stack had to have a client bind to some port, and that means no more stuff can bind to that port; so it is unique and can't clash with anything else &ndash; inside that remote stack.) So this tuple uniquely identifies the connection in this scenario of a single-interface local TCP that can have both active client sockets and passive-client-socket-spawning server sockets; and talk to other stacks like it. Of course, there can be more than one remote TCP stack. So the 2-tuple (pair) becomes a 3-tuple (triplet) in our slightly simplified version of reality: (1) destination (local) TCP port; (2) source (remote) IP address; and (3) source (remote) TCP port. (In reality, the local TCP stack can bind to different interfaces, so it becomes a 4-tuple by adding in destination (local) IP address... but that's TCP and is of no interest to our analogy to Flow protocol.)</p>
<p >What about Flow protocol? GIVEN <code>n1</code> and <code>n2</code>, it works just the same. We have a special, TCP-like, Flow port space WITHIN <code>n1</code> and similarly within <code>n2</code>. So if only <code>n1</code> and <code>n2</code> are involved, an <code>n1</code> <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> (class) object can <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> (&lt;&ndash; actual method) on a <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d" title="Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).">net_flow::flow_port_t</a> (&lt;&ndash; alias to 2-byte unsigned as of this writing) port P1; <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> (another method) incoming connections, each still bound to port P1; and <code>n1</code> can also actively <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (another method) to <code>n2</code> at some port over there. Then an incoming UDP packet's intended established connection is demuxed to by a 2-tuple: (1) destination (local) <code>flow_port_t</code>; (2) source (remote) <code>flow_port_t</code>.</p>
<p >In reality, other remote <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s can of course be involved: <code>n3</code>, <code>n4</code>, whatever. As we've established, each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> lives at a UDP endpoint: <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> (again, IP address + UDP port). Therefore, from the stand-point of a given local <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> n1</code>, each established peer-to-peer connection is identified fully by the 5-tuple (marked here with roman numerals):</p><ol type="1">
<li>Local <code>flow_port_t</code> within <code>n1</code>'s port-space (not dissimilar to TCP's port space in size and behavior). (I)</li>
<li>Remote endpoint identifying the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>: <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html" title="Represents the remote endpoint of a Flow-protocol connection; identifies the UDP endpoint of the remo...">Remote_endpoint</a>.<ol type="a">
<li><a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>.<ol type="i">
<li>IP address. (II)</li>
<li>UDP port. (III)</li>
</ol>
</li>
<li>Remote <a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d" title="Logical Flow port type (analogous to a UDP/TCP port in spirit but in no way relevant to UDP/TCP).">net_flow::flow_port_t</a>. (IV)</li>
</ol>
</li>
</ol>
<p >So, that is how it works. Of course, if this complexity is not really necessary for some application, then only really (II) and (III) are truly necessary. (I) and (IV) can just be chosen to be some agreed-upon constant port number. Only one connection can ever exist in this situation, and one would need to create more <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s one side or the other or both to achieve more connections between the same pair of IP addresses, but that's totally reasonable: it's no different from simply binding to more UDP ports. My point here is that the Flow-protocol-invented construct of "Flow ports" (given as <code>flow_port_t</code> values) can be used to conserve UDP ports; but they can also be NOT used, and one can just use more UDP ports, as a "regular" UDP-using pair of applications would, if more than one flow of information is necessary between those two apps. It is up to you. (Again, some arguments can be made for getting rid of (I) and (IV), after all. This possibility is discussed in a below to-do.)</p>
<p >(Do note that, while we've emulated TCP's port scheme, there is no equivalent of IP's "interfaces." Each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> just has a bunch of ports; there is no port table belonging to each of N interfaces or any such thing.)</p>
<h3><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a> API overview</h3>
<p >This is a summary (and some of this is very briefly mentioned above); all the classes and APIs are much more deeply documented in their own right. Also, see above pointer to <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> whose doc header may be immediately helpful to experienced users. Meanwhile, to summarize:</p>
<p >The <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> hands out sockets as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects; it acts as a factory for them (directly) via its <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> and (indirectly) <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> families of methods. It is not possible to construct a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> independently of a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, due to tight coordination between the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and each <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. Moreover each <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is handed out via <code>boost::shared_ptr</code> smart pointer. While not strictly necessary, this is a situation where both the user and a central registry (<a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>) can own the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> at a given time, which is an ideal application for <code>shared_ptr&lt;&gt;</code> that can greatly simplify questions of object ownership and providing auto-<code>delete</code> to boot.</p>
<p >Thus: <code>Node::listen(flow_port_t P)</code> yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Server_socket::Ptr</a>, which will listen for incoming connections on <code>P</code>. <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> (and similar) yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>, one side of a peer-to-peer connection. On the other side, <code>Node::connect(Remote_endpoint R)</code> (where <code>R</code> contains <code>Udp_endpoint U</code>, where value equal to <code>U</code> had been earlier passed to constructor of the <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a></code>ing <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>; and <code>R</code> also contains <code>flow_port_t P</code>, passed to <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a></code>). <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>, too, yields a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>. And thus, if all went well, each side now has a <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a> <code>S1</code> and <code>S2</code>, which &ndash; while originating quite differently &ndash; are now completely equal in capabilities: they are indeed <em>peer</em> sockets. They have methods like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a>.</p>
<p >Further nuances can be explored in the various other doc headers, but I'll mention that both non-blocking behavior (meaning the call always returns immediately, even if unable to immediately perform the desired task such as accept a connection or receive 1 or more bytes) and blocking behavior as supported, as in (for example) a BSD sockets API. However, there is no "blocking" or "non-blocking" mode as in BSD or WinSock (personally I, Yuri, see it as an annoying anachronism). Instead you simply call a method named according to whether it will never block or (possibly &ndash; if appropriate) block. The nomenclature convention is as follows: if the action is <code>X</code> (e.g., <code>X</code> is <code>receive</code> or <code>accept</code>), then <code>-&gt;X()</code> is the non-blocking version; and <code>-&gt;sync_X()</code> is the blocking one. A non-blocking version always exists for any possible action; and a blocking version exists if it makes sense for it to exist. (Exception: <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a> explicitly includes <code>async_</code> prefix contrary to this convention. Partially it's because just calling it <code>wait()</code> &ndash; convention or not &ndash; makes it sound like it's going to block, whereas it emphatically will never do so. ALSO it's because it's a "special" method with unique properties including letting user execute their own code in a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s internal worker thread. So rules go out the window a little bit for that method; hence the slight naming exception.)</p>
<h3>Nomenclature: "low-level" instead of "UDP"</h3>
<p >Side note: You will sometimes see the phrase <code>low_lvl</code> in various identifiers among <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> APIs. <code>low_lvl</code> (low-level) really means "UDP" &ndash; but theoretically some other packet-based transport could be used instead in the future; or it could even be an option to chooose between possible underlying protocols. For example, if <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> moved to kernel-space, the transport could become IP, as it is for TCP. So this nomenclature is a hedge; and also it argubly is nicer/more generic: the fact it's UDP is immaterial; that it's the low-level (from our perspective) protocol is the salient fact. However, <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> is thus named because it is very specifically a gosh-darned UDP port (plus IP address), so hiding from that by naming it <code>Low_Lvl_endpoint</code> (or something) seemed absurd.</p>
<h3>Event, readability, writability, etc.</h3>
<p >Any experienced use of BSD sockets, WinSock, or similar is probably wondering by now, "That sounds reasonable, but
how does the API allow me to wait until I can connect/accept/read/write, letting me do other stuff in the meantime?" Again, one can use a blocking version of basically every operation; but then the wait for readability/writability/etc. may block the thread. One can work around this by creating multiple threads, but multi-threaded coding introduced various difficulties. So, the experienced socketeer will want to use non-blocking operations + an event loop + something that allow one to wait of various states (again, readability, writability, etc.) with various modes of operation (blocking, asynchronous, with or without a timeout, etc.). The most advanced and best way to get these capabilities is to use boost.asio integration (see <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a>). As explained elsewhere (see <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> doc header) this is sometimes not usable in practice. In that case: These capabilities are supplied in the class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. See that class's doc header for further information. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is the <code>select()</code> of this socket API. However it is significantly more convenient AND indeed supports a model that will allow one to use Flow-protocol sockets in a <code>select()</code>- or equivalent-based event loop, making <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> module usable in a true server, such as a web server. That is, you don't just have to write a separate Flow event loop operating independently of your other sockets, file handles, etc. This is an important property in practice. (Again: Ideally you wouldn't need <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> for this; <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a>/etc. might be better to use.)</p>
<h3>Error reporting</h3>
<p >Like all Flow modules, <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> uses error reporting conventions/semantics introduced in <code>namespace</code> <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header Error Reporting section.</p>
<p >In particular, this module does add its own error code set. See <code>namespace</code> <a class="el" href="namespaceflow_1_1net__flow_1_1error.html" title="Namespace containing the net_flow module&#39;s extension of boost.system error conventions,...">net_flow::error</a> doc header which should point you to <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> <code>enum</code>. All error-emitting <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> APIs emit <code>Error_code</code>s assigned from <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> <code>enum</code> values.</p>
<h3>Configurability, statistics, logging</h3>
<p >Great care is taken to provide visibility into the "black box" that is Flow-protocol. That is, while the API follows good practices wherein implementation is shielded away from the user, at the same time the <em>human</em> user has powerful tools to both examine the insides of the library/protocol's performance AND to tweak the parameters of its behavior. Picture a modern automobile: while you're driving at least, it's not going to let you look at or mess with its engine or transmission &ndash; nor do you need to understand how they work; BUT, the onboard monitor will feature screens that tell you about its fuel economy performance, the engine's inner workings, and perhaps a few knobs to control the transmission's performance (for example). Same principles are followed here.</p>
<p >More specifically:</p><ul>
<li><em>Configuration</em> Socket options are supported via <a class="el" href="structflow_1_1net__flow_1_1Node__options.html" title="A set of low-level options affecting a single Flow Node, including Peer_socket objects and other obje...">Node_options</a> and <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a>. These control many aspects of the library's behavior, for example which congestion control algorithm to use. These options can be set programmatically, through a config file, or through command line options. Particular care was taken to make the latter two features seamlessly available by leveraging boost.program_options.</li>
<li><em>Statistics</em> Very detailed stats are kept in <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html" title="A data store that keeps stats about the incoming direction of a Peer_socket connection to another Flo...">Peer_socket_receive_stats</a> and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html" title="A data store that keeps stats about the outgoing direction of a Peer_socket connection to another Flo...">Peer_socket_send_stats</a>, combined with more data in <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html" title="A data store that keeps stats about the a Peer_socket connection.">Peer_socket_info</a>. These can be accessed programmatically; their individual stats can also be accessed programmatically; or they can be logged to any <code>ostream</code>. Plus, the logging system periodically logs them (assuming this logging level is enabled).</li>
<li><em>Logging</em> Like all Flow modules, <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> uses logging conventions/semantics introduced in <code>namespace</code> <a class="el" href="namespaceflow.html" title="Catch-all namespace for the Flow project: A collection of various production-quality modules written ...">flow</a> doc header Logging section.</li>
</ul>
<h3>Multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects</h3>
<p >As mentioned already many times, multiple <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects can exist and function simultaneously (as long as they are not bound to the same conceptual <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a>, or to the same UDP port of at least one IP interface). However, it is worth emphasizing that &ndash; practically speaking &ndash; class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is implemented in such a way as to make a given <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> 100% independent of any other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> in the same process. They don't share working thread(s), data (except <code>static</code> data, probably just constants), any namespaces, port spaces, address spaces, anything. Each <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is independent both API-wise and in terms of internal implementation.</p>
<h3>Thread safety</h3>
<p >All operations safe for simultaneous execution on 2+ separate <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> objects <em>or on the same <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></em>, or on any objects (e.g., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>) returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (Please note the <em>emphasized</em> phrase.) "Operations" are any <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> or Node-returned-object method calls after construction and before destruction of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (In particular, for example, one thread can <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> while another <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>s.) The same guarantee may or may not apply to other classes; see their documentation headers for thread safety information.</p>
<h3>Thread safety of destructor</h3>
<p >Generally it is not safe to destruct a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (i.e., let <a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118" title="Destroys Node.">Node::~Node()</a> get called) while a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> operation is in progress on that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (obviously, in another thread). There is one exception to this: if a blocking operation (any operation with name starting with <code>sync_</code>) has entered its blocking (sleep) phase, it is safe to delete the underlying <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. In practice this means simply that, while you need not lock a given <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> with an external mutex while calling its various methods from different threads (if you really must use multiple threads this way), you should take care to probably join the various threads before letting a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> go away.</p>
<h2>Historical note re. FastTCP, Google BBR </h2>
<h3>Historical note re. FastTCP</h3>
<p >One notable change in this <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> vs. the original libgiga is this one lacks the FastTCP congestion control strategy. I omit the historical reasons for this for now (see to-do regarding re-introducing licensing/history/location/author info, in <a class="el" href="common_8hpp.html">common.hpp</a>).</p>
<p >Addendum to the topic of congestion control: I am not that interested in FastTCP, as I don't see it as cutting-edge any longer. I am interested in Google BBR. It is a goal to implement Google BBR in <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>, as that congestion control algorithm is seen by many as simply the best one available; a bold conclusion given how much research and given-and-take and pros-and-cons discussions have tramspired ever since the original Reno TCP became ubiquitous. Google BBR is (modulo whatever proprietary improvements Google chooses to implement in their closed-source software) publicly documented in research paper(s) and, I believe, available as Google open source.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">flow::net_flow</a> should use <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> for its socket-options mechanism. It is well suited for that purpose, and it uses some ideas from those socket-options in the first place but is generic and much more advanced. Currently <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> socket-options are custom-coded from long before <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> existed.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><code>ostream</code> output operators for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Node.html" title="A subclass of net_flow::Node that adds the ability to easily and directly use net_flow sockets in gen...">asio::Node</a> should exist. Also scour through all types; possibly some others could use the same. (I have been pretty good at already implementing these as-needed for logging; but I may have "missed a spot.")</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>Some of the <code>ostream&lt;&lt;</code> operators we have take <code>X*</code> instead of <code>const X&amp;</code>; this should be changed to the latter for various minor reasons and for consistency.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Actively support IPv6 and IPv4, particularly in dual-stack mode (wherein <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a> would bind to an IPv6 endpoint but accept incoming V4 and V6 connections alike). It already supports it nominally, in that one can indeed listen on either type of address and connect to either as well, but how well it works is untested, and from some outside experience it might involve some subtle provisions internally.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Based on some outside experience, there maybe be problems &ndash; particularly considering the to-do regarding dual-stack IPv6/v4 support &ndash; in servers listening in multiple-IP situations; make sure we support these seamlessly. For example consider a machine with a WAN IP address and a LAN (10.x.x.x) IP address (and possibly IPv6 versions of each also) that (as is typical) binds on all of them at ANY:P (where P is some port; and ANY is the IPv6 version, with dual-stack mode ensuring V4 datagrams are also received). If a client connects to a LAN IP, while in our return datagrams we set the source IP to the default, does it work? Outside experience shows it might not, depending, plus even if in our protocol it does, it might be defeated by some firewall... the point is it requires investigation (e.g., mimic TCP itself; or look into what IETF or Google QUIC does; and so on).</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd93ba39d6a9cdee60c2ad7da1085902" name="acd93ba39d6a9cdee60c2ad7da1085902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd93ba39d6a9cdee60c2ad7da1085902">&#9670;&nbsp;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>low_lvl_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Net__env__simulator.html">Net_env_simulator</a> *&#160;</td>
          <td class="paramname"><em>net_env_sim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Post-condition: <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> ready for arbitrary use. (Internally this includes asynchronously waiting for any incoming UDP packets on the given endpoint.)</p>
<p >Does not block. After exiting this constructor, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aae148cec361b59237996a4b30c6624b5" title="Returns true if and only if the Node is operating.">running()</a> can be used to determine whether <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> initialized or failed to do so; or one can get this from <code>*err_code</code>.</p>
<h3>Potential shared use of <code>Logger *logger</code></h3>
<p >All logging, both in this thread (from which the constructor executes) and any potential internally spawned threads, by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and all objects created through it (directly or otherwise) will be through this Logger. <code>*logger</code> may have been used or not used for any purpose whatsoever prior to this constructor call. However, from now on, <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will assume that <code>*logger</code> will be in exclusive use by this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and no other code until destruction. It is strongly recommended that all code refrains from further use of <code>*logger</code> until the destructor <a class="el" href="classflow_1_1net__flow_1_1Node.html#a16c53c4848ea976b075a0b56f33eb118" title="Destroys Node.">~Node()</a> exits. Otherwise, quality of this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s logging (until destruction) may be lowered in undefined fashion except for the following formal guarantees: the output will not be corrupted from unsafe concurrent logging; and the current thread's nickname (for logging purposes only) will not be changed at any point. Less formally, interleaved or concurrent use of the same Logger might result in such things as formatters from <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> log calls affecting output of your log calls or vice versa. Just don't, and it'll look good.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low_lvl_endpoint</td><td>The UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. E.g.: <code>Udp_endpoint(Ip_address_v4::any(), 1234)</code> // UDP port 1234 on all IPv4 interfaces. </td></tr>
    <tr><td class="paramname">logger</td><td>The Logger implementation through which all logging from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> will run. See notes on logger ownership above. </td></tr>
    <tr><td class="paramname">net_env_sim</td><td>Network environment simulator to use to simulate (fake) external network conditions inside the code, e.g., for testing. If 0, no such simulation will occur. Otherwise the code will add conditions such as loss and latency (in addition to any present naturally) and will take ownership of the the passed in pointer (meaning, we will <code>delete</code> as we see fit; and you must never do so from now on). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> failed to initialize), <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>The low-level per-Node options to use. The default uses reasonable values that normally need not be changed. No reference to opts is saved; it is only copied. See also <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">Node::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">Node::options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">Peer_socket::options()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16c53c4848ea976b075a0b56f33eb118" name="a16c53c4848ea976b075a0b56f33eb118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c53c4848ea976b075a0b56f33eb118">&#9670;&nbsp;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Closes all <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects as if by <code>sock-&gt;close_abruptly()</code>. Then closes all <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects Then closes all <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects as if by <code>event_set-&gt;close()</code>. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> objects closed as if by what?</dd></dl>
<p >Frees all resources except the objects still shared by <code>shared_ptr&lt;&gt;</code>s returned to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> user. All <code>shared_ptr&lt;&gt;</code> instances inside <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> sharing the latter objects are, however, eliminated. Therefore any such object will be deleted the moment the user also eliminates all her <code>shared_ptr&lt;&gt;</code> instances sharing that same object; any object for which that is already the case is deleted immediately.</p>
<p >Does not block.</p>
<p >Note: as a corollary of the fact this acts as if <code>{Peer|Server_}socket::close_abruptly()</code> and <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>, in that order, were called, all event waits on the closed sockets (<code>sync_send()</code>, <code>sync_receive()</code>, <code>sync_accept()</code>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>) will execute their on-event behavior (<code>sync_send()</code> return, <code>sync_receive()</code> return, <code>sync_accept()</code> return, <code>sync_wait()</code> return and invoke handler, respectively). Since <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a> is executed soon after the sockets close, those <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects are cleared. Therefore, the user on-event behavior handling may find that, despite a given event firing, the containing <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> is empty; or they may win the race and see an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> with a bunch of <code>S_CLOSED</code> sockets. Either way, no work is possible on these sockets.</p>
<p >Rationale for previous paragraph: We want to wake up any threads or event loops waiting on these sockets, so they don't sit around while the underlying <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is long since destroyed. On the other hand, we want to free any resources we own (including socket handles inside <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>). This solution satisfies both desires. It does add a bit of non-determinism (easily handled by the user: any socket in the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>, even if user wins the race, will be <code>S_CLOSED</code> anyway). However it introduces no actual thread safety problems (corruption, etc.).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>Provide another method to shut down everything gracefully? </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a893c8393930110e2aa0823583e37cabd" name="a893c8393930110e2aa0823583e37cabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893c8393930110e2aa0823583e37cabd">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an active connect to the specified remote Flow server. </p>
<p >Returns a safe pointer to a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. The socket's state will be some substate of <code>S_OPEN</code> at least initially. The connection operation, involving network traffic, will be performed asynchronously.</p>
<p >One can treat the resulting socket as already connected; its Writable and Readable status can be determined; once Readable or Writable one can receive or send, respectively.</p>
<p >Port selection: An available local Flow port will be chosen and will be available for information purposes via sock-&gt;local_port(), where <code>sock</code> is the returned socket. The port will be in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">Node::S_NUM_EPHEMERAL_PORTS</a> - 1]. Note that there is no overlap between that range and the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">Node::S_NUM_SERVICE_PORTS</a> - 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The remote Flow port to which to connect. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>The low-level per-Peer_socket options to use in the new socket. If null (typical), the per-socket options template in <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">Node::options()</a> is used. If not null, the given per-socket options are first validated and, if valid, used. If invalid, it is an error. See also <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">Peer_socket::set_options()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">Peer_socket::options()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, which is in the <code>S_OPEN</code> main state; or null pointer, indicating an error. </dd></dl>

</div>
</div>
<a id="ae9a0e5492b9ea005cc12c20c8e7cec9a" name="ae9a0e5492b9ea005cc12c20c8e7cec9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a0e5492b9ea005cc12c20c8e7cec9a">&#9670;&nbsp;</a></span>connect_with_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but sends, as part of the connection handshake, the user-supplied metadata, which the other side can access via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> after accepting the connection. </p>
<dl class="section note"><dt>Note</dt><dd>It is up to the user to serialize the metadata portably. One recommended convention is to use <code>boost::endian::native_to_little()</code> (and similar) before connecting; and on the other side use the reverse (<code>boost::endian::little_to_native()</code>) before using the value. Packet dumps will show a flipped (little-endian) representation, while with most platforms the conversion will be a no-op at compile time. Alternatively use <code>native_to_big()</code> and vice-versa. </dd>
<dd>
Why provide this metadata facility? After all, they could just send the data upon connection via send()/receive()/etc. Answers: Firstly, this is guaranteed to be delivered (assuming successful connection), even if reliability (such as via retransmission) is disabled in socket options (opts argument). For example, if a reliability mechanism (such as FEC) is built on top of the Flow layer, parameters having to do with configuring that reliability mechanism can be bootstrapped reliably using this mechanism. Secondly, it can be quite convenient (albeit not irreplaceably so) for connection-authenticating techniques like security tokens known by both sides. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>Data copied and sent to the other side during the connection establishment. The other side can get equal data using <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a>. The returned socket <code>sock</code> also stores it; it's similarly accessible via sock-&gt;get_connect_metadata() on this side. The metadata must fit into a single low-level packet; otherwise <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a> error is returned. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </dd></dl>

</div>
</div>
<a id="ad100464cf0126dbbad39bde1c90a774f" name="ad100464cf0126dbbad39bde1c90a774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad100464cf0126dbbad39bde1c90a774f">&#9670;&nbsp;</a></span>event_set_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Event_set::Ptr</a> flow::net_flow::Node::event_set_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> in <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a2855bd159b6e63bf448ed1f41b608975a9ed0ac855342c04cf614bf2fb5549657" title="Default state; valid Event_set that is not currently waiting on events.">Event_set::State::S_INACTIVE</a> state with no sockets/events stored; returns this <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a>; or null pointer, indicating an error. </dd></dl>

</div>
</div>
<a id="a1124027c715d674f113f2d961e4c6861" name="a1124027c715d674f113f2d961e4c6861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1124027c715d674f113f2d961e4c6861">&#9670;&nbsp;</a></span>interrupt_all_waits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Node::interrupt_all_waits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts any blocking operation, a/k/a wait, and informs the invoker of that operation that the blocking operation's outcome was being interrupted. </p>
<p >Conceptually, this causes a similar fate as a POSIX blocking function exiting with -1/<code>EINTR</code>, for all such functions currently executing. This may be called from any thread whatsoever and, particularly, from signal handlers as well.</p>
<p >Before deciding to call this explicitly from signal handler(s), consider using the simpler <a class="el" href="structflow_1_1net__flow_1_1Node__options.html#aea7861f3c7739f8e588293d16a2de447" title="If and only if this is true, the Node will detect SIGINT and SIGTERM (or your OS&#39;s version thereof); ...">Node_options::m_st_capture_interrupt_signals_internally</a> instead.</p>
<p >The above is vague about how an interrupted "wait" exhibits itself. More specifically, then: Any operation with name <code>sync_...()</code> will return with an error, that error being <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">Error_code</a> <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>. <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>-initiated wait will end, with the handler function being called, passing the Boolean value <code>true</code> to that function. <code>true</code> indicates the wait was interrupted rather than successfully finishing with 1 or more active events (<code>false</code> would've indicated th latter, more typical situation).</p>
<p >Note that various calsses have <code>sync_...()</code> operations, including <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a>), <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>), and <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c2cd6a6c328a2d5381308258d35d95d" name="a3c2cd6a6c328a2d5381308258d35d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2cd6a6c328a2d5381308258d35d95d">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Server_socket::Ptr</a> flow::net_flow::Node::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a server on the given local Flow port and returns <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> which can be used to accept subsequent incoming connections to this server. </p>
<p >Any subsequent incoming connections will be established asynchronously and, once established, can be claimed (as <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects) via Server_server::accept() and friends.</p>
<p >Port specification: You must select a port in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#a96b593d90c246cb2e35fc6a0834e6876" title="The port number of the lowest service port, making the range of service ports [S_FIRST_SERVICE_PORT,...">Node::S_FIRST_SERVICE_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1b913c5c759a465a9fcaa637ddaea99" title="Total number of Flow &quot;service&quot; ports (ones that can be reserved by number with Node::listen()).">Node::S_NUM_SERVICE_PORTS</a> - 1] or the special value <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a>. In the latter case an available port in the range [<a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a>, <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa1d1021e099c70c1a6e192e65f86debf" title="The port number of the lowest ephemeral Flow port, making the range of ephemeral ports [S_FIRST_EPHEM...">Node::S_FIRST_EPHEMERAL_PORT</a> + <a class="el" href="classflow_1_1net__flow_1_1Node.html#a7aadcad6c19587cd0d788570194b2afd" title="Total number of Flow &quot;ephemeral&quot; ports (ones reserved locally at random with Node::listen(S_PORT_ANY)...">Node::S_NUM_EPHEMERAL_PORTS</a> - 1] will be chosen for you. Otherwise we will use the port you explicitly specified.</p>
<p >Note that using <a class="el" href="namespaceflow_1_1net__flow.html#a9dd0c9d8de00fab78d8b0a3f50dad2a9" title="Special Flow port value used to indicate &quot;invalid port&quot; or &quot;please pick a random available ephemeral ...">S_PORT_ANY</a> in this context typically makes sense only if you somehow communicate <code>serv-&gt;local_port()</code> (where <code>serv</code> is the returned socket) to the other side through some other means (for example if both client and server are running in the same program, you could just pass it via variable or function call). Note that there is no overlap between the two aforementioned port ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_port</td><td>The local Flow port to which to bind. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a2c42b01b60ebe4834e9be3933ce94cb6" title="Flow port already reserved.">error::Code::S_PORT_TAKEN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482abb79e941df00b67a8631a9361ee5a4d1" title="Flow port number is not in the valid service port number range.">error::Code::S_INVALID_SERVICE_PORT_NUMBER</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>. </td></tr>
    <tr><td class="paramname">child_sock_opts</td><td>If null, any Peer_sockets that <code>serv-&gt;accept()</code> may return (where <code>serv</code> is the returned <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>) will be initialized with the options set equal to <code><a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>.m_dyn_sock_opts</code>. If not null, they will be initialized with a copy of <code>*child_sock_opts</code>. No reference to <code>*child_sock_opts</code> is saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, which is in the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a" title="Future or current accept()s may be possible. A socket in this state may be Acceptable.">Server_socket::State::S_LISTENING</a> state at least initially; or null pointer, indicating an error. </dd></dl>

</div>
</div>
<a id="a4cb3dcb90f1dfc44a4343c0e89ce6b83" name="a4cb3dcb90f1dfc44a4343c0e89ce6b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb3dcb90f1dfc44a4343c0e89ce6b83">&#9670;&nbsp;</a></span>local_low_lvl_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196">util::Udp_endpoint</a> &amp; flow::net_flow::Node::local_low_lvl_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the UDP endpoint (IP address and UDP port) which will be used for receiving incoming and sending outgoing Flow traffic in this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >This is similar to to the value passed to the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> constructor, except that it represents the actual bound address and port (e.g., if you chose 0 as the port, the value returned here will contain the actual emphemeral port randomly chosen by the OS).</p>
<p >If <code>!running()</code>, this equals <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">Udp_endpoint()</a>. The logical value of the returned <a class="el" href="namespaceflow_1_1util.html#af1b28edb7bad743c1c77f6b982cc3196" title="Short-hand for the UDP endpoint (IP/port) type.">util::Udp_endpoint</a> never changes over the lifetime of the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. Note that it is a reference. </dd></dl>

</div>
</div>
<a id="a4bd7b471dd6cd3e3570930b48d30e577" name="a4bd7b471dd6cd3e3570930b48d30e577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7b471dd6cd3e3570930b48d30e577">&#9670;&nbsp;</a></span>max_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Node::max_block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes of user data per received or sent block on connections generated from this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, unless this value is overridden in the <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html" title="A set of low-level options affecting a single Peer_socket.">Peer_socket_options</a> argument to <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">listen()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> (or friend). </p>
<p >See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7" title="The size of block that we will strive to (and will, assuming at least that many bytes are available i...">Peer_socket_options::m_st_max_block_size</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a159b9c2b9a8a969f5e3715341c433aec" name="a159b9c2b9a8a969f5e3715341c433aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159b9c2b9a8a969f5e3715341c433aec">&#9670;&nbsp;</a></span>options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> flow::net_flow::Node::options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s option set and returns that copy. </p>
<p >If you intend to use <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> to modify a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s options, we recommend you make the modifications on the copy returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="aae148cec361b59237996a4b30c6624b5" name="aae148cec361b59237996a4b30c6624b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae148cec361b59237996a4b30c6624b5">&#9670;&nbsp;</a></span>running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Node::running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is operating. </p>
<p >If not, all attempts to use this object or any objects generated by this object (<a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>, etc.) will result in error. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="ab330b19f4039bab074251111789b568a" name="ab330b19f4039bab074251111789b568a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab330b19f4039bab074251111789b568a">&#9670;&nbsp;</a></span>serv_create_forward_plus_ctor_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_socket_impl_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> * flow::net_flow::Node::serv_create_forward_plus_ctor_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1net__flow_1_1Node.html#aa42efbce8c5ea908a253fca2e9b2a02c" title="Returns a raw pointer to newly created Peer_socket or sub-instance like asio::Peer_socket,...">sock_create_forward_plus_ctor_args()</a> but for Server_sockets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Server_socket_impl_type</td><td>Either <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">net_flow::Server_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Server__socket.html" title="A net_flow::Server_socket that adds integration with boost.asio.">net_flow::asio::Server_socket</a>, as of this writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_sock_opts</td><td>See, for example, <code>Peer_socket::accept(..., const Peer_socket_options* child_sock_opts)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new object of type <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> or of a subclass. </dd></dl>

</div>
</div>
<a id="a2779cc2429651696df1bca8de73534f3" name="a2779cc2429651696df1bca8de73534f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2779cc2429651696df1bca8de73534f3">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Node::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>) with the given options set. </p>
<p >Only those members of <code>opts</code> designated as dynamic (as opposed to static) may be different between <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a> and <code>opts</code>. If this is violated, it is an error, and no options are changed.</p>
<p >Typically one would acquire a copy of the existing options set via <a class="el" href="classflow_1_1net__flow_1_1Node.html#a159b9c2b9a8a969f5e3715341c433aec" title="Copies this Node&#39;s option set and returns that copy.">options()</a>, modify the desired dynamic data members of that copy, and then apply that copy back by calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>. Warning: this technique is only safe if other (user) threads do not call <a class="el" href="classflow_1_1net__flow_1_1Node.html#a2779cc2429651696df1bca8de73534f3" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> simultaneously. There is a to-do to provide a thread-safe maneuver for when this is a problem (see class <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> doc header).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The new options to apply to this socket. It is copied; no reference is saved. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a id="aa42efbce8c5ea908a253fca2e9b2a02c" name="aa42efbce8c5ea908a253fca2e9b2a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42efbce8c5ea908a253fca2e9b2a02c">&#9670;&nbsp;</a></span>sock_create_forward_plus_ctor_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Peer_socket_impl_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> * flow::net_flow::Node::sock_create_forward_plus_ctor_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to newly created <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or sub-instance like <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">asio::Peer_socket</a>, depending on the template parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Peer_socket_impl_type</td><td>Either <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">net_flow::Peer_socket</a> or <a class="el" href="classflow_1_1net__flow_1_1asio_1_1Peer__socket.html" title="A net_flow::Peer_socket that adds integration with boost.asio.">net_flow::asio::Peer_socket</a>, as of this writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>See, for example, <code>Peer_socket::connect(..., const Peer_socket_options&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new object of type <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> or of a subclass. </dd></dl>

</div>
</div>
<a id="aba2e6fc905dbeef3ea9e31bf844f8da5" name="aba2e6fc905dbeef3ea9e31bf844f8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2e6fc905dbeef3ea9e31bf844f8da5">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a> but instead of returning a connecting socket immediately, waits until the initial handshake either succeeds or fails, and then returns the socket or null, respectively. Additionally, you can specify a timeout; if the connection is not successful by this time, the connection attempt is aborted and null is returned.</p>
<p >Note that there is always a built-in Flow protocol connect timeout that is mandatory and will report an error if it expires; but it may be too long for your purposes, so you can specify your own that may expire before it. The two timeouts should be thought of as fundamentally independent (built-in one is in the lower level of Flow protocol; the one you provide is at the application layer), so don't make assumptions about Flow's behavior and set a timeout if you know you need one &ndash; even if in practice it is longer than the Flow one (which as of this writing can be controlled via socket option).</p>
<p >The following are the possible outcomes:</p><ol type="1">
<li>Connection succeeds before the given timeout expires (or succeeds, if no timeout given). Socket is at least Writable at time of return. The new socket is returned, no error is returned via <code>*err_code</code>.</li>
<li>Connection fails before the given timeout expires (or fails, if no timeout given). null is returned, <code>*err_code</code> is set to reason for connection failure. (Note that a built-in handshake timeout &ndash; NOT the given user timeout, if any &ndash; falls under this category.) <code>*err_code == <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a></code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>A user timeout is given, and the connection does not succeed before it expires. null is returned, and <code>*err_code</code> is set to <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. (Rationale: consistent with <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">Peer_socket::sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">Peer_socket::sync_send()</a> behavior.)</li>
</ol>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait &ndash; however, not really, as there is a built-in connection timeout that will expire. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482" title="All possible errors returned (via flow::Error_code arguments) by flow::net_flow functions/methods.">error::Code</a> generated: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aac3ec8d83192e9cd271376fce4001e99" title="Cannot ask to connect to &quot;any&quot; IP address. Use specific IP address.">error::Code::S_CANNOT_CONNECT_TO_IP_ANY</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a1975df7ed76c42660cbdc6039d5c70c5" title="No more ephemeral Flow ports available.">error::Code::S_OUT_OF_PORTS</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ae90ff1c87f2393dd6b14232b159f02b2" title="Internal error: Ephemeral port double reservation allowed.">error::Code::S_INTERNAL_ERROR_PORT_COLLISION</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090" title="Other side did not complete connection handshake within the allowed time; perhaps no one is listening...">error::Code::S_CONN_TIMEOUT</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482aa220d89e1d0e34bab02ed2fc7512be9b" title="Other side refused connection.">error::Code::S_CONN_REFUSED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4" title="Other side reset an established connection.">error::Code::S_CONN_RESET_BY_OTHER_SIDE</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5d57c6a6029d7c6a9e5442ac72ac7a6b" title="Node shutting down.">error::Code::S_NODE_SHUTTING_DOWN</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a>. </dd></dl>

</div>
</div>
<a id="ac094b83973fd9af8b45d8f4cb3c14e35" name="ac094b83973fd9af8b45d8f4cb3c14e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac094b83973fd9af8b45d8f4cb3c14e35">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_connect(to, duration::max(), err_code, opt)s</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> with no user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

</div>
</div>
<a id="a6db1043586a0e6413b1118d6c090bf89" name="a6db1043586a0e6413b1118d6c090bf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db1043586a0e6413b1118d6c090bf89">&#9670;&nbsp;</a></span>sync_connect_with_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_connect_with_metadata(to, duration::max(), serialized_metadata, err_code, opts)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Node.html#a6725d69ea1a6457d88abb63cef6e6bb2" title="A combination of sync_connect() and connect_with_metadata() (blocking connect, with supplied metadata...">sync_connect_with_metadata()</a> with no user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

</div>
</div>
<a id="a6725d69ea1a6457d88abb63cef6e6bb2" name="a6725d69ea1a6457d88abb63cef6e6bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6725d69ea1a6457d88abb63cef6e6bb2">&#9670;&nbsp;</a></span>sync_connect_with_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Node::sync_connect_with_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>serialized_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a> and <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a> (blocking connect, with supplied metadata). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">serialized_metadata</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. Added error: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a9a2cbc62120ca52c1f7e695b56b2bdcd" title="During connection user supplied metadata that is too large.">error::Code::S_CONN_METADATA_TOO_LARGE</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">sync_connect()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab13749ccdf4ab44445f21c77296ffa13" name="ab13749ccdf4ab44445f21c77296ffa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13749ccdf4ab44445f21c77296ffa13">&#9670;&nbsp;</a></span>S_DEFAULT_CONN_METADATA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a> flow::net_flow::Node::S_DEFAULT_CONN_METADATA = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type and value to supply as user-supplied metadata in SYN, if user chooses to use <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">connect()</a></code> instead of <code>[[a]sync_]<a class="el" href="classflow_1_1net__flow_1_1Node.html#ae9a0e5492b9ea005cc12c20c8e7cec9a" title="Same as connect() but sends, as part of the connection handshake, the user-supplied metadata,...">connect_with_metadata()</a></code>. </p>
<p >If you change this value, please update <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752" title="Obtains the serialized connect metadata, as supplied by the user during the connection handshake.">Peer_socket::get_connect_metadata()</a> doc header. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="node_8hpp.html">node.hpp</a></li>
<li>net_flow/<a class="el" href="event__set_8cpp.html">event_set.cpp</a></li>
<li>net_flow/<a class="el" href="node_8cpp.html">node.cpp</a></li>
<li>net_flow/<a class="el" href="peer__socket_8cpp.html">peer_socket.cpp</a></li>
<li>net_flow/<a class="el" href="server__socket_8cpp.html">server_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 11 2024 23:58:00 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
