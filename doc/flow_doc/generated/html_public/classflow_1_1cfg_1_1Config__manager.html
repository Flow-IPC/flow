<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::cfg::Config_manager&lt; S_d_value_set &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1cfg.html">cfg</a></li><li class="navelem"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1cfg_1_1Config__manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::cfg::Config_manager&lt; S_d_value_set &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of static config and dynamic config, each, via that number of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> types supplied by the user as template arguments.  
 <a href="classflow_1_1cfg_1_1Config__manager.html#details">More...</a></p>

<p><code>#include &lt;cfg_manager.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::cfg::Config_manager&lt; S_d_value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager__inherit__graph.svg" width="178" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::cfg::Config_manager&lt; S_d_value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Config__manager__coll__graph.svg" width="178" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque handle for managing a dynamic config change callback.  <a href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6768eb0c92bd11fd84986058903b10d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a> { <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed">S_ALLOW_INVALID_DEFAULTS</a>
 }</td></tr>
<tr class="memdesc:a6768eb0c92bd11fd84986058903b10d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type: indicates an <code>apply_*()</code> method must <em>allow</em> invalid defaults and only complain if the config source does not explicitly supply a valid value.  <a href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">More...</a><br /></td></tr>
<tr class="separator:a6768eb0c92bd11fd84986058903b10d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab501967b40259c1a29264af1ad17baf2"><td class="memItemLeft" align="right" valign="top"><a id="ab501967b40259c1a29264af1ad17baf2" name="ab501967b40259c1a29264af1ad17baf2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>On_dynamic_change_func</b> = Function&lt; void()&gt;</td></tr>
<tr class="memdesc:ab501967b40259c1a29264af1ad17baf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a callback to execute on dynamic config change. <br /></td></tr>
<tr class="separator:ab501967b40259c1a29264af1ad17baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad59bfabf66e01922542629bae77508ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad59bfabf66e01922542629bae77508ad">Config_manager</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> nickname, typename <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; S_d_value_set &gt;::Declare_options_func &amp;&amp;... declare_opts_func_moved)</td></tr>
<tr class="memdesc:ad59bfabf66e01922542629bae77508ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ready to read initial config via <code>apply_*()</code> and other setup methods; and further capable of both static and dynamic config.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad59bfabf66e01922542629bae77508ad">More...</a><br /></td></tr>
<tr class="separator:ad59bfabf66e01922542629bae77508ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707">apply_static</a> (const fs::path &amp;static_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:a22bfec8082d0c7b5dff9ee7e98865707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this after construction to load the permanent set of static config from config sources including a static config file; if you are also using dynamic config, see <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> as a <em>potential</em> alternative.  <a href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707">More...</a><br /></td></tr>
<tr class="separator:a22bfec8082d0c7b5dff9ee7e98865707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#af027c6f4b595f1f8ebbd6d41ad705f5e">apply_static</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;static_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#af027c6f4b595f1f8ebbd6d41ad705f5e">More...</a><br /></td></tr>
<tr class="separator:af027c6f4b595f1f8ebbd6d41ad705f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304">apply_static_and_dynamic</a> (const fs::path &amp;cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use dynamic config, <em>and</em> you allow for initial values for dynamic options to be read from the same file as the static config values, then invoke this instead of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.  <a href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304">More...</a><br /></td></tr>
<tr class="separator:a9d9811d1b4aab2c4ea3e6813d4161304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a5d85fa5a1ed933c9b85444ddb9a416b1">apply_static_and_dynamic</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#a5d85fa5a1ed933c9b85444ddb9a416b1">More...</a><br /></td></tr>
<tr class="separator:a5d85fa5a1ed933c9b85444ddb9a416b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26712af2d38d3afbeb52d21b7012a03c"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a26712af2d38d3afbeb52d21b7012a03c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c">apply_dynamic</a> (const fs::path &amp;dynamic_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:a26712af2d38d3afbeb52d21b7012a03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the first or subsequent set of dynamic config from config source including a dynamic config file.  <a href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c">More...</a><br /></td></tr>
<tr class="separator:a26712af2d38d3afbeb52d21b7012a03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2503b020137aca00a8ee4b81fc921750"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a2503b020137aca00a8ee4b81fc921750"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a2503b020137aca00a8ee4b81fc921750">apply_dynamic</a> (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>, const fs::path &amp;dynamic_cfg_path, const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;... final_validator_func, bool commit=true)</td></tr>
<tr class="memdesc:a2503b020137aca00a8ee4b81fc921750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; except that &ndash; applicably only to the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> without a preceding <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> &ndash; skips the stringent check on individual defaults' validity.  <a href="classflow_1_1cfg_1_1Config__manager.html#a2503b020137aca00a8ee4b81fc921750">More...</a><br /></td></tr>
<tr class="separator:a2503b020137aca00a8ee4b81fc921750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ab5cefe86e6aaa0518d675f309907e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e">reject_candidates</a> ()</td></tr>
<tr class="memdesc:ac1ab5cefe86e6aaa0518d675f309907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.  <a href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e">More...</a><br /></td></tr>
<tr class="separator:ac1ab5cefe86e6aaa0518d675f309907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c7224711ef8a51c7005629e4eae6e7"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a76c7224711ef8a51c7005629e4eae6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7">all_static_values</a> (const Value_set **... value_set_or_null) const</td></tr>
<tr class="memdesc:a76c7224711ef8a51c7005629e4eae6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a pointer to each permanently set static config value set; the same pointers are emitted throughout for each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> static config slots.  <a href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7">More...</a><br /></td></tr>
<tr class="separator:a76c7224711ef8a51c7005629e4eae6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486">all_static_values_candidates</a> (const Value_set **... value_set_or_null) const</td></tr>
<tr class="memdesc:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then for any static value set for which values have been parsed and validated (but not yet applied) so far, a pointer to the parsed values <em>candidate</em> will be emitted instead.  <a href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486">More...</a><br /></td></tr>
<tr class="separator:a616c39cdf1c6f7f4d2af3a3055edf486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8431806f82bed676f5fedb3b64f67245"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a8431806f82bed676f5fedb3b64f67245"><td class="memTemplItemLeft" align="right" valign="top">const Value_set &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245">static_values</a> (size_t s_value_set_idx) const</td></tr>
<tr class="memdesc:a8431806f82bed676f5fedb3b64f67245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but obtains the static config in <em>one</em> specified slot as opposed to all of them.  <a href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245">More...</a><br /></td></tr>
<tr class="separator:a8431806f82bed676f5fedb3b64f67245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae034a71792f952256c18e385475627d1"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:ae034a71792f952256c18e385475627d1"><td class="memTemplItemLeft" align="right" valign="top">const Value_set &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1">static_values_candidate</a> (size_t s_value_set_idx) const</td></tr>
<tr class="memdesc:ae034a71792f952256c18e385475627d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then the parsed values <em>candidate</em> will be returned, instead, if values have been parsed and validated for the static value set but have not yet been applied.  <a href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1">More...</a><br /></td></tr>
<tr class="separator:ae034a71792f952256c18e385475627d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afb8620600dcb54d41211ef68859f93"><td class="memTemplParams" colspan="2">template&lt;typename... Value_set&gt; </td></tr>
<tr class="memitem:a6afb8620600dcb54d41211ef68859f93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93">all_dynamic_values</a> (typename Value_set::Const_ptr *... value_set_or_null) const</td></tr>
<tr class="memdesc:a6afb8620600dcb54d41211ef68859f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at <code>struct</code> is set permanently; while another call may return a different pointer if config is changed dynamically in the meantime (for that slot).  <a href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93">More...</a><br /></td></tr>
<tr class="separator:a6afb8620600dcb54d41211ef68859f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memTemplItemLeft" align="right" valign="top">Value_set::Const_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f">dynamic_values</a> (size_t d_value_set_idx) const</td></tr>
<tr class="memdesc:ac2239443cf48bfdaa78c95af935e1d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> but obtains the dynamic config in <em>one</em> specified slot as opposed to all of them.  <a href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f">More...</a><br /></td></tr>
<tr class="separator:ac2239443cf48bfdaa78c95af935e1d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978295c03998af212b464061d780520b"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:a978295c03998af212b464061d780520b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b">register_dynamic_change_listener</a> (size_t d_value_set_idx, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> &amp;&amp;on_dynamic_change_func_moved)</td></tr>
<tr class="memdesc:a978295c03998af212b464061d780520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the given callback; next time <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> detects at least one changed (or initially set) option value in the specified slot, it will execute this and any other previously registered such callbacks synchronously.  <a href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b">More...</a><br /></td></tr>
<tr class="separator:a978295c03998af212b464061d780520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d">unregister_dynamic_change_listener</a> (const <a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a> &amp;handle)</td></tr>
<tr class="memdesc:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously registered dynamic change callback.  <a href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d">More...</a><br /></td></tr>
<tr class="separator:a4e0dfe1e8f57d974a775f1320bd9856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ae9775f51953805ea08086c276a78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d">state_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a19ae9775f51953805ea08086c276a78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of current values where applicable.  <a href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d">More...</a><br /></td></tr>
<tr class="separator:a19ae9775f51953805ea08086c276a78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220535219634c62ed2a580934c76c481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481">log_state</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:a220535219634c62ed2a580934c76c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> would print.  <a href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481">More...</a><br /></td></tr>
<tr class="separator:a220535219634c62ed2a580934c76c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c">help_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a human-targeted long-form usage message that includes all options with their descriptions and defaults.  <a href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c">More...</a><br /></td></tr>
<tr class="separator:ad5cda6ace05e8bbe52a5129ed1c0720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0192ddc2cc7302bdc8720ee56a395c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">log_help</a> (<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:a0192ddc2cc7302bdc8720ee56a395c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> would print.  <a href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">More...</a><br /></td></tr>
<tr class="separator:a0192ddc2cc7302bdc8720ee56a395c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a68da387dad566805b969aded698661cb"><td class="memItemLeft" align="right" valign="top"><a id="a68da387dad566805b969aded698661cb" name="a68da387dad566805b969aded698661cb"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_nickname</b></td></tr>
<tr class="memdesc:a68da387dad566805b969aded698661cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <code>nickname</code> ctor arg. <br /></td></tr>
<tr class="separator:a68da387dad566805b969aded698661cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="memItemLeft" align="right" valign="top"><a id="ad49d54a2ae34b14c276cf3de05c3c4f8" name="ad49d54a2ae34b14c276cf3de05c3c4f8"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>S_N_VALUE_SETS</b> = sizeof...(S_d_value_set)</td></tr>
<tr class="memdesc:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of template params in this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> instantiation. It must be even and positive. <br /></td></tr>
<tr class="separator:ad49d54a2ae34b14c276cf3de05c3c4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c07f711e98435d00420277f1c20be75"><td class="memItemLeft" align="right" valign="top"><a id="a9c07f711e98435d00420277f1c20be75" name="a9c07f711e98435d00420277f1c20be75"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>S_N_S_VALUE_SETS</b> = sizeof...(S_d_value_set) / 2</td></tr>
<tr class="memdesc:a9c07f711e98435d00420277f1c20be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of static value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s). <br /></td></tr>
<tr class="separator:a9c07f711e98435d00420277f1c20be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c2d6efe1670e940badccb3fdea609"><td class="memItemLeft" align="right" valign="top"><a id="ac26c2d6efe1670e940badccb3fdea609" name="ac26c2d6efe1670e940badccb3fdea609"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>S_N_D_VALUE_SETS</b> = sizeof...(S_d_value_set) / 2</td></tr>
<tr class="memdesc:ac26c2d6efe1670e940badccb3fdea609"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dynamic value sets (including any <code><a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a></code>s). <br /></td></tr>
<tr class="separator:ac26c2d6efe1670e940badccb3fdea609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplParams" colspan="2">template&lt;typename... S_d_value_set&gt; </td></tr>
<tr class="memitem:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a453d83bf1e8b57b1aaff511fbe913ecc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;val)</td></tr>
<tr class="memdesc:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream.  <a href="classflow_1_1cfg_1_1Config__manager.html#a453d83bf1e8b57b1aaff511fbe913ecc">More...</a><br /></td></tr>
<tr class="separator:a453d83bf1e8b57b1aaff511fbe913ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename... S_d_value_set&gt;<br />
class flow::cfg::Config_manager&lt; S_d_value_set &gt;</div><p >Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of static config and dynamic config, each, via that number of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>-ready raw value <code>struct</code> types supplied by the user as template arguments. </p>
<p >There is an even number of template args (or it will not compile); each successive pair contains, in order, a <em>static</em> <code>Value_set</code> followed by a <em>dynamic</em> one. It is possible, for each given pair, to use static config alone or dynamic config alone; in that case pass in <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> for the unused one:</p>
<div class="fragment"><div class="line"><span class="comment">// First config pair is static-only; second config pair -- for a separate application module perhaps --</span></div>
<div class="line"><span class="comment">// has both a static and dynamic parts.</span></div>
<div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager&lt;Static_config_general, Null_value_set, Static_socket_opts, Dynamic_socket_opts&gt;</a> ...;</div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Config__manager_html"><div class="ttname"><a href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a></div><div class="ttdoc">Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...</div><div class="ttdef"><b>Definition:</b> cfg_manager.hpp:384</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> for the probably-common use case when you have only static config and only one <code>struct</code> at that. <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">Static_config_manager</a> adapts <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> with a very simple API, avoiding parameter packs and any mention of various dynamic-config complexities.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Dynamic config support lacks crash rejection; though these features should be an incremental improvement around the existing code. By crash rejection I mean something like: config file X comes in; we rename it to X.unparsed; we try to parse it; program crashes &ndash; versus it's fine, so we rename it X.parsed, and next time X.parsed is what we presumably-safely parse after any restart. Similarly invalid config may not cause a crash but still shouldn't be repeatedly re-parsed (etc.). Exact design TBD and will be informed by previous work on other projects (by echan and ygoldfel at least).</dd></dl>
<h3>When (and how) to use this</h3>
<p >First see the namespace <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> doc header for a brief overview. If you have chosen to use <a class="el" href="namespaceflow_1_1cfg.html" title="Flow module that facilitates configuring modules, such as applications and APIs, via statically and/o...">flow::cfg</a> for (at least some of) your config needs, what is mandatory to use is the class template <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>. The choice is to use it directly (writing your own facilities around it) or to use this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to maintain a couple of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s for you in a straightforward way. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> supports that one straightforward way, and for daemon programs it may be a good choice. Otherwise, the idea behind <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is to be able to flexibly use them as needed (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> providing one such way).</p>
<p >Firstly, you may create a <code>const</code> (immutable) <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> via its constructor and then just use it to output a help message (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02" title="Logs what help_to_ostream() would print.">log_help()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a>). This could be used with your program's <code>--help</code> option or similar, and that's it (no parsing takes place).</p>
<div class="fragment"><div class="line"><span class="comment">// Example of a static-config-only Config_manager created just to log the help, and that&#39;s it.</span></div>
<div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager&lt;Static_value_set, Null_value_set&gt;</a></div>
<div class="line">  (<a class="code hl_function" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a>(), <span class="stringliteral">&quot;cfg&quot;</span>, &amp;static_cfg_declare_opts, <a class="code hl_function" href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">flow::cfg::null_declare_opts_func</a>())</div>
<div class="line">  .<a class="code hl_function" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">log_help</a>();</div>
<div class="ttc" id="aclassflow_1_1cfg_1_1Config__manager_html_a0192ddc2cc7302bdc8720ee56a395c02"><div class="ttname"><a href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02">flow::cfg::Config_manager::log_help</a></div><div class="ttdeci">void log_help(log::Sev sev=log::Sev::S_INFO) const</div><div class="ttdoc">Logs what help_to_ostream() would print.</div><div class="ttdef"><b>Definition:</b> cfg_manager.hpp:2619</div></div>
<div class="ttc" id="aclassflow_1_1log_1_1Log__context_html_af4db395042b065b00398cd59845dcb4d"><div class="ttname"><a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">flow::log::Log_context::get_logger</a></div><div class="ttdeci">Logger * get_logger() const</div><div class="ttdoc">Returns the stored Logger pointer, particularly as many FLOW_LOG_*() macros expect.</div><div class="ttdef"><b>Definition:</b> log.cpp:223</div></div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_adfe41c8484a878742976ddb84aa9e2d8"><div class="ttname"><a href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8">flow::cfg::null_declare_opts_func</a></div><div class="ttdeci">Option_set&lt; Null_value_set &gt;::Declare_options_func null_declare_opts_func()</div><div class="ttdoc">Returns a value usable as declare_opts_func_moved Config_manager ctor arg for a Null_value_set value ...</div><div class="ttdef"><b>Definition:</b> cfg_manager.cpp:26</div></div>
</div><!-- fragment --><p >Orthogonally, of course, you may want to use it to parse things. In which case:</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> assumes the following setup:</p><ul>
<li>1 or more config sets, each applicable perhaps to a different module of your application/library/etc. For <em>each</em> config set, have 1 or both of the following. (Having neither is pointless; so do not. Officially behavior is undefined if you do this.)<ul>
<li>One set of values, such that it is read from config source(s) once; then no value therein ever changes again. Call this type <code>S_value_set</code> (S for static). <code>S_value_set</code> must be a type suitable for <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> as its <code>Value_set</code> template arg. See <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header. Spoiler alert: It essentially needs to be a <code>struct</code> of reasonably-copyable, reasonably-equality-comparable, stream-parseable, stream-printable scalars (possibly nested); it needs to declare its default values in a no-arg ctor; and it needs an option-declaring function that calls <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> for each data member therein. The latter function must be passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor.<ul>
<li>After ctor, static config stored herein will be at its default values. Call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> (or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>; see below) to read the static values (from a file, etc.).</li>
<li>This <code>S_value_set</code> is accessible by reference-to-immutable accessor <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> are essentially thread-safe, at least after <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, in that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> will always return a reference to the same <code>S_value_set</code> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> will always emit the same pointers, and the values within the <code>S_value_set</code>(s) shall never change.</li>
</ul>
</li>
</ul>
</li>
<li>A 2nd set of values, such that it is read from config source(s) at least once; but then potentially more times, and each time 0 or more of the values may be changed from the original setting. <code>D_value_set</code>, again, must be a type suitable for <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> as its <code>Value_set</code>.<ul>
<li>Initialize the first set of dynamic values by calling either <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> (if your setup allows for initial dynamic values to be supplied in the same config source(s) (e.g., same file) as static ones) <em>and</em> then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>; or <em>only</em> the latter.</li>
<li>After that initial <code>apply*_dynamic()</code>: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> returns a ref-counted pointer to the heap-allocated <code>D_value_set</code> canonical at that time. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> may return a different pointer each time (and will, if a dynamic change is detected); but the values <em>at</em> a given return pointer will <em>never</em> change. <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> is an alternate approach but essentially the same idea.</li>
<li>Now, whenever you have reason to believe the dynamic config may have changed, call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> (after the first one) and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> are mutually thread-safe: they can be safely called concurrently with each other and/or themselves. Internally, an atomic pointer to <code>D_value_set</code> is stored; <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a></code> makes a single update to it &ndash; after a potentially lengthy successful parse of config source(s) &ndash; while <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> makes an atomic read followed by a pointer copy (and returns the copy). The ref-counted-ptr handle ensures the returned <code>D_value_set</code> survives as long as the user needs it, even if it's immediately replaced by new config within the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a>.</li>
<li>Since dynamic config can change at any time, it is up to the config user how they want to operate on the ref-counted handle obtained from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. If a potentially new value each time is fine, it's fine to simply do <code>cm.dynamic_values()-&gt;m_some_opt</code>. If one needs a consistent set of 2 or more values, or if one needs values to not change over time, then one can simply save <code>auto dyn_cfg = cm.dynamic_values()</code> and then access values through <code>dyn_cfg-&gt;</code> as long as consistency is desired. (Again: <code>*dyn_cfg</code> can never change, once <code>dyn_cfg</code> is returned through <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>.)</li>
</ul>
</li>
<li>You may also have hooks executed when dynamic config changes. This is a simple system: before any relevant <code>apply*_dynamic()</code> calls, call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> for each module that wants to be informed. Each callback so registered will be <em>synchronously</em> executed from <code>apply*_dynamic()</code>, when a relevant change is detected.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >To summarize: This is the assumed order of API calls on a given <code>*this</code>; other orders may lead to undefined behavior:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor.</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or (if using dynamic config, but even so still optional) <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.</li>
<li>If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.</li>
<li>Simultaneously/at various times (thread-safe w/r/t each other):<ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> (always returns a reference to the same immutable <code>S_value_set</code>).</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> (always emits the same pointers to immutable <code>S_value_set</code>s).</li>
<li>If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> (if returned <code>x</code>, <code>*x</code> is immutable; but may return different <code>x</code>es over time). Alternatively: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>.</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> (changes ptr returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>).</li>
</ul>
</li>
<li>Config-using modules' destructors/deinitialization code.<ul>
<li>For each such module: Obviously it must run after the last <code>*ic_values()</code> call.</li>
<li>For each such module: It <em>must</em> run before <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> dtor.</li>
</ul>
</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> dtor.</li>
</ul>
<p >In addition, between <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ctor and dtor:</p><ul>
<li>(Optional) If using dynamic config: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> (for each module interested in it); not thread-safe against concurrent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.<ul>
<li>Functions <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a></code>ed earlier may execute synchronously from within <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> and/or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.<ul>
<li>Such user functions may load async work elsewhere.</li>
<li>Ensure that thing onto which they load async work exists! See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> for useful patterns to ensure this.</li>
</ul>
</li>
</ul>
</li>
<li>(Optional) If a callback has been registered: <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>; not thread-safe against concurrent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.<ul>
<li>Any callback which accesses something which can be invalidated SHOULD be unregistered before that thing becomes invalid. If there is a chance that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> might be called after it has become invalid, then the callback MUST be unregistered (otherwise, undefined behavior could be encountered when the invalid thing is accessed).</li>
</ul>
</li>
</ul>
<h3>Advanced feature: multi-source parsing and source skipping</h3>
<p >By default this feature is not in play, as the <code>bool commit</code> arg to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> defaults to <code>true</code>. The multi-source feature is enabled by the user setting it to <code>false</code> for some calls to <code>apply_*()</code>. To explain how it works consider one particular <code>Value_set</code> and an attempt to execute one of <code>apply_*()</code> methods w/r/t that <code>Value_set</code> (among potentially others to which the same discussion applies equally). For purposes of discussion assume it is a dynamic <code>Value_set</code>, and the operation in question is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>; the same points apply to static ones and the other two <code>apply_*()</code> calls except where noted below.</p>
<p >Suppose the canonical (as returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>) <code>Value_set</code> is in state B, the baseline state. (If <code>Value_set</code> is static, then B is the default state from default-cted <code>Value_set</code>, and the canonical-state accessors are <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.) Normally a single <em>update</em> consists of just one call to <code>apply_dynamic(commit = true)</code>:</p><ol type="1">
<li><code>R = apply_dynamic(P, F, true)</code>, where <code>P</code> is a file path, and <code>F</code> is your <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html#a5475ab0b6e93f2ccded2aa8690ace0a4" title="Short-hand for a function that takes a parsed config set (meaning all values are individually OK) and...">Final_validator_func::Type</a> function.</li>
</ol>
<p >If <code>F() == <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a></code>, then <code>R == false</code>; state stays at B. If it's <code>F() == S_ACCEPT</code> (and the individual options were all fine), then <code>R == true</code>; state becomes B'; and if B does not equal B' (a change was detected), then the dynamic changes listener(s) (from <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>) are synchronously called before <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> returns. (That listener stuff does not apply to static <code>Value_set</code>s in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>.)</p>
<p >That's the default behavior without engaging this feature. To engage the feature, one has to call <code>apply_dynamic(commit = false)</code> at least once. A single <em>update</em> now consists of 2+ calls to <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a></code>:</p><ol type="1">
<li><code>R = apply_dynamic(P1, F, false)</code>; if <code>!R</code>, update failed/exit algorithm; else:</li>
<li><code>R = apply_dynamic(P2, F, false)</code>; if <code>!R</code>, update failed/exit algorithm; else:</li>
<li>...</li>
<li><code>R = apply_dynamic(Pn, F, true)</code>; if <code>!R</code>, update failed/exit algorithm; else done. The <code>true</code> arg indicates the final call.</li>
</ol>
<p >(<code>F</code> can be different each time, though informally we suspect that would be unorthodox. It is allowed formally.)</p>
<p >Each <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call builds up a <em>candidate</em> <code>Value_set C</code> which is created (at the top of call 1) to equal baseline/initial state B and then potentially incrementally morphed by each <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call. Assuming no error (from individual validator or an <code>F() == S_FAIL</code>) at any stage, the effect on the <em>candidate</em> <code>Value_set C</code> is as follows:</p><ol type="1">
<li>If <code>F(Cnext) == S_ACCEPT</code>: Modify the <em>candidate</em> by overwriting it: <code>C = Cnext;</code>.</li>
<li>If <code>F(Cnext) == S_SKIP</code>: Keep the <em>candidate</em> <code>Value_set C</code> unchanged from its current value at entry to that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> call. <code>Cnext</code> is discarded (so the incremental update to the candidate is <em>skipped</em>).</li>
</ol>
<p >However, and this is the key:</p><ul>
<li><code>apply_dynamic(..., false)</code> does <em>not</em> modify the canonical (as returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>, etc.) state. It remains equal to B. Hence no dynamic change listeners are invoked. However:</li>
<li>the final call &ndash; <code>apply_dynamic(..., true)</code> &ndash; makes the canonical state equal the <em>candidate</em> <code>Value_set C</code> that has been built up. Accordingly, before <code>apply_dynamic(..., true)</code> returns, if the canonical <code>Value_set B</code> differs from the candidate <code>Value_set C</code> that overwrites it, dynamic change listeners are invoked.</li>
</ul>
<p >(Hence the one-call update scenario (the vanilla one) is merely a degenerate case of the multi-call scenario; as then the last call is the only call and thus canonicalizes the candidate and calls dynamic change listeners if appropriate.)</p>
<p >If at any stage <code>F(Cnext)</code> yields <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a>, then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> returns <code>false</code>. This means the entire update has failed; the <em>candidate</em> is abandoned, and you should not make the subsequent <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> calls that may be remaining in the update. The next such call will be taken to be the 1st of another update, with a fresh candidate C created to equal B.</p>
<p >Why use this? Why use 2+ files for a given update? Indeed you shouldn't, unless there is specifically a good reason. What might that be? The precipitating use case, and the basic one immediately obvious to the authors, is where exactly for 1 of the files the final-validator shall return <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567" title="The holistically-checked cumulative Value_set has no problems and shall be accepted into the candidat...">Final_validator_outcome::S_ACCEPT</a>, while for <em>all</em> others it will return <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>. For example, if your distributed network consists of 3 sections, and each machine knows to which section it belongs, and each file is aimed at exactly 1 of the 3 and thus specifies it as some option <code>if-section-is=</code> (possible values 1 or 2 or 3), then the final-validator func would:</p><ol type="1">
<li>Check <code>if-section-is</code> option and return SKIP if the machine's actual section does not match it. Else:</li>
<li>Ensure internal consistency of candidate <code>Value_set</code> (as usual).</li>
<li>Return FAIL or ACCEPT depending on the answer to that (as usual).</li>
</ol>
<p >Now you've enabled conditional config in a distributed deployment.</p>
<dl class="section warning"><dt>Warning</dt><dd>In this <em>conditional config</em> use case, it is likely best to declare any given conditional option using a <code>_NO_ACC</code> variation of your <code>FLOW_CFG_OPTION_SET_DECLARE_OPTION*()</code> option of choice; that is <code><a class="el" href="option__set_8hpp.html#a9187f169f3eaf596c0e7b0f9e7e34761" title="Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), except the option is marked as non-accumulating,...">FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC()</a></code> or similarly-postfixed variation. You probably do not want such an option's value to persist from an earlier file in the update to a later one; instead it should probably reset to its default "at the top" of each file; <code>_NO_ACC</code> variants will accomplish this.</dd></dl>
<p>That said the use of SKIP (for all but 1) is not mandatory in such a multi-file-update setup. You can never-SKIP, or you can ACCEPT (not-SKIP) 2+ files; it is conceivable those setups have use cases as well. Informally though we reason to you as follows:</p><ul>
<li>If you never SKIP, then why complicate matters by having updates consist of 2+ files in the first place? Isn't it simpler (for config deployment and other aspects of the system) to just keep it to 1?</li>
<li>If you ACCEPT (don't-SKIP) 2+ files, then merely looking at a given file will no longer easily show the resulting final config, as each individual update is now incremental in nature; a preceding file in the same update may have changed (versus baseline) some setting not mentioned in that particular file. This may prove to be confusing.<ul>
<li>If you ACCEPT (don't-SKIP) exactly 1 file, then this no longer the case, and things are simple enough again.</li>
<li>If you ACCEPT (don't-SKIP) 2+ files, then to mitigate the problem where the final config is not quite clear just by looking at the input files, it's simple to use <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a220535219634c62ed2a580934c76c481" title="Logs what state_to_ostream() would print.">log_state()</a> to direct the result to a file or the logs, for human viewing.</li>
</ul>
</li>
</ul>
<p >The above are informal recommendations for maximum simplicity or clarity, but it is entirely conceivable a more complex situation arises and requires they not be heeded.</p>
<h3>Relationship with the rest of your program/threads</h3>
<p >At this time <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> is deliberately simple in that it doesn't start any threads of its own; it doesn't watch file modifications to detect dynamic changes; and its methods can be called from any thread and always act entirely synchronously. (The only methods affected by thread considerations are <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> + <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>; they are intentionally thread-safe w/r/t each other.)</p>
<p >To the extent that it uses callbacks &ndash; again, only for dynamic config needs and only optionally &ndash; they, too, are executed synchronously. However, these callbacks can (of course) <code>.post()</code> work onto boost.asio <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6" title="Short-hand for boost.asio event service, the central class of boost.asio.">util::Task_engine</a> or <a class="el" href="classflow_1_1async_1_1Concurrent__task__loop.html" title="The core flow::async interface, providing an optionally multi-threaded thread pool onto which runnabl...">async::Concurrent_task_loop</a> or <a class="el" href="classflow_1_1async_1_1Single__thread__task__loop.html" title="A Concurrent_task_loop-related adapter-style class that represents a single-thread task loop; essenti...">async::Single_thread_task_loop</a>.</p>
<p >Informally: It is, however, possible and perhaps probable that one should build more facilities to detect cfg changes of various kinds; for this thread(s) may be useful. We suspect it is better to build class(es) that do that and make use of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> &ndash; not expand <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to do such things. Its simplicity and relative light weight and flexibility are good properties to conserve and not saddle with baggage (even optional baggage).</p>
<h3>Thread safety</h3>
<p >This is discussed in bits and pieces above and in various doc headers. Here is the overall picture however:</p><ul>
<li>Separate <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> objects are independent of each other, so there are no thread safety issues.</li>
<li>For a given <code>*this</code>:<ul>
<li>By default, no non-<code>const</code> method is safe to call concurrently with any other method. Except:</li>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> may be called concurrently with itself/each other or any other method including <code>apply_dynamic(commit = *)</code>, as long as either <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> has succeeded at least once prior.</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_d_value_set</td><td>An even number (at least 2) of settings <code>struct</code>s &ndash; see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header for requirements for each &ndash; in order static, dynamic, static, dynamic, .... Use <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> as needed; but do not use <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a> for both the static and dynamic parameter in a given pair (e.g., <code>&lt;<a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>, <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>, ...&gt;</code> is both useless and formally disallowed). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6768eb0c92bd11fd84986058903b10d4" name="a6768eb0c92bd11fd84986058903b10d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6768eb0c92bd11fd84986058903b10d4">&#9670;&nbsp;</a></span>allow_invalid_defaults_tag_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">flow::cfg::Config_manager::allow_invalid_defaults_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type: indicates an <code>apply_*()</code> method must <em>allow</em> invalid defaults and only complain if the config source does not explicitly supply a valid value. </p>
<p >Otherwise the defaults themselves are also stringently checked regardless of whether they are overridden. This setting applies only to individual-option-validators. <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html" title="Utility/traits type to concisely work with final-validation functions when calling methods like Confi...">Final_validator_func</a> validation is orthogonal to this. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed" name="a6768eb0c92bd11fd84986058903b10d4a7ea4d19303bcf5de0947176d9637a9ed"></a>S_ALLOW_INVALID_DEFAULTS&#160;</td><td class="fielddoc"><p >Sole value for tag type <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad59bfabf66e01922542629bae77508ad" name="ad59bfabf66e01922542629bae77508ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59bfabf66e01922542629bae77508ad">&#9670;&nbsp;</a></span>Config_manager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::Config_manager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; S_d_value_set &gt;::Declare_options_func &amp;&amp;...&#160;</td>
          <td class="paramname"><em>declare_opts_func_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> ready to read initial config via <code>apply_*()</code> and other setup methods; and further capable of both static and dynamic config. </p>
<p >See class doc header for class life cycle instructions.</p>
<h3>Logging assumption</h3>
<p ><code>*logger_ptr</code> is a standard logging arg. Note, though, that the class will assume that log verbosity may not have yet been configured &ndash; since this <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> may be the thing configuring it. Informal recommendations:</p><ul>
<li>You should let through INFO and WARNING messages in <code>*logger_ptr</code>.</li>
<li>If you plan to use <code>*this</code> only for <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a0192ddc2cc7302bdc8720ee56a395c02" title="Logs what help_to_ostream() would print.">log_help()</a> (such as in your <code>--help</code> implementation), you should <em>not</em> let through TRACE-or-more-verbose.</li>
<li>Once (and if) you engage any actual parsing (<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, etc.), TRACE may be helpful in debugging as usual.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">nickname</td><td>Brief string used for logging subsequently. </td></tr>
    <tr><td class="paramname">declare_opts_func_moved</td><td>For each <code>S_d_value_set</code>, in order, the declare-options callback as required by <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;S_d_value_set&gt;</code> constructor; see its doc header for instructions. For each <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>: use the function returned by <code><a class="el" href="namespaceflow_1_1cfg.html#adfe41c8484a878742976ddb84aa9e2d8" title="Returns a value usable as declare_opts_func_moved Config_manager ctor arg for a Null_value_set value ...">null_declare_opts_func()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6afb8620600dcb54d41211ef68859f93" name="a6afb8620600dcb54d41211ef68859f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afb8620600dcb54d41211ef68859f93">&#9670;&nbsp;</a></span>all_dynamic_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_dynamic_values </td>
          <td>(</td>
          <td class="paramtype">typename Value_set::Const_ptr *...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at <code>struct</code> is set permanently; while another call may return a different pointer if config is changed dynamically in the meantime (for that slot). </p>
<p >For each slot: If you require a consistent set of dynamic config over some period of time or over some code path, save a copy of the returned ref-counted pointer to the <code>Value_set</code> and keep accessing values in that immutable structure through that ref-counted pointer.</p>
<p >After the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>: It is safe to call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> concurrently with any number of itself or of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> and/or a call to <code>apply_dynamic(commit = *)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Have each <code>Value_set</code> derive from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html" title="Convenience class template that endows the given subclass T with nested aliases Ptr and Const_ptr ali...">util::Shared_ptr_alias_holder</a>, so that it is endowed with <code>Ptr</code> and <code>Const_ptr</code> ref-counted pointer type aliases, for your convenience and as required by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> and <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.</dd></dl>
<h3>Performance</h3>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> performance is no worse than: lock mutex, copy <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <code>shared_ptr</code>s, unlock mutex. See also Performance section of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 1, 3, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> in order. Likely you will need to explicitly specify them, as the compiler will probably not deduce them. E.g.: <code>cfg_mgr.all_dynamic_values&lt;D_cfg1, D_cfg2, <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>&gt;(&amp;d1, &amp;d2, 0)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>For each element in the param pack: <code>*value_set_or_null</code> is set to point to the immutable dynamic config set currently canonical in that slot; or that slot is ignored if <code>value_set_or_null</code> is null. Remember: <code>**value_set_or_null</code> is immutable; but another call may yield a different <code>*value_set_or_null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76c7224711ef8a51c7005629e4eae6e7" name="a76c7224711ef8a51c7005629e4eae6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c7224711ef8a51c7005629e4eae6e7">&#9670;&nbsp;</a></span>all_static_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_static_values </td>
          <td>(</td>
          <td class="paramtype">const Value_set **...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a pointer to each permanently set static config value set; the same pointers are emitted throughout for each of the <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> static config slots. </p>
<p >Tip: It should be sufficient to pass around only <code>const</code> refs (from the pointers obtained here) all around the app &ndash; no <code>Value_set</code> copying should be needed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 0, 2, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> in order. The compiler should be able to deduce them automatically from each <code>value_set_or_null</code> type; though when passing in null it may be then necessary to cast <code>nullptr</code> (or <code>0</code>) to the appropriate pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>For each element in the param pack: <code>*value_set_or_null</code> is set to point to the immutable static config set in that slot; or that slot is ignored if <code>value_set_or_null</code> is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616c39cdf1c6f7f4d2af3a3055edf486" name="a616c39cdf1c6f7f4d2af3a3055edf486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616c39cdf1c6f7f4d2af3a3055edf486">&#9670;&nbsp;</a></span>all_static_values_candidates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::all_static_values_candidates </td>
          <td>(</td>
          <td class="paramtype">const Value_set **...&#160;</td>
          <td class="paramname"><em>value_set_or_null</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then for any static value set for which values have been parsed and validated (but not yet applied) so far, a pointer to the parsed values <em>candidate</em> will be emitted instead. </p>
<p >If called from elsewhere, the behavior is equivalent to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. A values candidate consists of what has been parsed and validated (and not skipped via <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>) for the value set, but has not yet been applied such that it would be available through <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</p>
<p >This could be useful to provide static values to a final validator function for another value set which depends on them. During the execution of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, the validator function for each value set will be executed before any are canonicalized. This method can be used by a validator function to obtain the candidate values which have been parsed and validated (but have not yet been canonicalized) for a preceding static value set.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_set_or_null</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2503b020137aca00a8ee4b81fc921750" name="a2503b020137aca00a8ee4b81fc921750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2503b020137aca00a8ee4b81fc921750">&#9670;&nbsp;</a></span>apply_dynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>dynamic_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; except that &ndash; applicably only to the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> without a preceding <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> &ndash; skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. However &ndash; assuming <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> was not used, and this is the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> &ndash; the other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> will return <code>false</code> if a default is invalid, even if file <code>dynamic_cfg_path</code> explicitly sets it to a valid value. This tagged overload will not and let parsing continue. If <code>apply_static_and_dynamic(commit = true) == true</code> was used, or if <code>apply_dynamic(commit = true) == true</code> has been called before, then the overloads behave identically: defaults are not checked; it must occur just before the initial dynamic load or never. </dd></dl>

</div>
</div>
<a id="a26712af2d38d3afbeb52d21b7012a03c" name="a26712af2d38d3afbeb52d21b7012a03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26712af2d38d3afbeb52d21b7012a03c">&#9670;&nbsp;</a></span>apply_dynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_dynamic </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>dynamic_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the first or subsequent set of dynamic config from config source including a dynamic config file. </p>
<p >If you use dynamic config: You must invoke this, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, once before access via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>. After that, optionally invoke it whenever there is good reason to believe new dynamic config is available in the dynamic config source(s).</p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. If not using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, <em>and</em> this is the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> invoked, then see also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >After the initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>: It is safe to call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> concurrently with any number of <code>[all_]<a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a></code>. However behavior is undefined if one calls <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> concurrently with itself or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> (on the same <code>*this</code>).</p>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. WARNING(s) logged given failure.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> will be tolerant of unknown option names appearing in the config source, though it will log about them. The reasoning: Dynamic config must grapple with backward- and forward-compatibility.</p>
<p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<h3>Performance</h3>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> + <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> locking performance is no worse than: lock mutex, assign <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> <code>shared_ptr</code>s, unlock mutex. The rest of the parse/validate/etc. code is outside any such critical section. See also Performance section of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> doc header.</p>
<p >Outside that locking critical section, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> may be expensive, in that it performs file input and some internal copying of option value sets and maps, plus detailed logging. It is, however, not typically called frequently. Just be aware it will block the calling thread, albeit still only for a split second in normal conditions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 1, 3, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a> in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_cfg_path</td><td>File to read. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>); and all relevant dynamic change listeners are synchronously called for each <code>Value_set</code> for which the cumulative candidate differs from the canonical state. <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>; no dynamic change listeners are invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source(s) and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (dynamic) config sets; and defaults were also all individually valid, in the case of initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a>) have not been updated. </dd></dl>

</div>
</div>
<a id="af027c6f4b595f1f8ebbd6d41ad705f5e" name="af027c6f4b595f1f8ebbd6d41ad705f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af027c6f4b595f1f8ebbd6d41ad705f5e">&#9670;&nbsp;</a></span>apply_static() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>static_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. The difference between the other <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a></code> and this overload is: The other overload will return <code>false</code> given an invalid default, even if file <code>static_cfg_path</code> explicitly sets it to a valid value. This tagged overload will not fail (return <code>false</code> for that reason) and will let parsing continue instead. </dd></dl>

</div>
</div>
<a id="a22bfec8082d0c7b5dff9ee7e98865707" name="a22bfec8082d0c7b5dff9ee7e98865707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bfec8082d0c7b5dff9ee7e98865707">&#9670;&nbsp;</a></span>apply_static() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename... Value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>static_cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; Value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke this after construction to load the permanent set of static config from config sources including a static config file; if you are also using dynamic config, see <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> as a <em>potential</em> alternative. </p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >After this runs and succeeds, assuming <code>commit == true</code>, you may use <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and/or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> to access the loaded values. After this runs and succeeds, but <code>commit == false</code>, you should call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> again 1+ times, with the last such call having <code>commit == true</code> and thus canonicalizing each progressively-built candidate <code>Value_set</code>, so that it becomes available via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>.</p>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. The next <code>apply_*()</code> call begins a fresh update.</p>
<p >Tip: On failure you may want to exit program with error; or you can continue knowing that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> will return a reference to default values (and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> will emit pointers to <code>Value_set</code>s with default values) according to <code>Value_set()</code> no-arg ctor (for each <code>Value_set</code>). WARNING(s) logged given failure.</p>
<p ><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> will <em>not</em> be tolerant of unknown option names appearing in the config source. The reasoning (and we might change our minds over time): It should be possible to deliver the proper set of static config along with the binary that supports it. However <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> is tolerant of unknown option names.</p>
<p >You must supply exactly <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> <code>final_validator_func</code>s. The compiler will likely require you to explicitly specify the <code>struct</code> types as explicit template args; e.g:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager&lt;S_config1, D_config1, S_config2, D_config2, Null_value_set, D_config3&gt;</a> cfg_mgr(...);</div>
<div class="line"><span class="comment">// Explicitly specify the static config struct types.  Provide that number of final-validate functions.</span></div>
<div class="line"><span class="comment">// Use null_final_validator_func() for the dummy Null_value_set in particular.</span></div>
<div class="line">cfg_mgr.apply_static&lt;S_config1, S_config2, <a class="code hl_struct" href="structflow_1_1cfg_1_1Null__value__set.html">Null_value_set</a>&gt;</div>
<div class="line">  (file_path, &amp;s_decl_opts1, &amp;s_decl_opts2, <a class="code hl_function" href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">null_final_validator_func</a>());</div>
<div class="ttc" id="anamespaceflow_1_1cfg_html_af1a4e0a153ec8216ead76450e900e386"><div class="ttname"><a href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386">flow::cfg::null_final_validator_func</a></div><div class="ttdeci">Final_validator_func&lt; Null_value_set &gt;::Type null_final_validator_func()</div><div class="ttdoc">Returns a value usable as final_validator_func arg to Config_manager::apply_static() and others – for...</div><div class="ttdef"><b>Definition:</b> cfg_manager.cpp:31</div></div>
<div class="ttc" id="astructflow_1_1cfg_1_1Null__value__set_html"><div class="ttname"><a href="structflow_1_1cfg_1_1Null__value__set.html">flow::cfg::Null_value_set</a></div><div class="ttdoc">Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...</div><div class="ttdef"><b>Definition:</b> cfg_manager.hpp:72</div></div>
</div><!-- fragment --><p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>final_validator_func()</code> can be made quite brief by using convenience macro <a class="el" href="cfg__manager__fwd_8hpp.html#a1e8c66781034dd50ad8e2de9c0c47e0e" title="Convenience macro particularly useful in the final_validator_func() callback taken by various Config_...">FLOW_CFG_OPT_CHECK_ASSERT()</a>. This will take care of most logging in most cases. </dd>
<dd>
For each <a class="el" href="structflow_1_1cfg_1_1Null__value__set.html" title="Empty struct suitable as a *_value_set template arg for Config_manager, when a slot requires a Value_...">Null_value_set</a>: use <code>final_validator_func = <a class="el" href="namespaceflow_1_1cfg.html#af1a4e0a153ec8216ead76450e900e386" title="Returns a value usable as final_validator_func arg to Config_manager::apply_static() and others – for...">null_final_validator_func()</a></code>. </dd>
<dd>
A validator function will not be run if there is a failure to parse any preceding <code>Value_set</code> (including a failure of its associated validator function). </dd>
<dd>
A validator function may rely on <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1" title="Similar to static_values(), but if called from within a validator function passed to apply_static() o...">static_values_candidate()</a> providing the parsed (and validated) values candidate for any preceding static value set.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Add support for command line as a config source in addition to file(s), for static config in <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">cfg::Config_manager</a> and <a class="el" href="classflow_1_1cfg_1_1Static__config__manager.html" title="A Config_manager-related adapter-style class that manages a simple config setup involving a single (t...">cfg::Static_config_manager</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>These must be <code>S_d_value_set</code> template param pack args 0, 2, ..., numbering <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a> in order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_cfg_path</td><td>File to read. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>For each arg: If parsing and individual-option-validation succeed, the method shall return success if <code>final_validator_func(V)</code> returns <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3a655ec6aa779cb1c799c9ba80f24e9567" title="The holistically-checked cumulative Value_set has no problems and shall be accepted into the candidat...">Final_validator_outcome::S_ACCEPT</a> or <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3ace64a8fc2c16fb21be22f603ef4d2eec" title="The holistically-checked cumulative Value_set has contents such that the validator function decided t...">Final_validator_outcome::S_SKIP</a>, where V is the parsed <code>Value_set</code>. (If <code>apply_static(commit = false) == true</code> call(s) preceded this one, V is the cumulative candidate from such call(s) so far, plus values parsed from <code>static_cfg_path</code> on top of that.) Informally: Please place individual-option validation into <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> invocations; only use <code>final_validator_func()</code> for internal consistency checks (if any) and skip conditions (if any). </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this call and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>). <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (static) config sets; and defaults were also all individually valid. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>) have not been updated. If <code>false</code> with <code>commit == false</code>, you should not call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> for the planned subsequent config sources: this update has failed, and any built-up candidate <code>Value_set</code>s are discarded. </dd></dl>

</div>
</div>
<a id="a5d85fa5a1ed933c9b85444ddb9a416b1" name="a5d85fa5a1ed933c9b85444ddb9a416b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d85fa5a1ed933c9b85444ddb9a416b1">&#9670;&nbsp;</a></span>apply_static_and_dynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_and_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4">allow_invalid_defaults_tag_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag; but skips the stringent check on individual defaults' validity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> doc header and/or return-value doc just below.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_path</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. The difference between the other <code><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a></code> and this overload is: The other overload will return <code>false</code> given an invalid default, even if file <code>cfg_path</code> explicitly sets it to a valid value. This tagged overload will not fail (return <code>false</code> for that reason) and will let parsing continue instead. </dd></dl>

</div>
</div>
<a id="a9d9811d1b4aab2c4ea3e6813d4161304" name="a9d9811d1b4aab2c4ea3e6813d4161304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9811d1b4aab2c4ea3e6813d4161304">&#9670;&nbsp;</a></span>apply_static_and_dynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::apply_static_and_dynamic </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structflow_1_1cfg_1_1Final__validator__func.html">Final_validator_func</a>&lt; S_d_value_set &gt;::Type &amp;...&#160;</td>
          <td class="paramname"><em>final_validator_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use dynamic config, <em>and</em> you allow for initial values for dynamic options to be read from the same file as the static config values, then invoke this instead of <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>. </p>
<p >See also <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> overload with <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6768eb0c92bd11fd84986058903b10d4" title="Tag type: indicates an apply_*() method must allow invalid defaults and only complain if the config s...">allow_invalid_defaults_tag_t</a> tag.</p>
<p >With static config-only use case:</p><ul>
<li>Just <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a> whenever needed.</li>
</ul>
<p >With dynamic-and-static config use case, <em>with</em> allowing baseline dynamic values to be set in static config file:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. &lt;&ndash; ATTN</li>
<li>Initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>. (Typically it is allowed that there is no dynamic config file present yet though.)</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> whenever needed.<ul>
<li>Further <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, if dynamic config source(s) may have changed.</li>
</ul>
</li>
</ul>
<p >With dynamic-and-static config use case, <em>without</em> allowing baseline dynamic values to be set in static config file:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>.</li>
<li>Initial <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>.</li>
<li>Then <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> / <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> whenever needed.<ul>
<li>Further <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, if dynamic config source(s) may have changed.</li>
</ul>
</li>
</ul>
<p >On failure returns <code>false</code>; else returns <code>true</code>. In the former case the canonical state remains unchanged, and any candidate built-up via preceding <code>commit == false</code> calls (if any) is discarded. WARNING(s) logged given failure.</p>
<p >For context w/r/t <code>commit</code> arg: Please read the section of the class doc header regarding multi-source updates. Corner case note: Formally: invoking <code>apply_Y()</code> immediately after <code>apply_X(commit = false) == true</code>, without <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> between them, where Y and X differ =&gt; <code>apply_Y()</code> shall log an INFO message and invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> itself; then proceed. In this case <code>apply_Y()</code> is <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>. Informally we discourage doing this; it is stylistically better to invoke <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac1ab5cefe86e6aaa0518d675f309907e" title="Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress.">reject_candidates()</a> explicitly in that scenario which cancels an in-progress update which is unusual though conceivably useful.</p>
<dl class="section note"><dt>Note</dt><dd>By definition this will not compile unless <code>final_validator_func</code> count equals <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad49d54a2ae34b14c276cf3de05c3c4f8" title="The number of template params in this Config_manager instantiation. It must be even and positive.">S_N_VALUE_SETS</a>. However, unlike <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a>, there are no template args to explicitly supply.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_path</td><td>File to read for both static and dynamic config. </td></tr>
    <tr><td class="paramname">final_validator_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>; particularly the notes about how a validator function will not be run if there is a preceding failure and that <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a> and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ae034a71792f952256c18e385475627d1" title="Similar to static_values(), but if called from within a validator function passed to apply_static() o...">static_values_candidate()</a> can be relied upon. </td></tr>
    <tr><td class="paramname">commit</td><td><code>true</code> means that this call being successful (returning <code>true</code>) shall cause the promotion of each candidate <code>Value_set</code> built-up so far (via this and all preceding successful calls with <code>commit == false</code>) to canonical state (accessed via <code>*ic_values()</code> or <code>all_*ic_values()</code>); and all dynamic change listeners are synchronously called. <code>false</code> means that this call being successful shall merely create-and-set (if first such call) or incrementally update (if 2nd, 3rd, ... such call) each candidate <code>Value_set</code>; no dynamic change listeners are invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if successfully parsed config source(s) and validated all settings including <code>final_validator_func() != S_FAIL</code> for <em>all</em> (static and dynamic) config sets; and defaults were also all individually valid. However, if <code>true</code> but <code>commit == false</code>, then the canonical values (accessed via <code>*ic_values()</code> or <code>*ic_values()</code>) have not been updated. If <code>false</code> with <code>commit == false</code>, you should not call <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a> for the planned subsequent config sources: this update has failed, and any built-up candidate <code>Value_set</code>s are discarded. </dd></dl>

</div>
</div>
<a id="ac2239443cf48bfdaa78c95af935e1d0f" name="ac2239443cf48bfdaa78c95af935e1d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2239443cf48bfdaa78c95af935e1d0f">&#9670;&nbsp;</a></span>dynamic_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value_set::Const_ptr <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::dynamic_values </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> but obtains the dynamic config in <em>one</em> specified slot as opposed to all of them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>This must be <code>S_d_value_set</code> template param pack args in position <code>1 + 2 * d_value_set_idx</code> (so one of [1, 3, ..., <code>(2 * S_N_D_VALUE_SETS) - 1</code>]). You will need to explicitly specify this <code>tparam</code>. E.g.: <code>const auto cfg_ptr = cfg_mgr.dynamic_values&lt;D_cfg2&gt;(1)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>The dynamic config slot index; so one of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac26c2d6efe1670e940badccb3fdea609" title="The number of dynamic value sets (including any Null_value_sets).">S_N_D_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ref-counted pointer to the immutable dynamic config set currently canonical in that slot. Remember: if <code>p</code> returned, then <code>*p</code> is immutable; but another <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a> call may return a different <code>p2</code> not equal to <code>p</code>. </dd></dl>

</div>
</div>
<a id="ad5cda6ace05e8bbe52a5129ed1c0720c" name="ad5cda6ace05e8bbe52a5129ed1c0720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cda6ace05e8bbe52a5129ed1c0720c">&#9670;&nbsp;</a></span>help_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::help_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a human-targeted long-form usage message that includes all options with their descriptions and defaults. </p>
<p >This is thread-safe against all concurrent methods on <code>*this</code> and can be invoked anytime after ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0192ddc2cc7302bdc8720ee56a395c02" name="a0192ddc2cc7302bdc8720ee56a395c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0192ddc2cc7302bdc8720ee56a395c02">&#9670;&nbsp;</a></span>log_help()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::log_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ad5cda6ace05e8bbe52a5129ed1c0720c" title="Prints a human-targeted long-form usage message that includes all options with their descriptions and...">help_to_ostream()</a> would print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Severity to use for the log message(s). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a220535219634c62ed2a580934c76c481" name="a220535219634c62ed2a580934c76c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220535219634c62ed2a580934c76c481">&#9670;&nbsp;</a></span>log_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::log_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs what <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a19ae9775f51953805ea08086c276a78d" title="Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of ...">state_to_ostream()</a> would print. </p>
<p >This is not thread-safe against several non-<code>const</code> methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Severity to use for the log message(s). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a978295c03998af212b464061d780520b" name="a978295c03998af212b464061d780520b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978295c03998af212b464061d780520b">&#9670;&nbsp;</a></span>register_dynamic_change_listener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt;::On_dynamic_change_func_handle <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::register_dynamic_change_listener </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d_value_set_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ab501967b40259c1a29264af1ad17baf2">On_dynamic_change_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_dynamic_change_func_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the given callback; next time <code>apply_dynamic(commit = true)</code> or <code>apply_static_and_dynamic(commit = true)</code> detects at least one changed (or initially set) option value in the specified slot, it will execute this and any other previously registered such callbacks synchronously. </p>
<p >The callbacks will be called after the pointers to be returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a6afb8620600dcb54d41211ef68859f93" title="Obtain ref-counted pointers to each currently-canonical set of dynamic config; each pointed-at struct...">all_dynamic_values()</a> have all been updated.</p>
<p >This is not thread-safe against concurrent calls to itself; nor against concurrent <code>apply_dynamic(commit = true)</code> (against <code>apply_dynamic(commit = false)</code> is okay), <code>apply_static_and_dynamic(commit = true)</code> (against <code>apply_static_and_dynamic(commit = false)</code> is okay), or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The callback may optionally be unregistered by using <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a4e0dfe1e8f57d974a775f1320bd9856d" title="Remove a previously registered dynamic change callback.">unregister_dynamic_change_listener()</a>. This <em>should</em> be done before anything that the callback accesses is invalidated. If there is a chance that <code>apply*_dynamic()</code> might be called later, then the callback <em>must</em> be unregistered before anything that it accesses is invalidated, otherwise there could be undefined behavior when the callback accesses something which is invalid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_value_set_idx</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#ac2239443cf48bfdaa78c95af935e1d0f" title="Similar to all_dynamic_values() but obtains the dynamic config in one specified slot as opposed to al...">dynamic_values()</a>. </td></tr>
    <tr><td class="paramname">on_dynamic_change_func_moved</td><td>Function to call synchronously from the next <code>apply*_dynamic()</code> that detects a change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unregister the callback. </dd></dl>

</div>
</div>
<a id="ac1ab5cefe86e6aaa0518d675f309907e" name="ac1ab5cefe86e6aaa0518d675f309907e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ab5cefe86e6aaa0518d675f309907e">&#9670;&nbsp;</a></span>reject_candidates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::reject_candidates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a not-yet-canonicalized (incomplete) multi-source update, if one is in progress. </p>
<p >If one is not in-progress, INFO-log but otherwise no-op.</p>
<p >This method only has effect following <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a>, <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a26712af2d38d3afbeb52d21b7012a03c" title="Load the first or subsequent set of dynamic config from config source including a dynamic config file...">apply_dynamic()</a> that</p><ul>
<li>returned <code>true</code>; and</li>
<li>had arg <code>commit == false</code>.</li>
</ul>
<p >That is, if there are pending <em>candidate</em> <code>Value_set</code>s that have not yet been upgraded to canonical status via a <code>commit == true</code> <code>apply_*()</code> call, this call discards them, making it as-if no such call(s) were made in the first place.</p>
<p >Informally we do not expect this to be commonly used; typically <code>apply_*()</code> will automatically do this upon encountering an error (in individual option validation or due to <a class="el" href="namespaceflow_1_1cfg.html#a80b3319f3d3a657837d0d8b28d22ccc3aec1a4aed91659725c96b0b8378dba316" title="The holistically-checked cumulative Value_set has invalid contents; the candidate shall be rejected,...">Final_validator_outcome::S_FAIL</a>). However if there is some outside reason to abort an ongoing, so-far-successful multi-source update this method will similarly do it. </p>

</div>
</div>
<a id="a19ae9775f51953805ea08086c276a78d" name="a19ae9775f51953805ea08086c276a78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ae9775f51953805ea08086c276a78d">&#9670;&nbsp;</a></span>state_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::state_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a human-targeted long-form summary of our contents, doubling as a usage message and a dump of current values where applicable. </p>
<p >This is not thread-safe against several non-<code>const</code> methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8431806f82bed676f5fedb3b64f67245" name="a8431806f82bed676f5fedb3b64f67245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8431806f82bed676f5fedb3b64f67245">&#9670;&nbsp;</a></span>static_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set &amp; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::static_values </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a76c7224711ef8a51c7005629e4eae6e7" title="Emit a pointer to each permanently set static config value set; the same pointers are emitted through...">all_static_values()</a>, but obtains the static config in <em>one</em> specified slot as opposed to all of them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>This must be <code>S_d_value_set</code> template param pack args in position <code>2 * s_value_set_idx</code> (so one of [0, 2, ..., <code>(2 * S_N_S_VALUE_SETS) - 2</code>]). You will need to explicitly specify this <code>tparam</code>. E.g.: <code>const auto cfg_ptr = cfg_mgr.static_values&lt;S_cfg2&gt;(1)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s_value_set_idx</td><td>The static config slot index; so one of [0, 1, ..., <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9c07f711e98435d00420277f1c20be75" title="The number of static value sets (including any Null_value_sets).">S_N_S_VALUE_SETS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The immutable, permanently set static config value set in the <code>s_value_set_idx</code> slot. </dd></dl>

</div>
</div>
<a id="ae034a71792f952256c18e385475627d1" name="ae034a71792f952256c18e385475627d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae034a71792f952256c18e385475627d1">&#9670;&nbsp;</a></span>static_values_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set &amp; <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::static_values_candidate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_value_set_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>, but if called from within a validator function passed to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a22bfec8082d0c7b5dff9ee7e98865707" title="Invoke this after construction to load the permanent set of static config from config sources includi...">apply_static()</a> or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a9d9811d1b4aab2c4ea3e6813d4161304" title="If you use dynamic config, and you allow for initial values for dynamic options to be read from the s...">apply_static_and_dynamic()</a>, then the parsed values <em>candidate</em> will be returned, instead, if values have been parsed and validated for the static value set but have not yet been applied. </p>
<p >Otherwise, the behavior is equivalent to <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a616c39cdf1c6f7f4d2af3a3055edf486" title="Similar to all_static_values(), but if called from within a validator function passed to apply_static...">all_static_values_candidates()</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s_value_set_idx</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above and <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a8431806f82bed676f5fedb3b64f67245" title="Similar to all_static_values(), but obtains the static config in one specified slot as opposed to all...">static_values()</a>. </dd></dl>

</div>
</div>
<a id="a4e0dfe1e8f57d974a775f1320bd9856d" name="a4e0dfe1e8f57d974a775f1320bd9856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0dfe1e8f57d974a775f1320bd9856d">&#9670;&nbsp;</a></span>unregister_dynamic_change_listener()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">flow::cfg::Config_manager</a>&lt; S_d_value_set &gt;::unregister_dynamic_change_listener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1cfg_1_1Config__manager_1_1On__dynamic__change__func__handle.html">On_dynamic_change_func_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously registered dynamic change callback. </p>
<p >See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>.</p>
<p >This is not thread-safe against concurrent calls to itself; nor against concurrent <code>apply_dynamic(commit = true)</code> (against <code>apply_dynamic(commit = false)</code> is okay), <code>apply_static_and_dynamic(commit = true)</code> (against <code>apply_static_and_dynamic(commit = false)</code> is okay), or <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle which was returned by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html#a978295c03998af212b464061d780520b" title="Saves the given callback; next time apply_dynamic(commit = true) or apply_static_and_dynamic(commit =...">register_dynamic_change_listener()</a> when the callback was registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a453d83bf1e8b57b1aaff511fbe913ecc" name="a453d83bf1e8b57b1aaff511fbe913ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453d83bf1e8b57b1aaff511fbe913ecc">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... S_d_value_set&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Config__manager.html">Config_manager</a>&lt; S_d_value_set... &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes (briefly) a <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_d_value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cfg/<a class="el" href="cfg__manager_8hpp.html">cfg_manager.hpp</a></li>
<li>cfg/<a class="el" href="cfg__manager__fwd_8hpp.html">cfg_manager_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 02:13:39 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
