<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Server_socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1net__flow_1_1Server__socket-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Server_socket Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A server socket able to listen on a single Flow port for incoming connections and return peer sockets (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects) to the local user once such connections are established.  
 <a href="classflow_1_1net__flow_1_1Server__socket.html#details">More...</a></p>

<p><code>#include &lt;server_socket.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Server_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Server__socket__inherit__graph.svg" width="575" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Server_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Server__socket__coll__graph.svg" width="399" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8bc789b851677a47d7c0a1aa0c69a997"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">State</a> { <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a">S_LISTENING</a>
, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42">S_CLOSING</a>
, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>
 }</td></tr>
<tr class="memdesc:a8bc789b851677a47d7c0a1aa0c69a997"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">More...</a><br /></td></tr>
<tr class="separator:a8bc789b851677a47d7c0a1aa0c69a997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc28900b6854a425ea33a192eda8252"><td class="memItemLeft" align="right" valign="top"><a id="a3bc28900b6854a425ea33a192eda8252" name="a3bc28900b6854a425ea33a192eda8252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Peer_socket_ptr</b> = boost::shared_ptr&lt; <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> &gt;</td></tr>
<tr class="memdesc:a3bc28900b6854a425ea33a192eda8252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a>, but can't use that due to C++'s circular reference nonsense. <br /></td></tr>
<tr class="separator:a3bc28900b6854a425ea33a192eda8252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Server_socket &gt; &gt;</a></td></tr>
<tr class="memitem:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top"><a id="aa4f1af88393042e60159a3a67f0accbc" name="aa4f1af88393042e60159a3a67f0accbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = boost::shared_ptr&lt; Server_socket &gt;</td></tr>
<tr class="memdesc:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to mutable values of type <code>Target_type::element_type</code> (a-la <code>T*</code>). <br /></td></tr>
<tr class="separator:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top"><a id="aef7998db71c60eeb5d1e3d1a97c14886" name="aef7998db71c60eeb5d1e3d1a97c14886"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_ptr</b> = Const_target_ptr</td></tr>
<tr class="memdesc:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to immutable values of type <code>Target_type::element_type</code> (a-la <code>T const *</code>). <br /></td></tr>
<tr class="separator:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acafb67ed1f81b90f3b2ab923de4e0525"><td class="memItemLeft" align="right" valign="top"><a id="acafb67ed1f81b90f3b2ab923de4e0525" name="acafb67ed1f81b90f3b2ab923de4e0525"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Server_socket</b> () override</td></tr>
<tr class="memdesc:acafb67ed1f81b90f3b2ab923de4e0525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly. <br /></td></tr>
<tr class="separator:acafb67ed1f81b90f3b2ab923de4e0525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2683ecde1fac2b0a79a957de1a2a8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff">state</a> () const</td></tr>
<tr class="memdesc:ab2683ecde1fac2b0a79a957de1a2a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current State of the socket.  <a href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff">More...</a><br /></td></tr>
<tr class="separator:ab2683ecde1fac2b0a79a957de1a2a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e94978d59dfe23559a254349670bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ae22e94978d59dfe23559a254349670bd">node</a> () const</td></tr>
<tr class="memdesc:ae22e94978d59dfe23559a254349670bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>.  <a href="classflow_1_1net__flow_1_1Server__socket.html#ae22e94978d59dfe23559a254349670bd">More...</a><br /></td></tr>
<tr class="separator:ae22e94978d59dfe23559a254349670bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b6b9c66eee2f3bbf35ac1068b1cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#acd7b6b9c66eee2f3bbf35ac1068b1cb1">local_port</a> () const</td></tr>
<tr class="memdesc:acd7b6b9c66eee2f3bbf35ac1068b1cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local Flow-protocol port on which this server is or was listening.  <a href="classflow_1_1net__flow_1_1Server__socket.html#acd7b6b9c66eee2f3bbf35ac1068b1cb1">More...</a><br /></td></tr>
<tr class="separator:acd7b6b9c66eee2f3bbf35ac1068b1cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea8554e23c8d743ca4956c772adbf24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a3bc28900b6854a425ea33a192eda8252">Peer_socket_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24">accept</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aeea8554e23c8d743ca4956c772adbf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connection on this server.  <a href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24">More...</a><br /></td></tr>
<tr class="separator:aeea8554e23c8d743ca4956c772adbf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ba529163a2d50132eff7aec9d9c9b8"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a02ba529163a2d50132eff7aec9d9c9b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a3bc28900b6854a425ea33a192eda8252">Peer_socket_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8">sync_accept</a> (const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, bool reactor_pattern=false, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a02ba529163a2d50132eff7aec9d9c9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8">More...</a><br /></td></tr>
<tr class="separator:a02ba529163a2d50132eff7aec9d9c9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbf25d3921f6b9cbba463ef5a93d1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a3bc28900b6854a425ea33a192eda8252">Peer_socket_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a5bbf25d3921f6b9cbba463ef5a93d1e4">sync_accept</a> (bool reactor_pattern=false, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a5bbf25d3921f6b9cbba463ef5a93d1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_accept(duration::max(), reactor_pattern, err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a> with no user timeout.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a5bbf25d3921f6b9cbba463ef5a93d1e4">More...</a><br /></td></tr>
<tr class="separator:a5bbf25d3921f6b9cbba463ef5a93d1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba400221e347613c0d101b19602a3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a6ba400221e347613c0d101b19602a3a2">disconnect_cause</a> () const</td></tr>
<tr class="memdesc:a6ba400221e347613c0d101b19602a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a6ba400221e347613c0d101b19602a3a2">More...</a><br /></td></tr>
<tr class="separator:a6ba400221e347613c0d101b19602a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1f48a72439665d8754549f11a4f4c7bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a1f48a72439665d8754549f11a4f4c7bb">Server_socket</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *child_sock_opts)</td></tr>
<tr class="memdesc:a1f48a72439665d8754549f11a4f4c7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a1f48a72439665d8754549f11a4f4c7bb">More...</a><br /></td></tr>
<tr class="separator:a1f48a72439665d8754549f11a4f4c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acbbe4fae58626a54fabdcd4bcdfdb011"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#acbbe4fae58626a54fabdcd4bcdfdb011">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *serv)</td></tr>
<tr class="memdesc:acbbe4fae58626a54fabdcd4bcdfdb011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Server__socket.html#acbbe4fae58626a54fabdcd4bcdfdb011">More...</a><br /></td></tr>
<tr class="separator:acbbe4fae58626a54fabdcd4bcdfdb011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a48bc8803c67e75b955a1f2778a8ad2bf">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a> <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff">state</a>)</td></tr>
<tr class="memdesc:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Server__socket.html#a48bc8803c67e75b955a1f2778a8ad2bf">More...</a><br /></td></tr>
<tr class="separator:a48bc8803c67e75b955a1f2778a8ad2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Server_socket &gt; &gt;</a></td></tr>
<tr class="memitem:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides syntactic-sugary way to perform a <code>static_pointer_cast&lt;&gt;</code> from a compatible smart pointer type <code>From_ptr</code>, typically <code>From_ptr::element_type</code> being in the same class hierarchy as <code>Target_ptr::element_type</code>.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">More...</a><br /></td></tr>
<tr class="separator:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but adds <code>const</code>-ness (immutability) to the pointed-to type.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">More...</a><br /></td></tr>
<tr class="separator:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">dynamic_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">More...</a><br /></td></tr>
<tr class="separator:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">dynamic_const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8" title="Identical to ptr_cast() but adds const-ness (immutability) to the pointed-to type.">const_ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">More...</a><br /></td></tr>
<tr class="separator:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A server socket able to listen on a single Flow port for incoming connections and return peer sockets (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects) to the local user once such connections are established. </p>
<h3>Life cycle of a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a></h3>
<p >A given <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> can only arise by calling <a class="el" href="classflow_1_1net__flow_1_1Node.html#a3c2cd6a6c328a2d5381308258d35d95d" title="Sets up a server on the given local Flow port and returns Server_socket which can be used to accept s...">Node::listen()</a>. <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> generates a new <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> and returns it (factory pattern). <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> is not instantiable otherwise. A <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> cannot be deleted explicitly by the user and will only be returned via <code>boost::shared_ptr&lt;&gt;</code>; when both the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and all user code no longer refers to it, the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> will be destroyed.</p>
<p >Once a Flow-protocol user has a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> object, that object represents a socket in one of the following basic states:</p>
<ul>
<li>Listening.<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> may or may not return peer socket ("Acceptable").</li>
</ul>
</li>
<li>Closing.<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> will never return peer socket (never Acceptable).</li>
</ul>
</li>
<li>Closed.<ul>
<li><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> will never return peer socket (never Acceptable).</li>
</ul>
</li>
</ul>
<p >Exactly the following state transitions are possible for a given <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>:</p>
<ul>
<li>start =&gt; Listening</li>
<li>start =&gt; Closing</li>
<li>start =&gt; Closed</li>
<li>Listening =&gt; Closing</li>
<li>Listening =&gt; Closed</li>
<li>Closing =&gt; Closed</li>
</ul>
<p >Note, in particular, that Closed is final; socket cannot move from Closed to Listening. If after an error or valid closing you want to reestablish a server, obtain a new <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> from <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s factory. Same rationale as for equivalent design decision in <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.</p>
<p >Closing means either this side or other side initiated the closing of this server socket for any reason, but <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is still finishing up operations related to that in the background (such as closing in-progress peer connections). Closed means <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has finished any such operations and has disowned the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>.</p>
<p >In either case the only operation <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> supports (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> and derivatives thereof) is impossible in Closing and Closed. Therefore the two states are distinguished for diagnostic/informational purposes only. Generally one should only <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> when Acceptable, and <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> will return an error if the state is Closing or Closed.</p>
<p >Note that a Closing or Closed <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> does NOT mean that already <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>ed <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects will be in any way affected.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd>Implement <code>Server_socket::close()</code> functionality &ndash; at least the equivalent of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">Peer_socket::close_abruptly()</a>.</dd></dl>
<h3>Accept queue</h3>
<p ><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, like a TCP server socket, stores a queue of fully established peer connections. A <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is placed onto this internal queue only once its <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff" title="Current State of the socket.">state()</a> == State::S_OPEN (i.e., the connection handshake is finished/successful). <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects are then obtained from this queue via the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> call and its derivatives.</p>
<h3>Efficiently <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>ing</h3>
<p >The <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a> method is efficient, in that it uses no processor cycles until Acceptable is achieved (i.e., it sleeps until that point). The non-blocking <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> method doesn't sleep/block, however. For a program using it to be efficient it should sleep until Acceptable and only then call <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>, when a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is certainly available for immediate acceptance. Moreover, a complex program is likely to want to perform this sleep-and-conditional-wake on a set of several Server_sockets (and/or other sockets) simultaneously (similarly to <code>select()</code>, <code>epoll*()</code>, etc.). Use class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> for this purpose.</p>
<h3>Thread safety</h3>
<p >Same as for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (Briefly: all operations safe for simultaneous execution on separate or the same object.) </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8bc789b851677a47d7c0a1aa0c69a997" name="a8bc789b851677a47d7c0a1aa0c69a997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc789b851677a47d7c0a1aa0c69a997">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">flow::net_flow::Server_socket::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State of a <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a" name="a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a"></a>S_LISTENING&#160;</td><td class="fielddoc"><p >Future or current <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>s may be possible. A socket in this state may be Acceptable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42" name="a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42"></a>S_CLOSING&#160;</td><td class="fielddoc"><p >No <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>s are or will be possible, but <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is still finishing up the closing operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" name="a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f"></a>S_CLOSED&#160;</td><td class="fielddoc"><p >No <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>s are or will be possible, AND <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has disowned the <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f48a72439665d8754549f11a4f4c7bb" name="a1f48a72439665d8754549f11a4f4c7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f48a72439665d8754549f11a4f4c7bb">&#9670;&nbsp;</a></span>Server_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Server_socket::Server_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> *&#160;</td>
          <td class="paramname"><em>child_sock_opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The Logger implementation to use subsequently. </td></tr>
    <tr><td class="paramname">child_sock_opts</td><td>Pointer to a per-socket options <code>struct</code> to copy and store; for each <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> resulting from this <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, the options will be a copy of this copy. If null pointer, then instead the enclosing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s global per-socket options will be used to produce the copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeea8554e23c8d743ca4956c772adbf24" name="aeea8554e23c8d743ca4956c772adbf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea8554e23c8d743ca4956c772adbf24">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Server_socket::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connection on this server. </p>
<p >There is a queue (FIFO) of not-yet-claimed connections, and this returns the one at the front of the queue.</p>
<p >If <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff" title="Current State of the socket.">state()</a> is <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42" title="No accept()s are or will be possible, but Node is still finishing up the closing operation.">State::S_CLOSING</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">State::S_CLOSED</a> (i.e., not <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aebae5ec546409cde4d74d99452d9cc8a" title="Future or current accept()s may be possible. A socket in this state may be Acceptable.">State::S_LISTENING</a>), this will return null (and an error), even if connections have been queued up. Rationale: BSD sockets act similarly: cannot succeed with <code>accept(s)</code>, if <code>s</code> is not listening; also internal implementation is simpler. Anti-rationale: our API is much more amenable to allowing <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>s in that situation; and it would mirror the fact that <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> can succeed in <code>S_OPEN+S_DISCONNECTING</code> state. Why rationale &gt; anti-rationale: it's a judgment call, and I'm going with simplicity of implementation at least for now.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000057">Todo:</a></b></dt><dd>Reconsider allowing successful <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> in <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997aa27ca0689984ee6c6784a9265a678d42" title="No accept()s are or will be possible, but Node is still finishing up the closing operation.">State::S_CLOSING</a> state?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Note: no available connections is not, in itself, an error. So it's quite possible for null to be returned but <code>*err_code</code> is success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> <code>sock</code> with <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff" title="Current State of the socket.">state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">Peer_socket::State::S_OPEN</a></code>. If no connections are available (including if <code>bool(*err_code) == true</code>), returns null pointer. </dd></dl>

</div>
</div>
<a id="a6ba400221e347613c0d101b19602a3a2" name="a6ba400221e347613c0d101b19602a3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba400221e347613c0d101b19602a3a2">&#9670;&nbsp;</a></span>disconnect_cause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> flow::net_flow::Server_socket::disconnect_cause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#ab2683ecde1fac2b0a79a957de1a2a8ff" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997a6abcbd1be8478aa03e76aec9c540e14f" title="No accept()s are or will be possible, AND Node has disowned the Server_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED. </p>
<p >Note that once it returns non-success, the returned value subsequently will always be the same.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="acd7b6b9c66eee2f3bbf35ac1068b1cb1" name="acd7b6b9c66eee2f3bbf35ac1068b1cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b6b9c66eee2f3bbf35ac1068b1cb1">&#9670;&nbsp;</a></span>local_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Server_socket::local_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The local Flow-protocol port on which this server is or was listening. </p>
<p >For a given <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>, this will always return the same value, even if CLOSED. However, when CLOSED, the port may be unused or taken by another socket.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ae22e94978d59dfe23559a254349670bd" name="ae22e94978d59dfe23559a254349670bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22e94978d59dfe23559a254349670bd">&#9670;&nbsp;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> * flow::net_flow::Server_socket::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to (guaranteed valid) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>; 0 if state is S_CLOSED. </dd></dl>

</div>
</div>
<a id="ab2683ecde1fac2b0a79a957de1a2a8ff" name="ab2683ecde1fac2b0a79a957de1a2a8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2683ecde1fac2b0a79a957de1a2a8ff">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a> flow::net_flow::Server_socket::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current State of the socket. </p>
<dl class="section return"><dt>Returns</dt><dd>Current state of the socket. </dd></dl>

</div>
</div>
<a id="a5bbf25d3921f6b9cbba463ef5a93d1e4" name="a5bbf25d3921f6b9cbba463ef5a93d1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbf25d3921f6b9cbba463ef5a93d1e4">&#9670;&nbsp;</a></span>sync_accept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Peer_socket::Ptr</a> flow::net_flow::Server_socket::sync_accept </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reactor_pattern</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_accept(duration::max(), reactor_pattern, err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a> with no user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a>. </td></tr>
    <tr><td class="paramname">reactor_pattern</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a>. </dd></dl>

</div>
</div>
<a id="a02ba529163a2d50132eff7aec9d9c9b8" name="a02ba529163a2d50132eff7aec9d9c9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ba529163a2d50132eff7aec9d9c9b8">&#9670;&nbsp;</a></span>sync_accept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a3bc28900b6854a425ea33a192eda8252">Server_socket::Peer_socket_ptr</a> flow::net_flow::Server_socket::sync_accept </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reactor_pattern</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a>, except that if <code>*this</code> is not immediately Acceptable (i.e., <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> would return null and no error), waits until it is Acceptable (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> would return either non-null, or null and an error) and returns <code>accept(err_code)</code>. In <code>reactor_pattern</code> mode (see arg doc), if it were to otherwise return a non-null <code><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc" title="Short-hand for ref-counted pointer to mutable values of type Target_type::element_type (a-la T*).">Peer_socket::Ptr</a></code>, it instead leaves the ready peer socket available for subsequence acceptance and returns null.</p>
<p >If a timeout is specified, and this timeout expires before socket is Acceptable, acts like <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">accept()</a> executed on an un-Acceptable server socket.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes.</p><ol type="1">
<li>Connection succeeds before the given timeout expires (or succeeds, if no timeout given). Socket is at least Writable at time of return. If <code>!reactor_pattern</code> then the new socket is returned, and no error is returned via <code>*err_code</code>; otherwise the socket is left available for acceptance, while null is returned, and (similarly to non-reactor-pattern mode) no error is returned via <code>*err_code</code>.</li>
<li>Connection fails before the given timeout expires (or fails, if no timeout given). null is returned, <code>*err_code</code> is set to reason for connection failure unless null. (If <code>err_code</code> null, Runtime_error thrown.) The code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>A user timeout is given, and the connection does not succeed before it expires. Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>. (Rationale: consistent with sync_receive(), sync_send() behavior.)</li>
</ol>
<p >Note that &ndash; if <code>!reactor_pattern</code> &ndash; it is NOT possible to return null and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="section see"><dt>See also</dt><dd>The version of <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">sync_accept()</a> with no timeout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait (i.e., no timeout). </td></tr>
    <tr><td class="paramname">reactor_pattern</td><td>If and only if <code>true</code>, and the call successfully waited until server socket became Acceptable, then we return a null pointer and leave the peer socket ready to be accepted by the caller. If <code>false</code>, then in that same situation the socket is accepted and returned. The parameter doesn't affect any other situations. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference-counted pointer to new <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a>; or an empty pointer (essentially null). Reminder that in <code>reactor_pattern</code> mode this may be null, yet indeed a socket is Acceptable (the presence or lack of an error indicates whether that's the case). </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="acbbe4fae58626a54fabdcd4bcdfdb011" name="acbbe4fae58626a54fabdcd4bcdfdb011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbe4fae58626a54fabdcd4bcdfdb011">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html">Server_socket</a> *&#160;</td>
          <td class="paramname"><em>serv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given socket to given standard <code>ostream</code> and returns the latter. </p>
<p >The representation includes the local endpoint and the hex pointer value.</p>
<dl class="section note"><dt>Note</dt><dd><code>shared_ptr</code> forwards <code>ostream</code> output to the underlying pointer type, so this will affect <code>Ptr</code> output as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">serv</td><td>Object to serialize. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="a48bc8803c67e75b955a1f2778a8ad2bf" name="a48bc8803c67e75b955a1f2778a8ad2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bc8803c67e75b955a1f2778a8ad2bf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a8bc789b851677a47d7c0a1aa0c69a997">Server_socket::State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given socket state to given standard <code>ostream</code> and returns the latter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">state</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="server__socket_8hpp.html">server_socket.hpp</a></li>
<li>net_flow/<a class="el" href="net__flow__fwd_8hpp.html">net_flow_fwd.hpp</a></li>
<li>net_flow/<a class="el" href="server__socket_8cpp.html">server_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 02:13:39 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
