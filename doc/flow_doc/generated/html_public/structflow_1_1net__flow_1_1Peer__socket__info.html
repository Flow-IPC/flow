<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Peer_socket_info Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structflow_1_1net__flow_1_1Peer__socket__info-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Peer_socket_info Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A data store that keeps stats about the a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> connection.  
 <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#details">More...</a></p>

<p><code>#include &lt;info.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Peer_socket_info:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structflow_1_1net__flow_1_1Peer__socket__info__coll__graph.svg" width="679" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af165063dae6f488685c7d9c0a2f42eaf"><td class="memItemLeft" align="right" valign="top"><a id="af165063dae6f488685c7d9c0a2f42eaf" name="af165063dae6f488685c7d9c0a2f42eaf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Fine_duration</b> = <a class="el" href="namespaceflow.html#a48799f1263cdeedec125be51a3db2b79">flow::Fine_duration</a></td></tr>
<tr class="memdesc:af165063dae6f488685c7d9c0a2f42eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a fine boost.chrono time duration type. <br /></td></tr>
<tr class="separator:af165063dae6f488685c7d9c0a2f42eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2cb2bd7bfd1be576d9f5ddf8ac0492"><td class="memItemLeft" align="right" valign="top"><a id="a3b2cb2bd7bfd1be576d9f5ddf8ac0492" name="a3b2cb2bd7bfd1be576d9f5ddf8ac0492"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Fine_time_pt</b> = <a class="el" href="namespaceflow.html#a9d9cc2eeb10d398cff5591d446b763b8">flow::Fine_time_pt</a></td></tr>
<tr class="memdesc:a3b2cb2bd7bfd1be576d9f5ddf8ac0492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for a fine boost.chrono time point type. <br /></td></tr>
<tr class="separator:a3b2cb2bd7bfd1be576d9f5ddf8ac0492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3033730514f1bcf125eb1657ccab2f58"><td class="memItemLeft" align="right" valign="top"><a id="a3033730514f1bcf125eb1657ccab2f58" name="a3033730514f1bcf125eb1657ccab2f58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Peer_socket_info</b> ()</td></tr>
<tr class="memdesc:a3033730514f1bcf125eb1657ccab2f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by initializing stats to their initial values. <br /></td></tr>
<tr class="separator:a3033730514f1bcf125eb1657ccab2f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa22131f82263a6c8c9c0512cb016be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#adaa22131f82263a6c8c9c0512cb016be">output</a> (std::ostream *os) const</td></tr>
<tr class="memdesc:adaa22131f82263a6c8c9c0512cb016be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the current stats, across multiple lines but not ending with a newline, into the given output stream.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#adaa22131f82263a6c8c9c0512cb016be">More...</a><br /></td></tr>
<tr class="separator:adaa22131f82263a6c8c9c0512cb016be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a116259f40c07caafe63017dddb9a837c"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a116259f40c07caafe63017dddb9a837c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a116259f40c07caafe63017dddb9a837c">output_map_of_pkt_counts</a> (std::ostream *os, const std::map&lt; Key, Value &gt; &amp;count_by_type, const std::map&lt; Key, Value &gt; *size_by_type)</td></tr>
<tr class="memdesc:a116259f40c07caafe63017dddb9a837c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for various <code><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#adaa22131f82263a6c8c9c0512cb016be" title="Outputs the current stats, across multiple lines but not ending with a newline, into the given output...">output()</a></code> methods that outputs a one-line representation of a sorted map, with arbitrary keys and values.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a116259f40c07caafe63017dddb9a837c">More...</a><br /></td></tr>
<tr class="separator:a116259f40c07caafe63017dddb9a837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af8234f1645d63b9eee57f6937dc222de"><td class="memItemLeft" align="right" valign="top"><a id="af8234f1645d63b9eee57f6937dc222de" name="af8234f1645d63b9eee57f6937dc222de"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html">Peer_socket_receive_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv</b></td></tr>
<tr class="memdesc:af8234f1645d63b9eee57f6937dc222de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for incoming direction of traffic. As opposed to the other <code>m_rcv_*</code> members, this typically accumulates. <br /></td></tr>
<tr class="separator:af8234f1645d63b9eee57f6937dc222de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c61270ec35141affc5bb9f6edc5cd0"><td class="memItemLeft" align="right" valign="top"><a id="a02c61270ec35141affc5bb9f6edc5cd0" name="a02c61270ec35141affc5bb9f6edc5cd0"></a>
<a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html">Peer_socket_send_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd</b></td></tr>
<tr class="memdesc:a02c61270ec35141affc5bb9f6edc5cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for outgoing direction of traffic. As opposed to the other <code>m_snd_*</code> members, this typically accumulates. <br /></td></tr>
<tr class="separator:a02c61270ec35141affc5bb9f6edc5cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddfcfe377cda3266dfc968797ce4c18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a0ddfcfe377cda3266dfc968797ce4c18">m_low_lvl_max_buf_size</a></td></tr>
<tr class="memdesc:a0ddfcfe377cda3266dfc968797ce4c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UDP receive buffer maximum size, as reported by an appropriate call to the appropriate <code>getsockopt()</code> immediately after the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> sets the UDP receive buffer size via <code>setsockopt()</code>.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a0ddfcfe377cda3266dfc968797ce4c18">More...</a><br /></td></tr>
<tr class="separator:a0ddfcfe377cda3266dfc968797ce4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636e783090aee4ca8770a9f85f35dd21"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21">m_int_state_str</a></td></tr>
<tr class="memdesc:a636e783090aee4ca8770a9f85f35dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal state of the socket, rendered into string (e.g., "SYN_RECEIVED" or "ESTABLISHED").  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21">More...</a><br /></td></tr>
<tr class="separator:a636e783090aee4ca8770a9f85f35dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0db949c58be9d7779c342cf5a67c9c"><td class="memItemLeft" align="right" valign="top"><a id="acc0db949c58be9d7779c342cf5a67c9c" name="acc0db949c58be9d7779c342cf5a67c9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_is_active_connect</b></td></tr>
<tr class="memdesc:acc0db949c58be9d7779c342cf5a67c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if this is the "client" socket (<code>connect()</code>ed); <code>false</code> otherwise (<code>accept()</code>ed). <br /></td></tr>
<tr class="separator:acc0db949c58be9d7779c342cf5a67c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24bf78d7bad33c38b96694733836224"><td class="memItemLeft" align="right" valign="top"><a id="aa24bf78d7bad33c38b96694733836224" name="aa24bf78d7bad33c38b96694733836224"></a>
<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_disconnect_cause</b></td></tr>
<tr class="memdesc:aa24bf78d7bad33c38b96694733836224"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the socket is closing or closed, this is the reason for the closure; otherwise the default-constructed value. <br /></td></tr>
<tr class="separator:aa24bf78d7bad33c38b96694733836224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127a03a0b0e2f73d1059b7b42f251fa2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a127a03a0b0e2f73d1059b7b42f251fa2">m_rcv_buf_size</a></td></tr>
<tr class="memdesc:a127a03a0b0e2f73d1059b7b42f251fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes in the internal Receive buffer.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a127a03a0b0e2f73d1059b7b42f251fa2">More...</a><br /></td></tr>
<tr class="separator:a127a03a0b0e2f73d1059b7b42f251fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ae8091d89ae59304fd5ebd18539d8b"><td class="memItemLeft" align="right" valign="top"><a id="a84ae8091d89ae59304fd5ebd18539d8b" name="a84ae8091d89ae59304fd5ebd18539d8b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv_wnd</b></td></tr>
<tr class="memdesc:a84ae8091d89ae59304fd5ebd18539d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive window size = max Receive buffer space minus space taken. Infinity if flow control disabled. <br /></td></tr>
<tr class="separator:a84ae8091d89ae59304fd5ebd18539d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2562eebd9be1837147fef6fa616cb920"><td class="memItemLeft" align="right" valign="top"><a id="a2562eebd9be1837147fef6fa616cb920" name="a2562eebd9be1837147fef6fa616cb920"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv_wnd_last_advertised</b></td></tr>
<tr class="memdesc:a2562eebd9be1837147fef6fa616cb920"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last rcv_wnd (receive window) size sent to sender (not necessarily received; packets can be lost). <br /></td></tr>
<tr class="separator:a2562eebd9be1837147fef6fa616cb920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a38b2a47235621222eb58e6212a4f05"><td class="memItemLeft" align="right" valign="top"><a id="a3a38b2a47235621222eb58e6212a4f05" name="a3a38b2a47235621222eb58e6212a4f05"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv_reassembly_q_data_size</b></td></tr>
<tr class="memdesc:a3a38b2a47235621222eb58e6212a4f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>rexmit_on</code> is <code>false</code> then 0; otherwise the total DATA payload in the reassembly queue of the socket. <br /></td></tr>
<tr class="separator:a3a38b2a47235621222eb58e6212a4f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3326fea94763621c47c8b0e4d31eb2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a8c3326fea94763621c47c8b0e4d31eb2">m_rcv_packets_with_gaps</a></td></tr>
<tr class="memdesc:a8c3326fea94763621c47c8b0e4d31eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of DATA packets tracked in structure tracking all valid received packets such at least one packet that has not yet been received precedes (by sequence #) each one (in other words, all post-first-gap packets).  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a8c3326fea94763621c47c8b0e4d31eb2">More...</a><br /></td></tr>
<tr class="separator:a8c3326fea94763621c47c8b0e4d31eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f97c94357653fe6df91677ef070d3e8"><td class="memItemLeft" align="right" valign="top"><a id="a4f97c94357653fe6df91677ef070d3e8" name="a4f97c94357653fe6df91677ef070d3e8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv_syn_rcvd_data_cumulative_size</b></td></tr>
<tr class="memdesc:a4f97c94357653fe6df91677ef070d3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of DATA payload queued while waiting for SYN_ACK_ACK in SYN_RCVD state. <br /></td></tr>
<tr class="separator:a4f97c94357653fe6df91677ef070d3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210e5a1ecd85ed1cb46be696f5faec4"><td class="memItemLeft" align="right" valign="top"><a id="a6210e5a1ecd85ed1cb46be696f5faec4" name="a6210e5a1ecd85ed1cb46be696f5faec4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_rcv_syn_rcvd_data_q_size</b></td></tr>
<tr class="memdesc:a6210e5a1ecd85ed1cb46be696f5faec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of DATA packets queued while waiting for SYN_ACK_ACK in SYN_RCVD state. <br /></td></tr>
<tr class="separator:a6210e5a1ecd85ed1cb46be696f5faec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2cdb7f0a7e0fd470adeab4009f44a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a45e2cdb7f0a7e0fd470adeab4009f44a">m_snd_buf_size</a></td></tr>
<tr class="memdesc:a45e2cdb7f0a7e0fd470adeab4009f44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes in the internal Send buffer.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a45e2cdb7f0a7e0fd470adeab4009f44a">More...</a><br /></td></tr>
<tr class="separator:a45e2cdb7f0a7e0fd470adeab4009f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b267eb5fa888e21e415f0e0d26a87"><td class="memItemLeft" align="right" valign="top"><a id="abb8b267eb5fa888e21e415f0e0d26a87" name="abb8b267eb5fa888e21e415f0e0d26a87"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_rcv_wnd</b></td></tr>
<tr class="memdesc:abb8b267eb5fa888e21e415f0e0d26a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The receive window (rcv_wnd a/k/a free Receive buffer space) value of the peer socket on the other side, last advertised by the other side. <br /></td></tr>
<tr class="separator:abb8b267eb5fa888e21e415f0e0d26a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959898645f07733966840b7b8309e6c2"><td class="memItemLeft" align="right" valign="top"><a id="a959898645f07733966840b7b8309e6c2" name="a959898645f07733966840b7b8309e6c2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_cong_ctl_wnd_bytes</b></td></tr>
<tr class="memdesc:a959898645f07733966840b7b8309e6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In congestion control, the current congestion window (number of outgoing data bytes allowed In-flight currently). <br /></td></tr>
<tr class="separator:a959898645f07733966840b7b8309e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9da1d80bbed4b286c084dba3ed5b12e"><td class="memItemLeft" align="right" valign="top"><a id="ab9da1d80bbed4b286c084dba3ed5b12e" name="ab9da1d80bbed4b286c084dba3ed5b12e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_cong_ctl_wnd_count_approx</b></td></tr>
<tr class="memdesc:ab9da1d80bbed4b286c084dba3ed5b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In congestion control, the approximate equivalent of <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9" title="In congestion control, the current sent data bytes that have been neither acknowledged nor considered...">m_snd_cong_ctl_in_flight_bytes</a> as a full packet count. <br /></td></tr>
<tr class="separator:ab9da1d80bbed4b286c084dba3ed5b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784bd75264e26acbccd966e48c07dab9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9">m_snd_cong_ctl_in_flight_bytes</a></td></tr>
<tr class="memdesc:a784bd75264e26acbccd966e48c07dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In congestion control, the current sent data bytes that have been neither acknowledged nor considered lost.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9">More...</a><br /></td></tr>
<tr class="separator:a784bd75264e26acbccd966e48c07dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f59a6c658d45c3283865b97dd01489"><td class="memItemLeft" align="right" valign="top"><a id="a76f59a6c658d45c3283865b97dd01489" name="a76f59a6c658d45c3283865b97dd01489"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_cong_ctl_in_flight_count</b></td></tr>
<tr class="memdesc:a76f59a6c658d45c3283865b97dd01489"><td class="mdescLeft">&#160;</td><td class="mdescRight">In congestion control, the current sent data packets that have been neither acknowledged nor considered lost. <br /></td></tr>
<tr class="separator:a76f59a6c658d45c3283865b97dd01489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fafa98dd848eb3944591472c6ce0548"><td class="memItemLeft" align="right" valign="top"><a id="a9fafa98dd848eb3944591472c6ce0548" name="a9fafa98dd848eb3944591472c6ce0548"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#af165063dae6f488685c7d9c0a2f42eaf">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_smoothed_round_trip_time</b></td></tr>
<tr class="memdesc:a9fafa98dd848eb3944591472c6ce0548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated current round trip time of packets, computed as a smooth value over the past individual RTTs. <br /></td></tr>
<tr class="separator:a9fafa98dd848eb3944591472c6ce0548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedadfb406ca6842ab1ecc0c4020e2a58"><td class="memItemLeft" align="right" valign="top"><a id="aedadfb406ca6842ab1ecc0c4020e2a58" name="aedadfb406ca6842ab1ecc0c4020e2a58"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#af165063dae6f488685c7d9c0a2f42eaf">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_round_trip_time_variance</b></td></tr>
<tr class="memdesc:aedadfb406ca6842ab1ecc0c4020e2a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTTVAR used for <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a9fafa98dd848eb3944591472c6ce0548" title="Estimated current round trip time of packets, computed as a smooth value over the past individual RTT...">m_snd_smoothed_round_trip_time</a> calculation; it is the current RTT variance. <br /></td></tr>
<tr class="separator:aedadfb406ca6842ab1ecc0c4020e2a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe104d81f760a454df6d3b0273a2d101"><td class="memItemLeft" align="right" valign="top"><a id="afe104d81f760a454df6d3b0273a2d101" name="afe104d81f760a454df6d3b0273a2d101"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#af165063dae6f488685c7d9c0a2f42eaf">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_drop_timeout</b></td></tr>
<tr class="memdesc:afe104d81f760a454df6d3b0273a2d101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop Timeout: how long a given packet must remain unacknowledged to be considered dropped due to Drop Timeout. <br /></td></tr>
<tr class="separator:afe104d81f760a454df6d3b0273a2d101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd2ed68fd975dfa113f9f66c41d152a"><td class="memItemLeft" align="right" valign="top"><a id="accd2ed68fd975dfa113f9f66c41d152a" name="accd2ed68fd975dfa113f9f66c41d152a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_pacing_packet_q_size</b></td></tr>
<tr class="memdesc:accd2ed68fd975dfa113f9f66c41d152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In pacing, number of packets currently queued to be sent out by the pacing module. <br /></td></tr>
<tr class="separator:accd2ed68fd975dfa113f9f66c41d152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b03bba60c815cb17c40802eee400ae2"><td class="memItemLeft" align="right" valign="top"><a id="a6b03bba60c815cb17c40802eee400ae2" name="a6b03bba60c815cb17c40802eee400ae2"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3b2cb2bd7bfd1be576d9f5ddf8ac0492">Fine_time_pt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_pacing_slice_start</b></td></tr>
<tr class="memdesc:a6b03bba60c815cb17c40802eee400ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In pacing, the time point marking the beginning of the current pacing time slice. <br /></td></tr>
<tr class="separator:a6b03bba60c815cb17c40802eee400ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab155050d2cc96c5dc7dc9a2d1e2b1"><td class="memItemLeft" align="right" valign="top"><a id="a36ab155050d2cc96c5dc7dc9a2d1e2b1" name="a36ab155050d2cc96c5dc7dc9a2d1e2b1"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#af165063dae6f488685c7d9c0a2f42eaf">Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_pacing_slice_period</b></td></tr>
<tr class="memdesc:a36ab155050d2cc96c5dc7dc9a2d1e2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In pacing, the duration of the current pacing time slice. <br /></td></tr>
<tr class="separator:a36ab155050d2cc96c5dc7dc9a2d1e2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6229cdcd3e949523658b02fa7d0e0"><td class="memItemLeft" align="right" valign="top"><a id="a3ac6229cdcd3e949523658b02fa7d0e0" name="a3ac6229cdcd3e949523658b02fa7d0e0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_snd_pacing_bytes_allowed_this_slice</b></td></tr>
<tr class="memdesc:a3ac6229cdcd3e949523658b02fa7d0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This many bytes worth of DATA packets may still be sent, at this time, within the time slice defined by <code>m_slice_start</code> and <code>m_slice_period</code>. <br /></td></tr>
<tr class="separator:a3ac6229cdcd3e949523658b02fa7d0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788325f467420b83a92adce8302f2e18"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a788325f467420b83a92adce8302f2e18">m_snd_est_bandwidth_mbit_per_sec</a></td></tr>
<tr class="memdesc:a788325f467420b83a92adce8302f2e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate of the currently available (to this connection) outgoing bandwidth, in megabits per second.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a788325f467420b83a92adce8302f2e18">More...</a><br /></td></tr>
<tr class="separator:a788325f467420b83a92adce8302f2e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437ab79b98100ec9f8ee4f2195b24430"><td class="memItemLeft" align="right" valign="top"><a id="a437ab79b98100ec9f8ee4f2195b24430" name="a437ab79b98100ec9f8ee4f2195b24430"></a>
<a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_sock_opts</b></td></tr>
<tr class="memdesc:a437ab79b98100ec9f8ee4f2195b24430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-socket options currently set on the socket. <br /></td></tr>
<tr class="separator:a437ab79b98100ec9f8ee4f2195b24430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05abba2bde50995af42cd6cf02d0b167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a05abba2bde50995af42cd6cf02d0b167">m_node_opts</a></td></tr>
<tr class="memdesc:a05abba2bde50995af42cd6cf02d0b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-node options currently set on the socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a05abba2bde50995af42cd6cf02d0b167">More...</a><br /></td></tr>
<tr class="separator:a05abba2bde50995af42cd6cf02d0b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a13391099a7662dbbef0a2ea171d1e7e9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a13391099a7662dbbef0a2ea171d1e7e9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> &amp;stats)</td></tr>
<tr class="memdesc:a13391099a7662dbbef0a2ea171d1e7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter.  <a href="structflow_1_1net__flow_1_1Peer__socket__info.html#a13391099a7662dbbef0a2ea171d1e7e9">More...</a><br /></td></tr>
<tr class="separator:a13391099a7662dbbef0a2ea171d1e7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A data store that keeps stats about the a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> connection. </p>
<p >This includes a <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__receive__stats.html" title="A data store that keeps stats about the incoming direction of a Peer_socket connection to another Flo...">Peer_socket_receive_stats</a> <code>struct</code>, a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket__send__stats.html" title="A data store that keeps stats about the outgoing direction of a Peer_socket connection to another Flo...">Peer_socket_send_stats</a> <code>struct</code>, and a few other individual pieces of data. Typically the former 2 accumulate data, while the other members may go up or down. This is not a hard rule however.</p>
<p >The objects also have an <code>ostream</code> output interface for human-readability, e.g., for logs.</p>
<p >The user can obtain objects representing actual stats via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">Peer_socket::info()</a>.</p>
<h3>Thread safety</h3>
<p >Same as any <code>struct</code> with no locking done therein.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is very heavily discouraged to make algorithmic decisions based on the data in these objects. They are for human diagnostics, information, and debugging only. For example, some data represented may pertain to internal implementation; other data may not be up-to-date; etc. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adaa22131f82263a6c8c9c0512cb016be" name="adaa22131f82263a6c8c9c0512cb016be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa22131f82263a6c8c9c0512cb016be">&#9670;&nbsp;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket_info::output </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the current stats, across multiple lines but not ending with a newline, into the given output stream. </p>
<p ><code>operator&lt;&lt;()</code> uses this and is more likely to be used directly by the class user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a116259f40c07caafe63017dddb9a837c" name="a116259f40c07caafe63017dddb9a837c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116259f40c07caafe63017dddb9a837c">&#9670;&nbsp;</a></span>output_map_of_pkt_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket_info::output_map_of_pkt_counts </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>count_by_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, Value &gt; *&#160;</td>
          <td class="paramname"><em>size_by_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for various <code><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#adaa22131f82263a6c8c9c0512cb016be" title="Outputs the current stats, across multiple lines but not ending with a newline, into the given output...">output()</a></code> methods that outputs a one-line representation of a sorted map, with arbitrary keys and values. </p>
<p >This representation will lack newlines and will include a wrapping pair of brackets <code>"[]"</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Type such that <code>output_pkt_count_key(os, k)</code>, with <code>Key k</code>, will output a one-line representation of <code>k</code> to <code>*os</code>. The representation should include wrapping brackets if desired. </td></tr>
    <tr><td class="paramname">Value</td><td>Analogous to <code>Key</code> but the function is <code>output_pkt_count_value(os, v)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#adaa22131f82263a6c8c9c0512cb016be" title="Outputs the current stats, across multiple lines but not ending with a newline, into the given output...">output()</a>. </td></tr>
    <tr><td class="paramname">count_by_type</td><td>Map whose values represent &ndash; at some level (not necessarily directly) &ndash; a packet count. </td></tr>
    <tr><td class="paramname">size_by_type</td><td>Map whose values represent a total byte count in packets counted by <code>count_by_type</code>. null pointer if no such map applies (i.e., only a count is available). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a13391099a7662dbbef0a2ea171d1e7e9" name="a13391099a7662dbbef0a2ea171d1e7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13391099a7662dbbef0a2ea171d1e7e9">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the stats in the given stats object to the standard <code>ostream</code> and returns the latter. </p>
<p >The representation is multi-line but ends in no newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to print. </td></tr>
    <tr><td class="paramname">stats</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a636e783090aee4ca8770a9f85f35dd21" name="a636e783090aee4ca8770a9f85f35dd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636e783090aee4ca8770a9f85f35dd21">&#9670;&nbsp;</a></span>m_int_state_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string flow::net_flow::Peer_socket_info::m_int_state_str</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The internal state of the socket, rendered into string (e.g., "SYN_RECEIVED" or "ESTABLISHED"). </p>
<p >Reminder: this is for informational purposes only &ndash; for human consumption; do not try to base program code on this value under any circumstances. </p>

</div>
</div>
<a id="a0ddfcfe377cda3266dfc968797ce4c18" name="a0ddfcfe377cda3266dfc968797ce4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddfcfe377cda3266dfc968797ce4c18">&#9670;&nbsp;</a></span>m_low_lvl_max_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_info::m_low_lvl_max_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The UDP receive buffer maximum size, as reported by an appropriate call to the appropriate <code>getsockopt()</code> immediately after the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> sets the UDP receive buffer size via <code>setsockopt()</code>. </p>
<p >The set value is determined by a socket option, but the OS may or may not respect that value.</p>
<p >This value remains constant and the same for all <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects for a given <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. It is set at <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> creation. </p>

</div>
</div>
<a id="a05abba2bde50995af42cd6cf02d0b167" name="a05abba2bde50995af42cd6cf02d0b167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05abba2bde50995af42cd6cf02d0b167">&#9670;&nbsp;</a></span>m_node_opts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Node__options.html">Node_options</a> flow::net_flow::Peer_socket_info::m_node_opts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Per-node options currently set on the socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >Note that this includes the full set of per-socket options as well, but these will only potentially affect future sockets generated by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>, not this socket. For the latter, see <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a437ab79b98100ec9f8ee4f2195b24430" title="Per-socket options currently set on the socket.">m_sock_opts</a>. </p>

</div>
</div>
<a id="a127a03a0b0e2f73d1059b7b42f251fa2" name="a127a03a0b0e2f73d1059b7b42f251fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127a03a0b0e2f73d1059b7b42f251fa2">&#9670;&nbsp;</a></span>m_rcv_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_info::m_rcv_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bytes in the internal Receive buffer. </p>
<p >These are the bytes intended for the application layer's consumption that the application layer has not yet claimed with <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">Peer_socket::receive()</a> or similar method. When this exceeds the Receive buffer max size, incoming bytes will be dropped (which will cause at least the slowdown of traffic).</p>
<p >Same reminder as for <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21" title="The internal state of the socket, rendered into string (e.g., &quot;SYN_RECEIVED&quot; or &quot;ESTABLISHED&quot;).">m_int_state_str</a> applies here. </p>

</div>
</div>
<a id="a8c3326fea94763621c47c8b0e4d31eb2" name="a8c3326fea94763621c47c8b0e4d31eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3326fea94763621c47c8b0e4d31eb2">&#9670;&nbsp;</a></span>m_rcv_packets_with_gaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_info::m_rcv_packets_with_gaps</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of DATA packets tracked in structure tracking all valid received packets such at least one packet that has not yet been received precedes (by sequence #) each one (in other words, all post-first-gap packets). </p>
<p >If <code>rexmit_on</code> is <code>true</code>, this is the reassembly queue length; otherwise is is length of structure used to detect duplicate receipt of data past the first gap (and possibly other accounting purposes). An important subtlety is that in the latter case, as of this writing, there is no need to (and hence we don't) store the actual payload of those packets but only metadata like sequence numbers. That's why in that case <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a3a38b2a47235621222eb58e6212a4f05" title="If rexmit_on is false then 0; otherwise the total DATA payload in the reassembly queue of the socket.">m_rcv_reassembly_q_data_size</a> is zero and doesn't, in particular, count against rcv_wnd. (However, if <code>rexmit_on</code>, then it's not zero and does count.) </p>

</div>
</div>
<a id="a45e2cdb7f0a7e0fd470adeab4009f44a" name="a45e2cdb7f0a7e0fd470adeab4009f44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e2cdb7f0a7e0fd470adeab4009f44a">&#9670;&nbsp;</a></span>m_snd_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_info::m_snd_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bytes in the internal Send buffer. </p>
<p >These are the bytes provided by the application layer to send that have not yet been "sent over the network," for some definition of "sent over the network." The latter definition is not entirely unambiguous, but that should not matter to the library user.</p>
<p >When this exceeds the Send buffer max size, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">Peer_socket::send()</a> and similar methods will return 0 (meaning, cannot accept more bytes to send at this time). That should happen only if some aspect of networking is preventing <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> from sending more data over network at this time.</p>
<p >Same reminder as for <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a636e783090aee4ca8770a9f85f35dd21" title="The internal state of the socket, rendered into string (e.g., &quot;SYN_RECEIVED&quot; or &quot;ESTABLISHED&quot;).">m_int_state_str</a> applies here. </p>

</div>
</div>
<a id="a784bd75264e26acbccd966e48c07dab9" name="a784bd75264e26acbccd966e48c07dab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784bd75264e26acbccd966e48c07dab9">&#9670;&nbsp;</a></span>m_snd_cong_ctl_in_flight_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket_info::m_snd_cong_ctl_in_flight_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In congestion control, the current sent data bytes that have been neither acknowledged nor considered lost. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>Does <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html#a784bd75264e26acbccd966e48c07dab9" title="In congestion control, the current sent data bytes that have been neither acknowledged nor considered...">m_snd_cong_ctl_in_flight_bytes</a> count data queued in the pacing module or truly In-flight data only? </dd></dl>

</div>
</div>
<a id="a788325f467420b83a92adce8302f2e18" name="a788325f467420b83a92adce8302f2e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788325f467420b83a92adce8302f2e18">&#9670;&nbsp;</a></span>m_snd_est_bandwidth_mbit_per_sec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double flow::net_flow::Peer_socket_info::m_snd_est_bandwidth_mbit_per_sec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate of the currently available (to this connection) outgoing bandwidth, in megabits per second. </p>
<p >A megabit is 1000 x 1000 bits (not 1024 x 1024, as people sometimes assume, that being a mebibit). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>net_flow/<a class="el" href="info_8hpp.html">info.hpp</a></li>
<li>net_flow/<a class="el" href="info_8cpp.html">info.cpp</a></li>
<li>net_flow/<a class="el" href="net__flow__fwd_8hpp.html">net_flow_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 7 2025 20:04:49 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
