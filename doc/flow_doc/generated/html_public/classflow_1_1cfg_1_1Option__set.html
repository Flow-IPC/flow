<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::cfg::Option_set&lt; Value_set &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1cfg.html">cfg</a></li><li class="navelem"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1cfg_1_1Option__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::cfg::Option_set&lt; Value_set &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a given simple config-holding object, of the type <code>Value_set</code>, a template argument to this class template.  
 <a href="classflow_1_1cfg_1_1Option__set.html#details">More...</a></p>

<p><code>#include &lt;option_set.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::cfg::Option_set&lt; Value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Option__set__inherit__graph.svg" width="344" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::cfg::Option_set&lt; Value_set &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1cfg_1_1Option__set__coll__graph.svg" width="344" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-use structure to use with <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Declare_options_func</a> callback.  <a href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab12751047ec45932c26364e533a96e7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> = Value_set</td></tr>
<tr class="memdesc:ab12751047ec45932c26364e533a96e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the template parameter type <code>Value_set</code>.  <a href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">More...</a><br /></td></tr>
<tr class="separator:ab12751047ec45932c26364e533a96e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aec14275948fe5b66ca75ba5f3b43d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d">Values_ptr</a> = typename Values::Const_ptr</td></tr>
<tr class="memdesc:aa1aec14275948fe5b66ca75ba5f3b43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to an immutable <code>Value_set</code> (config payload storable in an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>).  <a href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d">More...</a><br /></td></tr>
<tr class="separator:aa1aec14275948fe5b66ca75ba5f3b43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ec172ee1f15c091ca78102faa55987"><td class="memItemLeft" align="right" valign="top"><a id="a03ec172ee1f15c091ca78102faa55987" name="a03ec172ee1f15c091ca78102faa55987"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mutable_values_ptr</b> = typename Values::Ptr</td></tr>
<tr class="memdesc:a03ec172ee1f15c091ca78102faa55987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to a mutable <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> (config payload storable in an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>). <br /></td></tr>
<tr class="separator:a03ec172ee1f15c091ca78102faa55987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6755bc762fc40b1ae8f4bd47c55bd39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">Declare_options_func</a> = Function&lt; void(const <a class="el" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a> &amp;args)&gt;</td></tr>
<tr class="memdesc:ac6755bc762fc40b1ae8f4bd47c55bd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the ever-important callback passed to the main <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> constructor.  <a href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">More...</a><br /></td></tr>
<tr class="separator:ac6755bc762fc40b1ae8f4bd47c55bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1cfg_1_1Option__set__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1cfg_1_1Option__set__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html">flow::cfg::Option_set_base</a></td></tr>
<tr class="memitem:a812f2164fb689d4cbcaa04f482ecf4cd inherit pub_types_classflow_1_1cfg_1_1Option__set__base"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">Declare_options_func_call_type</a> { <br />
&#160;&#160;<a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda4f70649bf85f31925dd145af4c67025c">S_FILL_PARSING_ROLE_OPT_TABLE</a>
, <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda2525895c3e467823cc3450761eaac825">S_FILL_OUTPUT_HELP_ROLE_OPT_TABLE</a>
, <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda0950d89fa823703860cf10d79f68e806">S_FILL_OUTPUT_CURRENT_ROLE_OPT_TABLE</a>
, <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda3f9727baaf0cacb224d783f7c54a3ba4">S_COMPARE_PARSED_VALS</a>
, <br />
&#160;&#160;<a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cdaff70279b5a59725f049c39c5fe5e2910">S_LOAD_VALS_AS_IF_PARSED</a>
, <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cda1700f8f4a850612c0d81cc197835bda6">S_VALIDATE_STORED_VALS</a>
<br />
 }</td></tr>
<tr class="memdesc:a812f2164fb689d4cbcaa04f482ecf4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-use type to use with <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Option_set::Declare_options_func</a> callback.  <a href="classflow_1_1cfg_1_1Option__set__base.html#a812f2164fb689d4cbcaa04f482ecf4cd">More...</a><br /></td></tr>
<tr class="separator:a812f2164fb689d4cbcaa04f482ecf4cd inherit pub_types_classflow_1_1cfg_1_1Option__set__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbbc9648c8c4bac0c456ed176106a0d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2">Option_set</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> nickname, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">Declare_options_func</a> &amp;&amp;declare_opts_func_moved)</td></tr>
<tr class="memdesc:abbbc9648c8c4bac0c456ed176106a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an option set in CANONICAL state with a default-valued <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> payload and options declared by synchronously invoking the callback <code>declare_opts_func()</code>.  <a href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2">More...</a><br /></td></tr>
<tr class="separator:abbbc9648c8c4bac0c456ed176106a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ab889bf230d21961c22bd4bf21e06a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a">values</a> () const</td></tr>
<tr class="memdesc:a93ab889bf230d21961c22bd4bf21e06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Externally immutable internally stored canonical (current) config values as last constructed or parsed, whichever happened more recently.  <a href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a">More...</a><br /></td></tr>
<tr class="separator:a93ab889bf230d21961c22bd4bf21e06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eebf6c9d7384bcc95c10ff7c934e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">Mutable_values_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f">mutable_values_copy</a> () const</td></tr>
<tr class="memdesc:a45eebf6c9d7384bcc95c10ff7c934e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method that heap-allocates a copy of the internally stored <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a></code> and wraps in a ref-counted handle suitable for speedy passing around the rest of the application.  <a href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f">More...</a><br /></td></tr>
<tr class="separator:a45eebf6c9d7384bcc95c10ff7c934e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce212853383183bd1b60505157f7215"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215">values_candidate</a> () const</td></tr>
<tr class="memdesc:adce212853383183bd1b60505157f7215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after the last successful <code>parse_*()</code> API call.  <a href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215">More...</a><br /></td></tr>
<tr class="separator:adce212853383183bd1b60505157f7215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3d6a15332fd7e2da1b852adc81aec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">validate_values</a> (bool *success_or_null=0) const</td></tr>
<tr class="memdesc:a4a3d6a15332fd7e2da1b852adc81aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the current contents of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> using the validators <code>*this</code> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> is configured to use via constructor.  <a href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3">More...</a><br /></td></tr>
<tr class="separator:a4a3d6a15332fd7e2da1b852adc81aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601592ed6eacb42eb5296a2c79fb6ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a601592ed6eacb42eb5296a2c79fb6ace">validate_values</a> (const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;values_to_validate, bool *success_or_null=0) const</td></tr>
<tr class="memdesc:a601592ed6eacb42eb5296a2c79fb6ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an arbitrary <code>Value_set</code>, using the same validators <code>*this</code> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> is configured to use when parsing config sources.  <a href="classflow_1_1cfg_1_1Option__set.html#a601592ed6eacb42eb5296a2c79fb6ace">More...</a><br /></td></tr>
<tr class="separator:a601592ed6eacb42eb5296a2c79fb6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b85e12065536214e78266d086be3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2">validate_values_candidate</a> (bool *success_or_null=0) const</td></tr>
<tr class="memdesc:ae6b85e12065536214e78266d086be3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>validate_values(success_or_null)</code> but validates <code>*values_candidate()</code> instead of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>.  <a href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2">More...</a><br /></td></tr>
<tr class="separator:ae6b85e12065536214e78266d086be3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf2ec0dd43cb8372f33a3f4cc23633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633">values_to_ostream</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> *values_or_null=0) const</td></tr>
<tr class="memdesc:adbbf2ec0dd43cb8372f33a3f4cc23633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a multi-line user-suitable representation of the current values in a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object, at some point perhaps initialized or parsed by <code>*this</code>, to the given stream.  <a href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633">More...</a><br /></td></tr>
<tr class="separator:adbbf2ec0dd43cb8372f33a3f4cc23633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1c681c600d989cd3ae4fe834501214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214">log_values</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> *values_or_null=0, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:acb1c681c600d989cd3ae4fe834501214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the given values payload using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633" title="Writes a multi-line user-suitable representation of the current values in a Values object,...">values_to_ostream()</a>.  <a href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214">More...</a><br /></td></tr>
<tr class="separator:acb1c681c600d989cd3ae4fe834501214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06b27cbbf36393e81da4713c20a6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3">help_to_ostream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ade06b27cbbf36393e81da4713c20a6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a multi-line help message about the set of options that <code>*this</code> can parse.  <a href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3">More...</a><br /></td></tr>
<tr class="separator:ade06b27cbbf36393e81da4713c20a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4542b206e60f310db02bc98706aac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4">log_help</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> summary, <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a> sev=<a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a>) const</td></tr>
<tr class="memdesc:a6e4542b206e60f310db02bc98706aac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs a multi-line help message using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3" title="Prints a multi-line help message about the set of options that *this can parse.">help_to_ostream()</a>.  <a href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4">More...</a><br /></td></tr>
<tr class="separator:a6e4542b206e60f310db02bc98706aac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca1b50ec692a98865e4afde76d04128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128">parse_config_file</a> (const fs::path &amp;cfg_path, bool allow_unregistered, bool *success_or_null=0, const boost::unordered_set&lt; std::string &gt; &amp;allowed_unregistered_opts_or_empty={})</td></tr>
<tr class="memdesc:a4ca1b50ec692a98865e4afde76d04128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the form of the given file in the file-system.  <a href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128">More...</a><br /></td></tr>
<tr class="separator:a4ca1b50ec692a98865e4afde76d04128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd900a94beabe8e9964efc3bc1b91bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc">parse_direct_values</a> (const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;src_values)</td></tr>
<tr class="memdesc:afcd900a94beabe8e9964efc3bc1b91bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters into (from CANONICAL state) or continues in PARSING state by simply setting <code>*values_candidate()</code> to equal the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> payload given as an argument.  <a href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc">More...</a><br /></td></tr>
<tr class="separator:afcd900a94beabe8e9964efc3bc1b91bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f780bfd3a5ff07ade1e36785e28f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49">canonicalize_candidate</a> (bool *change_detected=0)</td></tr>
<tr class="memdesc:aa1f780bfd3a5ff07ade1e36785e28f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">In PARSING state enters CANONICAL state, finalizing <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> from <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a>.  <a href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49">More...</a><br /></td></tr>
<tr class="separator:aa1f780bfd3a5ff07ade1e36785e28f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5452a6e866c911df46d948f02b6a587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587">reject_candidate</a> ()</td></tr>
<tr class="memdesc:ac5452a6e866c911df46d948f02b6a587"><td class="mdescLeft">&#160;</td><td class="mdescRight">In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.  <a href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587">More...</a><br /></td></tr>
<tr class="separator:ac5452a6e866c911df46d948f02b6a587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ecbc1b1da6efb81002f1431bdbbeaa"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:aa5ecbc1b1da6efb81002f1431bdbbeaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa">declare_option_for_parsing</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, Value *target_value, const Value *value_default_if_no_acc, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str)</td></tr>
<tr class="memdesc:aa5ecbc1b1da6efb81002f1431bdbbeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa">More...</a><br /></td></tr>
<tr class="separator:aa5ecbc1b1da6efb81002f1431bdbbeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57de4947f2c8fd5e4663ab982e8dbce"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ad57de4947f2c8fd5e4663ab982e8dbce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce">declare_option_for_help</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, const Value &amp;value_default, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description)</td></tr>
<tr class="memdesc:ad57de4947f2c8fd5e4663ab982e8dbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set.html#ad57de4947f2c8fd5e4663ab982e8dbce">More...</a><br /></td></tr>
<tr class="separator:ad57de4947f2c8fd5e4663ab982e8dbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b08b3a98b57d3b6caa2057e5e59e8"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:afe4b08b3a98b57d3b6caa2057e5e59e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8">scan_parsed_option</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, const Value &amp;canonical_value)</td></tr>
<tr class="memdesc:afe4b08b3a98b57d3b6caa2057e5e59e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set.html#afe4b08b3a98b57d3b6caa2057e5e59e8">More...</a><br /></td></tr>
<tr class="separator:afe4b08b3a98b57d3b6caa2057e5e59e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8435631dfa49db887d2fc56638378aae"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a8435631dfa49db887d2fc56638378aae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae">load_option_value_as_if_parsed</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, Value *target_value, const Value &amp;source_value)</td></tr>
<tr class="memdesc:a8435631dfa49db887d2fc56638378aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set.html#a8435631dfa49db887d2fc56638378aae">More...</a><br /></td></tr>
<tr class="separator:a8435631dfa49db887d2fc56638378aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd086867406387070ac766b03e7998c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">null</a> () const</td></tr>
<tr class="memdesc:accd086867406387070ac766b03e7998c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if and only if the option-declaring function passed to the constructor declared no options.  <a href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c">More...</a><br /></td></tr>
<tr class="separator:accd086867406387070ac766b03e7998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b105705745a5369a35cedbff326d1"><td class="memItemLeft" align="right" valign="top">const boost::unordered_set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1">option_names</a> () const</td></tr>
<tr class="memdesc:a2c5b105705745a5369a35cedbff326d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set of all option names declared by the option-declaring function passed to the constructor.  <a href="classflow_1_1cfg_1_1Option__set.html#a2c5b105705745a5369a35cedbff326d1">More...</a><br /></td></tr>
<tr class="separator:a2c5b105705745a5369a35cedbff326d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f3924bff19cae0beb9f06b6dffbd504"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a7f3924bff19cae0beb9f06b6dffbd504">validate_values</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;values_to_validate, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">Declare_options_func</a> &amp;declare_opts_func, bool *success_or_null=0)</td></tr>
<tr class="memdesc:a7f3924bff19cae0beb9f06b6dffbd504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an arbitrary <code>Value_set</code>, as parseable by <em>an</em> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code>, according to the given option-registering function suitable for <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> constructor.  <a href="classflow_1_1cfg_1_1Option__set.html#a7f3924bff19cae0beb9f06b6dffbd504">More...</a><br /></td></tr>
<tr class="separator:a7f3924bff19cae0beb9f06b6dffbd504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1cfg_1_1Option__set__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html">flow::cfg::Option_set_base</a></td></tr>
<tr class="memitem:a1d2f46a93337cf83f1e7b5c3f805725b inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a1d2f46a93337cf83f1e7b5c3f805725b inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b">declare_option_for_output</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, opts::options_description *target_opts, const Value &amp;value_default, const Value &amp;current_value, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> description)</td></tr>
<tr class="memdesc:a1d2f46a93337cf83f1e7b5c3f805725b inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set__base.html#a1d2f46a93337cf83f1e7b5c3f805725b">More...</a><br /></td></tr>
<tr class="separator:a1d2f46a93337cf83f1e7b5c3f805725b inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c61f62032b238cb25e132ce1e1d43 inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ab79c61f62032b238cb25e132ce1e1d43 inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43">validate_parsed_option</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, const Value &amp;value, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str)</td></tr>
<tr class="memdesc:ab79c61f62032b238cb25e132ce1e1d43 inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header).  <a href="classflow_1_1cfg_1_1Option__set__base.html#ab79c61f62032b238cb25e132ce1e1d43">More...</a><br /></td></tr>
<tr class="separator:ab79c61f62032b238cb25e132ce1e1d43 inherit pub_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5e5cf9a5efd81ba6d851171a109005f6"><td class="memItemLeft" align="right" valign="top"><a id="a5e5cf9a5efd81ba6d851171a109005f6" name="a5e5cf9a5efd81ba6d851171a109005f6"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_nickname</b></td></tr>
<tr class="memdesc:a5e5cf9a5efd81ba6d851171a109005f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <code>nickname</code> ctor arg. <br /></td></tr>
<tr class="separator:a5e5cf9a5efd81ba6d851171a109005f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acd1ce6e7c258d7486388915d59019880"><td class="memTemplParams" colspan="2">template&lt;typename Value_set &gt; </td></tr>
<tr class="memitem:acd1ce6e7c258d7486388915d59019880"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#acd1ce6e7c258d7486388915d59019880">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; &amp;val)</td></tr>
<tr class="memdesc:acd1ce6e7c258d7486388915d59019880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes (briefly) an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> to a standard output stream.  <a href="classflow_1_1cfg_1_1Option__set.html#acd1ce6e7c258d7486388915d59019880">More...</a><br /></td></tr>
<tr class="separator:acd1ce6e7c258d7486388915d59019880"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classflow_1_1cfg_1_1Option__set__base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classflow_1_1cfg_1_1Option__set__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html">flow::cfg::Option_set_base</a></td></tr>
<tr class="memitem:ae2f1d04cb457f4845d636e93aa156f46 inherit pro_types_classflow_1_1cfg_1_1Option__set__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">Opt_table</a> = opts::options_description</td></tr>
<tr class="memdesc:ae2f1d04cb457f4845d636e93aa156f46 inherit pro_types_classflow_1_1cfg_1_1Option__set__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for boost.program_options config options description, each of which is used for parsing and/or describing (to humans) one or more config option/its value.  <a href="classflow_1_1cfg_1_1Option__set__base.html#ae2f1d04cb457f4845d636e93aa156f46">More...</a><br /></td></tr>
<tr class="separator:ae2f1d04cb457f4845d636e93aa156f46 inherit pro_types_classflow_1_1cfg_1_1Option__set__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classflow_1_1cfg_1_1Option__set__base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classflow_1_1cfg_1_1Option__set__base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classflow_1_1cfg_1_1Option__set__base.html">flow::cfg::Option_set_base</a></td></tr>
<tr class="memitem:a74619d5264f549f99b8187f38be3c838 inherit pro_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a74619d5264f549f99b8187f38be3c838 inherit pro_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memTemplItemLeft" align="right" valign="top">static Function&lt; void(const Value &amp;val)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">throw_on_invalid_func</a> (<a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> name, Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;validator_func_moved, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a> validator_cond_str)</td></tr>
<tr class="memdesc:a74619d5264f549f99b8187f38be3c838 inherit pro_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that wraps a <code>Value</code>-&gt;Boolean validator function, as passed to declare_option_for_parsing() and others, in code that will throw an exception with a human-useful message if that validator function indicates the <code>Value</code> passed to it is invalid; else will no-op.  <a href="classflow_1_1cfg_1_1Option__set__base.html#a74619d5264f549f99b8187f38be3c838">More...</a><br /></td></tr>
<tr class="separator:a74619d5264f549f99b8187f38be3c838 inherit pro_static_methods_classflow_1_1cfg_1_1Option__set__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Value_set&gt;<br />
class flow::cfg::Option_set&lt; Value_set &gt;</div><p >The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a given simple config-holding object, of the type <code>Value_set</code>, a template argument to this class template. </p>
<h3>General use pattern</h3>
<ul>
<li>First, create your <code>Value_set</code> (named however you want, of course) <code>struct</code>. The values stored therein must be reasonably deep-copyable; must have standard-stream <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators; and must reasonably implement <code>==</code> comparison. <code>Value_set</code> itself must be copy-constructible and copy-assignable in a reasonable way. Lastly, and very importantly, the no-arg ctor <code>Value_set()</code> must initialize all configured members to reasonable defaults: it is not possible to declare options as "required."<ul>
<li>If you use the optional features <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f" title="Convenience method that heap-allocates a copy of the internally stored values() and wraps in a ref-co...">mutable_values_copy()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987" title="Short-hand for ref-counted pointer to a mutable Values (config payload storable in an Option_set).">Mutable_values_ptr</a>, and/or <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1aec14275948fe5b66ca75ba5f3b43d" title="Short-hand for ref-counted pointer to an immutable Value_set (config payload storable in an Option_se...">Values_ptr</a>, then, also, <code>Value_set</code> shall derive from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html" title="Convenience class template that endows the given subclass T with nested aliases Ptr and Const_ptr ali...">util::Shared_ptr_alias_holder</a>. (Don't worry: it's easy.)</li>
</ul>
</li>
<li>Next, write a function fitting <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Option_set::Declare_options_func</a>, which shall be used (when passed into <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> ctor) by <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> to enable parsing (and human-readable help/other output to streams) of various members of <code>Value_set</code>, which officially turns them into <em>options</em>.<ul>
<li>This is documented more fully in the <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#abbbc9648c8c4bac0c456ed176106a0d2" title="Constructs an option set in CANONICAL state with a default-valued values() payload and options declar...">Option_set()</a></code> ctor doc header; but essentially this function shall use <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> macro to enumerate every parseable member, turning it into an option <em>managed by</em> the containing <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.</li>
<li>(The data members that thus become options need not be direct members of <code>Value_set</code>. Composition via directly nested, and nested via pointer, <code>struct</code>s is supported. See <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> doc header for details.)</li>
</ul>
</li>
<li>Finally, create an instance of <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code>, and use <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> (or any other <code>parse_*()</code> methods that might exist) to parse things at will.<ul>
<li>"At rest," <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is in CANONICAL state. <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> returns null, and <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> is the <em>canonical</em> (official, current) set of parsed config; originally it equals <code>Value_set()</code>. It returns a reference to immutable internally stored <code>Value_set</code>.</li>
<li>Invoking <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> (or any other <code>parse_*()</code>) either enters or continues PARSING state. In this state <code>*values_candidate()</code> starts equal to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>; and is then potentially modified by each <code>parse_*()</code> operation.</li>
<li>Call <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a></code> to set <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> to <code>*values_candidate()</code>, thus canonicalizing the parsed values, and return to CANONICAL state.<ul>
<li>Alternatively, if a <code>parse_*()</code> or <code>validate_values*()</code> fails, or any manual check of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> fails, one might want to instead call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a> to discard any parse attempts and return to CANONICAL state.</li>
<li>See notes in Validation below.</li>
</ul>
</li>
<li>If one desires to model multiple dynamic updates, meaning calling <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> multiple times &ndash; once for each update &ndash; it may be desirable to use <a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc" title="Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...">parse_direct_values()</a> to load a baseline state at entry into PARSING state, and only then <code>parse_*()</code> from actual config source(s). (It would be trivial to save a previous state using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> to be that baseline state.)</li>
</ul>
</li>
</ul>
<p >A typical expected scenario &ndash; although more complex ones can be devised &ndash; and one assumed by <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> &ndash; is to have 2 <code>struct</code>s of config; one for static and one for dynamic config, the latter being something that can be parsed-into repeatedly over time, as new config is delivered to the process. In that case one would use one <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Static_value_set&gt;</code> and one <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Dynamic_value_set&gt;</code> and invoke their parsing at appropriate times (1+ times for the latter, once for the former). It is also possible to allow, on startup, to read both sets from the same config source(s) (e.g., a static config file); then read the dynamic <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code> from the dynamic config source(s) once (for any initial dynamic values overriding the initial baseline static ones); and after that accept any further updates of the latter config source(s), as they come in (e.g., if the dynamic config file is modified externally). The <code>allow_unregistered</code> argument to <code>parse_*()</code> allows 2+ <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code>s to share one config file.</p>
<h3>Validation</h3>
<p >Option validation <em>mandatorily</em> occurs in the following places.</p><ul>
<li>When <code>parse_*()</code> is invoked, the config source (e.g., config file in case of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a>) may have plainly illegal contents, such as an option expecting a number but receiving alphanumerics, or a syntax error. This will cause <code>parse_*()</code> to indicate error.</li>
<li>If that passes, the individual-option-validator checks are performed <em>on values in fact read+parsed</em>. For example, a duration option may need to be non-negative, or a value in bytes must be a multiple of 4KiB. To provide any such additional <em>per-option</em>, <em>independent-of-other-options</em> conditions, use the <code>ARG_bool_validate_expr</code> argument to <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> when declaring the options (see above). This is somewhat reminiscent of writing <code>assert()</code> conditions. If a validator fails, <code>parse*()</code> will transparently fail, not dissimilarly to what happens if some line is straight-up illegal (previous bullet point).</li>
</ul>
<p >However this is likely insufficient validation in at least some use cases. You should also concern yourself with the following.</p><ul>
<li>Note that <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> (and any similar <code>parse_*()</code> that scans+parses strings) will <em>only</em> validate (via individual-option-validator checks) values actually present in the config source. Defaults (from <code>Value_set()</code>) or baseline values (from <a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc" title="Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...">parse_direct_values()</a>) are not <em>mandatorily</em> checked. If one performs no additional validation calls, it will not be possible to know of bad defaults or baseline values, and one can <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> invalid values. This is allowed, for flexibility, but in most cases one will want to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a> instead. The following abilities are provided to resolve this. For flexibility we do not here enforce any particular approach. It is your reponsibility to trace the possibilities. (For example <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> chooses certain conventions as it marshals various <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s.)<ul>
<li>To validate defaults (default-constructed <code>Value_set</code>) themselves, call <code>validate_values(bool*)</code> overload &ndash; just after construction. (Informally: This is a stringent convention. It is possible to instead establish the convention wherein intentionally invalid defaults are allowed, to force that a config source must specify such values explicitly. In that case: one would not call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3" title="Validates the current contents of values() using the validators *this Option_set&lt;Value_set&gt; is config...">validate_values()</a> this way but rather... see next bullet point.)</li>
<li>To validate any defaults and/or baseline values that "got through" in PARSING mode, by virtue of not being present in a parsed config source (e.g., file) so far, call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a>. (Informally: Typically you will not want to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> when the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> might have invalid values. So, just ahead of the decision to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> or <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a>, call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a>. If it indicates failure, probably you'll want to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a>.)</li>
<li>Lastly: <a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc" title="Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...">parse_direct_values()</a> intentionally does not validate the supplied <code>Value_set</code>. You are free to call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a> right after it to detect problems, if it suits your needs. (Informally: Whether this is necessary really depends on your setup, including the source of the values applied &ndash; which may have already been validated &ndash; and whether you're going to be calling <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a> before canonicalizing anyway.)</li>
</ul>
</li>
<li>You may also need a validation for inner consistency; e.g., if one setting must not exceed another setting. Do this yourself: Before calling <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> check whatever is necessary in <code>*values_candidate()</code>. If you find problems call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a> instead.<ul>
<li>Informal recommendation: It is better to not leave individual-option checking to this step; make use of <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> to its fullest. This will result in more maintainable, reusable code and likely improve the experience (e.g., the individual validator machinery will always print the value of the offending option and, <code>assert()</code>-style, a string representation of the condition that failed).</li>
</ul>
</li>
</ul>
<p >Lastly, and optionally, you may validate a given <code>Value_set</code> object "offline," meaning outside of any <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> &ndash; which need not even exist or ever parse anything; only the function fitting <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Option_set::Declare_options_func</a> must exist, as-if for <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code> ctor. Simply call a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3" title="Validates the current contents of values() using the validators *this Option_set&lt;Value_set&gt; is config...">validate_values()</a> API on your object; it will yield failure given at least 1 invalid value. This can be useful, at least, when setting values manually through assignment (perhaps in a simpler program not requiring external config; or when unit-testing); just because you aren't parsing it through <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> does not mean you don't want to sanity-check it for validity.</p>
<h3>Change detection</h3>
<p >For dynamic options, it may be necessary to detect whether the set of option values has changed or even individual changes (and then, in many cases, invoke config-changed hooks). <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is designed with this in mind, as it is able to provide such checks <em>without</em> forcing the user to write an <code>operator==(Value_set, Value_set)</code> (a laborious and error-prone procedure).</p>
<p >Change detection occurs at the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> stage. That is, once you've parsed all the different config sources in a parse pass, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> will scan for changes. As of this writing that method will optionally return a Boolean indicating whether at least one value changed vs. the canonical <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>. It is possible to add an API for detecting individual option changes. As I write this, it doesn't exist, but it may be added after I write this. <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> is eminently capable of it; and in fact it at least logs an INFO message for each option that has changed, at <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> time.</p>
<h3>Input/output</h3>
<p >Input of configurable values in <code>Value_set</code> is required to be able to parse the corresponding options (parse_*()). Output thereof is required in:</p><ul>
<li><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3" title="Prints a multi-line help message about the set of options that *this can parse.">help_to_ostream()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a6e4542b206e60f310db02bc98706aac4" title="Logs a multi-line help message using help_to_ostream().">log_help()</a>: A usage/help message describing all options, and their default values, in human-friendly form.</li>
<li><a class="el" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633" title="Writes a multi-line user-suitable representation of the current values in a Values object,...">values_to_ostream()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#acb1c681c600d989cd3ae4fe834501214" title="Logs the given values payload using values_to_ostream().">log_values()</a>: A message describing all options, their default values, and their <em>current</em> (presumably parsed at some point) values, is printed (in human-friendly form). You can use this to output any <code>Value_set</code>, but if none is specified, it will log the canonical one (<a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>).</li>
</ul>
<p >For input (parsing), every configurable value in <code>Value_set</code> must have an <code>istream&gt;&gt;</code> operator.</p>
<p >For output (in help and current-values output), every such value must have an <code>ostream&lt;&lt;</code> operator. In addition, it is sometimes desirable to further massage output in config help/current-values output but not in a general <code>ostream&lt;&lt;</code> operator for that type. (E.g., you would not want to, or be able to usually, override stream output for <code>std::string</code> or <code>chrono::duration</code>.) To do this, provide a specialization or overload of the free function <code><a class="el" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96" title="Serializes a value of type Value to the given ostream suitably for output in Option_set-related outpu...">cfg::value_to_ostream</a>&lt;Value_set&gt;()</code>. Its generic implementation simply forwards to <code>ostream&lt;&lt;</code>, but you can do something different. As of this writing we already provide an overload for <code><a class="el" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96" title="Serializes a value of type Value to the given ostream suitably for output in Option_set-related outpu...">cfg::value_to_ostream</a>&lt;chrono::duration&lt;...&gt;&gt;</code>, which will automatically print the duration (which is typically stored in nanoseconds) in the coarsest possible units that would lose no precision (e.g., 60billion nanoseconds =&gt; "1 minute").</p>
<h3>Recommended conventions</h3>
<p >Firstly, it is recommended to store all durations in your <code>Value_set</code> as util::Fine_duration instead of using coarser units like <code>chrono::seconds()</code> or even <code>chrono::milliseconds()</code>. This tends to lead to more consistent and maintainable code, in the author's (ygoldfel) opinion, as util::Fine_duration <em>can</em> store durations expressed in essentially any units, without losing precision; <em>does</em> use the same underlying storage type &ndash; <code>int64_t</code> &ndash; and hence presents no performance or overflow difficulties (usually); and changing the desired units of a duration config value is fairly common. Simply put <code>Fine_duration</code> supports 99.99999999% of units and use cases without perf overhead. <em>In addition</em>, <code>value_to_ostream&lt;&gt;</code> is overloaded in such a way as to output <code>Fine_duration</code> members of <code>Value_set</code> in the most convenient possible units &ndash; automagically. So you're in no way forcing humans to work with nanoseconds: you can use any units in input and in code.</p>
<dl class="section note"><dt>Note</dt><dd>For all duration values, config sources can specify <em>any</em> units (convertible without loss of precision to the specific <code>chrono</code> type); and indeed <em>should</em> specify units. E.g., "5 ms" and "5 milliseconds" will both work. Since util::Fine_duration is in nanoseconds internally, almost any conceivable units (from "hours" to "nanoseconds") are accepted equally well as inputs in config sources.</dd></dl>
<p>Secondly, when working with non-durations, specify units as a suffix in the member name.</p><ul>
<li>Exception: if it's in bytes, <code>_bytes</code> or <code>_b</code> shall be omitted.</li>
<li>If it's in multiples of bytes, use <code>_kb</code>, <code>_mb</code>, etc., knowing that this stands for KiB (1024), MiB (1024^2), etc. In the rare case that actual KILObytes, etc., are needed, spell it out: <code>_kilob</code>, <code>_megab</code>, etc.<ul>
<li>I (ygoldfel) am not recommending <code>_kib</code>, etc., only because the convention in the relevant organization(s) is quite strong to say KB for KiB, etc.</li>
</ul>
</li>
<li>If, for some reason, you must use a duration with a max resolution lower than ns, then use these suffixes: <code>_hr</code>, <code>_min</code>, <code>_sec</code>, <code>_msec</code>, <code>_usec</code>, <code>_nsec</code>. Please still use <code>chrono::duration</code>, though, even if you chose something other than <code>Fine_duration</code>. (Do not use an integer type.)</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Add individual-option-changed detection API(s) in addition to the existing <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> overall-value-set-changed detection API. This is contingent on a use case needing it. The existing code already detects this internally and logs a message for each changed option (in <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>The value type stored inside <code>*this</code>, and returned by <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>. Requirements on this type are at least informally explained above. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac6755bc762fc40b1ae8f4bd47c55bd39" name="ac6755bc762fc40b1ae8f4bd47c55bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6755bc762fc40b1ae8f4bd47c55bd39">&#9670;&nbsp;</a></span>Declare_options_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::Declare_options_func =  Function&lt;void (const <a class="el" href="structflow_1_1cfg_1_1Option__set_1_1Declare__options__func__args.html">Declare_options_func_args</a>&amp; args)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for the ever-important callback passed to the main <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> constructor. </p>
<p >The user of the class need not understand the meanings of the args, because the <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> macro will take care of using them properly. </p>

</div>
</div>
<a id="ab12751047ec45932c26364e533a96e7c" name="ab12751047ec45932c26364e533a96e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12751047ec45932c26364e533a96e7c">&#9670;&nbsp;</a></span>Values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::Values =  Value_set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for the template parameter type <code>Value_set</code>. </p>
<p >E.g.: <code>Cool_option_set::Values</code>, where one aliased <code>Cool_option_set</code> to <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Cool_value_set&gt;</code>. </p>

</div>
</div>
<a id="aa1aec14275948fe5b66ca75ba5f3b43d" name="aa1aec14275948fe5b66ca75ba5f3b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aec14275948fe5b66ca75ba5f3b43d">&#9670;&nbsp;</a></span>Values_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::Values_ptr =  typename Values::Const_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for ref-counted pointer to an immutable <code>Value_set</code> (config payload storable in an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>). </p>
<p >The name is not, say, <code>Const_values_ptr</code>, because we would expect such objects to be passed around in <code>const</code> form most of the time, including when made accessible from within a config-holding API. When a mutable <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> is desired, one would typically create it from an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> by using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f" title="Convenience method that heap-allocates a copy of the internally stored values() and wraps in a ref-co...">mutable_values_copy()</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abbbc9648c8c4bac0c456ed176106a0d2" name="abbbc9648c8c4bac0c456ed176106a0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbc9648c8c4bac0c456ed176106a0d2">&#9670;&nbsp;</a></span>Option_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::Option_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">Declare_options_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>declare_opts_func_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an option set in CANONICAL state with a default-valued <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> payload and options declared by synchronously invoking the callback <code>declare_opts_func()</code>. </p>
<p >See below for details on the latter.</p>
<p >Post-condition: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a></code> is equal to <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values()</a></code>; <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> is null (so the state is initially CANONICAL). (Therefore <code>Value_set</code> no-args ctor must by definition be written so as to initialize all its relevant members to their defaults. Recall <code>Value_set</code> is a template parameter type with certain requirements.)</p>
<p >Use <code>parse_*()</code> (once per config source) and <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a></code> (once) to move to PARSING state and back to CANONICAL state respectively.</p>
<h3>Declaring options via <code>declare_opts_func()</code> callback</h3>
<p ><code>declare_opts_func</code> above denotes an internally saved callback <code>move()</code>d from the corresponding arg <code>declare_opts_func_moved</code>. <code>declare_opts_func()</code> is also invoked synchronously from within various relevant output APIs; their doc headers mention it. (E.g., invoking stream output <code>os &lt;&lt; *this</code> will call <code>declare_opts_func()</code>.)</p>
<p >Informally, the callback must declare every parseable (and therefore stream-printable-semantic-description-having) option, linking it to some data member within a target <code>Values</code> whose address is passed to the callback as an arg; in a consistent order; and as many times through the lifetime of <code>*this</code> (including during this ctor) as <code>*this</code> deems necessary. Use <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> to describe all the options. Formally, it must follow the following exact rules:</p><ul>
<li>Its signature right above the <code>{ body }</code> must name its args <em>exactly</em> as shown in the value of the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Declare_options_func</a> alias.</li>
<li>Its body must execute N&gt;=1 invocations of the macro <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> &ndash; see its doc header &ndash; each corresponding to a distinct data member of <code>Values</code>, always in the same order and the same N. Clues as to how this works:<ul>
<li>The naming of the args is so specific in order to make the macro minimally concise to use.</li>
<li>Macro machinery will auto-determine the main name of the option (as seen in config sources like files) based on the naming of the <code>m_</code> member.</li>
<li>The macro will call a public API that is not to be called directly, passing in various data just mentioned, plus the text description passed to it (if relevant) and the option name passed to it.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">nickname</td><td>Brief string used for logging subsequently. </td></tr>
    <tr><td class="paramname">declare_opts_func_moved</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1f780bfd3a5ff07ade1e36785e28f49" name="aa1f780bfd3a5ff07ade1e36785e28f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f780bfd3a5ff07ade1e36785e28f49">&#9670;&nbsp;</a></span>canonicalize_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::canonicalize_candidate </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>change_detected</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In PARSING state enters CANONICAL state, finalizing <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> from <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a>. </p>
<p >Any cumulative changes are INFO-logged on a per-changed-option basis; and if at least one option's value indeed changed then <code>*change_detected</code> is set to <code>true</code> (else <code>false</code>). (Leave the arg null, if you do not care.)</p>
<dl class="section note"><dt>Note</dt><dd>Individual option validation should be done via the validation condition argument to <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a>. However, it may be necessary to perform a check for internal consistency among the final values. The proper time to do this is just before calling <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>. If the final check fails, typically one would instead call <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">change_detected</td><td>If null, ignored; otherwise <code>*change_detected</code> is set to <code>true</code> if a setting changed; else <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad57de4947f2c8fd5e4663ab982e8dbce" name="ad57de4947f2c8fd5e4663ab982e8dbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57de4947f2c8fd5e4663ab982e8dbce">&#9670;&nbsp;</a></span>declare_option_for_help()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::declare_option_for_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value_default</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Type of the value inside a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object. It must be reasonably copyable; and it must be supported by some version (including specialization(s) and overload(s)) of <a class="el" href="namespaceflow_1_1cfg.html#a1f5ff766e52aae24e6d5c876b3b26e96" title="Serializes a value of type Value to the given ostream suitably for output in Option_set-related outpu...">value_to_ostream()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa" title="Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...">declare_option_for_parsing()</a>. </td></tr>
    <tr><td class="paramname">value_default</td><td>Default value to show to the user. </td></tr>
    <tr><td class="paramname">description</td><td>The description text to show to the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ecbc1b1da6efb81002f1431bdbbeaa" name="aa5ecbc1b1da6efb81002f1431bdbbeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ecbc1b1da6efb81002f1431bdbbeaa">&#9670;&nbsp;</a></span>declare_option_for_parsing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::declare_option_for_parsing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>target_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value *&#160;</td>
          <td class="paramname"><em>value_default_if_no_acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&lt; bool(const Value &amp;val)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>validator_func_moved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>validator_cond_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Type of the value inside a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object. It must be reasonably copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Main option name: as specified by the user in a config source. As of this writing <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> uses macro magic to automatically form this from the identifier name within a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object (e.g., <code>Value_set::m_cool_option</code> =&gt; "cool-option"). </td></tr>
    <tr><td class="paramname">target_value</td><td>When deserializing a value from a config source, the bits shall be written there. This must point inside <code>m_values_candidate</code>. </td></tr>
    <tr><td class="paramname">value_default_if_no_acc</td><td>Usually &ndash; with regular (accumulating) options &ndash; null; otherwise pointer to the default value for <code>*target_value</code> (as from <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values()</a></code>), inside <code>m_values_default</code>. In the latter case (non-null) this indicates this is an option marked by the user as non-accumulating (see <a class="el" href="option__set_8hpp.html#a9187f169f3eaf596c0e7b0f9e7e34761" title="Identical to FLOW_CFG_OPTION_SET_DECLARE_OPTION(), except the option is marked as non-accumulating,...">FLOW_CFG_OPTION_SET_DECLARE_OPTION_NO_ACC()</a> and similar), meaning each time a config source (e.g., a file) is parsed <code>*target_value</code> is first reset to this default; then overwritten with the value in the config source if, else left at the default. An accumulating option in the latter case would instead keep its existing value already in <code>*target_value</code>. </td></tr>
    <tr><td class="paramname">validator_func_moved</td><td>Function F, such that F(V) shall be called from <code>parse_*()</code> when this option's successfully parsed value V is being validated before final storage in <code>m_values_candidate</code>. Return <code>false</code> if the validation shall fail; otherwise return <code>true</code>. </td></tr>
    <tr><td class="paramname">validator_cond_str</td><td>String containing the Boolean code that <code>validator_func_moved()</code> would need to evaluate to <code>true</code> to pass validation. As of this writing <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> uses macro magic to automatically form this from a Boolean expression fragment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade06b27cbbf36393e81da4713c20a6d3" name="ade06b27cbbf36393e81da4713c20a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade06b27cbbf36393e81da4713c20a6d3">&#9670;&nbsp;</a></span>help_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::help_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a multi-line help message about the set of options that <code>*this</code> can parse. </p>
<p >This should typically be preceded by a newline but not followed by one, unless one desires a blank line there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8435631dfa49db887d2fc56638378aae" name="a8435631dfa49db887d2fc56638378aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8435631dfa49db887d2fc56638378aae">&#9670;&nbsp;</a></span>load_option_value_as_if_parsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::load_option_value_as_if_parsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>target_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>source_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Type of the value inside a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object. It must have a meaningful <code>=</code> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa" title="Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...">declare_option_for_parsing()</a>. </td></tr>
    <tr><td class="paramname">target_value</td><td>Target value inside <code>m_values_candidate</code>. </td></tr>
    <tr><td class="paramname">source_value</td><td>Value to load into <code>*target_value</code> (as-if it was parsed from a config source). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4542b206e60f310db02bc98706aac4" name="a6e4542b206e60f310db02bc98706aac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4542b206e60f310db02bc98706aac4">&#9670;&nbsp;</a></span>log_help()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::log_help </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>summary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs a multi-line help message using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ade06b27cbbf36393e81da4713c20a6d3" title="Prints a multi-line help message about the set of options that *this can parse.">help_to_ostream()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">summary</td><td>Brief summary of the help message. </td></tr>
    <tr><td class="paramname">sev</td><td>Severity to use for the log message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb1c681c600d989cd3ae4fe834501214" name="acb1c681c600d989cd3ae4fe834501214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1c681c600d989cd3ae4fe834501214">&#9670;&nbsp;</a></span>log_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::log_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>summary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> *&#160;</td>
          <td class="paramname"><em>values_or_null</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04">log::Sev</a>&#160;</td>
          <td class="paramname"><em>sev</em> = <code><a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04ac238793326fae17afcc849e96b96e8e7">log::Sev::S_INFO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs the given values payload using <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633" title="Writes a multi-line user-suitable representation of the current values in a Values object,...">values_to_ostream()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values_or_null</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adbbf2ec0dd43cb8372f33a3f4cc23633" title="Writes a multi-line user-suitable representation of the current values in a Values object,...">values_to_ostream()</a>. </td></tr>
    <tr><td class="paramname">summary</td><td>Brief summary of what this payload represents. </td></tr>
    <tr><td class="paramname">sev</td><td>Severity to use for the log message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45eebf6c9d7384bcc95c10ff7c934e1f" name="a45eebf6c9d7384bcc95c10ff7c934e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45eebf6c9d7384bcc95c10ff7c934e1f">&#9670;&nbsp;</a></span>mutable_values_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt;<a class="el" href="classflow_1_1cfg_1_1Option__set.html#a03ec172ee1f15c091ca78102faa55987">::Mutable_values_ptr</a> <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::mutable_values_copy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that heap-allocates a copy of the internally stored <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a></code> and wraps in a ref-counted handle suitable for speedy passing around the rest of the application. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="accd086867406387070ac766b03e7998c" name="accd086867406387070ac766b03e7998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd086867406387070ac766b03e7998c">&#9670;&nbsp;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if and only if the option-declaring function passed to the constructor declared no options. </p>
<p >This value is always the same for a given <code>*this</code>.</p>
<h3>Rationale</h3>
<p >While likely of little value when the user instantiates an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> directly, this can be useful in generic meta-programming, wherein multiple <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s might be instantiated at compile time, but the coder doesn't know how many while coding. For example <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> uses <a class="el" href="classflow_1_1cfg_1_1Option__set.html#accd086867406387070ac766b03e7998c" title="Return true if and only if the option-declaring function passed to the constructor declared no option...">null()</a> to bypass confusingly-logging <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> calls on empty <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> objects, such as if a static config set has no dynamic config counterpart.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a2c5b105705745a5369a35cedbff326d1" name="a2c5b105705745a5369a35cedbff326d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5b105705745a5369a35cedbff326d1">&#9670;&nbsp;</a></span>option_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const boost::unordered_set&lt; std::string &gt; &amp; <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::option_names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set of all option names declared by the option-declaring function passed to the constructor. </p>
<p >This can be useful to supply to <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a>, for example, when parsing another <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> from the same file: then other options can be passed to that function as not causing a parse error if encountered; hence 2 or more <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s can <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> the same file despite having disjoint option name sets &ndash; yet totally extraneous options in none of the <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a></code>s would cause an error as desired.</p>
<p >This returns the same value (and reference) each time it is called.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a4ca1b50ec692a98865e4afde76d04128" name="a4ca1b50ec692a98865e4afde76d04128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca1b50ec692a98865e4afde76d04128">&#9670;&nbsp;</a></span>parse_config_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::parse_config_file </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>cfg_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_unregistered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success_or_null</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>allowed_unregistered_opts_or_empty</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the form of the given file in the file-system. </p>
<p >On success <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> is updated; on failure it is untouched.</p>
<p >On failure throws an exception, if <code>success_or_null</code> is null; otherwise set <code>*success_or_null</code> to <code>false</code>. On success simply returns or sets <code>*success_or_null</code> to <code>true</code> respectively. Information is logged regardless.</p>
<p >A failure may occur due to invalid contents in the config source. A failure may occur due to a validator condition failed (see <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a>).</p>
<p >However: the latter applies only to settings actually specified in <code>cfg_path</code> file. Any default or baseline or otherwise-previously-set, but not overridden in <code>cfg_path</code>, values are not validated &ndash; neither before nor after scanning <code>cfg_path</code>. You are, however, free to do so by next (or previously, or both) invoking <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a>. (If "previously," and not yet in PARSING state, then use <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4a3d6a15332fd7e2da1b852adc81aec3" title="Validates the current contents of values() using the validators *this Option_set&lt;Value_set&gt; is config...">validate_values()</a>.) See Validation in class doc header for discussion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> which will finalize the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> constructed so far. </dd>
<dd>
<a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a> which will snap back to CANONICAL state rejecting any successful parsing done. In particular it would make sense in many cases to do this if <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> indicates failure. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg_path</td><td>Path to parse. </td></tr>
    <tr><td class="paramname">allow_unregistered</td><td>If <code>true</code>, if an unknown option is encountered it may be allowed (not considered a failure), subject to <code>allowed_unregistered_opts_or_empty</code>, though an INFO message is still logged for each; if <code>false</code> it is an error like any other illegal config setting. One reason for <code>true</code> is if another <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;&gt;</code> will be parsed from the same config source. Another is if there could be forward- or backward-compatibility concerns. </td></tr>
    <tr><td class="paramname">allowed_unregistered_opts_or_empty</td><td>Meaningful only if <code>allow_unregistered == true</code>, this is the list of all option names (compared case-sensitively) that will not cause a validation error; or empty to allow <em>all</em> unknown options. </td></tr>
    <tr><td class="paramname">success_or_null</td><td>If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd900a94beabe8e9964efc3bc1b91bc" name="afcd900a94beabe8e9964efc3bc1b91bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd900a94beabe8e9964efc3bc1b91bc">&#9670;&nbsp;</a></span>parse_direct_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::parse_direct_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>src_values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters into (from CANONICAL state) or continues in PARSING state by simply setting <code>*values_candidate()</code> to equal the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> payload given as an argument. </p>
<p >Typically precedes other <code>parse_*()</code> calls such as <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a>. If already in PARSING state, note that any changes accumulated in <code>*values_candidate()</code> so far will be overwritten entirely.</p>
<p >The values in <code>src_values</code> are not checked for validity according to the validators configured in the <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> invocations in <code>declare_opts_func()</code> passed to ctor. You are, however, free to do so by next invoking <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ae6b85e12065536214e78266d086be3b2" title="Equivalent to validate_values(success_or_null) but validates *values_candidate() instead of values().">validate_values_candidate()</a>. See Validation in class doc header for discussion.</p>
<h3>Rationale</h3>
<p >This is useful, particularly, when one plans to repeatedly apply updates to one <code>*this</code>, but a certain <em>baseline</em> state is desired before each update. Consider the example of an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> that stores dynamically changeable values. Suppose each update consists only of a single <code>parse_config_file(F)</code> call, where <code>F</code> is some file that might get changed at various times to deliver dynamic updates. Then consider this series:</p><ol type="1">
<li>Initial <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> construction. End state: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> == <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values()</a></code> (default).</li>
<li>First update occurs: <code>parse_config_file(F)</code>, followed by <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>. End state: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a></code> == defaults + changes in file <code>F</code> at time 1.</li>
<li>Second update occurs: <code>parse_config_file(F)</code>, followed by <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>. End state: <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a></code> == defaults + changes in file <code>F</code> at time 1 + changes in file <code>F</code> at time 2.</li>
<li>(etc.)</li>
</ol>
<p >In this case <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> is incrementally changed by each dynamic update, as the file <code>F</code> keeps changing. E.g., if at time 1 it contained only option A, and at time 2 it contained only option B, then <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> would contain both time-1 option A value and time-2 option B value &ndash; even though the file <code>F</code> at time 2 contains only the latter. This <em>might</em> be what you want, but since it's fully incremental, there are some usability landmines. Mainly: If one looks at <code>F</code> contents at any given time, they can't know what the resulting state would be; it depends on what updates preceded it.</p>
<p >To resolve this, one can save a <em>baseline</em> state of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> by copy; and then apply it via this <a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc" title="Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...">parse_direct_values()</a> call before parsing the file in each dynamic update. The baseline state could just be defaults (<code><a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values()</a></code>), or it could come from some special "baseline" config file that is not <code>F</code> which one knows to never change. (Such a file could also typically store static config managed by a separate <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>.)</p>
<p >So then the sequence might become not <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>, ...; but rather:</p><ol type="1">
<li>Baseline parse: <code>parse_config_file(B)</code>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>.</li>
<li>Save <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> copy into <code>Values baseline</code>.</li>
<li>Update 0: <code>parse_direct_values(baseline)</code>, <code>parse_config_file(F)</code>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>.</li>
<li>Update 1: <code>parse_direct_values(baseline)</code>, <code>parse_config_file(F)</code>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>.</li>
<li>Update 2: <code>parse_direct_values(baseline)</code>, <code>parse_config_file(F)</code>, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a>.</li>
<li>... (The first <code>parse_direct_values(baseline)</code> here is a no-op but included for clarity/symmetry, as usually one would just do the same thing for each update.)</li>
</ol>
<p >It is also sometimes desirable to "rewind" the state of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> (by first memorizing it, then <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a4ca1b50ec692a98865e4afde76d04128" title="Enters into (from CANONICAL state) or continues in PARSING state by parsing the config source in the ...">parse_config_file()</a> or similar, then if some value in the resulting value set indicates the file should not apply after all, <a class="el" href="classflow_1_1cfg_1_1Option__set.html#afcd900a94beabe8e9964efc3bc1b91bc" title="Enters into (from CANONICAL state) or continues in PARSING state by simply setting *values_candidate(...">parse_direct_values()</a> to "undo." <a class="el" href="classflow_1_1cfg_1_1Config__manager.html" title="Manages a config setup, intended for a single daemon process, by maintaining 1 or more set(s) of stat...">Config_manager</a> uses it when its multi-source feature is engaged &ndash; <code>commit = false</code>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_values</td><td>The values set loaded into <code>*values_candidate()</code>, as-if parsed from some config source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5452a6e866c911df46d948f02b6a587" name="ac5452a6e866c911df46d948f02b6a587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5452a6e866c911df46d948f02b6a587">&#9670;&nbsp;</a></span>reject_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::reject_candidate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred. </p>
<p >In CANONICAL state, a no-op. Calling this is typically a good idea when a <code>parse_*()</code> attempt indicates failure. </p>

</div>
</div>
<a id="afe4b08b3a98b57d3b6caa2057e5e59e8" name="afe4b08b3a98b57d3b6caa2057e5e59e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4b08b3a98b57d3b6caa2057e5e59e8">&#9670;&nbsp;</a></span>scan_parsed_option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::scan_parsed_option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">util::String_view</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>canonical_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal-through-macro helper function; the user shall not call this directly but only through <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> (see <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> main constructor doc header). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Type of the value inside a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object. It must have a meaningful <code>==</code> operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa5ecbc1b1da6efb81002f1431bdbbeaa" title="Internal-through-macro helper function; the user shall not call this directly but only through FLOW_C...">declare_option_for_parsing()</a>. </td></tr>
    <tr><td class="paramname">canonical_value</td><td>Current value in <code>m_values</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a3d6a15332fd7e2da1b852adc81aec3" name="a4a3d6a15332fd7e2da1b852adc81aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3d6a15332fd7e2da1b852adc81aec3">&#9670;&nbsp;</a></span>validate_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::validate_values </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success_or_null</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the current contents of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> using the validators <code>*this</code> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> is configured to use via constructor. </p>
<p >If at least one option is invalid according to a validator declared by a <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> invocation in <code>declare_opts_func()</code>, then this function shall indicate failure; else success.</p>
<p >On failure throws an exception, if <code>success_or_null</code> is null; otherwise set <code>*success_or_null</code> to <code>false</code>. On success simply returns or sets <code>*success_or_null</code> to <code>true</code> respectively. In the exception case the message will indicate every reasonable detail about the option value that went wrong. This info is logged regardless.</p>
<p >Informally, the use case driving the presence of this overload is discussed in the Validation section of our class doc header; see that. To restate: If you want to stringently ensure the defaults are themselves valid, simply invoke this right after construction, at which point <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a> are by definition at their defaults.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success_or_null</td><td>If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601592ed6eacb42eb5296a2c79fb6ace" name="a601592ed6eacb42eb5296a2c79fb6ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601592ed6eacb42eb5296a2c79fb6ace">&#9670;&nbsp;</a></span>validate_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::validate_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>values_to_validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success_or_null</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates an arbitrary <code>Value_set</code>, using the same validators <code>*this</code> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> is configured to use when parsing config sources. </p>
<p >This essentially means using the <code>static</code> overload and passing to it <code>declare_opts_func</code> equal to the one earlier passed by the user to <code>*this</code> constructor. The success/failure semantics are identical to the other overload's (see that doc header).</p>
<p >You can also use the <code>static</code> overload, if you aren't at all parsing from config sources but still want to validate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values_to_validate</td><td>The values in this structure shall be validated in the same way as they are upon <code>this-&gt;parse_*()</code>ing from a config source. </td></tr>
    <tr><td class="paramname">success_or_null</td><td>If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f3924bff19cae0beb9f06b6dffbd504" name="a7f3924bff19cae0beb9f06b6dffbd504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3924bff19cae0beb9f06b6dffbd504">&#9670;&nbsp;</a></span>validate_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::validate_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>values_to_validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39">Declare_options_func</a> &amp;&#160;</td>
          <td class="paramname"><em>declare_opts_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success_or_null</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates an arbitrary <code>Value_set</code>, as parseable by <em>an</em> <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code>, according to the given option-registering function suitable for <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> constructor. </p>
<p >If at least one option is invalid according to a validator declared by a <a class="el" href="option__set_8hpp.html#ae6bc0bcf28a53682a4c9a5fbe3a3837f" title="Macro the user must use, as prescribed in the flow::cfg::Option_set constructor doc header discussing...">FLOW_CFG_OPTION_SET_DECLARE_OPTION()</a> invocation in <code>declare_opts_func()</code>, then this function shall indicate failure; else success.</p>
<p >On failure throws an exception, if <code>success_or_null</code> is null; otherwise set <code>*success_or_null</code> to <code>false</code>. On success simply returns or sets <code>*success_or_null</code> to <code>true</code> respectively. In the exception case the message will indicate every reasonable detail about the option value that went wrong. This info is logged regardless.</p>
<p >Use this, at least, if you've filled out a <code>Value_set</code> through manual assignment or some other source, rather than parsing through an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> &ndash; and don't even <em>use</em> an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>, as you don't parse from config &ndash; but still want to check it for validity.</p>
<p >You can also use the non-<code>static</code> overload to reuse the <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac6755bc762fc40b1ae8f4bd47c55bd39" title="Short-hand for the ever-important callback passed to the main Option_set constructor.">Declare_options_func</a> passed to an existing parsing-capable <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">values_to_validate</td><td>The values in this structure shall be validated in the same way as they are upon parsing by a hypothetical <code><a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a>&lt;Value_set&gt;</code> into whose ctor the same <code>declare_opts_func</code> were passed. </td></tr>
    <tr><td class="paramname">declare_opts_func</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> constructor. </td></tr>
    <tr><td class="paramname">success_or_null</td><td>If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6b85e12065536214e78266d086be3b2" name="ae6b85e12065536214e78266d086be3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b85e12065536214e78266d086be3b2">&#9670;&nbsp;</a></span>validate_values_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::validate_values_candidate </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success_or_null</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>validate_values(success_or_null)</code> but validates <code>*values_candidate()</code> instead of <a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>. </p>
<p >Behavior is undefined (assertion may trip) if not in PARSING mode currently (i.e., <a class="el" href="classflow_1_1cfg_1_1Option__set.html#adce212853383183bd1b60505157f7215" title="Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after ...">values_candidate()</a> is null).</p>
<p >Informally, the use case driving the presence of this overload is discussed in the Validation section of our class doc header; see that. To restate: If you want to ensure no invalid defaults or baseline values have "gotten through" in the current PARSING state, then invoke this &ndash; particularly just ahead of the decision to either <a class="el" href="classflow_1_1cfg_1_1Option__set.html#aa1f780bfd3a5ff07ade1e36785e28f49" title="In PARSING state enters CANONICAL state, finalizing values() from values_candidate().">canonicalize_candidate()</a> or <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ac5452a6e866c911df46d948f02b6a587" title="In PARSING state, returns to CANONICAL state, as if no parse attempts have occurred.">reject_candidate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success_or_null</td><td>If null exceptions mark failure; otherwise the pointed-to value shall indicate success or failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93ab889bf230d21961c22bd4bf21e06a" name="a93ab889bf230d21961c22bd4bf21e06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab889bf230d21961c22bd4bf21e06a">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set &amp; <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::values</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Externally immutable internally stored canonical (current) config values as last constructed or parsed, whichever happened more recently. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1cfg_1_1Option__set.html#a45eebf6c9d7384bcc95c10ff7c934e1f" title="Convenience method that heap-allocates a copy of the internally stored values() and wraps in a ref-co...">mutable_values_copy()</a> to get a copy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="adce212853383183bd1b60505157f7215" name="adce212853383183bd1b60505157f7215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce212853383183bd1b60505157f7215">&#9670;&nbsp;</a></span>values_candidate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value_set * <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::values_candidate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns null in CANONICAL state; or in PARSING state a pointer to the not-yet-canonical values after the last successful <code>parse_*()</code> API call. </p>
<p >Rationale: It is supplied publicly in case the caller wans to log it or something; or perhaps to check for current state (CANONICAL if and only it returns null).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="adbbf2ec0dd43cb8372f33a3f4cc23633" name="adbbf2ec0dd43cb8372f33a3f4cc23633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbf2ec0dd43cb8372f33a3f4cc23633">&#9670;&nbsp;</a></span>values_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1cfg_1_1Option__set.html">flow::cfg::Option_set</a>&lt; Value_set &gt;::values_to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c">Values</a> *&#160;</td>
          <td class="paramname"><em>values_or_null</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a multi-line user-suitable representation of the current values in a <a class="el" href="classflow_1_1cfg_1_1Option__set.html#ab12751047ec45932c26364e533a96e7c" title="Short-hand for the template parameter type Value_set.">Values</a> object, at some point perhaps initialized or parsed by <code>*this</code>, to the given stream. </p>
<p >This should typically be preceded by a newline but not followed by one, unless one desires a blank line there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">values_or_null</td><td>Values to serialize; if null then we act as-if it's <code>&amp;(<a class="el" href="classflow_1_1cfg_1_1Option__set.html#a93ab889bf230d21961c22bd4bf21e06a" title="Externally immutable internally stored canonical (current) config values as last constructed or parse...">values()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="acd1ce6e7c258d7486388915d59019880" name="acd1ce6e7c258d7486388915d59019880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1ce6e7c258d7486388915d59019880">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1cfg_1_1Option__set.html">Option_set</a>&lt; Value_set &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes (briefly) an <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> to a standard output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_set</td><td>See <a class="el" href="classflow_1_1cfg_1_1Option__set.html" title="The core config-parsing facility, which builds parsing/comparison/output capabilities on top of a giv...">Option_set</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cfg/<a class="el" href="cfg__fwd_8hpp.html">cfg_fwd.hpp</a></li>
<li>cfg/<a class="el" href="option__set_8hpp.html">option_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 01:11:10 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
