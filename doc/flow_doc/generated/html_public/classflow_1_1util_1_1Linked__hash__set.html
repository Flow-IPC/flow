<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Linked_hash_set&lt; Key_t, Hash_t, Pred_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Linked__hash__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Linked_hash_set&lt; Key_t, Hash_t, Pred_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a map that combines the lookup speed of an <code>unordered_set&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>.  
 <a href="classflow_1_1util_1_1Linked__hash__set.html#details">More...</a></p>

<p><code>#include &lt;linked_hash_set.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa3bedf484b3d3bd41b3375f8c8342581"><td class="memItemLeft" align="right" valign="top"><a id="aa3bedf484b3d3bd41b3375f8c8342581" name="aa3bedf484b3d3bd41b3375f8c8342581"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Key</b> = Key_t</td></tr>
<tr class="memdesc:aa3bedf484b3d3bd41b3375f8c8342581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:aa3bedf484b3d3bd41b3375f8c8342581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bdba2ace4f562fa761bb8cad8125c2"><td class="memItemLeft" align="right" valign="top"><a id="ab0bdba2ace4f562fa761bb8cad8125c2" name="ab0bdba2ace4f562fa761bb8cad8125c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Hash</b> = Hash_t</td></tr>
<tr class="memdesc:ab0bdba2ace4f562fa761bb8cad8125c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:ab0bdba2ace4f562fa761bb8cad8125c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1573c437d154124653f1878f45ac462a"><td class="memItemLeft" align="right" valign="top"><a id="a1573c437d154124653f1878f45ac462a" name="a1573c437d154124653f1878f45ac462a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Pred</b> = Pred_t</td></tr>
<tr class="memdesc:a1573c437d154124653f1878f45ac462a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:a1573c437d154124653f1878f45ac462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56bfaa1dab525c469e9329e62cd6d4"><td class="memItemLeft" align="right" valign="top"><a id="a5f56bfaa1dab525c469e9329e62cd6d4" name="a5f56bfaa1dab525c469e9329e62cd6d4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a></td></tr>
<tr class="memdesc:a5f56bfaa1dab525c469e9329e62cd6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for values, which in this case are simply the keys. <br /></td></tr>
<tr class="separator:a5f56bfaa1dab525c469e9329e62cd6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39922a66be81234c043a5e43647df40b"><td class="memItemLeft" align="right" valign="top"><a id="a39922a66be81234c043a5e43647df40b" name="a39922a66be81234c043a5e43647df40b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:a39922a66be81234c043a5e43647df40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses sizes/lengths of relevant things. <br /></td></tr>
<tr class="separator:a39922a66be81234c043a5e43647df40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb077c5dc4dd72cf343012b814053596"><td class="memItemLeft" align="right" valign="top"><a id="acb077c5dc4dd72cf343012b814053596" name="acb077c5dc4dd72cf343012b814053596"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:acb077c5dc4dd72cf343012b814053596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s. <br /></td></tr>
<tr class="separator:acb077c5dc4dd72cf343012b814053596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c9047cc6342a4a07f107b127bfbc1"><td class="memItemLeft" align="right" valign="top"><a id="ab04c9047cc6342a4a07f107b127bfbc1" name="ab04c9047cc6342a4a07f107b127bfbc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_iterator</b> = typename Value_list::const_iterator</td></tr>
<tr class="memdesc:ab04c9047cc6342a4a07f107b127bfbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type. <br /></td></tr>
<tr class="separator:ab04c9047cc6342a4a07f107b127bfbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee77d3405116b26e39f70ef8b44697b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a></td></tr>
<tr class="memdesc:a8ee77d3405116b26e39f70ef8b44697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">More...</a><br /></td></tr>
<tr class="separator:a8ee77d3405116b26e39f70ef8b44697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8d53b4c62d3982b6eb202315ed2aa"><td class="memItemLeft" align="right" valign="top"><a id="a6ad8d53b4c62d3982b6eb202315ed2aa" name="a6ad8d53b4c62d3982b6eb202315ed2aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_reverse_iterator</b> = typename Value_list::const_reverse_iterator</td></tr>
<tr class="memdesc:a6ad8d53b4c62d3982b6eb202315ed2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into an immutable structure of this type. <br /></td></tr>
<tr class="separator:a6ad8d53b4c62d3982b6eb202315ed2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1779e07739a1377e7b82d0a36235f56a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">Reverse_iterator</a> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a></td></tr>
<tr class="memdesc:a1779e07739a1377e7b82d0a36235f56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa" title="Type for reverse iterator pointing into an immutable structure of this type.">Const_reverse_iterator</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">More...</a><br /></td></tr>
<tr class="separator:a1779e07739a1377e7b82d0a36235f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d73bb3f10de5e6b7e68cbf44f44d00"><td class="memItemLeft" align="right" valign="top"><a id="a86d73bb3f10de5e6b7e68cbf44f44d00" name="a86d73bb3f10de5e6b7e68cbf44f44d00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a></td></tr>
<tr class="memdesc:a86d73bb3f10de5e6b7e68cbf44f44d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581" title="Convenience alias for template arg.">Key</a> type. <br /></td></tr>
<tr class="separator:a86d73bb3f10de5e6b7e68cbf44f44d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2233a1b14c8dad45b6ff109422d844fd"><td class="memItemLeft" align="right" valign="top"><a id="a2233a1b14c8dad45b6ff109422d844fd" name="a2233a1b14c8dad45b6ff109422d844fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a></td></tr>
<tr class="memdesc:a2233a1b14c8dad45b6ff109422d844fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4" title="Short-hand for values, which in this case are simply the keys.">Value</a> type. <br /></td></tr>
<tr class="separator:a2233a1b14c8dad45b6ff109422d844fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0720b5c7e7971f2a8376c5801bbe0dae"><td class="memItemLeft" align="right" valign="top"><a id="a0720b5c7e7971f2a8376c5801bbe0dae" name="a0720b5c7e7971f2a8376c5801bbe0dae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a></td></tr>
<tr class="memdesc:a0720b5c7e7971f2a8376c5801bbe0dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2" title="Convenience alias for template arg.">Hash</a> type. <br /></td></tr>
<tr class="separator:a0720b5c7e7971f2a8376c5801bbe0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee73351ae7acc66eb4558df94d9e7a"><td class="memItemLeft" align="right" valign="top"><a id="a54ee73351ae7acc66eb4558df94d9e7a" name="a54ee73351ae7acc66eb4558df94d9e7a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a></td></tr>
<tr class="memdesc:a54ee73351ae7acc66eb4558df94d9e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a" title="Convenience alias for template arg.">Pred</a> type. <br /></td></tr>
<tr class="separator:a54ee73351ae7acc66eb4558df94d9e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a52a532b9fb3dfcb234548f89495d27"><td class="memItemLeft" align="right" valign="top"><a id="a0a52a532b9fb3dfcb234548f89495d27" name="a0a52a532b9fb3dfcb234548f89495d27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> *</td></tr>
<tr class="memdesc:a0a52a532b9fb3dfcb234548f89495d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581" title="Convenience alias for template arg.">Key</a> type. <br /></td></tr>
<tr class="separator:a0a52a532b9fb3dfcb234548f89495d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6524716c8cf81c62a83014664543529d"><td class="memItemLeft" align="right" valign="top"><a id="a6524716c8cf81c62a83014664543529d" name="a6524716c8cf81c62a83014664543529d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> *</td></tr>
<tr class="memdesc:a6524716c8cf81c62a83014664543529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const Key</code> type. <br /></td></tr>
<tr class="separator:a6524716c8cf81c62a83014664543529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d97d8bb80c624e4d61f1aab6aa216a"><td class="memItemLeft" align="right" valign="top"><a id="af8d97d8bb80c624e4d61f1aab6aa216a" name="af8d97d8bb80c624e4d61f1aab6aa216a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> &amp;</td></tr>
<tr class="memdesc:af8d97d8bb80c624e4d61f1aab6aa216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581" title="Convenience alias for template arg.">Key</a> type. <br /></td></tr>
<tr class="separator:af8d97d8bb80c624e4d61f1aab6aa216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd883150facb341ddeea81151683113"><td class="memItemLeft" align="right" valign="top"><a id="aabd883150facb341ddeea81151683113" name="aabd883150facb341ddeea81151683113"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> &amp;</td></tr>
<tr class="memdesc:aabd883150facb341ddeea81151683113"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const Key</code> type. <br /></td></tr>
<tr class="separator:aabd883150facb341ddeea81151683113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab523c43ba22adcdec83079f2cf98a08b"><td class="memItemLeft" align="right" valign="top"><a id="ab523c43ba22adcdec83079f2cf98a08b" name="ab523c43ba22adcdec83079f2cf98a08b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a></td></tr>
<tr class="memdesc:ab523c43ba22adcdec83079f2cf98a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Iterator</code> type. <br /></td></tr>
<tr class="separator:ab523c43ba22adcdec83079f2cf98a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a565c3b0d832e53dfe24ce90fdc1ec"><td class="memItemLeft" align="right" valign="top"><a id="a76a565c3b0d832e53dfe24ce90fdc1ec" name="a76a565c3b0d832e53dfe24ce90fdc1ec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a></td></tr>
<tr class="memdesc:a76a565c3b0d832e53dfe24ce90fdc1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <code>Const_iterator</code> type. <br /></td></tr>
<tr class="separator:a76a565c3b0d832e53dfe24ce90fdc1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94276dc6f6728152c7bcc1a27c2909a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a94276dc6f6728152c7bcc1a27c2909a9">Linked_hash_set</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a>{})</td></tr>
<tr class="memdesc:a94276dc6f6728152c7bcc1a27c2909a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty structure with some basic parameters.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a94276dc6f6728152c7bcc1a27c2909a9">More...</a><br /></td></tr>
<tr class="separator:a94276dc6f6728152c7bcc1a27c2909a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b89aaefe84fc6bc3a9055f21c984a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad38b89aaefe84fc6bc3a9055f21c984a">Linked_hash_set</a> (std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> &gt; values, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a>{})</td></tr>
<tr class="memdesc:ad38b89aaefe84fc6bc3a9055f21c984a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs structure with some basic parameters, and values initialized from initializer list.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ad38b89aaefe84fc6bc3a9055f21c984a">More...</a><br /></td></tr>
<tr class="separator:ad38b89aaefe84fc6bc3a9055f21c984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b85d58f6e27290f805353b9f4236b3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a0b85d58f6e27290f805353b9f4236b3c">Linked_hash_set</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;src)</td></tr>
<tr class="memdesc:a0b85d58f6e27290f805353b9f4236b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object that is a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a0b85d58f6e27290f805353b9f4236b3c">More...</a><br /></td></tr>
<tr class="separator:a0b85d58f6e27290f805353b9f4236b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4292c4688320127817a4de232900270e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4292c4688320127817a4de232900270e">Linked_hash_set</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a4292c4688320127817a4de232900270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4292c4688320127817a4de232900270e">More...</a><br /></td></tr>
<tr class="separator:a4292c4688320127817a4de232900270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef57d99d28c0bb33e5af0fd2a6708d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3ef57d99d28c0bb33e5af0fd2a6708d3">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;src)</td></tr>
<tr class="memdesc:a3ef57d99d28c0bb33e5af0fd2a6708d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object with a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a3ef57d99d28c0bb33e5af0fd2a6708d3">More...</a><br /></td></tr>
<tr class="separator:a3ef57d99d28c0bb33e5af0fd2a6708d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16960d867315b173fff1c0bf4336f94c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a16960d867315b173fff1c0bf4336f94c">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a16960d867315b173fff1c0bf4336f94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a16960d867315b173fff1c0bf4336f94c">More...</a><br /></td></tr>
<tr class="separator:a16960d867315b173fff1c0bf4336f94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f73c0627f8b37f233afa9827af3009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a15f73c0627f8b37f233afa9827af3009">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a> &amp;other)</td></tr>
<tr class="memdesc:a15f73c0627f8b37f233afa9827af3009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a15f73c0627f8b37f233afa9827af3009">More...</a><br /></td></tr>
<tr class="separator:a15f73c0627f8b37f233afa9827af3009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3553fc2a52e6d2a265c7c05a5489d8a4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3553fc2a52e6d2a265c7c05a5489d8a4">insert</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a3553fc2a52e6d2a265c7c05a5489d8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert (copying it) the given keyinto the map; if key already in <code>*this</code> makes no change.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a3553fc2a52e6d2a265c7c05a5489d8a4">More...</a><br /></td></tr>
<tr class="separator:a3553fc2a52e6d2a265c7c05a5489d8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b234c28dc3647005b85655a6e25fe9f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b234c28dc3647005b85655a6e25fe9f">insert</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&amp;key)</td></tr>
<tr class="memdesc:a4b234c28dc3647005b85655a6e25fe9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4b234c28dc3647005b85655a6e25fe9f">More...</a><br /></td></tr>
<tr class="separator:a4b234c28dc3647005b85655a6e25fe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6de0950504a3bab6289ef2892bbe1ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab6de0950504a3bab6289ef2892bbe1ee">find</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:ab6de0950504a3bab6289ef2892bbe1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find value at the given key in the map.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ab6de0950504a3bab6289ef2892bbe1ee">More...</a><br /></td></tr>
<tr class="separator:ab6de0950504a3bab6289ef2892bbe1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b576487fa0570ebf2b7533ae219356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a98b576487fa0570ebf2b7533ae219356">count</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a98b576487fa0570ebf2b7533ae219356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab6de0950504a3bab6289ef2892bbe1ee" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a98b576487fa0570ebf2b7533ae219356">More...</a><br /></td></tr>
<tr class="separator:a98b576487fa0570ebf2b7533ae219356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68510d5492d94311c4a427c665b7c306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a68510d5492d94311c4a427c665b7c306">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a68510d5492d94311c4a427c665b7c306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a68510d5492d94311c4a427c665b7c306">More...</a><br /></td></tr>
<tr class="separator:a68510d5492d94311c4a427c665b7c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ca0346b07067af7279feea6b2404d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ae3ca0346b07067af7279feea6b2404d6">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ae3ca0346b07067af7279feea6b2404d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ae3ca0346b07067af7279feea6b2404d6">More...</a><br /></td></tr>
<tr class="separator:ae3ca0346b07067af7279feea6b2404d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8fe29c23e6580d4d2a7d14c991d223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3d8fe29c23e6580d4d2a7d14c991d223">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a3d8fe29c23e6580d4d2a7d14c991d223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element pointed to by the given valid iterator.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a3d8fe29c23e6580d4d2a7d14c991d223">More...</a><br /></td></tr>
<tr class="separator:a3d8fe29c23e6580d4d2a7d14c991d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f40a62a9e05dc4eb025a789f8e45e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7f40a62a9e05dc4eb025a789f8e45e04">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;it_newest, const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;it_past_oldest)</td></tr>
<tr class="memdesc:a7f40a62a9e05dc4eb025a789f8e45e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7f40a62a9e05dc4eb025a789f8e45e04">More...</a><br /></td></tr>
<tr class="separator:a7f40a62a9e05dc4eb025a789f8e45e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d815747d40adce6e5c5ba865852f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7d0d815747d40adce6e5c5ba865852f1">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a7d0d815747d40adce6e5c5ba865852f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element with the given key, if it exists.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7d0d815747d40adce6e5c5ba865852f1">More...</a><br /></td></tr>
<tr class="separator:a7d0d815747d40adce6e5c5ba865852f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef8bdeefef5cd79dac28b6a4098f149"><td class="memItemLeft" align="right" valign="top"><a id="a1ef8bdeefef5cd79dac28b6a4098f149" name="a1ef8bdeefef5cd79dac28b6a4098f149"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a1ef8bdeefef5cd79dac28b6a4098f149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a494cbbb586ceb41455f3c1e830a969c1" title="Returns number of elements stored.">size()</a> == 0</code>. <br /></td></tr>
<tr class="separator:a1ef8bdeefef5cd79dac28b6a4098f149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8bc4e2c71592279381045c83e6adcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7a8bc4e2c71592279381045c83e6adcf">begin</a> () const</td></tr>
<tr class="memdesc:a7a8bc4e2c71592279381045c83e6adcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#abd14cba1fe3c5fdaba7b5e0f1a10e9ed" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7a8bc4e2c71592279381045c83e6adcf">More...</a><br /></td></tr>
<tr class="separator:a7a8bc4e2c71592279381045c83e6adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd14cba1fe3c5fdaba7b5e0f1a10e9ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#abd14cba1fe3c5fdaba7b5e0f1a10e9ed">newest</a> () const</td></tr>
<tr class="memdesc:abd14cba1fe3c5fdaba7b5e0f1a10e9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#abd14cba1fe3c5fdaba7b5e0f1a10e9ed">More...</a><br /></td></tr>
<tr class="separator:abd14cba1fe3c5fdaba7b5e0f1a10e9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda0d15fe8206d32043c14365cfa72c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#adda0d15fe8206d32043c14365cfa72c8">end</a> () const</td></tr>
<tr class="memdesc:adda0d15fe8206d32043c14365cfa72c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a896d5a459c22e2f7e043d89c9259d411" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#adda0d15fe8206d32043c14365cfa72c8">More...</a><br /></td></tr>
<tr class="separator:adda0d15fe8206d32043c14365cfa72c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896d5a459c22e2f7e043d89c9259d411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a896d5a459c22e2f7e043d89c9259d411">past_oldest</a> () const</td></tr>
<tr class="memdesc:a896d5a459c22e2f7e043d89c9259d411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a896d5a459c22e2f7e043d89c9259d411">More...</a><br /></td></tr>
<tr class="separator:a896d5a459c22e2f7e043d89c9259d411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13980f43fc09f26b5c1f1f75a9645057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a13980f43fc09f26b5c1f1f75a9645057">cbegin</a> () const</td></tr>
<tr class="memdesc:a13980f43fc09f26b5c1f1f75a9645057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a70c1d7a6c78ac664771779d3187452ff" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a13980f43fc09f26b5c1f1f75a9645057">More...</a><br /></td></tr>
<tr class="separator:a13980f43fc09f26b5c1f1f75a9645057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1d7a6c78ac664771779d3187452ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a70c1d7a6c78ac664771779d3187452ff">const_newest</a> () const</td></tr>
<tr class="memdesc:a70c1d7a6c78ac664771779d3187452ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a70c1d7a6c78ac664771779d3187452ff">More...</a><br /></td></tr>
<tr class="separator:a70c1d7a6c78ac664771779d3187452ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517dfea6a7bb55d5c45ff395bff14869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a517dfea6a7bb55d5c45ff395bff14869">cend</a> () const</td></tr>
<tr class="memdesc:a517dfea6a7bb55d5c45ff395bff14869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b8ea38ac5b6fa4476928a80362a3706" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a517dfea6a7bb55d5c45ff395bff14869">More...</a><br /></td></tr>
<tr class="separator:a517dfea6a7bb55d5c45ff395bff14869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8ea38ac5b6fa4476928a80362a3706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b8ea38ac5b6fa4476928a80362a3706">const_past_oldest</a> () const</td></tr>
<tr class="memdesc:a4b8ea38ac5b6fa4476928a80362a3706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "oldest," element's iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4b8ea38ac5b6fa4476928a80362a3706">More...</a><br /></td></tr>
<tr class="separator:a4b8ea38ac5b6fa4476928a80362a3706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8e03420e3482a575b5a6a0485df9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b8e03420e3482a575b5a6a0485df9c5">rbegin</a> () const</td></tr>
<tr class="memdesc:a4b8e03420e3482a575b5a6a0485df9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7bcf78a144e0891917ff00f1c4da87e8" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a4b8e03420e3482a575b5a6a0485df9c5">More...</a><br /></td></tr>
<tr class="separator:a4b8e03420e3482a575b5a6a0485df9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcf78a144e0891917ff00f1c4da87e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7bcf78a144e0891917ff00f1c4da87e8">oldest</a> () const</td></tr>
<tr class="memdesc:a7bcf78a144e0891917ff00f1c4da87e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a7bcf78a144e0891917ff00f1c4da87e8">More...</a><br /></td></tr>
<tr class="separator:a7bcf78a144e0891917ff00f1c4da87e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3536c7369a995db24aa48014a3e2de53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3536c7369a995db24aa48014a3e2de53">rend</a> () const</td></tr>
<tr class="memdesc:a3536c7369a995db24aa48014a3e2de53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aec39f63e21309c3494c26c5ac7989ebe" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a3536c7369a995db24aa48014a3e2de53">More...</a><br /></td></tr>
<tr class="separator:a3536c7369a995db24aa48014a3e2de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39f63e21309c3494c26c5ac7989ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aec39f63e21309c3494c26c5ac7989ebe">past_newest</a> () const</td></tr>
<tr class="memdesc:aec39f63e21309c3494c26c5ac7989ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element, due to nature of this type).  <a href="classflow_1_1util_1_1Linked__hash__set.html#aec39f63e21309c3494c26c5ac7989ebe">More...</a><br /></td></tr>
<tr class="separator:aec39f63e21309c3494c26c5ac7989ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd64cf1cbd43c658aed4283f079d9366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#afd64cf1cbd43c658aed4283f079d9366">crbegin</a> () const</td></tr>
<tr class="memdesc:afd64cf1cbd43c658aed4283f079d9366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a13d2d6da14cd0041a21fa786dd9aac3b" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#afd64cf1cbd43c658aed4283f079d9366">More...</a><br /></td></tr>
<tr class="separator:afd64cf1cbd43c658aed4283f079d9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d2d6da14cd0041a21fa786dd9aac3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a13d2d6da14cd0041a21fa786dd9aac3b">const_oldest</a> () const</td></tr>
<tr class="memdesc:a13d2d6da14cd0041a21fa786dd9aac3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a13d2d6da14cd0041a21fa786dd9aac3b">More...</a><br /></td></tr>
<tr class="separator:a13d2d6da14cd0041a21fa786dd9aac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89a3525a1c1b43384191f2ea85125b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ad89a3525a1c1b43384191f2ea85125b3">crend</a> () const</td></tr>
<tr class="memdesc:ad89a3525a1c1b43384191f2ea85125b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a43ec6c068dcd30a5d066afe89e9db6be" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#ad89a3525a1c1b43384191f2ea85125b3">More...</a><br /></td></tr>
<tr class="separator:ad89a3525a1c1b43384191f2ea85125b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ec6c068dcd30a5d066afe89e9db6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a43ec6c068dcd30a5d066afe89e9db6be">const_past_newest</a> () const</td></tr>
<tr class="memdesc:a43ec6c068dcd30a5d066afe89e9db6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__set.html#a43ec6c068dcd30a5d066afe89e9db6be">More...</a><br /></td></tr>
<tr class="separator:a43ec6c068dcd30a5d066afe89e9db6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbcb5f6a387904e11c413aa60539365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1fbcb5f6a387904e11c413aa60539365">empty</a> () const</td></tr>
<tr class="memdesc:a1fbcb5f6a387904e11c413aa60539365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if container is empty.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a1fbcb5f6a387904e11c413aa60539365">More...</a><br /></td></tr>
<tr class="separator:a1fbcb5f6a387904e11c413aa60539365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494cbbb586ceb41455f3c1e830a969c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a494cbbb586ceb41455f3c1e830a969c1">size</a> () const</td></tr>
<tr class="memdesc:a494cbbb586ceb41455f3c1e830a969c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored.  <a href="classflow_1_1util_1_1Linked__hash__set.html#a494cbbb586ceb41455f3c1e830a969c1">More...</a><br /></td></tr>
<tr class="separator:a494cbbb586ceb41455f3c1e830a969c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa38e11188ee81d15fa8b66910af70f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aaa38e11188ee81d15fa8b66910af70f4">max_size</a> () const</td></tr>
<tr class="memdesc:aaa38e11188ee81d15fa8b66910af70f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max number of elements that can be stored.  <a href="classflow_1_1util_1_1Linked__hash__set.html#aaa38e11188ee81d15fa8b66910af70f4">More...</a><br /></td></tr>
<tr class="separator:aaa38e11188ee81d15fa8b66910af70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af9236b0fce20cb81abac3a70360db155"><td class="memTemplParams" colspan="2">template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </td></tr>
<tr class="memitem:af9236b0fce20cb81abac3a70360db155"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#af9236b0fce20cb81abac3a70360db155">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;val1, <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;val2)</td></tr>
<tr class="memdesc:af9236b0fce20cb81abac3a70360db155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>val1.swap(val2)</code>.  <a href="classflow_1_1util_1_1Linked__hash__set.html#af9236b0fce20cb81abac3a70360db155">More...</a><br /></td></tr>
<tr class="separator:af9236b0fce20cb81abac3a70360db155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key_t, typename Hash_t, typename Pred_t&gt;<br />
class flow::util::Linked_hash_set&lt; Key_t, Hash_t, Pred_t &gt;</div><p >An object of this class is a map that combines the lookup speed of an <code>unordered_set&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>. </p>
<p >This is just like <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a>, except it only stores keys &ndash; no mapped values. All comments, except for self-explanatory differences, from <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a> apply here. Thus I will only speak of differences below to avoid duplication of this header. Incidentally the most visible API difference (aside from having no <code>Mapped</code>s to speak of, only <code>Key</code>s) is that <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html" title="An object of this class is a map that combines the lookup speed of an unordered_set&lt;&gt; and ordering an...">Linked_hash_set</a> lacks <code>(*this)[]</code> operator; so one always uses <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a3553fc2a52e6d2a265c7c05a5489d8a4" title="Attempts to insert (copying it) the given keyinto the map; if key already in *this makes no change.">insert()</a> to insert.</p>
<p >Move semantics for keys are supported (let <code>x</code> be a <code>*this</code>):</p><ul>
<li><code>x.insert(std::move(a_key))</code>;</li>
<li><code>x.insert(Key{...})</code>.</li>
</ul>
<p >The iterators are, really, <code>list&lt;Key&gt;</code> const-iterators; and as such are not invalidated except due to direct erasure of a given pointee.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key_t</td><td>Key type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a>. </td></tr>
    <tr><td class="paramname">Hash_t</td><td>Hasher type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a>. </td></tr>
    <tr><td class="paramname">Pred_t</td><td>Equality functor type. Same as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ee77d3405116b26e39f70ef8b44697b" name="a8ee77d3405116b26e39f70ef8b44697b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee77d3405116b26e39f70ef8b44697b">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a>. </p>
<p >Note these are standard semantics (see <code>std::set</code>, etc.). </p>

</div>
</div>
<a id="a1779e07739a1377e7b82d0a36235f56a" name="a1779e07739a1377e7b82d0a36235f56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1779e07739a1377e7b82d0a36235f56a">&#9670;&nbsp;</a></span>Reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Reverse_iterator =  <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">Const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for reverse iterator pointing into a mutable structure of this type but actually that is not possible; so alias to <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa" title="Type for reverse iterator pointing into an immutable structure of this type.">Const_reverse_iterator</a>. </p>
<p >Note these are standard semantics (see <code>std::set</code>, etc.). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94276dc6f6728152c7bcc1a27c2909a9" name="a94276dc6f6728152c7bcc1a27c2909a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94276dc6f6728152c7bcc1a27c2909a9">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs empty structure with some basic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_buckets</td><td>Number of buckets for the unordered (hash) table. Special value -1 (default) will cause us to use whatever <code>unordered_set&lt;&gt;</code> would use by default. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>Instance of the hash function type (<code>hasher_obj(k) -&gt; size_t</code> should be hash of <code>Key k</code>). </td></tr>
    <tr><td class="paramname">pred</td><td>Instance of the equality function type (<code>pred(k1, k2)</code> should return <code>true</code> if and only if the <code>Key</code>s are equal by value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38b89aaefe84fc6bc3a9055f21c984a" name="ad38b89aaefe84fc6bc3a9055f21c984a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38b89aaefe84fc6bc3a9055f21c984a">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a5f56bfaa1dab525c469e9329e62cd6d4">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs structure with some basic parameters, and values initialized from initializer list. </p>
<p >The values are inserted as if <code>insert(v)</code> was called for each element <code>v</code> in <code>values</code> <b>in reverse order</b>. Since the canonical ordering places the <em>newest</em> (last inserted/<code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a68510d5492d94311c4a427c665b7c306" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a></code>ed) element at the <em>front</em> of the ordering, that means that forward iteration through the set (right after this constructor runs) will yield values in the <em>same</em> order as in initializer list <code>values</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Values with which to fill the structure after initializing it. Typically you'd provide a series of keys like this: <code>{ key1, key2, ... }</code>. They will appear in iterated sequence in the same order as they appear in this list. </td></tr>
    <tr><td class="paramname">n_buckets</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">pred</td><td>See other constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b85d58f6e27290f805353b9f4236b3c" name="a0b85d58f6e27290f805353b9f4236b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b85d58f6e27290f805353b9f4236b3c">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object that is a copy of the given source. </p>
<p >Equivalent to default-ction followed by <code>operator=(src)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4292c4688320127817a4de232900270e" name="a4292c4688320127817a4de232900270e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4292c4688320127817a4de232900270e">&#9670;&nbsp;</a></span>Linked_hash_set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::Linked_hash_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object by making it equal to the given source, while the given source becomes as-if default-cted. </p>
<p >Equivalent to default-ction followed by <code>operator=(std::move(src))</code>.</p>
<p >This is a constant-time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a8bc4e2c71592279381045c83e6adcf" name="a7a8bc4e2c71592279381045c83e6adcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8bc4e2c71592279381045c83e6adcf">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#abd14cba1fe3c5fdaba7b5e0f1a10e9ed" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#abd14cba1fe3c5fdaba7b5e0f1a10e9ed" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element, due to nature of this type).">newest()</a>. </dd></dl>

</div>
</div>
<a id="a13980f43fc09f26b5c1f1f75a9645057" name="a13980f43fc09f26b5c1f1f75a9645057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13980f43fc09f26b5c1f1f75a9645057">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a70c1d7a6c78ac664771779d3187452ff" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a70c1d7a6c78ac664771779d3187452ff" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator (to immutable element).">const_newest()</a>. </dd></dl>

</div>
</div>
<a id="a517dfea6a7bb55d5c45ff395bff14869" name="a517dfea6a7bb55d5c45ff395bff14869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517dfea6a7bb55d5c45ff395bff14869">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b8ea38ac5b6fa4476928a80362a3706" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a4b8ea38ac5b6fa4476928a80362a3706" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element).">const_past_oldest()</a>. </dd></dl>

</div>
</div>
<a id="a70c1d7a6c78ac664771779d3187452ff" name="a70c1d7a6c78ac664771779d3187452ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c1d7a6c78ac664771779d3187452ff">&#9670;&nbsp;</a></span>const_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::const_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a13d2d6da14cd0041a21fa786dd9aac3b" name="a13d2d6da14cd0041a21fa786dd9aac3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d2d6da14cd0041a21fa786dd9aac3b">&#9670;&nbsp;</a></span>const_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::const_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a43ec6c068dcd30a5d066afe89e9db6be" name="a43ec6c068dcd30a5d066afe89e9db6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ec6c068dcd30a5d066afe89e9db6be">&#9670;&nbsp;</a></span>const_past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::const_past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a4b8ea38ac5b6fa4476928a80362a3706" name="a4b8ea38ac5b6fa4476928a80362a3706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8ea38ac5b6fa4476928a80362a3706">&#9670;&nbsp;</a></span>const_past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::const_past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a98b576487fa0570ebf2b7533ae219356" name="a98b576487fa0570ebf2b7533ae219356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b576487fa0570ebf2b7533ae219356">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab6de0950504a3bab6289ef2892bbe1ee" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or 1. </dd></dl>

</div>
</div>
<a id="afd64cf1cbd43c658aed4283f079d9366" name="afd64cf1cbd43c658aed4283f079d9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd64cf1cbd43c658aed4283f079d9366">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a13d2d6da14cd0041a21fa786dd9aac3b" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a13d2d6da14cd0041a21fa786dd9aac3b" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </dd></dl>

</div>
</div>
<a id="ad89a3525a1c1b43384191f2ea85125b3" name="ad89a3525a1c1b43384191f2ea85125b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89a3525a1c1b43384191f2ea85125b3">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a6ad8d53b4c62d3982b6eb202315ed2aa">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a43ec6c068dcd30a5d066afe89e9db6be" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a43ec6c068dcd30a5d066afe89e9db6be" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element).">const_past_newest()</a>. </dd></dl>

</div>
</div>
<a id="a1fbcb5f6a387904e11c413aa60539365" name="a1fbcb5f6a387904e11c413aa60539365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbcb5f6a387904e11c413aa60539365">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if container is empty. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="adda0d15fe8206d32043c14365cfa72c8" name="adda0d15fe8206d32043c14365cfa72c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda0d15fe8206d32043c14365cfa72c8">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a896d5a459c22e2f7e043d89c9259d411" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a896d5a459c22e2f7e043d89c9259d411" title="Returns one past last, a/k/a &quot;oldest,&quot; element&#39;s iterator (to immutable element, due to nature of thi...">past_oldest()</a>. </dd></dl>

</div>
</div>
<a id="a3d8fe29c23e6580d4d2a7d14c991d223" name="a3d8fe29c23e6580d4d2a7d14c991d223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8fe29c23e6580d4d2a7d14c991d223">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element pointed to by the given valid iterator. </p>
<p >Behavior undefined if it is not valid. <code>it</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator of element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator one position past (i.e., "older") than <code>it</code>, before <code>*it</code> was removed. </dd></dl>

</div>
</div>
<a id="a7f40a62a9e05dc4eb025a789f8e45e04" name="a7f40a62a9e05dc4eb025a789f8e45e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f40a62a9e05dc4eb025a789f8e45e04">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_newest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_past_oldest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>). </p>
<p >Behavior undefined if a given iterator is invalid, or if the range is invalid. Corner case: an empty range is allowed; then this no-ops. Unless no-op, <code>it_newest</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it_newest</td><td>Iterator of first ("newest") element to erase. </td></tr>
    <tr><td class="paramname">it_past_oldest</td><td>Iterator of one past last ("oldest") element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>it_past_oldest</code> copy. </dd></dl>

</div>
</div>
<a id="a7d0d815747d40adce6e5c5ba865852f1" name="a7d0d815747d40adce6e5c5ba865852f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0d815747d40adce6e5c5ba865852f1">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element with the given key, if it exists. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it existed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key such that its equal's (if found) element will be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased (0 or 1). </dd></dl>

</div>
</div>
<a id="ab6de0950504a3bab6289ef2892bbe1ee" name="ab6de0950504a3bab6289ef2892bbe1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6de0950504a3bab6289ef2892bbe1ee">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find value at the given key in the map. </p>
<p >Key presence is determined identically to how it would be done in an <code>unordered_set&lt;Key_t, Hash_t, Pred_t&gt;</code>, with the particular <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab0bdba2ace4f562fa761bb8cad8125c2" title="Convenience alias for template arg.">Hash</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1573c437d154124653f1878f45ac462a" title="Convenience alias for template arg.">Pred</a> instances given to ctor (typically their default-cted instances, typically occupying no memory).</p>
<p >The returned iterator (if valid) <em>cannot</em> be used to mutate the key inside the map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#adda0d15fe8206d32043c14365cfa72c8" title="Synonym of past_oldest().">end()</a></code>. </dd></dl>

</div>
</div>
<a id="a3553fc2a52e6d2a265c7c05a5489d8a4" name="a3553fc2a52e6d2a265c7c05a5489d8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3553fc2a52e6d2a265c7c05a5489d8a4">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a>, bool &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert (copying it) the given keyinto the map; if key already in <code>*this</code> makes no change. </p>
<p >See also the overload which can avoid a copy and destructively move the key instead.</p>
<p >Return value indicates various info of interest about what occurred or did not occur. If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a68510d5492d94311c4a427c665b7c306" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected (use <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a68510d5492d94311c4a427c665b7c306" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> upon consulting the return value, if this is desirable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to attempt to insert. A copy of this value is placed in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair whose second element is true if and only if the insertion occurred; and whose first element is an iterator pointing to either the newly inserted element or already present one with a key equal to <code>key</code>. </dd></dl>

</div>
</div>
<a id="a4b234c28dc3647005b85655a6e25fe9f" name="a4b234c28dc3647005b85655a6e25fe9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b234c28dc3647005b85655a6e25fe9f">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a>, bool &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to attempt to insert (it is moved-from, if insertion occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other overload. </dd></dl>

</div>
</div>
<a id="aaa38e11188ee81d15fa8b66910af70f4" name="aaa38e11188ee81d15fa8b66910af70f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa38e11188ee81d15fa8b66910af70f4">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max number of elements that can be stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code> + <code>list&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="abd14cba1fe3c5fdaba7b5e0f1a10e9ed" name="abd14cba1fe3c5fdaba7b5e0f1a10e9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd14cba1fe3c5fdaba7b5e0f1a10e9ed">&#9670;&nbsp;</a></span>newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a7bcf78a144e0891917ff00f1c4da87e8" name="a7bcf78a144e0891917ff00f1c4da87e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcf78a144e0891917ff00f1c4da87e8">&#9670;&nbsp;</a></span>oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a3ef57d99d28c0bb33e5af0fd2a6708d3" name="a3ef57d99d28c0bb33e5af0fd2a6708d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef57d99d28c0bb33e5af0fd2a6708d3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object with a copy of the given source. </p>
<p >We become equal to <code>src</code> but independent of it to a common-sense extent. In addition, the hasher instance and equality predicate are copied from <code>src</code>. Finally, a reasonable attempt is made to also make the internal structure of the hash map to be similar to that of `src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. No-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a16960d867315b173fff1c0bf4336f94c" name="a16960d867315b173fff1c0bf4336f94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16960d867315b173fff1c0bf4336f94c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted. </p>
<p >This is a constant-time operation, plus whatever is the cost of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1ef8bdeefef5cd79dac28b6a4098f149" title="Makes it so that size() == 0.">clear()</a></code> (linear in pre-op <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a494cbbb586ceb41455f3c1e830a969c1" title="Returns number of elements stored.">size()</a></code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied; except no-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="aec39f63e21309c3494c26c5ac7989ebe" name="aec39f63e21309c3494c26c5ac7989ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec39f63e21309c3494c26c5ac7989ebe">&#9670;&nbsp;</a></span>past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a896d5a459c22e2f7e043d89c9259d411" name="a896d5a459c22e2f7e043d89c9259d411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896d5a459c22e2f7e043d89c9259d411">&#9670;&nbsp;</a></span>past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a8ee77d3405116b26e39f70ef8b44697b">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "oldest," element's iterator (to immutable element, due to nature of this type). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a4b8e03420e3482a575b5a6a0485df9c5" name="a4b8e03420e3482a575b5a6a0485df9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8e03420e3482a575b5a6a0485df9c5">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7bcf78a144e0891917ff00f1c4da87e8" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a7bcf78a144e0891917ff00f1c4da87e8" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element, due to nature of thi...">oldest()</a>. </dd></dl>

</div>
</div>
<a id="a3536c7369a995db24aa48014a3e2de53" name="a3536c7369a995db24aa48014a3e2de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3536c7369a995db24aa48014a3e2de53">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a1779e07739a1377e7b82d0a36235f56a">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aec39f63e21309c3494c26c5ac7989ebe" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aec39f63e21309c3494c26c5ac7989ebe" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator (to immutable element,...">past_newest()</a>. </dd></dl>

</div>
</div>
<a id="a494cbbb586ceb41455f3c1e830a969c1" name="a494cbbb586ceb41455f3c1e830a969c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494cbbb586ceb41455f3c1e830a969c1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a39922a66be81234c043a5e43647df40b">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;.</code> </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a15f73c0627f8b37f233afa9827af3009" name="a15f73c0627f8b37f233afa9827af3009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f73c0627f8b37f233afa9827af3009">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>. </p>
<p >This is a constant-time operation, as internal representations are swapped instead of any copy-assignment.</p>
<dl class="section see"><dt>See also</dt><dd>The <code><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#a15f73c0627f8b37f233afa9827af3009" title="Swaps the contents of this structure and other.">swap()</a></code> free function. It is generally best (equivalent but covers more generic cases) to use the ADL-enabled <code>swap(a, b)</code> pattern instead of this member function. That is: <code>using std::swap; ...; swap(a, b);</code>. (Details are outside our scope here; but in short ADL will cause the right thing to happen.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68510d5492d94311c4a427c665b7c306" name="a68510d5492d94311c4a427c665b7c306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68510d5492d94311c4a427c665b7c306">&#9670;&nbsp;</a></span>touch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#ab04c9047cc6342a4a07f107b127bfbc1">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order. </p>
<p >Behavior undefined if iterator invalid.</p>
<p >The iterator continues to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to an element of the structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ca0346b07067af7279feea6b2404d6" name="ae3ca0346b07067af7279feea6b2404d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ca0346b07067af7279feea6b2404d6">&#9670;&nbsp;</a></span>touch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">flow::util::Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html#aa3bedf484b3d3bd41b3375f8c8342581">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key was found (even if it was already "newest"); <code>false</code> if not found. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af9236b0fce20cb81abac3a70360db155" name="af9236b0fce20cb81abac3a70360db155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9236b0fce20cb81abac3a70360db155">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__set.html">Linked_hash_set</a>&lt; Key_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>val1.swap(val2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="linked__hash__set_8hpp.html">linked_hash_set.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 15 2026 00:48:59 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
