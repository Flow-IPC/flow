<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Basic_blob&lt; Allocator, S_SHARING_ALLOWED &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Basic__blob-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Basic_blob&lt; Allocator, S_SHARING_ALLOWED &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A hand-optimized and API-tweaked replacement for <code>vector&lt;uint8_t&gt;</code>, i.e., buffer of bytes inside an allocated area of equal or larger size; also optionally supports limited garbage-collected memory pool functionality and SHM-friendly custom-allocator support.  
 <a href="classflow_1_1util_1_1Basic__blob.html#details">More...</a></p>

<p><code>#include &lt;basic_blob.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb9b64885b78263048d406ec34907ecf"><td class="memItemLeft" align="right" valign="top"><a id="aeb9b64885b78263048d406ec34907ecf" name="aeb9b64885b78263048d406ec34907ecf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="el" href="namespaceflow.html#ae02da22c4a101eaab447511c905e4f32">uint8_t</a></td></tr>
<tr class="memdesc:aeb9b64885b78263048d406ec34907ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for values, which in this case are unsigned bytes. <br /></td></tr>
<tr class="separator:aeb9b64885b78263048d406ec34907ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b27f4b460a0fa8a9c9638174a9433a"><td class="memItemLeft" align="right" valign="top"><a id="af9b27f4b460a0fa8a9c9638174a9433a" name="af9b27f4b460a0fa8a9c9638174a9433a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:af9b27f4b460a0fa8a9c9638174a9433a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for index into blob or length of blob or sub-blob. <br /></td></tr>
<tr class="separator:af9b27f4b460a0fa8a9c9638174a9433a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d9cd750d8db928b4d1e045ef15c56"><td class="memItemLeft" align="right" valign="top"><a id="a614d9cd750d8db928b4d1e045ef15c56" name="a614d9cd750d8db928b4d1e045ef15c56"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a614d9cd750d8db928b4d1e045ef15c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s. <br /></td></tr>
<tr class="separator:a614d9cd750d8db928b4d1e045ef15c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b5764b185d0a1a1d143211e39b2de1"><td class="memItemLeft" align="right" valign="top"><a id="a93b5764b185d0a1a1d143211e39b2de1" name="a93b5764b185d0a1a1d143211e39b2de1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> *</td></tr>
<tr class="memdesc:a93b5764b185d0a1a1d143211e39b2de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type. <br /></td></tr>
<tr class="separator:a93b5764b185d0a1a1d143211e39b2de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e21c26d61b50e019987097f7779ed51"><td class="memItemLeft" align="right" valign="top"><a id="a3e21c26d61b50e019987097f7779ed51" name="a3e21c26d61b50e019987097f7779ed51"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_iterator</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> const *</td></tr>
<tr class="memdesc:a3e21c26d61b50e019987097f7779ed51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type. <br /></td></tr>
<tr class="separator:a3e21c26d61b50e019987097f7779ed51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2089286c63766445b3bf40422eb17db"><td class="memItemLeft" align="right" valign="top"><a id="ae2089286c63766445b3bf40422eb17db" name="ae2089286c63766445b3bf40422eb17db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Allocator_raw</b> = Allocator</td></tr>
<tr class="memdesc:ae2089286c63766445b3bf40422eb17db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the allocator type specified at compile-time. Its element type is our <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf" title="Short-hand for values, which in this case are unsigned bytes.">value_type</a>. <br /></td></tr>
<tr class="separator:ae2089286c63766445b3bf40422eb17db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55075d7e257e08058eabf5fe06ee33"><td class="memItemLeft" align="right" valign="top"><a id="adc55075d7e257e08058eabf5fe06ee33" name="adc55075d7e257e08058eabf5fe06ee33"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a></td></tr>
<tr class="memdesc:adc55075d7e257e08058eabf5fe06ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to element. <br /></td></tr>
<tr class="separator:adc55075d7e257e08058eabf5fe06ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73d1c26268670495dda161f95d33ec1"><td class="memItemLeft" align="right" valign="top"><a id="ab73d1c26268670495dda161f95d33ec1" name="ab73d1c26268670495dda161f95d33ec1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a></td></tr>
<tr class="memdesc:ab73d1c26268670495dda161f95d33ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const</code> element. <br /></td></tr>
<tr class="separator:ab73d1c26268670495dda161f95d33ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b010e5051889dd4732facb0b0d2e12"><td class="memItemLeft" align="right" valign="top"><a id="a72b010e5051889dd4732facb0b0d2e12" name="a72b010e5051889dd4732facb0b0d2e12"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;</td></tr>
<tr class="memdesc:a72b010e5051889dd4732facb0b0d2e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to element. <br /></td></tr>
<tr class="separator:a72b010e5051889dd4732facb0b0d2e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a94572c51f89991987ca9f5bcf2b2"><td class="memItemLeft" align="right" valign="top"><a id="a8b5a94572c51f89991987ca9f5bcf2b2" name="a8b5a94572c51f89991987ca9f5bcf2b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;</td></tr>
<tr class="memdesc:a8b5a94572c51f89991987ca9f5bcf2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const</code> element. <br /></td></tr>
<tr class="separator:a8b5a94572c51f89991987ca9f5bcf2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5feeeb171724712ace3ec667fc0a3e2"><td class="memItemLeft" align="right" valign="top"><a id="ae5feeeb171724712ace3ec667fc0a3e2" name="ae5feeeb171724712ace3ec667fc0a3e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a></td></tr>
<tr class="memdesc:ae5feeeb171724712ace3ec667fc0a3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type. <br /></td></tr>
<tr class="separator:ae5feeeb171724712ace3ec667fc0a3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527a63b2de0a165bb63296935aee954c"><td class="memItemLeft" align="right" valign="top"><a id="a527a63b2de0a165bb63296935aee954c" name="a527a63b2de0a165bb63296935aee954c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a></td></tr>
<tr class="memdesc:a527a63b2de0a165bb63296935aee954c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type. <br /></td></tr>
<tr class="separator:a527a63b2de0a165bb63296935aee954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8c99e64b04da1420005c984879290ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae8c99e64b04da1420005c984879290ce">Basic_blob</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a> &amp;alloc_raw=<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>())</td></tr>
<tr class="memdesc:ae8c99e64b04da1420005c984879290ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs blob with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#ae8c99e64b04da1420005c984879290ce">More...</a><br /></td></tr>
<tr class="separator:ae8c99e64b04da1420005c984879290ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d658402197aeda90c4b813e50b5f4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a77d658402197aeda90c4b813e50b5f4c">Basic_blob</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0, const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a> &amp;alloc_raw=<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>())</td></tr>
<tr class="memdesc:a77d658402197aeda90c4b813e50b5f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs blob with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> equal to the given <code>size</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a77d658402197aeda90c4b813e50b5f4c">More...</a><br /></td></tr>
<tr class="separator:a77d658402197aeda90c4b813e50b5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f88c8e8ca1cbd618d0cafff0cf663"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a0b2f88c8e8ca1cbd618d0cafff0cf663">Basic_blob</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a0b2f88c8e8ca1cbd618d0cafff0cf663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor, constructing a blob exactly internally equal to pre-call <code>moved_src</code>, while the latter is made to be exactly as if it were just constructed as <code>Basic_blob(nullptr)</code> (allocator subtleties aside).  <a href="classflow_1_1util_1_1Basic__blob.html#a0b2f88c8e8ca1cbd618d0cafff0cf663">More...</a><br /></td></tr>
<tr class="separator:a0b2f88c8e8ca1cbd618d0cafff0cf663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feb29f4d1045490e8497ec067f8a70b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7feb29f4d1045490e8497ec067f8a70b">Basic_blob</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a7feb29f4d1045490e8497ec067f8a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, constructing a blob logically equal to <code>src</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a7feb29f4d1045490e8497ec067f8a70b">More...</a><br /></td></tr>
<tr class="separator:a7feb29f4d1045490e8497ec067f8a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc395523fae83128888d9bb1c90726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae9fc395523fae83128888d9bb1c90726">~Basic_blob</a> ()</td></tr>
<tr class="memdesc:ae9fc395523fae83128888d9bb1c90726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that drops <code>*this</code> ownership of the allocated internal buffer if any, as by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also.  <a href="classflow_1_1util_1_1Basic__blob.html#ae9fc395523fae83128888d9bb1c90726">More...</a><br /></td></tr>
<tr class="separator:ae9fc395523fae83128888d9bb1c90726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b07b9b83929cfb35f80f13ce416ec4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b">assign</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a3b07b9b83929cfb35f80f13ce416ec4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b">More...</a><br /></td></tr>
<tr class="separator:a3b07b9b83929cfb35f80f13ce416ec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151d35b3c35219089d53061503841b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a151d35b3c35219089d53061503841b75">operator=</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&amp;moved_src)</td></tr>
<tr class="memdesc:a151d35b3c35219089d53061503841b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator (no logging): equivalent to <code>assign(std::move(moved_src), nullptr)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a151d35b3c35219089d53061503841b75">More...</a><br /></td></tr>
<tr class="separator:a151d35b3c35219089d53061503841b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7d10ef9bb9c1c449def462eb9b2c01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#afd7d10ef9bb9c1c449def462eb9b2c01">assign</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:afd7d10ef9bb9c1c449def462eb9b2c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment: assuming <code>(this != &amp;src) &amp;&amp; (!blobs_sharing(*this, src))</code>, makes <code>*this</code> logically equal to <code>src</code>; but behavior undefined if a reallocation would be necessary to do this.  <a href="classflow_1_1util_1_1Basic__blob.html#afd7d10ef9bb9c1c449def462eb9b2c01">More...</a><br /></td></tr>
<tr class="separator:afd7d10ef9bb9c1c449def462eb9b2c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eda661d71306c2fbd0422993922309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a72eda661d71306c2fbd0422993922309">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;src)</td></tr>
<tr class="memdesc:a72eda661d71306c2fbd0422993922309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (no logging): equivalent to <code>assign(src, nullptr)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a72eda661d71306c2fbd0422993922309">More...</a><br /></td></tr>
<tr class="separator:a72eda661d71306c2fbd0422993922309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835d127753a70d8c397a1a6153cab78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a835d127753a70d8c397a1a6153cab78d">swap</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> &amp;other, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a835d127753a70d8c397a1a6153cab78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>, or no-op if <code>this == &amp;other</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a835d127753a70d8c397a1a6153cab78d">More...</a><br /></td></tr>
<tr class="separator:a835d127753a70d8c397a1a6153cab78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1f09551d36d058c16d505c76a1780a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a">share</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0) const</td></tr>
<tr class="memdesc:a6d1f09551d36d058c16d505c76a1780a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to <code>!zero()</code> blobs, this returns an identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it.  <a href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a">More...</a><br /></td></tr>
<tr class="separator:a6d1f09551d36d058c16d505c76a1780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6fd467f8ac364edf13915713e36969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969">share_after_split_left</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a3e6fd467f8ac364edf13915713e36969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicable to <code>!zero()</code> blobs, this shifts <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> by <code>size</code> to the right without changing <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; and returns a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> containing the shifted-past values that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it.  <a href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969">More...</a><br /></td></tr>
<tr class="separator:a3e6fd467f8ac364edf13915713e36969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc565dcada148095cb14863387d5696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aacc565dcada148095cb14863387d5696">share_after_split_right</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:aacc565dcada148095cb14863387d5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>, except <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> shifts by <code>size</code> to the left (instead of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> to the right), and the split-off <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> contains the *right-most*</code>size` elements (instead of the left-most).  <a href="classflow_1_1util_1_1Basic__blob.html#aacc565dcada148095cb14863387d5696">More...</a><br /></td></tr>
<tr class="separator:aacc565dcada148095cb14863387d5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab9186e23dd171d7ce84514a80c9d5"><td class="memTemplParams" colspan="2">template&lt;typename Emit_blob_func &gt; </td></tr>
<tr class="memitem:adaab9186e23dd171d7ce84514a80c9d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5">share_after_split_equally</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, bool headless_pool, Emit_blob_func &amp;&amp;emit_blob_func, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:adaab9186e23dd171d7ce84514a80c9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to successively performing <code>share_after_split_left(size)</code> until <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code>; the resultings <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s are emitted via <code>emit_blob_func()</code> callback in the order they're split off from the left.  <a href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5">More...</a><br /></td></tr>
<tr class="separator:adaab9186e23dd171d7ce84514a80c9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae515e3769cc901b75789713636a1688e"><td class="memTemplParams" colspan="2">template&lt;typename Blob_container &gt; </td></tr>
<tr class="memitem:ae515e3769cc901b75789713636a1688e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae515e3769cc901b75789713636a1688e">share_after_split_equally_emit_seq</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, bool headless_pool, Blob_container *out_blobs, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:ae515e3769cc901b75789713636a1688e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s into the given container via <code>push_back()</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#ae515e3769cc901b75789713636a1688e">More...</a><br /></td></tr>
<tr class="separator:ae515e3769cc901b75789713636a1688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918dd61f8b24ebfb8b3aba5920b1d13f"><td class="memTemplParams" colspan="2">template&lt;typename Blob_ptr_container &gt; </td></tr>
<tr class="memitem:a918dd61f8b24ebfb8b3aba5920b1d13f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a918dd61f8b24ebfb8b3aba5920b1d13f">share_after_split_equally_emit_ptr_seq</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, bool headless_pool, Blob_ptr_container *out_blobs, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a918dd61f8b24ebfb8b3aba5920b1d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code>Ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>s into the given container via <code>push_back()</code>, where the type <code>Ptr&lt;&gt;</code> is determined via <code>Blob_ptr_container::value_type</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a918dd61f8b24ebfb8b3aba5920b1d13f">More...</a><br /></td></tr>
<tr class="separator:a918dd61f8b24ebfb8b3aba5920b1d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa2763f88c61a57f52133dc22223cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3fa2763f88c61a57f52133dc22223cef">assign_copy</a> (const boost::asio::const_buffer &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a3fa2763f88c61a57f52133dc22223cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces logical contents with a copy of the given non-overlapping area anywhere in memory.  <a href="classflow_1_1util_1_1Basic__blob.html#a3fa2763f88c61a57f52133dc22223cef">More...</a><br /></td></tr>
<tr class="separator:a3fa2763f88c61a57f52133dc22223cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d154ee5afaee08a62397174f9f7a879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3d154ee5afaee08a62397174f9f7a879">emplace_copy</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> dest, const boost::asio::const_buffer &amp;src, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a3d154ee5afaee08a62397174f9f7a879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>src</code> buffer directly onto equally sized area within <code>*this</code> at location <code>dest</code>; <code>*this</code> must have sufficient <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> to accomodate all of the data copied.  <a href="classflow_1_1util_1_1Basic__blob.html#a3d154ee5afaee08a62397174f9f7a879">More...</a><br /></td></tr>
<tr class="separator:a3d154ee5afaee08a62397174f9f7a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac24a23b94cd10a4dd6088d3e3f2fe2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aac24a23b94cd10a4dd6088d3e3f2fe2f">sub_copy</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> src, const boost::asio::mutable_buffer &amp;dest, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0) const</td></tr>
<tr class="memdesc:aac24a23b94cd10a4dd6088d3e3f2fe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opposite of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3d154ee5afaee08a62397174f9f7a879" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> in every way, copying a sub-blob onto a target memory area.  <a href="classflow_1_1util_1_1Basic__blob.html#aac24a23b94cd10a4dd6088d3e3f2fe2f">More...</a><br /></td></tr>
<tr class="separator:aac24a23b94cd10a4dd6088d3e3f2fe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c04d217b83800f818c794da17dc8e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a> () const</td></tr>
<tr class="memdesc:a8c04d217b83800f818c794da17dc8e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored, namely <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">More...</a><br /></td></tr>
<tr class="separator:a8c04d217b83800f818c794da17dc8e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea173065830ef1a744458a7d05b833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833">start</a> () const</td></tr>
<tr class="memdesc:a64ea173065830ef1a744458a7d05b833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset between <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> and the start of the internally allocated buffer.  <a href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833">More...</a><br /></td></tr>
<tr class="separator:a64ea173065830ef1a744458a7d05b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797741a0a5c95b13b36f356ae8d397e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8">empty</a> () const</td></tr>
<tr class="memdesc:a797741a0a5c95b13b36f356ae8d397e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8">More...</a><br /></td></tr>
<tr class="separator:a797741a0a5c95b13b36f356ae8d397e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e5c04e4bdc65c31976fc385fd7f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24">capacity</a> () const</td></tr>
<tr class="memdesc:a719e5c04e4bdc65c31976fc385fd7f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buffer is internally allocated.  <a href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24">More...</a><br /></td></tr>
<tr class="separator:a719e5c04e4bdc65c31976fc385fd7f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a64646d656ec125fa8973ccf843c1be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be">zero</a> () const</td></tr>
<tr class="memdesc:a1a64646d656ec125fa8973ccf843c1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if a buffer is allocated and owned; <code>true</code> otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be">More...</a><br /></td></tr>
<tr class="separator:a1a64646d656ec125fa8973ccf843c1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328b40fe431698b38b48b66397664d1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f">reserve</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24">capacity</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a328b40fe431698b38b48b66397664d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that an internal buffer of at least <code>capacity</code> elements is allocated and owned; disallows growing an existing buffer; never shrinks an existing buffer; if a buffer is allocated, it is no larger than <code>capacity</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f">More...</a><br /></td></tr>
<tr class="separator:a328b40fe431698b38b48b66397664d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af431f32bde5ed1ba255e3e1cbbcbd906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906">make_zero</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:af431f32bde5ed1ba255e3e1cbbcbd906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> by dropping <code>*this</code> ownership of the allocated internal buffer if any; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also.  <a href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906">More...</a><br /></td></tr>
<tr class="separator:af431f32bde5ed1ba255e3e1cbbcbd906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2342b475fa8f2a67a9bb2cd1ba2c1b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43">resize</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> start_or_unchanged=<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7667397ae554e4a9dcb9a3bf1bf33eb8">S_UNCHANGED</a>, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a2342b475fa8f2a67a9bb2cd1ba2c1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == size</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == start</code>; no values in pre-call range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> are changed; any values <em>added</em> to that range by the call are not initialized to zero or otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43">More...</a><br /></td></tr>
<tr class="separator:a2342b475fa8f2a67a9bb2cd1ba2c1b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98832169c8e46d84f6c06987a3670e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3">start_past_prefix</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> prefix_size)</td></tr>
<tr class="memdesc:af98832169c8e46d84f6c06987a3670e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restructures blob to consist of an internally allocated buffer and a <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, end)</code> range starting at offset <code>prefix_size</code> within that buffer.  <a href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3">More...</a><br /></td></tr>
<tr class="separator:af98832169c8e46d84f6c06987a3670e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3497d662be650e7a560eb7a703acc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c3497d662be650e7a560eb7a703acc1">start_past_prefix_inc</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a614d9cd750d8db928b4d1e045ef15c56">difference_type</a> prefix_size_inc)</td></tr>
<tr class="memdesc:a9c3497d662be650e7a560eb7a703acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3" title="Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...">start_past_prefix()</a> but shifts the <em>current</em> prefix position by the given <em>incremental</em> value (positive or negative).  <a href="classflow_1_1util_1_1Basic__blob.html#a9c3497d662be650e7a560eb7a703acc1">More...</a><br /></td></tr>
<tr class="separator:a9c3497d662be650e7a560eb7a703acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62da4400fbde6c186fb989f55248e3d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a62da4400fbde6c186fb989f55248e3d2">clear</a> ()</td></tr>
<tr class="memdesc:a62da4400fbde6c186fb989f55248e3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>resize(0, start())</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a62da4400fbde6c186fb989f55248e3d2">More...</a><br /></td></tr>
<tr class="separator:a62da4400fbde6c186fb989f55248e3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49046a070b040ca17ca9062ac291a6dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a49046a070b040ca17ca9062ac291a6dd">erase</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> first, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> past_last)</td></tr>
<tr class="memdesc:a49046a070b040ca17ca9062ac291a6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the minimal number of operations to make range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> unchanged except for lacking sub-range <code>[first, past_last)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a49046a070b040ca17ca9062ac291a6dd">More...</a><br /></td></tr>
<tr class="separator:a49046a070b040ca17ca9062ac291a6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa427a42c8a8c24b585f96c37d277a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a">begin</a> ()</td></tr>
<tr class="memdesc:a9daa427a42c8a8c24b585f96c37d277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to mutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a">More...</a><br /></td></tr>
<tr class="separator:a9daa427a42c8a8c24b585f96c37d277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511ddaa3fb453888524cedba39c36ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef">const_begin</a> () const</td></tr>
<tr class="memdesc:ac511ddaa3fb453888524cedba39c36ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to immutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef">More...</a><br /></td></tr>
<tr class="separator:ac511ddaa3fb453888524cedba39c36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfd46fca324a6b80934b9230c2f2bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1dfd46fca324a6b80934b9230c2f2bb4">begin</a> () const</td></tr>
<tr class="memdesc:a1dfd46fca324a6b80934b9230c2f2bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a1dfd46fca324a6b80934b9230c2f2bb4">More...</a><br /></td></tr>
<tr class="separator:a1dfd46fca324a6b80934b9230c2f2bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61880291749335246f60fde4387f7ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6">end</a> ()</td></tr>
<tr class="memdesc:a61880291749335246f60fde4387f7ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer one past mutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> is possible.  <a href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6">More...</a><br /></td></tr>
<tr class="separator:a61880291749335246f60fde4387f7ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f1d8c42aea63ba4f127cb7ed5776d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6">const_end</a> () const</td></tr>
<tr class="memdesc:ae4f1d8c42aea63ba4f127cb7ed5776d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer one past immutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> is possible.  <a href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6">More...</a><br /></td></tr>
<tr class="separator:ae4f1d8c42aea63ba4f127cb7ed5776d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b61c80d3df1c53583362ec15cdbb0b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9b61c80d3df1c53583362ec15cdbb0b6">end</a> () const</td></tr>
<tr class="memdesc:a9b61c80d3df1c53583362ec15cdbb0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a9b61c80d3df1c53583362ec15cdbb0b6">More...</a><br /></td></tr>
<tr class="separator:a9b61c80d3df1c53583362ec15cdbb0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90859b0e130bef705a2e556ccb27df53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a90859b0e130bef705a2e556ccb27df53">const_front</a> () const</td></tr>
<tr class="memdesc:a90859b0e130bef705a2e556ccb27df53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable first element.  <a href="classflow_1_1util_1_1Basic__blob.html#a90859b0e130bef705a2e556ccb27df53">More...</a><br /></td></tr>
<tr class="separator:a90859b0e130bef705a2e556ccb27df53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c99b053ce77cd0573d882e194908e49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c99b053ce77cd0573d882e194908e49">const_back</a> () const</td></tr>
<tr class="memdesc:a7c99b053ce77cd0573d882e194908e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable last element.  <a href="classflow_1_1util_1_1Basic__blob.html#a7c99b053ce77cd0573d882e194908e49">More...</a><br /></td></tr>
<tr class="separator:a7c99b053ce77cd0573d882e194908e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a489088e29d5d4b82b0498c8e210f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a98a489088e29d5d4b82b0498c8e210f8">front</a> () const</td></tr>
<tr class="memdesc:a98a489088e29d5d4b82b0498c8e210f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a90859b0e130bef705a2e556ccb27df53" title="Returns reference to immutable first element.">const_front()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a98a489088e29d5d4b82b0498c8e210f8">More...</a><br /></td></tr>
<tr class="separator:a98a489088e29d5d4b82b0498c8e210f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10980e7748d8198fe831666254d864d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac10980e7748d8198fe831666254d864d">back</a> () const</td></tr>
<tr class="memdesc:ac10980e7748d8198fe831666254d864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c99b053ce77cd0573d882e194908e49" title="Returns reference to immutable last element.">const_back()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#ac10980e7748d8198fe831666254d864d">More...</a><br /></td></tr>
<tr class="separator:ac10980e7748d8198fe831666254d864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ea8c6aa0a7b043129fca8eacaedad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#abe7ea8c6aa0a7b043129fca8eacaedad">front</a> ()</td></tr>
<tr class="memdesc:abe7ea8c6aa0a7b043129fca8eacaedad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable first element.  <a href="classflow_1_1util_1_1Basic__blob.html#abe7ea8c6aa0a7b043129fca8eacaedad">More...</a><br /></td></tr>
<tr class="separator:abe7ea8c6aa0a7b043129fca8eacaedad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d05eed39be69ceec235fe3403b16b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a49d05eed39be69ceec235fe3403b16b9">back</a> ()</td></tr>
<tr class="memdesc:a49d05eed39be69ceec235fe3403b16b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to mutable last element.  <a href="classflow_1_1util_1_1Basic__blob.html#a49d05eed39be69ceec235fe3403b16b9">More...</a><br /></td></tr>
<tr class="separator:a49d05eed39be69ceec235fe3403b16b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4c0a1e530596982a3b5d3e0ff91e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a75d4c0a1e530596982a3b5d3e0ff91e6">const_data</a> () const</td></tr>
<tr class="memdesc:a75d4c0a1e530596982a3b5d3e0ff91e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a75d4c0a1e530596982a3b5d3e0ff91e6">More...</a><br /></td></tr>
<tr class="separator:a75d4c0a1e530596982a3b5d3e0ff91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581e779dace3d64fe4098eb0a7dbeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4581e779dace3d64fe4098eb0a7dbeb2">data</a> ()</td></tr>
<tr class="memdesc:a4581e779dace3d64fe4098eb0a7dbeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a4581e779dace3d64fe4098eb0a7dbeb2">More...</a><br /></td></tr>
<tr class="separator:a4581e779dace3d64fe4098eb0a7dbeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669252f9a78f516dfeaf964987078255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a669252f9a78f516dfeaf964987078255">cbegin</a> () const</td></tr>
<tr class="memdesc:a669252f9a78f516dfeaf964987078255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#a669252f9a78f516dfeaf964987078255">More...</a><br /></td></tr>
<tr class="separator:a669252f9a78f516dfeaf964987078255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9e80920dcc3d51c229db98a9d62ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ada9e80920dcc3d51c229db98a9d62ac6">cend</a> () const</td></tr>
<tr class="memdesc:ada9e80920dcc3d51c229db98a9d62ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>.  <a href="classflow_1_1util_1_1Basic__blob.html#ada9e80920dcc3d51c229db98a9d62ac6">More...</a><br /></td></tr>
<tr class="separator:ada9e80920dcc3d51c229db98a9d62ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e09b11e0067730db64f1fac7620a04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a73e09b11e0067730db64f1fac7620a04">valid_iterator</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> it) const</td></tr>
<tr class="memdesc:a73e09b11e0067730db64f1fac7620a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if: <code>this-&gt;derefable_iterator(it) || (it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a73e09b11e0067730db64f1fac7620a04">More...</a><br /></td></tr>
<tr class="separator:a73e09b11e0067730db64f1fac7620a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198eb271d009f153cae041ba1948e945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a198eb271d009f153cae041ba1948e945">derefable_iterator</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a> it) const</td></tr>
<tr class="memdesc:a198eb271d009f153cae041ba1948e945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the given iterator points to an element within this blob's <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> elements.  <a href="classflow_1_1util_1_1Basic__blob.html#a198eb271d009f153cae041ba1948e945">More...</a><br /></td></tr>
<tr class="separator:a198eb271d009f153cae041ba1948e945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb4e2420be2f8ca0dc8c4fb70feb8ea"><td class="memItemLeft" align="right" valign="top">boost::asio::const_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#afbb4e2420be2f8ca0dc8c4fb70feb8ea">const_buffer</a> () const</td></tr>
<tr class="memdesc:afbb4e2420be2f8ca0dc8c4fb70feb8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience accessor returning an immutable boost.asio buffer "view" into the entirety of the blob.  <a href="classflow_1_1util_1_1Basic__blob.html#afbb4e2420be2f8ca0dc8c4fb70feb8ea">More...</a><br /></td></tr>
<tr class="separator:afbb4e2420be2f8ca0dc8c4fb70feb8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd3cb0b6b3f304fb6fb771c1b76ec66"><td class="memItemLeft" align="right" valign="top">boost::asio::mutable_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2bd3cb0b6b3f304fb6fb771c1b76ec66">mutable_buffer</a> ()</td></tr>
<tr class="memdesc:a2bd3cb0b6b3f304fb6fb771c1b76ec66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Basic__blob.html#afbb4e2420be2f8ca0dc8c4fb70feb8ea" title="Convenience accessor returning an immutable boost.asio buffer &quot;view&quot; into the entirety of the blob.">const_buffer()</a> but the returned view is mutable.  <a href="classflow_1_1util_1_1Basic__blob.html#a2bd3cb0b6b3f304fb6fb771c1b76ec66">More...</a><br /></td></tr>
<tr class="separator:a2bd3cb0b6b3f304fb6fb771c1b76ec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32359d0bd98f378c7397a7c86e6e66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af32359d0bd98f378c7397a7c86e6e66d">get_allocator</a> () const</td></tr>
<tr class="memdesc:af32359d0bd98f378c7397a7c86e6e66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the internally cached <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> as set by a constructor or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b" title="Move assignment.">assign()</a> or assignment-operator, whichever happened last.  <a href="classflow_1_1util_1_1Basic__blob.html#af32359d0bd98f378c7397a7c86e6e66d">More...</a><br /></td></tr>
<tr class="separator:af32359d0bd98f378c7397a7c86e6e66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a67db182946127383fb48d6a1afbdca90"><td class="memItemLeft" align="right" valign="top"><a id="a67db182946127383fb48d6a1afbdca90" name="a67db182946127383fb48d6a1afbdca90"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_SHARING</b> = S_SHARING_ALLOWED</td></tr>
<tr class="memdesc:a67db182946127383fb48d6a1afbdca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of template parameter <code>S_SHARING_ALLOWED</code> (for generic programming). <br /></td></tr>
<tr class="separator:a67db182946127383fb48d6a1afbdca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7667397ae554e4a9dcb9a3bf1bf33eb8"><td class="memItemLeft" align="right" valign="top"><a id="a7667397ae554e4a9dcb9a3bf1bf33eb8" name="a7667397ae554e4a9dcb9a3bf1bf33eb8"></a>
static constexpr <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_UNCHANGED</b> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>(-1)</td></tr>
<tr class="memdesc:a7667397ae554e4a9dcb9a3bf1bf33eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value indicating an unchanged <code>size_type</code> value; such as in <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>. <br /></td></tr>
<tr class="separator:a7667397ae554e4a9dcb9a3bf1bf33eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79d366c55643022eaf9e0d7378165d7"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab79d366c55643022eaf9e0d7378165d7">S_IS_VANILLA_ALLOC</a> = std::is_same_v&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>, std::allocator&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a>&gt;&gt;</td></tr>
<tr class="memdesc:ab79d366c55643022eaf9e0d7378165d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> underlying allocator template is simply <code>std::allocator</code>; <code>false</code> otherwise.  <a href="classflow_1_1util_1_1Basic__blob.html#ab79d366c55643022eaf9e0d7378165d7">More...</a><br /></td></tr>
<tr class="separator:ab79d366c55643022eaf9e0d7378165d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a92215c61d9e3ca83bdbfa6b078b72dc9"><td class="memTemplParams" colspan="2">template&lt;typename Emit_blob_func , typename Share_after_split_left_func &gt; </td></tr>
<tr class="memitem:a92215c61d9e3ca83bdbfa6b078b72dc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a92215c61d9e3ca83bdbfa6b078b72dc9">share_after_split_equally_impl</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b">size</a>, bool headless_pool, Emit_blob_func &amp;&amp;emit_blob_func, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, Share_after_split_left_func &amp;&amp;share_after_split_left_func)</td></tr>
<tr class="memdesc:a92215c61d9e3ca83bdbfa6b078b72dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> but capable of emitting not just <code>*this</code> type (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;...&gt;</code>) but any sub-class (such as <code>Blob</code>/<code>Sharing_blob</code>) provided a functor like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning an object of that appropriate type.  <a href="classflow_1_1util_1_1Basic__blob.html#a92215c61d9e3ca83bdbfa6b078b72dc9">More...</a><br /></td></tr>
<tr class="separator:a92215c61d9e3ca83bdbfa6b078b72dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ad65bfdec2d39f4ccce6c311226b78c5b"><td class="memItemLeft" align="right" valign="top"><a id="ad65bfdec2d39f4ccce6c311226b78c5b" name="ad65bfdec2d39f4ccce6c311226b78c5b"></a>
static constexpr <a class="el" href="namespaceflow.html#a3938730ab4b89daf13d027a5f620e7ce">Flow_log_component</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_LOG_COMPONENT</b> = Flow_log_component::S_UTIL</td></tr>
<tr class="memdesc:ad65bfdec2d39f4ccce6c311226b78c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">flow::log::Component</a>. <br /></td></tr>
<tr class="separator:ad65bfdec2d39f4ccce6c311226b78c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af567381736851969f6e8812c54404028"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </td></tr>
<tr class="memitem:af567381736851969f6e8812c54404028"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af567381736851969f6e8812c54404028">blobs_sharing</a> (const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;blob1, const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;blob2)</td></tr>
<tr class="memdesc:af567381736851969f6e8812c54404028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if both given objects are not <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, and they either co-own a common underlying buffer, or <em>are</em> the same object.  <a href="classflow_1_1util_1_1Basic__blob.html#af567381736851969f6e8812c54404028">More...</a><br /></td></tr>
<tr class="separator:af567381736851969f6e8812c54404028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eaa4ab6a2673ed34fa8989c47a7bc0"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </td></tr>
<tr class="memitem:a71eaa4ab6a2673ed34fa8989c47a7bc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a71eaa4ab6a2673ed34fa8989c47a7bc0">swap</a> (<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;blob1, <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;blob2, <a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr=0)</td></tr>
<tr class="memdesc:a71eaa4ab6a2673ed34fa8989c47a7bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>blob1.swap(blob2)</code>.  <a href="classflow_1_1util_1_1Basic__blob.html#a71eaa4ab6a2673ed34fa8989c47a7bc0">More...</a><br /></td></tr>
<tr class="separator:a71eaa4ab6a2673ed34fa8989c47a7bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Allocator, bool S_SHARING_ALLOWED&gt;<br />
class flow::util::Basic_blob&lt; Allocator, S_SHARING_ALLOWED &gt;</div><p >A hand-optimized and API-tweaked replacement for <code>vector&lt;uint8_t&gt;</code>, i.e., buffer of bytes inside an allocated area of equal or larger size; also optionally supports limited garbage-collected memory pool functionality and SHM-friendly custom-allocator support. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Blob__with__log__context.html" title="Basic_blob that works in regular heap (and is itself placed in heap or stack) and memorizes a log::Lo...">Blob_with_log_context</a> (and especially aliases <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a> and <a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>), our non-polymorphic sub-class which adds some ease of use in exchange for a small <a class="el" href="namespaceflow_1_1perf.html" title="Flow module containing tools for profiling and optimization.">perf</a> trade-off. (More info below under "Logging.") </dd>
<dd>
<a class="el" href="namespaceflow_1_1util.html#a2c085aa47872fe7e4dbba0703e23923c" title="Short-hand for a Basic_blob that allocates/deallocates in regular heap and is itself assumed to be st...">Blob_sans_log_context</a> + <a class="el" href="namespaceflow_1_1util.html#a0edd9dd6bf51e7457477123b419f5bf6" title="Identical to Blob_sans_log_context but with sharing feature compile-time-enabled.">Sharing_blob_sans_log_context</a>, each simply an alias to <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;std::allocator, B&gt;</code> (with <code>B = false</code> or <code>true</code> respectively), in a fashion vaguely similar to what <code>string</code> is to <code>basic_string</code> (a little). This is much like <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>, in that it is a non-template concrete type; but does not take or store a <code>Logger*</code>.</dd></dl>
<p>The rationale for its existence mirrors its essential differences from <code>vector&lt;uint8_t&gt;</code> which are as follows. To summarize, though, it exists to guarantee specific performance by reducing implementation uncertainty via lower-level operations; and force user to explicitly authorize any allocation to ensure thoughtfully performant use. Update: Plus, it adds non-prefix-sub-buffer feature, which can be useful for zero-copy deserialization. Update: Plus, it adds a simple form of garbage-collected memory pools, useful for operating multiple <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s that share a common over-arching memory area (buffer). Update: Plus, it adds SHM-friendly custom allocator support. (While all <code>vector</code> impls support custom allocators, only some later versions of gcc <code>std::vector</code> work with shared-memory (SHM) allocators and imperfectly at that. <code>boost::container::vector</code> a/k/a <code>boost::interprocess::vector</code> is fully SHM-friendly.)</p>
<ul>
<li>It adds a feature over <code>vector&lt;uint8_t&gt;</code>: The logical contents <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> can optionally begin not at the start of the internally allocated buffer but somewhere past it. In other words, the logical buffer is not necessarily a prefix of the internal allocated buffer. This feature is critical when one wants to use some sub-buffer of a buffer without reallocating a smaller buffer and copying the sub-buffer into it. For example, if we read a DATA packet the majority of which is the payload, which begins a few bytes from the start &ndash; past a short header &ndash; it may be faster to keep passing around the whole thing with move semantics but use only the payload part, after logically deserializing it (a/k/a zero-copy deserialization semantics). Of course one can do this with <code>vector</code> as well; but one would need to always remember the prefix length even after deserializing, at which point such details would be ideally forgotten instead. So this API is significantly more pleasant in that case. Moreover it can then be used generically more easily, alongside other containers.</li>
<li>Its performance is guaranteed by internally executing low-level operations such as <code>memcpy()</code> directly instead of hoping that using a higher-level abstraction will ultimately do the same.<ul>
<li>In particular, the iterator types exposed by the API <em>are</em> pointers instead of introducing any performance uncertainty by possibly using wrapper/proxy iterator class.</li>
<li>In particular, no element or memory area is <em>ever</em> initialized to zero(es) or any other particular filler value(s). (This is surprisingly difficult to avoid with STL containers! Google it. Though, e.g., boost.container does provide a <code>default_init_t</code> extension to various APIs like <code>.<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a></code>.) If an allocation does occur, the area is left as-is unless user specifies a source memory area from which to copy data.</li>
<li>Note that I am making no assertion about <code>vector</code> being slow; the idea is to guarantee <em>we</em> aren't by removing any <em>question</em> about it; it's entirely possible a given <code>vector</code> is equally fast, but it cannot be guaranteed by standard except in terms of complexity guarantees (which is usually pretty good but not everything).<ul>
<li>That said a quick story about <code>std::vector&lt;uint8_t&gt;</code> (in gcc-8.3 anyway): I (ygoldfel) once used it with a custom allocator (which worked in shared memory) and stored a megabytes-long buffer in one. Its destructor, I noticed, spent milliseconds (with 2022 hardware) &ndash; outside the actual dealloc call. Reason: It was iterating over every (1-byte) element and invoking its (non-existent/trivial) destructor. It did not specialize to avoid this, intentionally so according to a comment, when using a custom allocator. <code>boost::container::vector&lt;uint8_t&gt;</code> lacked this problem; but nevertheless it shows generally written containers can have hidden such perf quirks.</li>
</ul>
</li>
</ul>
</li>
<li>To help achieve the previous bullet point, as well as to keep the code simple, the class does not parameterize on element type; it stores unsigned bytes, period (though <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf" title="Short-hand for values, which in this case are unsigned bytes.">Basic_blob::value_type</a> is good to use if you need to refer to that type in code generically). Perhaps the same could be achieved by specialization, but we don't need the parameterization in the first place.</li>
<li>Unlike <code>vector</code>, it has an explicit state where there is no underlying buffer; in this case <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>. Also in that case, <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code> (and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>). <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> is the case on default-constructed object of this class. The reason for this is I am never sure, at least, what a default-constructed <code>vector</code> looks like internally; a null buffer always seemed like a reasonable starting point worth guaranteeing explicitly.</li>
<li>If <code>!zero()</code>:<ul>
<li><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> deallocates any allocated buffer and ensures <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>, as if upon default construction.</li>
<li>Like <code>vector</code>, it keeps an allocated memory chunk of size M, at the start of which is the logical buffer of size <code>N &lt;= M</code>, where <code>N == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and <code>M == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>. However, <code>M &gt;= 1</code> always.<ul>
<li>There is the aforementioned added feature wherein the logical buffer begins to the right of the allocated buffer, namely at index <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code>. In this case <code>M &gt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and the buffer range is in indices <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code> of the allocated buffer. By default <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>, as in <code>vector</code>, but this can be changed via the 2nd, optional, argument to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>.</li>
</ul>
</li>
<li>Like <code>vector</code>, <code>reserve(Mnew)</code>, with <code>Mnew &lt;= M</code>, does nothing. However, unlike <code>vector</code>, the same call is <em>illegal</em> when <code>Mnew &gt; M &gt;= 1</code>. However, any <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> call <em>is</em> allowed when <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>. Therefore, if the user is intentionally okay with the performance implications of a reallocation, they can call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> and <em>then</em> force the reallocating <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> call.</li>
<li>Like <code>vector</code>, <code>resize(Nnew)</code> merely guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == Nnew</code>; which means that it is essentially equivalent to <code>reserve(Nnew)</code> followed by setting internal N member to Nnew. However, remember that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> therefore keeps all the behaviors of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, including that it cannot grow the buffer (only allocate it when <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code>).<ul>
<li>If changing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> from default, then: <code>resize(Nnew, Snew)</code> means <code>reserve(Nnew + Snew)</code>, plus saving internal N and S members.</li>
</ul>
</li>
</ul>
</li>
<li>The <em>only</em> way to allocate is to (directly or indirectly) call <code>reserve(Mnew)</code> when <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>. Moreover, <em>exactly</em> Mnew bytes elements are allocated and no more (unlike with <code>vector</code>, where the policy used is not known). Moreover, if <code>reserve(Mnew)</code> is called indirectly (by another method of the class), <code>Mnew</code> arg is set to no greater than size necessary to complete the operation (again, by contrast, it is unknown what <code>vector</code> does w/r/t capacity policy).</li>
<li>The rest of the API is common-sense but generally kept to only what has been necessary to date, in on-demand fashion.</li>
</ul>
<h3>Optional, simple garbage-collected shared ownership functionality</h3>
<p >The following feature was added quite some time after <code>Blob</code> was first introduced and matured. However it seamlessly subsumes all of the above basic functionality with full backwards compatibility. It can also be disabled (and is by default) by setting <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a67db182946127383fb48d6a1afbdca90" title="Value of template parameter S_SHARING_ALLOWED (for generic programming).">S_SHARING</a> to <code>false</code> at compile-time. (This gains back a little bit of perf namely by turning an internal <code>shared_ptr</code> to <code>unique_ptr</code>.)</p>
<p >The feature itself is simple: Suppose one has a blob A, constructed or otherwise <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a></code>d or <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a></code>d so as to have <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code>; meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> &gt;= 1</code>. Now suppose one calls the core method of this <em>pool</em> feature: <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> which returns a new blob B. B will have the same exact <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> &ndash; and, in fact, the pointer <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4581e779dace3d64fe4098eb0a7dbeb2" title="Equivalent to begin().">data()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> (i.e., the underlying buffer start pointer, buffer being <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> long). That is, B now shares the underlying memory buffer with A. Normally, that underlying buffer would be deallocated when either <code>A.make_zero()</code> is called, or A is destructed. Now that it's shared by A and B, however, the buffer is deallocated only once <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destruction occurs for <em>both</em> A and B. That is, there is an internal (thread-safe) ref-count that must reach 0.</p>
<p >Both A and B may now again be <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>d into further sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s. This further increments the ref-count of original buffer; all such <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s C, D, ... must now either <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destruct, at which point the dealloc occurs.</p>
<p >In that way the buffer &ndash; or <em>pool</em> &ndash; is <em>garbage-collected</em> as a whole, with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (and APIs like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and ctors that call it) initially allocating and setting internal ref-count to 1, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> incrementing it, and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae9fc395523fae83128888d9bb1c90726" title="Destructor that drops *this ownership of the allocated internal buffer if any, as by make_zero(); if ...">~Basic_blob()</a> decrementing it (and deallocating when ref-count=0).</p>
<h3>Application of shared ownership: Simple pool-of-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s functionality</h3>
<p >The other aspect of this feature is its pool-of-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s application. All of the sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s A, B, ... retain all the aforementioned features including the ability to use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c3497d662be650e7a560eb7a703acc1" title="Like start_past_prefix() but shifts the current prefix position by the given incremental value (posit...">start_past_prefix_inc()</a>, etc., to control the location of the logical sub-range [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) within the underlying buffer (pool). E.g., suppose A was 10 bytes, with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> = 0</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> = 10</code>; then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> B is also that way. Now <code>B.start_past_prefix_inc(5); A.resize(5);</code> makes it so that A = the 1st 5 bytes of the pool, B the last 5 bytes (and they don't overlap &ndash; can even be concurrently modified safely). In that way A and B are now independent <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s &ndash; potentially passed, say, to independent TCP-receive calls, each of which reads up to 5 bytes &ndash; that share an over-arching pool.</p>
<p >The API <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> is a convenience operation that splits a <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>'s [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) area into 2 areas of specified length, then returns a new <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> representing the first area in the split and modifies <code>*this</code> to represent the remainder (the 2nd area). This simply performs the op described in the preceding paragraph. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aacc565dcada148095cb14863387d5696" title="Identical to share_after_split_left(), except this-&gt;end() shifts by size to the left (instead of this...">share_after_split_right()</a> is similar but acts symmetrically from the right. Lastly <code>share_after_split_equally*()</code> splits a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> into several equally-sized (except the last one potentially) sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s of size N, where N is an arg. (It can be thought of as just calling <code>share_after_split_left(N)</code> repeatedly, then returning a sequence of the resulting post-split <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.)</p>
<p >To summarize: The <code>share_after_split*()</code> APIs are useful to divide (potentially progressively) a pool into non-overlapping <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s within a pool while ensuring the pool continues to exist while <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s refer to any part of it (but no later). Meanwhile direct use of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and <code>start_past_prefix*()</code> allows for overlapping such sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >Note that deallocation occurs regardless of which areas of that pool the relevant <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s represent, and whether they overlap or not (and, for that matter, whether they even together comprise the entire pool or leave "gaps" in-between). The whole pool is deallocated the moment the last of the co-owning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s performs either <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae9fc395523fae83128888d9bb1c90726" title="Destructor that drops *this ownership of the allocated internal buffer if any, as by make_zero(); if ...">~Basic_blob()</a> &ndash; the values of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> at the time are not relevant.</p>
<h3>Custom allocator (and SHared Memory) support</h3>
<p >Like STL containers this one optionally takes a custom allocator type (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>) as a compile-time parameter instead of using the regular heap (<code>std::allocator</code>). Unlike many STL container implementations, including at least older <code>std::vector</code>, it supports SHM-storing allocators without a constant cross-process vaddr scheme. (Some do support this but with surprising perf flaws when storing raw integers/bytes. boost.container <code>vector</code> has solid support but lacks various other properties of <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.) While a detailed discussion is outside our scope here, the main point is internally <code>*this</code> stores no raw <code>value_type*</code> but rather <code>Allocator_raw::pointer</code> &ndash; which in many cases <em>is</em> <code>value_type*</code>; but for advanced applications like SHM it might be a fancy-pointer like <code>boost::interprocess::offset_ptr&lt;value_type&gt;</code>. For general education check out boost.interprocess docs covering storage of STL containers in SHM. (However note that the allocators provided by that library are only one option even for SHM storage alone; e.g., they are stateful, and often one would like a stateless &ndash; zero-size &ndash; allocator. Plus there are other limitations to boost.interprocess SHM support, robust though it is.)</p>
<h3>Logging</h3>
<p >When and if <code>*this</code> logs, it is with <a class="el" href="namespaceflow_1_1log.html#a5c602384e6fe9d7642740ac2fae4ad04a3ee808b04c34bf6c110e3754de277f7b" title="Message indicates any condition that may occur with great frequency (thus verbose if logged).">log::Sev::S_TRACE</a> severity or more verbose.</p>
<p >Unlike many other Flow API classes this one does not derive from <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">log::Log_context</a> nor take a <code>Logger*</code> in ctor (and store it). Instead each API method/ctor/function capable of logging takes an optional (possibly null) <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a> pointer. If supplied it's used by that API alone (with some minor async exceptions). If you would like more typical Flow-style logging API then use our non-polymorphic sub-class <a class="el" href="classflow_1_1util_1_1Blob__with__log__context.html" title="Basic_blob that works in regular heap (and is itself placed in heap or stack) and memorizes a log::Lo...">Blob_with_log_context</a> (more likely aliases <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>, <a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>). However consider the following first.</p>
<p >Why this design? Answer:</p><ul>
<li><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> is meant to be lean, both in terms of RAM used and processor cycles spent. Storing a <code>Logger*</code> takes some space; and storing it, copying/moving it, etc., takes a little compute. In a low-level API like <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> this is potentially nice to avoid when not actively needed. (That said the logging can be extremely useful when debugging and/or profiling RAM use + allocations.)<ul>
<li>This isn't a killer. The original <code>Blob</code> (before <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> existed) stored a <code>Logger*</code>, and it was fine. However:</li>
</ul>
</li>
<li>Storing a <code>Logger*</code> is always okay when <code>*this</code> itself is stored in regular heap or on the stack. However, <code>*this</code> itself may be stored in SHM; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> parameterization (see above regarding "Custom allocator") suggests as much (i.e., if the buffer is stored in SHM, we might be too). In that case <code>Logger*</code> does not, usually, make sense. As of this writing <code>Logger</code> in process 1 has no relationship with any <code>Logger</code> in process 2; and even if the <code>Logger</code> were stored in SHM itself, <code>Logger</code> would need to be supplied via an in-SHM fancy-pointer, not <code>Logger*</code>, typically. The latter is a major can of worms and not supported by <a class="el" href="namespaceflow_1_1log.html" title="Flow module providing logging functionality.">flow::log</a> in any case as of this writing.<ul>
<li>Therefore, even if we don't care about RAM/perf implications of storing <code>Logger*</code> with the blob, at least in some real applications it makes no sense.</li>
</ul>
</li>
</ul>
<p ><a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a> provides this support while ensuring <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> (no longer a template parameter in its case) is the vanilla <code>std::allocator</code>. The trade-off is as noted just above.</p>
<h3>Thread safety</h3>
<p >Before <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> (or <code>share_*()</code>) is called: Essentially: Thread safety is the same as for <code>vector&lt;uint8_t&gt;</code>.</p>
<p >Without <code>share*()</code> any two <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> objects refer to separate areas in memory; hence it is safe to access <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> A concurrently with accessing <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> B in any fashion (read, write).</p>
<p >However: If 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s A and B co-own a pool, via a <code>share*()</code> chain, then concurrent write and read/write to A and B respectively are thread-safe if and only if their [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) ranges don't overlap. Otherwise, naturally, one would be writing to an area while it is being read simultaneously &ndash; not safe.</p>
<p >Tip: When working in <code>share*()</code> mode, exclusive use of <code>share_after_split*()</code> is a great way to guarantee no 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s ever overlap. Meanwhile one must be careful when using <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> directly and/or subsequently sliding the range around via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <code>start_past_prefix*()</code>: <code>A.share()</code> and A not only (originally) overlap but simply represent the same area of memory; and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> and co. can turn a non-overlapping range into an overlapping one (encroaching on someone else's "territory" within the pool).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>An allocator, with <code>value_type</code> equal to our <a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf" title="Short-hand for values, which in this case are unsigned bytes.">value_type</a>, per the standard C++1x <code>Allocator</code> concept. In most uses this shall be left at the default <code>std::allocator&lt;value_type&gt;</code> which allocates in standard heap (<code>new[]</code>, <code>delete[]</code>). A custom allocator may be used instead. SHM-storing allocators, and generally allocators for which <code>pointer</code> is not simply <code>value_type*</code> but rather a fancy-pointer (see cppreference.com) are correctly supported. (Note this may not be the case for your compiler's <code>std::vector</code>.) </td></tr>
    <tr><td class="paramname">S_SHARING_ALLOWED</td><td>If <code>true</code>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> and all derived methods, plus <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af567381736851969f6e8812c54404028" title="Returns true if and only if both given objects are not zero() == true, and they either co-own a commo...">blobs_sharing()</a>, can be instantiated (invoked in compiled code). If <code>false</code> they cannot (<code>static_assert()</code> will trip), but the resulting <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> concrete class will be slightly more performant (internally, a <code>shared_ptr</code> becomes instead a <code>unique_ptr</code> which means smaller allocations and no ref-count logic invoked). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae8c99e64b04da1420005c984879290ce" name="ae8c99e64b04da1420005c984879290ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c99e64b04da1420005c984879290ce">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc_raw</em> = <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs blob with <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>. </p>
<p >Note this means no buffer is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_raw</td><td>Allocator to copy and store in <code>*this</code> for all buffer allocations/deallocations. If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateless, then this has size zero, so nothing is copied at runtime, and by definition it is to equal <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d658402197aeda90c4b813e50b5f4c" name="a77d658402197aeda90c4b813e50b5f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d658402197aeda90c4b813e50b5f4c">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc_raw</em> = <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs blob with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> equal to the given <code>size</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>. </p>
<p >Performance note: elements are not initialized to zero or any other value. A new over-arching buffer (pool) is therefore allocated.</p>
<p >Corner case note: a post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == (<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0)</code>. Note, also, that the latter is <em>not</em> a universal invariant (see <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> doc header).</p>
<p >Formally: If <code>size &gt;= 1</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>A non-negative desired size. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
    <tr><td class="paramname">alloc_raw</td><td>Allocator to copy and store in <code>*this</code> for all buffer allocations/deallocations. If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> is stateless, then this has size zero, so nothing is copied at runtime, and by definition it is to equal <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b2f88c8e8ca1cbd618d0cafff0cf663" name="a0b2f88c8e8ca1cbd618d0cafff0cf663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2f88c8e8ca1cbd618d0cafff0cf663">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor, constructing a blob exactly internally equal to pre-call <code>moved_src</code>, while the latter is made to be exactly as if it were just constructed as <code>Basic_blob(nullptr)</code> (allocator subtleties aside). </p>
<p >Performance: constant-time, at most copying a few scalars.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>The object whose internals to move to <code>*this</code> and replace with a blank-constructed object's internals. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7feb29f4d1045490e8497ec067f8a70b" name="a7feb29f4d1045490e8497ec067f8a70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feb29f4d1045490e8497ec067f8a70b">&#9670;&nbsp;</a></span>Basic_blob() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::Basic_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor, constructing a blob logically equal to <code>src</code>. </p>
<p >More formally, guarantees post-condition wherein <code>[this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> range is equal by value (including length) to <code>src</code> equivalent range but no memory overlap. A post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>. Performance: see copying assignment operator.</p>
<p >Corner case note: the range equality guarantee includes the degenerate case where that range is empty, meaning we simply guarantee post-condition <code>src.empty() == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a></code>.</p>
<p >Corner case note 2: post-condition: <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a></code> (note <code>src.zero()</code> state is not necessarily preserved in <code>*this</code>).</p>
<p >Note: This is <code>explicit</code>, which is atypical for a copy constructor, to generate compile errors in hard-to-see (and often unintentional) instances of copying. Copies of <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> should be quite intentional and explicit. (One example where one might forget about a copy would be when using a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> argument without <code>cref</code> or <code>ref</code> in a <code>bind()</code>; or when capturing by value, not by ref, in a lambda.)</p>
<p >Formally: If <code>src.size() &gt;= 1</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Object whose range of bytes of length <code>src.size()</code> starting at <code>src.begin()</code> is copied into <code>*this</code>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9fc395523fae83128888d9bb1c90726" name="ae9fc395523fae83128888d9bb1c90726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fc395523fae83128888d9bb1c90726">&#9670;&nbsp;</a></span>~Basic_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::~<a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor that drops <code>*this</code> ownership of the allocated internal buffer if any, as by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also. </p>
<p >Recall that other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s can only gain co-ownership via <code>share*()</code>; hence if one does not use that feature, the destructor will in fact deallocate the buffer (if any).</p>
<p >Formally: If <code>!zero()</code>, then the internal ownership ref-count is decremented by 1, and if it reaches 0, then a buffer is deallocated.</p>
<h3>Logging</h3>
<p >This will not log, as it is not possible to pass a <code>Logger*</code> to a dtor without storing it (which we avoid for reasons outlined in class doc header). Use <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a> if it is important to log in this situation (although there are some minor trade-offs). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b07b9b83929cfb35f80f13ce416ec4b" name="a3b07b9b83929cfb35f80f13ce416ec4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b07b9b83929cfb35f80f13ce416ec4b">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p >Allocator subtleties aside and assuming <code>this != &amp;moved_src</code> it is equivalent to: <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; this-&gt;swap(moved_src, logger_ptr)</code>. (If <code>this == &amp;moved_src</code>, this is a no-op.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a835d127753a70d8c397a1a6153cab78d" title="Swaps the contents of this structure and other, or no-op if this == &amp;other.">swap()</a>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="afd7d10ef9bb9c1c449def462eb9b2c01" name="afd7d10ef9bb9c1c449def462eb9b2c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7d10ef9bb9c1c449def462eb9b2c01">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment: assuming <code>(this != &amp;src) &amp;&amp; (!blobs_sharing(*this, src))</code>, makes <code>*this</code> logically equal to <code>src</code>; but behavior undefined if a reallocation would be necessary to do this. </p>
<p >(If <code>this == &amp;src</code>, this is a no-op. If not but <code>blobs_sharing(*this, src) == true</code>, see "Sharing blobs" below. This is assumed to not be the case in further discussion.)</p>
<p >More formally: no-op if <code>this == &amp;src</code>; "Sharing blobs" behavior if not so, but <code>src</code> shares buffer with <code>*this</code>; otherwise: Guarantees post-condition wherein <code>[this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> range is equal by value (including length) to <code>src</code> equivalent range but no memory overlap. Post-condition: <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> either does not change or equals <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth is not allowed: behavior is undefined if <code>src.size()</code> exceeds pre-call <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>, unless <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> pre-call. Performance: at most a memory area of size <code>src.size()</code> is copied and some scalars updated; a memory area of that size is allocated only if required; no ownership drop or deallocation occurs.</p>
<p >Corner case note: the range equality guarantee includes the degenerate case where that range is empty, meaning we simply guarantee post-condition <code>src.empty() == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a></code>.</p>
<p >Corner case note 2: post-condition: if <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code> then <code>this.zero()</code> has the same value as at entry to this call. In other words, no deallocation occurs, even if <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code> post-condition holds; at most internally a scalar storing size is assigned 0. (You may force deallocation in that case via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> post-call, but this means you'll have to intentionally perform that relatively slow op.)</p>
<p >As with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, IF pre-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code>, THEN pre-condition <code>src.size() &lt;= this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> must hold, or behavior is undefined (i.e., as noted above, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth is not allowed except from 0). Therefore, NO REallocation occurs! However, also as with <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>, if you want to intentionally allow such a REallocation, then simply first call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a>; then execute the <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b" title="Move assignment.">assign()</a></code> copy as planned. This is an intentional restriction forcing caller to explicitly allow a relatively slow reallocation op.</p>
<p >Formally: If <code>src.size() &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<h3>Sharing blobs</h3>
<p >If <code>blobs_sharing(*this, src) == true</code>, meaning the target and source are operating on the same buffer, then behavior is undefined (assertion may trip). Rationale for this design is as follows. The possibilities were:</p><ol type="1">
<li>Undefined behavior/assertion.</li>
<li>Just adjust <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> and <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code> to match <code>src</code>; continue co-owning the underlying buffer; copy no data.</li>
<li><code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a></code> &ndash; losing <code>*this</code> ownership, while <code>src</code> keeps it &ndash; and then allocate a new buffer and copy <code>src</code> data into it.</li>
</ol>
<p >Choosing between these is tough, as this is an odd corner case. 3 is not criminal, but generally no method ever forces <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> behavior, always leaving it to the user to consciously do, so it seems prudent to keep to that practice (even though this case is a bit different from, say, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> &ndash; since <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> here has no chance to deallocate anything, only decrement ref-count). 2 is performant and slick but suggests a special behavior in a corner case; this <em>feels</em> slightly ill-advised in a standard copy assignment operator. Therefore it seems better to crash-and-burn (choice 1), in the same way an attempt to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>-higher a non-zero() blob would crash and burn, forcing the user to explicitly execute what they want. After all, 3 is done by simply calling <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> first; and 2 is possible with a simple <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> call; and the <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af567381736851969f6e8812c54404028" title="Returns true if and only if both given objects are not zero() == true, and they either co-own a commo...">blobs_sharing()</a> check is both easy and performant.</p>
<dl class="section warning"><dt>Warning</dt><dd>A post-condition is <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code>; meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> at entry is ignored and reset to 0; the entire (co-)owned buffer &ndash; if any &ndash; is potentially used to store the copied values. In particular, if one plans to work on a sub-blob of a shared pool (see class doc header), then using this assignment op is not advised. Use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3d154ee5afaee08a62397174f9f7a879" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> instead; or perform your own copy onto <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2bd3cb0b6b3f304fb6fb771c1b76ec66" title="Same as const_buffer() but the returned view is mutable.">mutable_buffer()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Object whose range of bytes of length <code>src.size()</code> starting at <code>src.begin()</code> is copied into <code>*this</code>. Behavior is undefined if pre-condition is <code>!zero()</code>, and this memory area overlaps at any point with the memory area of same size in <code>*this</code> (unless that size is zero &ndash; a degenerate case). (This can occur only via the use of <code>share*()</code> &ndash; otherwise <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s always refer to separate areas.) Also behavior undefined if pre-condition is <code>!zero()</code>, and <code>*this</code> (co-)owned buffer is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a3fa2763f88c61a57f52133dc22223cef" name="a3fa2763f88c61a57f52133dc22223cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa2763f88c61a57f52133dc22223cef">&#9670;&nbsp;</a></span>assign_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::assign_copy </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces logical contents with a copy of the given non-overlapping area anywhere in memory. </p>
<p >More formally: This is exactly equivalent to copy-assignment (<code>*this = b</code>), where <code>const <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> b</code> owns exactly the memory area given by <code>src</code>. However, note the newly relevant restriction documented for <code>src</code> parameter below (no overlap allowed).</p>
<p >All characteristics are as written for the copy assignment operator, including "Formally" and the warning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source memory area. Behavior is undefined if pre-condition is <code>!zero()</code>, and this memory area overlaps at any point with the memory area of same size at <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>. Otherwise it can be anywhere at all. Also behavior undefined if pre-condition is <code>!zero()</code>, and <code>*this</code> (co-)owned buffer is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements copied, namely <code>src.size()</code>, or simply <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>. </dd></dl>

</div>
</div>
<a id="a49d05eed39be69ceec235fe3403b16b9" name="a49d05eed39be69ceec235fe3403b16b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d05eed39be69ceec235fe3403b16b9">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable last element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac10980e7748d8198fe831666254d864d" name="ac10980e7748d8198fe831666254d864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10980e7748d8198fe831666254d864d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7c99b053ce77cd0573d882e194908e49" title="Returns reference to immutable last element.">const_back()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a9daa427a42c8a8c24b585f96c37d277a" name="a9daa427a42c8a8c24b585f96c37d277a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daa427a42c8a8c24b585f96c37d277a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to mutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a1dfd46fca324a6b80934b9230c2f2bb4" name="a1dfd46fca324a6b80934b9230c2f2bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfd46fca324a6b80934b9230c2f2bb4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a719e5c04e4bdc65c31976fc385fd7f24" name="a719e5c04e4bdc65c31976fc385fd7f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e5c04e4bdc65c31976fc385fd7f24">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buffer is internally allocated. </p>
<p >Some formal invariants: <code>(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0) == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a></code>; <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> &lt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code>.</p>
<p >See important notes on <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> policy in the class doc header.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a669252f9a78f516dfeaf964987078255" name="a669252f9a78f516dfeaf964987078255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669252f9a78f516dfeaf964987078255">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<p >Exists as standard container method (hence the odd formatting).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </dd></dl>

</div>
</div>
<a id="ada9e80920dcc3d51c229db98a9d62ac6" name="ada9e80920dcc3d51c229db98a9d62ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9e80920dcc3d51c229db98a9d62ac6">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </p>
<p >Exists as standard container method (hence the odd formatting).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </dd></dl>

</div>
</div>
<a id="a62da4400fbde6c186fb989f55248e3d2" name="a62da4400fbde6c186fb989f55248e3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62da4400fbde6c186fb989f55248e3d2">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>resize(0, start())</code>. </p>
<p >Note that the value returned by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> will <em>not</em> change due to this call. Only <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> (and the corresponding internally stored datum) may change. If one desires to reset <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, use <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> directly (but if one plans to work on a sub-Basic_blob of a shared pool &ndash; see class doc header &ndash; please think twice first). </p>

</div>
</div>
<a id="a7c99b053ce77cd0573d882e194908e49" name="a7c99b053ce77cd0573d882e194908e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c99b053ce77cd0573d882e194908e49">&#9670;&nbsp;</a></span>const_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable last element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac511ddaa3fb453888524cedba39c36ef" name="ac511ddaa3fb453888524cedba39c36ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac511ddaa3fb453888524cedba39c36ef">&#9670;&nbsp;</a></span>const_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to immutable first element; or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="afbb4e2420be2f8ca0dc8c4fb70feb8ea" name="afbb4e2420be2f8ca0dc8c4fb70feb8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb4e2420be2f8ca0dc8c4fb70feb8ea">&#9670;&nbsp;</a></span>const_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::const_buffer <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience accessor returning an immutable boost.asio buffer "view" into the entirety of the blob. </p>
<p >Equivalent to <code>const_buffer(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a75d4c0a1e530596982a3b5d3e0ff91e6" title="Equivalent to const_begin().">const_data()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a75d4c0a1e530596982a3b5d3e0ff91e6" name="a75d4c0a1e530596982a3b5d3e0ff91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d4c0a1e530596982a3b5d3e0ff91e6">&#9670;&nbsp;</a></span>const_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> const  * <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ac511ddaa3fb453888524cedba39c36ef" title="Returns pointer to immutable first element; or end() if empty().">const_begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="ae4f1d8c42aea63ba4f127cb7ed5776d6" name="ae4f1d8c42aea63ba4f127cb7ed5776d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f1d8c42aea63ba4f127cb7ed5776d6">&#9670;&nbsp;</a></span>const_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer one past immutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> is possible. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a90859b0e130bef705a2e556ccb27df53" name="a90859b0e130bef705a2e556ccb27df53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90859b0e130bef705a2e556ccb27df53">&#9670;&nbsp;</a></span>const_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::const_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable first element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a4581e779dace3d64fe4098eb0a7dbeb2" name="a4581e779dace3d64fe4098eb0a7dbeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4581e779dace3d64fe4098eb0a7dbeb2">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> * <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a198eb271d009f153cae041ba1948e945" name="a198eb271d009f153cae041ba1948e945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198eb271d009f153cae041ba1948e945">&#9670;&nbsp;</a></span>derefable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::derefable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the given iterator points to an element within this blob's <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> elements. </p>
<p >In particular, this is always <code>false</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>; and also when <code>it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator/pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a3d154ee5afaee08a62397174f9f7a879" name="a3d154ee5afaee08a62397174f9f7a879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d154ee5afaee08a62397174f9f7a879">&#9670;&nbsp;</a></span>emplace_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::emplace_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::const_buffer &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>src</code> buffer directly onto equally sized area within <code>*this</code> at location <code>dest</code>; <code>*this</code> must have sufficient <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> to accomodate all of the data copied. </p>
<p >Performance: The only operation performed is a copy from <code>src</code> to <code>dest</code> using the fastest reasonably available technique.</p>
<p >None of the following changes: <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; nor the location (or size) of internally stored buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination location within this blob. This must be in <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>]</code>; and, unless <code>src.size() == 0</code>, must not equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> either. </td></tr>
    <tr><td class="paramname">src</td><td>Source memory area. Behavior is undefined if this memory area overlaps at any point with the memory area of same size at <code>dest</code> (unless that size is zero &ndash; a degenerate case). Otherwise it can be anywhere at all, even partially or fully within <code>*this</code>. Also behavior undefined if <code>*this</code> blob is too short to accomodate all <code>src.size()</code> bytes (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location in this blob just past the last element copied; <code>dest</code> if none copied; in particular <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is a possible value. </dd></dl>

</div>
</div>
<a id="a797741a0a5c95b13b36f356ae8d397e8" name="a797741a0a5c95b13b36f356ae8d397e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797741a0a5c95b13b36f356ae8d397e8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is <code>true</code>; but if this is <code>true</code>, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a61880291749335246f60fde4387f7ad6" name="a61880291749335246f60fde4387f7ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61880291749335246f60fde4387f7ad6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer one past mutable last element; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> is possible. </p>
<p >Null is a possible value in the latter case.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a9b61c80d3df1c53583362ec15cdbb0b6" name="a9b61c80d3df1c53583362ec15cdbb0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b61c80d3df1c53583362ec15cdbb0b6">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer, possibly null. </dd></dl>

</div>
</div>
<a id="a49046a070b040ca17ca9062ac291a6dd" name="a49046a070b040ca17ca9062ac291a6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49046a070b040ca17ca9062ac291a6dd">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a93b5764b185d0a1a1d143211e39b2de1">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>past_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the minimal number of operations to make range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> unchanged except for lacking sub-range <code>[first, past_last)</code>. </p>
<p >Performance/behavior: At most, this copies the range <code>[past_last, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> to area starting at <code>first</code>; and then adjusts internally stored size member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Pointer to first element to erase. It must be dereferenceable, or behavior is undefined (assertion may trip). </td></tr>
    <tr><td class="paramname">past_last</td><td>Pointer to one past the last element to erase. If <code>past_last &lt;= first</code>, call is a no-op. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator equal to <code>first</code>. (This matches standard expectation for container <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a49046a070b040ca17ca9062ac291a6dd" title="Performs the minimal number of operations to make range [begin(), end()) unchanged except for lacking...">erase()</a></code> return value: iterator to element past the last one erased. In this contiguous sequence that simply equals <code>first</code>, since everything starting with <code>past_last</code> slides left onto <code>first</code>. In particular: If <code>past_last()</code> equaled <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> at entry, then the new <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is returned: everything starting with <code>first</code> was erased and thus <code>first == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> now. If nothing is erased <code>first</code> is still returned.) </dd></dl>

</div>
</div>
<a id="abe7ea8c6aa0a7b043129fca8eacaedad" name="abe7ea8c6aa0a7b043129fca8eacaedad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7ea8c6aa0a7b043129fca8eacaedad">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to mutable first element. </p>
<p >Behavior is undefined if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a98a489088e29d5d4b82b0498c8e210f8" name="a98a489088e29d5d4b82b0498c8e210f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a489088e29d5d4b82b0498c8e210f8">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">::value_type</a> const  &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a90859b0e130bef705a2e556ccb27df53" title="Returns reference to immutable first element.">const_front()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af32359d0bd98f378c7397a7c86e6e66d" name="af32359d0bd98f378c7397a7c86e6e66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32359d0bd98f378c7397a7c86e6e66d">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">::Allocator_raw</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::get_allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the internally cached <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> as set by a constructor or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b" title="Move assignment.">assign()</a> or assignment-operator, whichever happened last. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af431f32bde5ed1ba255e3e1cbbcbd906" name="af431f32bde5ed1ba255e3e1cbbcbd906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af431f32bde5ed1ba255e3e1cbbcbd906">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> by dropping <code>*this</code> ownership of the allocated internal buffer if any; if no other <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> holds ownership of that buffer, then that buffer is deallocated also. </p>
<p >Recall that other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s can only gain co-ownership via <code>share*()</code>; hence if one does not use that feature, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> will in fact deallocate the buffer (if any).</p>
<p >That post-condition can also be thought of as <code>*this</code> becoming indistinguishable from a default-constructed <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.</p>
<p >Performance/behavior: Assuming <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is not already <code>true</code>, this will deallocate <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> sized buffer and save a null pointer.</p>
<p >The many operations that involve <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> in their doc headers will explain importance of this method: As a rule, no method except <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> allows one to request an ownership-drop or deallocation of the existing buffer, even if this would be necessary for a larger buffer to be allocated. Therefore, if you intentionally want to allow such an operation, you CAN, but then you MUST explicitly call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> first.</p>
<p >Formally: If <code>!zero()</code>, then the internal ownership ref-count is decremented by 1, and if it reaches 0, then a buffer is deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd3cb0b6b3f304fb6fb771c1b76ec66" name="a2bd3cb0b6b3f304fb6fb771c1b76ec66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd3cb0b6b3f304fb6fb771c1b76ec66">&#9670;&nbsp;</a></span>mutable_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::mutable_buffer <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::mutable_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Basic__blob.html#afbb4e2420be2f8ca0dc8c4fb70feb8ea" title="Convenience accessor returning an immutable boost.asio buffer &quot;view&quot; into the entirety of the blob.">const_buffer()</a> but the returned view is mutable. </p>
<p >Equivalent to <code>mutable_buffer(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a4581e779dace3d64fe4098eb0a7dbeb2" title="Equivalent to begin().">data()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a151d35b3c35219089d53061503841b75" name="a151d35b3c35219089d53061503841b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151d35b3c35219089d53061503841b75">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>moved_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator (no logging): equivalent to <code>assign(std::move(moved_src), nullptr)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moved_src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b" title="Move assignment.">assign()</a> (move overload). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a72eda661d71306c2fbd0422993922309" name="a72eda661d71306c2fbd0422993922309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72eda661d71306c2fbd0422993922309">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator (no logging): equivalent to <code>assign(src, nullptr)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3b07b9b83929cfb35f80f13ce416ec4b" title="Move assignment.">assign()</a> (copy overload). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a328b40fe431698b38b48b66397664d1f" name="a328b40fe431698b38b48b66397664d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328b40fe431698b38b48b66397664d1f">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that an internal buffer of at least <code>capacity</code> elements is allocated and owned; disallows growing an existing buffer; never shrinks an existing buffer; if a buffer is allocated, it is no larger than <code>capacity</code>. </p>
<p ><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> may be called directly but should be formally understood to be called by <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3fa2763f88c61a57f52133dc22223cef" title="Replaces logical contents with a copy of the given non-overlapping area anywhere in memory.">assign_copy()</a>, copy assignment operator, copy constructor. In all cases, the value passed to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> is exactly the size needed to perform the particular task &ndash; no more (and no less). As such, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> policy is key to knowing how the class behaves elsewhere. See class doc header for discussion in larger context.</p>
<p >Performance/behavior: If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is true pre-call, <code>capacity</code> sized buffer is allocated. Otherwise, no-op if <code>capacity &lt;= <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> pre-call. Behavior is undefined if <code>capacity &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a></code> pre-call (again, unless <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, meaning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> == 0</code>). In other words, no deallocation occurs, and an allocation occurs only if necessary. Growing an existing buffer is disallowed. However, if you want to intentionally REallocate, then simply first check for <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == false</code> and call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> if that holds; then execute the <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a></code> as planned. This is an intentional restriction forcing caller to explicitly allow a relatively slow reallocation op. You'll note a similar suggestion for the other <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a>-using methods/operators.</p>
<p >Formally: If <code>capacity &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Non-negative desired minimum capacity. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2342b475fa8f2a67a9bb2cd1ba2c1b43" name="a2342b475fa8f2a67a9bb2cd1ba2c1b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2342b475fa8f2a67a9bb2cd1ba2c1b43">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>start_or_unchanged</em> = <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7667397ae554e4a9dcb9a3bf1bf33eb8">S_UNCHANGED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guarantees post-condition <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == size</code> and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == start</code>; no values in pre-call range <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>)</code> are changed; any values <em>added</em> to that range by the call are not initialized to zero or otherwise. </p>
<p >From other invariants and behaviors described, you'll realize this essentially means <code>reserve(size + start)</code> followed by saving <code>size</code> and <code>start</code> into internal size members. The various implications of this can be deduced by reading the related methods' doc headers. The key is to understand how <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> works, including what it disallows (growth in size of an existing buffer).</p>
<p >Formally: If <code>size &gt;= 1</code>, and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, then a buffer is allocated; and the internal ownership ref-count is set to 1.</p>
<h3>Leaving <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> unmodified</h3>
<p ><code>start</code> is taken to be the value of arg <code>start_or_unchanged</code>; unless the latter is set to special value <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7667397ae554e4a9dcb9a3bf1bf33eb8" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>; in which case <code>start</code> is taken to equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>. Since the default is indeed <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7667397ae554e4a9dcb9a3bf1bf33eb8" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>, the oft-encountered expression <code>resize(N)</code> will adjust only <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> and leave <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> unmodified &ndash; often the desired behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Non-negative desired value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>. </td></tr>
    <tr><td class="paramname">start_or_unchanged</td><td>Non-negative desired value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>; or special value <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a7667397ae554e4a9dcb9a3bf1bf33eb8" title="Special value indicating an unchanged size_type value; such as in resize().">S_UNCHANGED</a>. See above. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) or asynchronously when TRACE-logging in the event of buffer dealloc. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d1f09551d36d058c16d505c76a1780a" name="a6d1f09551d36d058c16d505c76a1780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f09551d36d058c16d505c76a1780a">&#9670;&nbsp;</a></span>share()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to <code>!zero()</code> blobs, this returns an identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it. </p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>: it is nonsensical to co-own nothing; just use the default ctor then.</p>
<p >The returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> is identical in that not only does it share the same memory area (hence same <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a>) but has identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> (and hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>). If you'd like to work on a different part of the allocated buffer, please consider <code>share_after_split*()</code> instead; the pool-of-sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s paradigm suggested in the class doc header is probably best accomplished using those methods and not <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>.</p>
<p >You can also adjust various sharing <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9c3497d662be650e7a560eb7a703acc1" title="Like start_past_prefix() but shifts the current prefix position by the given incremental value (posit...">start_past_prefix_inc()</a>, etc., directly &ndash; after <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> returns.</p>
<p >Formally: Before this returns, the internal ownership ref-count (shared among <code>*this</code> and the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>) is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An identical <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> to <code>*this</code> that shares the underlying allocated buffer. See above. </dd></dl>

</div>
</div>
<a id="adaab9186e23dd171d7ce84514a80c9d5" name="adaab9186e23dd171d7ce84514a80c9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaab9186e23dd171d7ce84514a80c9d5">&#9670;&nbsp;</a></span>share_after_split_equally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<div class="memtemplate">
template&lt;typename Emit_blob_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_equally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Emit_blob_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>emit_blob_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to successively performing <code>share_after_split_left(size)</code> until <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code>; the resultings <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s are emitted via <code>emit_blob_func()</code> callback in the order they're split off from the left. </p>
<p >In other words this partitions a non-zero() <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code> &ndash; perhaps typically used as a pool &ndash; into equally-sized (except possibly the last one) adjacent sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >A post-condition is that <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code> (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == 0</code>). In addition, if <code>headless_pool == true</code>, then <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code> is also a post-condition; i.e., the pool is "headless": it disappears once all the resulting sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s drop their ownership (as well as any other co-owning <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s). Otherwise, <code>*this</code> will continue to share the pool despite <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> becoming 0. (Of course, even then, one is free to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> or destroy <code>*this</code> &ndash; the former, before returning, is all that <code>headless_pool == true</code> really adds.)</p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> == true</code> (including if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, but even if not) or if <code>size == 0</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae515e3769cc901b75789713636a1688e" title="share_after_split_equally() wrapper that places Basic_blobs into the given container via push_back().">share_after_split_equally_emit_seq()</a> for a convenience wrapper to emit to, say, <code>vector&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>. </dd>
<dd>
<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a918dd61f8b24ebfb8b3aba5920b1d13f" title="share_after_split_equally() wrapper that places Ptr&lt;Basic_blob&gt;s into the given container via push_ba...">share_after_split_equally_emit_ptr_seq()</a> for a convenience wrapper to emit to, say, <code>vector&lt;unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;&gt;</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Emit_blob_func</td><td>A callback compatible with signature <code>void F(Basic_blob&amp;&amp; blob_moved)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> of each successive out-Basic_blob, except the last one. Behavior undefined (assertion may trip) if not positive. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>Whether to perform <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a></code> just before returning. See above. </td></tr>
    <tr><td class="paramname">emit_blob_func</td><td><code>F</code> such that <code>F(std::move(blob))</code> shall be called with each successive sub-Basic_blob. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a918dd61f8b24ebfb8b3aba5920b1d13f" name="a918dd61f8b24ebfb8b3aba5920b1d13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918dd61f8b24ebfb8b3aba5920b1d13f">&#9670;&nbsp;</a></span>share_after_split_equally_emit_ptr_seq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<div class="memtemplate">
template&lt;typename Blob_ptr_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_equally_emit_ptr_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blob_ptr_container *&#160;</td>
          <td class="paramname"><em>out_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code>Ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>s into the given container via <code>push_back()</code>, where the type <code>Ptr&lt;&gt;</code> is determined via <code>Blob_ptr_container::value_type</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Blob_ptr_container</td><td>Something with method compatible with <code>push_back(Ptr&amp;&amp; blob_ptr_moved)</code>, where <code>Ptr</code> is <code>Blob_ptr_container::value_type</code>, and <code>Ptr(new Basic_blob)</code> can be created. <code>Ptr</code> is to be a smart pointer type such as <code>unique_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code> or <code>shared_ptr&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">out_blobs</td><td><code>out_blobs-&gt;push_back()</code> shall be executed 1+ times. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae515e3769cc901b75789713636a1688e" name="ae515e3769cc901b75789713636a1688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae515e3769cc901b75789713636a1688e">&#9670;&nbsp;</a></span>share_after_split_equally_emit_seq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<div class="memtemplate">
template&lt;typename Blob_container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_equally_emit_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blob_container *&#160;</td>
          <td class="paramname"><em>out_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> wrapper that places <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s into the given container via <code>push_back()</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Blob_container</td><td>Something with method compatible with <code>push_back(Basic_blob&amp;&amp; blob_moved)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">out_blobs</td><td><code>out_blobs-&gt;push_back()</code> shall be executed 1+ times. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92215c61d9e3ca83bdbfa6b078b72dc9" name="a92215c61d9e3ca83bdbfa6b078b72dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92215c61d9e3ca83bdbfa6b078b72dc9">&#9670;&nbsp;</a></span>share_after_split_equally_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<div class="memtemplate">
template&lt;typename Emit_blob_func , typename Share_after_split_left_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_equally_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>headless_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Emit_blob_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>emit_blob_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Share_after_split_left_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>share_after_split_left_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impl of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a> but capable of emitting not just <code>*this</code> type (<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;...&gt;</code>) but any sub-class (such as <code>Blob</code>/<code>Sharing_blob</code>) provided a functor like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning an object of that appropriate type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Emit_blob_func</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>; however it is to take the type to emit which can be <code>*this</code> <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> or a sub-class. </td></tr>
    <tr><td class="paramname">Share_after_split_left_func</td><td>A callback with signature identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> but returning the same type emitted by <code>Emit_blob_func</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">headless_pool</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">emit_blob_func</td><td>See <code>Emit_blob_func</code>. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classflow_1_1util_1_1Basic__blob.html#adaab9186e23dd171d7ce84514a80c9d5" title="Identical to successively performing share_after_split_left(size) until this-&gt;empty() == true; the re...">share_after_split_equally()</a>. </td></tr>
    <tr><td class="paramname">share_after_split_left_func</td><td>See <code>Share_after_split_left_func</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e6fd467f8ac364edf13915713e36969" name="a3e6fd467f8ac364edf13915713e36969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6fd467f8ac364edf13915713e36969">&#9670;&nbsp;</a></span>share_after_split_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applicable to <code>!zero()</code> blobs, this shifts <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> by <code>size</code> to the right without changing <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>; and returns a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> containing the shifted-past values that shares (co-owns) <code>*this</code> allocated buffer along with <code>*this</code> and any other <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s also sharing it. </p>
<p >More formally, this is identical to simply <code>auto b = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>; b.resize(size); start_past_prefix_inc(size);</code>.</p>
<p >This is useful when working in the pool-of-sub-<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s paradigm. This and other <code>share_after_split*()</code> methods are usually better to use rather than <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a> directly (for that paradigm).</p>
<p >Behavior is undefined (assertion may trip) if <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>.</p>
<p >Corner case: If <code>size &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code>, then it is taken to equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>.</p>
<p >Degenerate case: If <code>size</code> (or <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>, whichever is smaller) is 0, then this method is identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>. Probably you don't mean to call <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> in that case, but it's your decision.</p>
<p >Degenerate case: If <code>size == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a></code> (and not 0), then <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a></code> becomes <code>true</code> &ndash; though <code>*this</code> continues to share the underlying buffer despite [<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>) becoming empty. Typically this would only be done as, perhaps, the last iteration of some progressively-splitting loop; but it's your decision.</p>
<p >Formally: Before this returns, the internal ownership ref-count (shared among <code>*this</code> and the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>) is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> of the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>; and the number of elements by which <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> is shifted right (hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> is incremented). Any value exceeding <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> is taken to equal it. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split-off-on-the-left <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares the underlying allocated buffer with <code>*this</code>. See above. </dd></dl>

</div>
</div>
<a id="aacc565dcada148095cb14863387d5696" name="aacc565dcada148095cb14863387d5696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc565dcada148095cb14863387d5696">&#9670;&nbsp;</a></span>share_after_split_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::share_after_split_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>, except <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> shifts by <code>size</code> to the left (instead of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a> to the right), and the split-off <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> contains the *right-most*</code>size` elements (instead of the left-most). </p>
<p >More formally, this is identical to simply <code>auto lt_size = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> - size; auto b = <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">share()</a>; resize(lt_size); b.start_past_prefix_inc(lt_size);</code>. Cf. <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a> formal definition and note the symmetry.</p>
<p >All other characteristics are as written for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e6fd467f8ac364edf13915713e36969" title="Applicable to !zero() blobs, this shifts this-&gt;begin() by size to the right without changing end(); a...">share_after_split_left()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Desired <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> of the returned <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>; and the number of elements by which <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code> is shifted left (hence <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> is decremented). Any value exceeding <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> is taken to equal it. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split-off-on-the-right <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> that shares the underlying allocated buffer with <code>*this</code>. See above. </dd></dl>

</div>
</div>
<a id="a8c04d217b83800f818c794da17dc8e4b" name="a8c04d217b83800f818c794da17dc8e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c04d217b83800f818c794da17dc8e4b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored, namely <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> - <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is 0; but if this is 0, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a64ea173065830ef1a744458a7d05b833" name="a64ea173065830ef1a744458a7d05b833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea173065830ef1a744458a7d05b833">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">::size_type</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset between <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code> and the start of the internally allocated buffer. </p>
<p >If <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a>, this is 0; but if this is 0, then <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> may or may not be <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af98832169c8e46d84f6c06987a3670e3" name="af98832169c8e46d84f6c06987a3670e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98832169c8e46d84f6c06987a3670e3">&#9670;&nbsp;</a></span>start_past_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::start_past_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#af9b27f4b460a0fa8a9c9638174a9433a">size_type</a>&#160;</td>
          <td class="paramname"><em>prefix_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restructures blob to consist of an internally allocated buffer and a <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, end)</code> range starting at offset <code>prefix_size</code> within that buffer. </p>
<p >More formally, it is a simple <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a> wrapper that ensures the internally allocated buffer remains unchanged or, if none is currently large enough to store <code>prefix_size</code> elements, is allocated to be of size <code>prefix_size</code>; and that <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == prefix_size</code>.</p>
<p >All of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>'s behavior, particularly any restrictions about <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> growth, applies, so in particular remember you may need to first <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af431f32bde5ed1ba255e3e1cbbcbd906" title="Guarantees post-condition zero() == true by dropping *this ownership of the allocated internal buffer...">make_zero()</a> if the internal buffer would need to be REallocated to satisfy the above requirements.</p>
<p >In practice, with current <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a328b40fe431698b38b48b66397664d1f" title="Ensures that an internal buffer of at least capacity elements is allocated and owned; disallows growi...">reserve()</a> (and thus <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43" title="Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...">resize()</a>) restrictions &ndash; which are intentional &ndash; this method is most useful if you already have a <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a> with internally allocated buffer of size <em>at least</em> <code>n == <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a></code> (and <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> == 0</code> for simplicity), and you'd like to treat this buffer as containing no-longer-relevant prefix of length S (which becomes new value for <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a>) and have <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> be readjusted down accordingly, while <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a> == n</code> remains unchaged. If the buffer also contains irrelevant data <em>past</em> a certain offset N, you can first make it irrelevant via <code>resize(N)</code> (then call <code>start_past_prefix(S)</code> as just described):</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a> b;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// b now has start() == 0, size() == M.</span></div>
<div class="line"><span class="comment">// We want all elements outside [S, N] to be irrelevant, where S &gt; 0, N &lt; M.</span></div>
<div class="line"><span class="comment">// (E.g., first S are a frame prefix, while all bytes past N are a frame postfix, and we want just the frame</span></div>
<div class="line"><span class="comment">// without any reallocating or copying.)</span></div>
<div class="line">b.<a class="code hl_function" href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43">resize</a>(N);</div>
<div class="line">b.<a class="code hl_function" href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3">start_past_prefix</a>(S);</div>
<div class="line"><span class="comment">// Now, [b.begin(), b.end()) are the frame bytes, and no copying/allocation/deallocation has occurred.</span></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a></div><div class="ttdoc">A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...</div><div class="ttdef"><b>Definition:</b> basic_blob.hpp:241</div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html_a2342b475fa8f2a67a9bb2cd1ba2c1b43"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html#a2342b475fa8f2a67a9bb2cd1ba2c1b43">flow::util::Basic_blob::resize</a></div><div class="ttdeci">void resize(size_type size, size_type start_or_unchanged=S_UNCHANGED, log::Logger *logger_ptr=0)</div><div class="ttdoc">Guarantees post-condition size() == size and start() == start; no values in pre-call range [begin(),...</div><div class="ttdef"><b>Definition:</b> basic_blob.hpp:2044</div></div>
<div class="ttc" id="aclassflow_1_1util_1_1Basic__blob_html_af98832169c8e46d84f6c06987a3670e3"><div class="ttname"><a href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3">flow::util::Basic_blob::start_past_prefix</a></div><div class="ttdeci">void start_past_prefix(size_type prefix_size)</div><div class="ttdoc">Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...</div><div class="ttdef"><b>Definition:</b> basic_blob.hpp:2079</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix_size</td><td>Desired prefix length. <code>prefix_size == 0</code> is allowed and is a degenerate case equivalent to: <code>resize(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">size()</a>, 0)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3497d662be650e7a560eb7a703acc1" name="a9c3497d662be650e7a560eb7a703acc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3497d662be650e7a560eb7a703acc1">&#9670;&nbsp;</a></span>start_past_prefix_inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::start_past_prefix_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a614d9cd750d8db928b4d1e045ef15c56">difference_type</a>&#160;</td>
          <td class="paramname"><em>prefix_size_inc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classflow_1_1util_1_1Basic__blob.html#af98832169c8e46d84f6c06987a3670e3" title="Restructures blob to consist of an internally allocated buffer and a [begin(), end) range starting at...">start_past_prefix()</a> but shifts the <em>current</em> prefix position by the given <em>incremental</em> value (positive or negative). </p>
<p >Identical to <code>start_past_prefix(<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + prefix_size_inc)</code>.</p>
<p >Behavior is undefined for negative <code>prefix_size_inc</code> whose magnitue exceeds <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> (assertion may trip).</p>
<p >Behavior is undefined in case of positive <code>prefix_size_inc</code> that results in overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix_size_inc</td><td>Positive, negative (or zero) increment, so that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> is changed to <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">start()</a> + prefix_size_inc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac24a23b94cd10a4dd6088d3e3f2fe2f" name="aac24a23b94cd10a4dd6088d3e3f2fe2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac24a23b94cd10a4dd6088d3e3f2fe2f">&#9670;&nbsp;</a></span>sub_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::sub_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::asio::mutable_buffer &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opposite of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3d154ee5afaee08a62397174f9f7a879" title="Copies src buffer directly onto equally sized area within *this at location dest; *this must have suf...">emplace_copy()</a> in every way, copying a sub-blob onto a target memory area. </p>
<p >Note that the size of that target buffer (<code>dest.size()</code>) determines how much of <code>*this</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source location within this blob. This must be in <code>[<a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a>]</code>; and, unless <code>dest.size() == 0</code>, must not equal <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> either. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination memory area. Behavior is undefined if this memory area overlaps at any point with the memory area of same size at <code>src</code> (unless that size is zero &ndash; a degenerate case). Otherwise it can be anywhere at all, even partially or fully within <code>*this</code>. Also behavior undefined if <code>src + dest.size()</code> is past end of <code>*this</code> blob (assertion may trip). </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location in this blob just past the last element copied; <code>src</code> if none copied; <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a> is a possible value. </dd></dl>

</div>
</div>
<a id="a835d127753a70d8c397a1a6153cab78d" name="a835d127753a70d8c397a1a6153cab78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835d127753a70d8c397a1a6153cab78d">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>, or no-op if <code>this == &amp;other</code>. </p>
<p >Performance: at most this involves swapping a few scalars which is constant-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73e09b11e0067730db64f1fac7620a04" name="a73e09b11e0067730db64f1fac7620a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e09b11e0067730db64f1fac7620a04">&#9670;&nbsp;</a></span>valid_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::valid_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a3e21c26d61b50e019987097f7779ed51">Const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if: <code>this-&gt;derefable_iterator(it) || (it == this-&gt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae4f1d8c42aea63ba4f127cb7ed5776d6" title="Returns pointer one past immutable last element; empty() is possible.">const_end()</a>)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator/pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1a64646d656ec125fa8973ccf843c1be" name="a1a64646d656ec125fa8973ccf843c1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a64646d656ec125fa8973ccf843c1be">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::zero</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>false</code> if a buffer is allocated and owned; <code>true</code> otherwise. </p>
<p >See important notes on how this relates to <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a797741a0a5c95b13b36f356ae8d397e8" title="Returns size() == 0.">empty()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a719e5c04e4bdc65c31976fc385fd7f24" title="Returns the number of elements in the internally allocated buffer, which is 1 or more; or 0 if no buf...">capacity()</a> in those methods' doc headers. See also other important notes in class doc header.</p>
<p >Note that <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> is <code>true</code> for any default-constructed <a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af567381736851969f6e8812c54404028" name="af567381736851969f6e8812c54404028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af567381736851969f6e8812c54404028">&#9670;&nbsp;</a></span>blobs_sharing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blobs_sharing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if both given objects are not <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a1a64646d656ec125fa8973ccf843c1be" title="Returns false if a buffer is allocated and owned; true otherwise.">zero()</a> == true</code>, and they either co-own a common underlying buffer, or <em>are</em> the same object. </p>
<p >Note: by the nature of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">Basic_blob::share()</a>, a <code>true</code> returned value is orthogonal to whether <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a64ea173065830ef1a744458a7d05b833" title="Returns the offset between begin() and the start of the internally allocated buffer.">Basic_blob::start()</a> and <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a8c04d217b83800f818c794da17dc8e4b" title="Returns number of elements stored, namely end() - begin().">Basic_blob::size()</a> values are respectively equal; <code>true</code> may be returned even if their [<code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a9daa427a42c8a8c24b585f96c37d277a" title="Returns pointer to mutable first element; or end() if empty().">begin()</a></code>, <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html#a61880291749335246f60fde4387f7ad6" title="Returns pointer one past mutable last element; empty() is possible.">end()</a></code>) ranges don't overlap at all &ndash; as long as the allocated buffer is co-owned by the 2 <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a></code>s.</p>
<p >If <code>&amp;blob1 != &amp;blob2</code>, <code>true</code> indicates <code>blob1</code> was obtained from <code>blob2</code> via a chain of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a6d1f09551d36d058c16d505c76a1780a" title="Applicable to !zero() blobs, this returns an identical Basic_blob that shares (co-owns) *this allocat...">Basic_blob::share()</a> (or wrapper thereof) calls, or vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob1</td><td>Object. </td></tr>
    <tr><td class="paramname">blob2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>blob1</code> and <code>blob2</code> both operate on the same underlying buffer. </dd></dl>

</div>
</div>
<a id="a71eaa4ab6a2673ed34fa8989c47a7bc0" name="a71eaa4ab6a2673ed34fa8989c47a7bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eaa4ab6a2673ed34fa8989c47a7bc0">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Basic__blob.html">Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>blob1.swap(blob2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob1</td><td>Object. </td></tr>
    <tr><td class="paramname">blob2</td><td>Object. </td></tr>
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use in <em>this</em> routine (synchronously) only. Null allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab79d366c55643022eaf9e0d7378165d7" name="ab79d366c55643022eaf9e0d7378165d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79d366c55643022eaf9e0d7378165d7">&#9670;&nbsp;</a></span>S_IS_VANILLA_ALLOC</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , bool S_SHARING_ALLOWED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classflow_1_1util_1_1Basic__blob.html">flow::util::Basic_blob</a>&lt; Allocator, S_SHARING_ALLOWED &gt;::S_IS_VANILLA_ALLOC = std::is_same_v&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db">Allocator_raw</a>, std::allocator&lt;<a class="el" href="classflow_1_1util_1_1Basic__blob.html#aeb9b64885b78263048d406ec34907ecf">value_type</a>&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a> underlying allocator template is simply <code>std::allocator</code>; <code>false</code> otherwise. </p>
<p >Note that if this is <code>true</code>, it may be worth using <a class="el" href="namespaceflow_1_1util.html#af09888b3a8feaff209b6625e493bc338" title="A concrete Blob_with_log_context that compile-time-disables Basic_blob::share() and the sharing API d...">Blob</a>/<a class="el" href="namespaceflow_1_1util.html#a164f043f9edc5e5ec8fc99a0e4eb9064" title="A concrete Blob_with_log_context that compile-time-enables Basic_blob::share() and the sharing API de...">Sharing_blob</a>, instead of its <code><a class="el" href="classflow_1_1util_1_1Basic__blob.html" title="A hand-optimized and API-tweaked replacement for vector&lt;uint8_t&gt;, i.e., buffer of bytes inside an all...">Basic_blob</a>&lt;std::allocator&gt;</code> super-class; at the cost of a marginally larger RAM footprint (an added <code>Logger*</code>) you'll get a more convenient set of logging API knobs (namely <code>Logger*</code> stored permanently from construction; and there will be no need to supply it as arg to subsequent APIs when logging is desired).</p>
<h3>Implications of <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ab79d366c55643022eaf9e0d7378165d7" title="true if Allocator_raw underlying allocator template is simply std::allocator; false otherwise.">S_IS_VANILLA_ALLOC</a> being <code>false</code></h3>
<p >This is introduced in our class doc header. Briefly however:</p><ul>
<li>The underlying buffer, if any, and possibly some small aux data shall be allocated via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>, not simply the regular heap's <code>new[]</code> and/or <code>new</code>.<ul>
<li>They shall be deallocated, if needed, via <a class="el" href="classflow_1_1util_1_1Basic__blob.html#ae2089286c63766445b3bf40422eb17db" title="Short-hand for the allocator type specified at compile-time. Its element type is our value_type.">Allocator_raw</a>, not simply the regular heap's <code>delete[]</code> and/or <code>delete</code>.</li>
</ul>
</li>
<li>Because storing a pointer to <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a> may be meaningless when storing in an area allocated by some custom allocators (particularly SHM-heap ones), we shall not auto-TRACE-log on dealloc.<ul>
<li>This caveat applies only if <a class="el" href="classflow_1_1util_1_1Basic__blob.html#a67db182946127383fb48d6a1afbdca90" title="Value of template parameter S_SHARING_ALLOWED (for generic programming).">S_SHARING</a> is <code>true</code>. </li>
</ul>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="basic__blob_8hpp.html">basic_blob.hpp</a></li>
<li>util/<a class="el" href="blob__fwd_8hpp.html">blob_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 11 2024 02:13:39 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
