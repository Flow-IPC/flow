<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::net_flow::Peer_socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1net__flow.html">net_flow</a></li><li class="navelem"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1net__flow_1_1Peer__socket-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::net_flow::Peer_socket Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes and reliability support.  
 <a href="classflow_1_1net__flow_1_1Peer__socket.html#details">More...</a></p>

<p><code>#include &lt;peer_socket.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::net_flow::Peer_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket__inherit__graph.svg" width="554" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::net_flow::Peer_socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1net__flow_1_1Peer__socket__coll__graph.svg" width="378" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6a9bb727c8982f24bcf978c10c2c7345"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a> { <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189">S_OPEN</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f">S_CLOSED</a>
 }</td></tr>
<tr class="memdesc:a6a9bb727c8982f24bcf978c10c2c7345"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">More...</a><br /></td></tr>
<tr class="separator:a6a9bb727c8982f24bcf978c10c2c7345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f48d01d1269c9d4260d972baa40e548"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> { <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb">S_CONNECTING</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe">S_CONNECTED</a>
, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9">S_DISCONNECTING</a>
 }</td></tr>
<tr class="memdesc:a6f48d01d1269c9d4260d972baa40e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sub-state of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">More...</a><br /></td></tr>
<tr class="separator:a6f48d01d1269c9d4260d972baa40e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;</a></td></tr>
<tr class="memitem:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top"><a id="aa4f1af88393042e60159a3a67f0accbc" name="aa4f1af88393042e60159a3a67f0accbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = boost::shared_ptr&lt; Peer_socket &gt;</td></tr>
<tr class="memdesc:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to mutable values of type <code>Target_type::element_type</code> (a-la <code>T*</code>). <br /></td></tr>
<tr class="separator:aa4f1af88393042e60159a3a67f0accbc inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top"><a id="aef7998db71c60eeb5d1e3d1a97c14886" name="aef7998db71c60eeb5d1e3d1a97c14886"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_ptr</b> = Const_target_ptr</td></tr>
<tr class="memdesc:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to immutable values of type <code>Target_type::element_type</code> (a-la <code>T const *</code>). <br /></td></tr>
<tr class="separator:aef7998db71c60eeb5d1e3d1a97c14886 inherit pub_types_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a729af2cb3465b67b811d8e9438b5af5d"><td class="memItemLeft" align="right" valign="top"><a id="a729af2cb3465b67b811d8e9438b5af5d" name="a729af2cb3465b67b811d8e9438b5af5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Peer_socket</b> () override</td></tr>
<tr class="memdesc:a729af2cb3465b67b811d8e9438b5af5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor. Note that deletion is to be handled exclusively via <code>shared_ptr</code>, never explicitly. <br /></td></tr>
<tr class="separator:a729af2cb3465b67b811d8e9438b5af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982953b5136c1df488066eacc293a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">state</a> (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> *open_sub_state=0) const</td></tr>
<tr class="memdesc:af982953b5136c1df488066eacc293a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current State of the socket.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78">More...</a><br /></td></tr>
<tr class="separator:af982953b5136c1df488066eacc293a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e7e1be830c901bc7348742e79ba2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">node</a> () const</td></tr>
<tr class="memdesc:aa9e7e1be830c901bc7348742e79ba2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa9e7e1be830c901bc7348742e79ba2e7">More...</a><br /></td></tr>
<tr class="separator:aa9e7e1be830c901bc7348742e79ba2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended other side of the connection (regardless of success, failure, or current State).  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5e423a9fd18a45cc7cc5fc34af29161e">More...</a><br /></td></tr>
<tr class="separator:a5e423a9fd18a45cc7cc5fc34af29161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af387476aa0bdc6b3906c153d824acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">local_port</a> () const</td></tr>
<tr class="memdesc:a7af387476aa0bdc6b3906c153d824acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local Flow-protocol port chosen by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (if active or passive open) or user (if passive open) for this side of the connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7af387476aa0bdc6b3906c153d824acb">More...</a><br /></td></tr>
<tr class="separator:a7af387476aa0bdc6b3906c153d824acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">get_connect_metadata</a> (const boost::asio::mutable_buffer &amp;buffer, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the serialized connect metadata, as supplied by the user during the connection handshake.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a0c99637726b3c2b2ff1dbf14c6c92752">More...</a><br /></td></tr>
<tr class="separator:a0c99637726b3c2b2ff1dbf14c6c92752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90b656d7e0b7e746b8beb4e24717cec"><td class="memTemplParams" colspan="2">template&lt;typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:af90b656d7e0b7e746b8beb4e24717cec"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec">send</a> (const Const_buffer_sequence &amp;data, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af90b656d7e0b7e746b8beb4e24717cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asynchronously sends them to the other side.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec">More...</a><br /></td></tr>
<tr class="separator:af90b656d7e0b7e746b8beb4e24717cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70629642551f18e474b87c128d2d77e2"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:a70629642551f18e474b87c128d2d77e2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">sync_send</a> (const Const_buffer_sequence &amp;data, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a70629642551f18e474b87c128d2d77e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2">More...</a><br /></td></tr>
<tr class="separator:a70629642551f18e474b87c128d2d77e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a28cb6fc51585c9fa2bf2f152675615a1">sync_send</a> (const boost::asio::null_buffers &amp;, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a28cb6fc51585c9fa2bf2f152675615a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Writable state is reached &ndash; the actual data are not moved out of any buffer, leaving that to the caller to do if desired.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a28cb6fc51585c9fa2bf2f152675615a1">More...</a><br /></td></tr>
<tr class="separator:a28cb6fc51585c9fa2bf2f152675615a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memTemplParams" colspan="2">template&lt;typename Const_buffer_sequence &gt; </td></tr>
<tr class="memitem:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6b9fa02a7c41b52fde9e05e862a9d20f">sync_send</a> (const Const_buffer_sequence &amp;data, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_send(data, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a6b9fa02a7c41b52fde9e05e862a9d20f">More...</a><br /></td></tr>
<tr class="separator:a6b9fa02a7c41b52fde9e05e862a9d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f3d07ec71e46ff8f4c4d1bbc44079">sync_send</a> (const boost::asio::null_buffers &amp;, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_send(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_send(null_buffers)</code> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d1f3d07ec71e46ff8f4c4d1bbc44079">More...</a><br /></td></tr>
<tr class="separator:a7d1f3d07ec71e46ff8f4c4d1bbc44079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memTemplParams" colspan="2">template&lt;typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0">receive</a> (const Mutable_buffer_sequence &amp;target, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of bytes as inferred from size of provided target buffer sequence.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0">More...</a><br /></td></tr>
<tr class="separator:aeb88e9253cc3f52269cb762c8e57e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b77e546fff9394ef8d509e2ae771b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:a256b77e546fff9394ef8d509e2ae771b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">sync_receive</a> (const Mutable_buffer_sequence &amp;target, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a256b77e546fff9394ef8d509e2ae771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b">More...</a><br /></td></tr>
<tr class="separator:a256b77e546fff9394ef8d509e2ae771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d796625339aa1aae09326091509d18"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a45d796625339aa1aae09326091509d18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a45d796625339aa1aae09326091509d18">sync_receive</a> (const boost::asio::null_buffers &amp;, const boost::chrono::duration&lt; Rep, Period &gt; &amp;max_wait, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a45d796625339aa1aae09326091509d18"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Readable state is reached &ndash; the actual data are not moved into any buffer, leaving that to the caller to do if desired.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a45d796625339aa1aae09326091509d18">More...</a><br /></td></tr>
<tr class="separator:a45d796625339aa1aae09326091509d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memTemplParams" colspan="2">template&lt;typename Mutable_buffer_sequence &gt; </td></tr>
<tr class="memitem:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af5143886b33b4f16e4fbfbe3a4e91e44">sync_receive</a> (const Mutable_buffer_sequence &amp;target, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_receive(target, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#af5143886b33b4f16e4fbfbe3a4e91e44">More...</a><br /></td></tr>
<tr class="separator:af5143886b33b4f16e4fbfbe3a4e91e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4429aead81514f99e3120a0b96667cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a4429aead81514f99e3120a0b96667cb5">sync_receive</a> (const boost::asio::null_buffers &amp;, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a4429aead81514f99e3120a0b96667cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>sync_receive(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_receive(null_buffers)</code> with no timeout.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a4429aead81514f99e3120a0b96667cb5">More...</a><br /></td></tr>
<tr class="separator:a4429aead81514f99e3120a0b96667cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab710704237f912eb219f9b8d574afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">close_abruptly</a> (<a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9ab710704237f912eb219f9b8d574afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as if fatal error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8" title="User code on this side abruptly closed connection; other side may be informed of this.">error::Code::S_USER_CLOSED_ABRUPTLY</a> has been discovered on the connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc">More...</a><br /></td></tr>
<tr class="separator:a9ab710704237f912eb219f9b8d574afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31cf18a3c075873de1c46c0176e41f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">set_options</a> (const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts, <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7d31cf18a3c075873de1c46c0176e41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>) with the given options set.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f">More...</a><br /></td></tr>
<tr class="separator:a7d31cf18a3c075873de1c46c0176e41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">options</a> () const</td></tr>
<tr class="memdesc:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this socket's option set and returns that copy.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d">More...</a><br /></td></tr>
<tr class="separator:ad94e37c8cca01f801f13e9e0e0bc857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">info</a> () const</td></tr>
<tr class="memdesc:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a structure containing the most up-to-date stats about this connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712">More...</a><br /></td></tr>
<tr class="separator:aad81cc16fc6f0d353fdc1379e1dd4712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f821dde38a7aa572651730744edbd8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">max_block_size</a> () const</td></tr>
<tr class="memdesc:aa1f821dde38a7aa572651730744edbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes of user data per received or sent packet on this connection.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8">More...</a><br /></td></tr>
<tr class="separator:aa1f821dde38a7aa572651730744edbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6fd527766fdeb05a96c5c03729a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">disconnect_cause</a> () const</td></tr>
<tr class="memdesc:a74f6fd527766fdeb05a96c5c03729a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a74f6fd527766fdeb05a96c5c03729a00">More...</a><br /></td></tr>
<tr class="separator:a74f6fd527766fdeb05a96c5c03729a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1util_1_1Null__interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1util_1_1Null__interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Null__interface.html">flow::util::Null_interface</a></td></tr>
<tr class="memitem:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">~Null_interface</a> ()=0</td></tr>
<tr class="memdesc:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boring <code>virtual</code> destructor.  <a href="classflow_1_1util_1_1Null__interface.html#a5916282577627e424a09884347eddbba">More...</a><br /></td></tr>
<tr class="separator:a5916282577627e424a09884347eddbba inherit pub_methods_classflow_1_1util_1_1Null__interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context.html">flow::log::Log_context</a></td></tr>
<tr class="memitem:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=0)</td></tr>
<tr class="memdesc:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a null <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a>.  <a href="classflow_1_1log_1_1Log__context.html#ae7100d2dd130d8f130e3e64fdb1f4fd9">More...</a><br /></td></tr>
<tr class="separator:ae7100d2dd130d8f130e3e64fdb1f4fd9 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> by storing the given pointer to a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> and a new <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> storing the specified generically typed payload (an <code>enum</code> value).  <a href="classflow_1_1log_1_1Log__context.html#af1ac7f30ab442c3c6aa6079335df6c9a">More...</a><br /></td></tr>
<tr class="separator:af1ac7f30ab442c3c6aa6079335df6c9a inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">Log_context</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that stores equal <code>Logger*</code> and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> values as the source.  <a href="classflow_1_1log_1_1Log__context.html#a5c57a7f44959a01ca9a1c948a6686cc0">More...</a><br /></td></tr>
<tr class="separator:a5c57a7f44959a01ca9a1c948a6686cc0 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">Log_context</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that makes this equal to <code>src</code>, while the latter becomes as-if default-constructed.  <a href="classflow_1_1log_1_1Log__context.html#a3d4e624833d96bdafa1485ffff472509">More...</a><br /></td></tr>
<tr class="separator:a3d4e624833d96bdafa1485ffff472509 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;src)</td></tr>
<tr class="memdesc:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that behaves similarly to the copy constructor.  <a href="classflow_1_1log_1_1Log__context.html#a5d628315d5a93908d47a281980d3113e">More...</a><br /></td></tr>
<tr class="separator:a5d628315d5a93908d47a281980d3113e inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that behaves similarly to the move constructor.  <a href="classflow_1_1log_1_1Log__context.html#aae857197aecba8606c32296bc7bec308">More...</a><br /></td></tr>
<tr class="separator:aae857197aecba8606c32296bc7bec308 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context.html">Log_context</a> &amp;other)</td></tr>
<tr class="memdesc:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointers and <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> objects held by <code>*this</code> and <code>other</code>.  <a href="classflow_1_1log_1_1Log__context.html#aa6bb8e4250586425631ef80063caf155">More...</a><br /></td></tr>
<tr class="separator:aa6bb8e4250586425631ef80063caf155 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">get_logger</a> () const</td></tr>
<tr class="memdesc:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">Logger</a> pointer, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#af4db395042b065b00398cd59845dcb4d">More...</a><br /></td></tr>
<tr class="separator:af4db395042b065b00398cd59845dcb4d inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">get_log_component</a> () const</td></tr>
<tr class="memdesc:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the stored <a class="el" href="classflow_1_1log_1_1Component.html" title="A light-weight class, each object storing a component payload encoding an enum value from enum type o...">Component</a> object, particularly as many <code>FLOW_LOG_*()</code> macros expect.  <a href="classflow_1_1log_1_1Log__context.html#a8a5fef42dc2cedf3c0d1a6e83beb2948">More...</a><br /></td></tr>
<tr class="separator:a8a5fef42dc2cedf3c0d1a6e83beb2948 inherit pub_methods_classflow_1_1log_1_1Log__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5003c554807f5b5b58989ad58be48d42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">Peer_socket</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> *task_engine, const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;opts)</td></tr>
<tr class="memdesc:a5003c554807f5b5b58989ad58be48d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a5003c554807f5b5b58989ad58be48d42">More...</a><br /></td></tr>
<tr class="separator:a5003c554807f5b5b58989ad58be48d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8497776b61df32a79707c264f8f2422b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a8497776b61df32a79707c264f8f2422b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *sock)</td></tr>
<tr class="memdesc:a8497776b61df32a79707c264f8f2422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of given socket to given standard <code>ostream</code> and returns the latter.  <a href="classflow_1_1net__flow_1_1Peer__socket.html#a8497776b61df32a79707c264f8f2422b">More...</a><br /></td></tr>
<tr class="separator:a8497776b61df32a79707c264f8f2422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html">flow::util::Shared_ptr_alias_holder&lt; boost::shared_ptr&lt; Peer_socket &gt; &gt;</a></td></tr>
<tr class="memitem:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides syntactic-sugary way to perform a <code>static_pointer_cast&lt;&gt;</code> from a compatible smart pointer type <code>From_ptr</code>, typically <code>From_ptr::element_type</code> being in the same class hierarchy as <code>Target_ptr::element_type</code>.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81">More...</a><br /></td></tr>
<tr class="separator:a55a247bb8fb2ec94b7cbfdd56be65a81 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but adds <code>const</code>-ness (immutability) to the pointed-to type.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8">More...</a><br /></td></tr>
<tr class="separator:a520b351b1463e585e278c8c7241b8fc8 inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aa4f1af88393042e60159a3a67f0accbc">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">dynamic_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a55a247bb8fb2ec94b7cbfdd56be65a81" title="Provides syntactic-sugary way to perform a static_pointer_cast&lt;&gt; from a compatible smart pointer type...">ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#ac242f13a290877e84e44165e00a5905c">More...</a><br /></td></tr>
<tr class="separator:ac242f13a290877e84e44165e00a5905c inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#aef7998db71c60eeb5d1e3d1a97c14886">Const_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">dynamic_const_ptr_cast</a> (const From_ptr &amp;ptr_to_cast)</td></tr>
<tr class="memdesc:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a520b351b1463e585e278c8c7241b8fc8" title="Identical to ptr_cast() but adds const-ness (immutability) to the pointed-to type.">const_ptr_cast()</a> but a <code>dynamic_pointer_cast</code> instead of static.  <a href="classflow_1_1util_1_1Shared__ptr__alias__holder.html#a013713e08c6537f91d6bdba29fcccdff">More...</a><br /></td></tr>
<tr class="separator:a013713e08c6537f91d6bdba29fcccdff inherit pub_static_methods_classflow_1_1util_1_1Shared__ptr__alias__holder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes and reliability support. </p>
<p >Reliability is enabled or disabled via a socket option, <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#a6c35e6014182ccfcbee6bed4571a8360" title="Whether to enable reliability via retransmission.">Peer_socket_options::m_st_rexmit_on</a>, at socket creation. Use unreliable mode with care &ndash; see <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> method doc header for details.</p>
<h3>Life cycle of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a></h3>
<p >A given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> can arise either by connecting to <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> on a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> or <a class="el" href="classflow_1_1net__flow_1_1Node.html#aba2e6fc905dbeef3ea9e31bf844f8da5" title="The blocking (synchronous) version of connect().">Node::sync_connect()</a>), or by listening on a <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> and accepting such a connection (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#a02ba529163a2d50132eff7aec9d9c9b8" title="Blocking (synchronous) version of accept().">Server_socket::sync_accept()</a>). In all cases, <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> or <a class="el" href="classflow_1_1net__flow_1_1Server__socket.html" title="A server socket able to listen on a single Flow port for incoming connections and return peer sockets...">Server_socket</a> generates a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and returns it (factory pattern). <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is not instantiable otherwise. A <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> cannot be deleted explicitly by the user and will only be returned via <code>boost::shared_ptr&lt;&gt;</code>; when both the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> and all user code no longer refers to it, the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> will be destroyed.</p>
<p >Once a <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code> user has a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> object, that object represents a socket in one of the following basic states:</p>
<ul>
<li>Open.<ul>
<li>Sub-states:<ul>
<li>Connecting. (Never Writable, never Readable.)</li>
<li>Connected. (May be Writable, may be Readable.)</li>
<li>Disconnecting. (May be Readable, never Writable.)</li>
</ul>
</li>
</ul>
</li>
<li>Closed.<ul>
<li>Socket can neither read nor write.</li>
</ul>
</li>
</ul>
<p >Open.Connecting means means <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> initiated a connect to the given server, and this is in progress. Open.Connected means the connection to the other <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is fully functional. Open.Disconnecting means either our side or the other side has initiated a clean or abrupt disconnect, but it is not yet entirely finished (background handshaking is happening, you have not read all available data or sent all queued data, etc.).</p>
<p >In either case, reading and writing may or may not be possible at a given time, depending on the state of the internal buffers and the data having arrived on the logical connection. Thus all Open sub-states can and often should be treated the same way in a typical Flow-protocol-using algorithm: simply determine when the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is Readable, and read; and similarly for Writable and write. Thus the sub-states are distinguished for informational/diagnostic purposes only, as user reading/writing logic in these states should usually be identical.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>Closing connection considerations. May implement closing only via timeouts at first (as opposed to explicit closing). Below text refers to <code>close_final()</code> and <code>close_start()</code>, but those are just ideas and may be replaced with timeout, or nothing. At this time, the only closing supported is abrupt close due to error or abrupt close via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a>.</dd></dl>
<p >Closed means that the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> has become disconnected, and no data can possibly be received or sent, AND that <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has no more background internal operations to perform and has disowned the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. In other words, a Closed <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> is entirely dead.</p>
<p >Exactly the following state transitions are possible for a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> returned by <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>:</p>
<ul>
<li>start =&gt; Closed</li>
<li>start =&gt; Open</li>
<li>Open =&gt; Closed</li>
</ul>
<p >Note, in particular, that Closed is final; socket cannot move from Closed to Open. If after an error or valid disconnection you want to reestablish a connection, obtain a new <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> from <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>'s factories. Rationale (subject to change): this cuts down on state having to be tracked inside a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, while the interface becomes simpler without much impact on usability. Anti-rationale: contradicts BSD socket and boost.asio established practices; potentially more resource-intensive/slower in the event of errors and disconnects. Why IMO rationale &gt; anti-rationale: it's simpler, and the potential problems do not appear immediately serious; added statefulness can be added later if found desirable.</p>
<p >Receving, sending, and buffers: <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, like a TCP socket, has a Receive buffer (a/k/a FIFO queue of bytes) of some maximum size and a Send buffer (a/k/a FIFO queue of bytes) of some maximum size. They are typically not directly exposed via the interface, but their existence affects documented behavior. I formally describe them here, but generally they work similarly to TCP socket Send/Receive buffers.</p>
<p >The Receive buffer: Contains bytes asynchronously received on the connection that have not yet been removed with a <code>*receive()</code> method. Any bytes that asynchronously arrive on the connection are asynchronously stored to the buffer on the other side of the buffer in a queued fashion.</p>
<p >The Send buffer: Contains bytes intended to be asynchronously sent on the connection that have been placed there by a <code>*send()</code> method but not yet sent on the connection. Any bytes that are asynchronously sent on the connection are asynchronously removed from the buffer on the other side of the buffer in a queued fashion.</p>
<p >With that in mind, here are the definitions of Readable and Writable while state is Open:</p>
<ul>
<li>Readable &lt;=&gt; Data available in internal Receive buffer, and user has not explicitly announced via <code>close_final()</code> they're not interested in reading further.</li>
<li>Writable &lt;=&gt; Space for data available in internal Send buffer, and the state is Open.Connected.</li>
</ul>
<p >Note that neither definition really cares about the state of the network connection (e.g., could bytes actually be sent over the network at the moment?). There is one caveat: A socket is not Writable until Open.Connecting state is transitioned away from; this prevents user from buffering up send data before the connection is ready. (Allowing that would not necessarily be wrong, but I'm taking a cue from BSD socket semantics on this, as they seem to be convenient.)</p>
<p >In Open, the following archetypal operations are provided. (In Closed all immediately fail; in Open.Disconnecting some immediately fail if <code>close*()</code> has been called.) Let R be the current size of data in the Receive buffer, and S be the available space for data in the Send buffer.</p>
<ul>
<li><code>receive(N)</code>. If Readable, return to caller <code>min(N, R)</code> oldest data to have been received from the other side, and remove them from Receive buffer. Otherwise do nothing.</li>
<li><code>send(N)</code>. If Writable, take from caller <code>min(N, S)</code> data to be appended to the Send buffer and, when possible, sent to the other side. Otherwise do nothing.</li>
<li><code>sync_receive(N)</code>. If Readable, <code>receive(N)</code>. Otherwise sleep until Readable, then <code>receive(N)</code>.</li>
<li><code>sync_send(N)</code>. If Writable, <code>send(N)</code>. Otherwise sleep until Writable, then <code>send(N)</code>.</li>
</ul>
<p >These are similar to TCP Receive and Send APIs in non-blocking mode, and TCP Receive and Send APIs in blocking mode, respectively. There may be other similarly themed methods, but all use these as semantic building blocks.</p>
<p >To understand the order of events, one can think of a disconnect-causing event (like a graceful close initiation from the remote socket) as a piece of data itself. Thus, for example, if 5 bytes are received and placed into the Receive buffer without being read by the user, and then a connection close is detected, the socket will be Readable until the 5 bytes have been <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>ed, and the next <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> (or <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>) would yield the error, since that's the order things happened. Similarly, suppose you've sent 5 bytes, but they haven't been yet sent over the wire and are sitting in the Send buffer. Then you trigger a graceful connection close. First the 5 bytes will be sent if possible, and then the closing procedure will actually begin.</p>
<p >Abrupt closes such as connection resets may force both buffers to be immediately emptied without giving to the user or writing to the other side, so that the above rule does not have to apply. Typically a connection reset means the socket is immediately unusable no matter what was in the buffers at the time, per BSD socket semantics.</p>
<h3>Efficiently reading/writing</h3>
<p >The <code>sync_*</code>() methods are efficient, in that they use no processor cycles until Readable or Writable is achieved (i.e., they sleep until that point). The non-blocking versions don't sleep/block, however. For a program using them to be efficient it should sleep until Readable or Writable and only then call <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>/send(), when data are certainly available for immediate reading or writing. Moreover, a complex program is likely to want to perform this sleep-and-conditional-wake on a set of several <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> objects simultaneously (similarly to <code>select()</code>, <code>epoll*()</code>, etc.). Use class <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> for this purpose.</p>
<h3>Thread safety</h3>
<p >Same as for <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. (Briefly: all operations safe for simultaneous execution on separate or the same object.) </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6f48d01d1269c9d4260d972baa40e548" name="a6f48d01d1269c9d4260d972baa40e548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f48d01d1269c9d4260d972baa40e548">&#9670;&nbsp;</a></span>Open_sub_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">flow::net_flow::Peer_socket::Open_sub_state</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sub-state of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb" name="a6f48d01d1269c9d4260d972baa40e548aae585d03fce4ac2011967830bf0ffbfb"></a>S_CONNECTING&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), and the connection to the remote <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> is currently being negotiated by this socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>. </p>
<p >A socket in this state may be Writable but cannot be Readable. However, except for diagnostic purposes, this state should generally be treated the same as S_CONNECTED. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe" name="a6f48d01d1269c9d4260d972baa40e548a357459237df4b1f8f34e81ce43e2d8fe"></a>S_CONNECTED&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through a passive connect (Node::accept() and the like) or an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), and the connection is (as far this socket's <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> knows) set up and functioning. </p>
<p >A socket in this state may be Writable or Readable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9" name="a6f48d01d1269c9d4260d972baa40e548ae2b40112ddbd5a78114d600ec26726b9"></a>S_DISCONNECTING&#160;</td><td class="fielddoc"><p >This <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> was created through a passive connect (Node::accept() and the like) or an active connect (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and the like), but since then either an active close, passive close, or an error has begun to close the connection, but data may still possibly arrive and be Readable; also data may have been "sent" but still sitting in the Send buffer and needs to be sent over the network. </p>
<p >A socket in this state may be Readable but cannot be Writable.</p>
<p >This implies that a non-S_CLOSED socket may be, at a lower level, disconnected. For example, say there are 5 bytes in the Receive buffer, and the other side sends a graceful disconnect packet to this socket. This means the connection is finished, but the user can still <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> the 5 bytes (without blocking). Then state will remain S_OPEN.S_DISCONNECTING until the last of the 5 bytes is received (gone from the buffer); at this point state may change to S_CLOSED (pending any other work <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> must do to be able to disown the socket). </p>
</td></tr>
</table>

</div>
</div>
<a id="a6a9bb727c8982f24bcf978c10c2c7345" name="a6a9bb727c8982f24bcf978c10c2c7345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9bb727c8982f24bcf978c10c2c7345">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">flow::net_flow::Peer_socket::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State of a <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" name="a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189"></a>S_OPEN&#160;</td><td class="fielddoc"><p >Future reads or writes may be possible. A socket in this state may be Writable or Readable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" name="a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f"></a>S_CLOSED&#160;</td><td class="fielddoc"><p >Neither future reads nor writes are possible, AND <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> has disowned the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5003c554807f5b5b58989ad58be48d42" name="a5003c554807f5b5b58989ad58be48d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5003c554807f5b5b58989ad58be48d42">&#9670;&nbsp;</a></span>Peer_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::net_flow::Peer_socket::Peer_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#adf23368210219716b6fd22d15b765cb6">util::Task_engine</a> *&#160;</td>
          <td class="paramname"><em>task_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object; initializes most values to well-defined (0, empty, etc.) but not necessarily meaningful values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>The Logger implementation to use subsequently. </td></tr>
    <tr><td class="paramname">task_engine</td><td>IO service for the timer(s) stored as data member(s). </td></tr>
    <tr><td class="paramname">opts</td><td>The options set to copy into this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a> and use subsequently. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ab710704237f912eb219f9b8d574afc" name="a9ab710704237f912eb219f9b8d574afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab710704237f912eb219f9b8d574afc">&#9670;&nbsp;</a></span>close_abruptly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flow::net_flow::Peer_socket::close_abruptly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acts as if fatal error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a35606f4143e15dbe6bc03a543599dec8" title="User code on this side abruptly closed connection; other side may be informed of this.">error::Code::S_USER_CLOSED_ABRUPTLY</a> has been discovered on the connection. </p>
<p >Does not block.</p>
<p >Post-condition: <code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a></code>. Additionally, assuming no loss on the network, the other side will close the connection with error <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a138a08bb4d41be4cdbc6311a1a617cf4" title="Other side reset an established connection.">error::Code::S_CONN_RESET_BY_OTHER_SIDE</a>.</p>
<p >Note: Discovering a fatal error on the connection would trigger all event waits on this socket (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>, <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a>, <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a43dfb881ab3a9488a6a60dd83ad21c85" title="Moves object to State::S_WAITING state, saves the given handler to be executed later (in a different,...">Event_set::async_wait()</a>) to execute on-event behavior (return, return, return, invoke handler, respectively). Therefore this method will cause just that, if applicable.</p>
<p >Note: As a corollary, a socket closing this way (or any other way) does NOT cause that socket's events (if any) to be removed from any <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> objects. Clearing an <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> of all or some sockets is the <a class="el" href="classflow_1_1net__flow_1_1Event__set.html" title="A user-set collection of sockets and desired conditions on those sockets (such as: &quot;socket has data t...">Event_set</a> user's responsibility (the classic way being <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a9ae292072a84d07c867536e3de3b878e" title="Clears all stored resources (any desired events, result events, and any handler saved by async_wait()...">Event_set::close()</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>The moment the other side is informed we have abruptly closed the connection, they will no longer be able to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> any of it (even if data had been queued up in their Receive buffer).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000047">Todo:</a></b></dt><dd>Currently this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> is the only way for the user to explicitly close one specified socket. All other ways are due to error (or other side starting graceful shutdown, once we implement that). Once we implement graceful close, via <code>close_start()</code> and <code>close_final()</code>, use of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> should be discouraged, or it may even be deprecated (e.g., <code><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a></code>s lack a way to initiate an abrupt close for a specific socket).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a9ab710704237f912eb219f9b8d574afc" title="Acts as if fatal error error::Code::S_USER_CLOSED_ABRUPTLY has been discovered on the connection.">close_abruptly()</a> return <code>bool</code> (<code>false</code> on failure)?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>, or &ndash; if socket already closed (<code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> == <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a></code>) &ndash; then the error that caused the closure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74f6fd527766fdeb05a96c5c03729a00" name="a74f6fd527766fdeb05a96c5c03729a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f6fd527766fdeb05a96c5c03729a00">&#9670;&nbsp;</a></span>disconnect_cause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> flow::net_flow::Peer_socket::disconnect_cause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error code that perviously caused <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af982953b5136c1df488066eacc293a78" title="Current State of the socket.">state()</a> to become <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, or success code if state is not CLOSED. </p>
<p >For example, error::code::S_CONN_RESET_BY_OTHER_SIDE (if was connected) or <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a074451c0bc9f5ae37e0c8fbe82677090" title="Other side did not complete connection handshake within the allowed time; perhaps no one is listening...">error::Code::S_CONN_TIMEOUT</a> (if was connecting)</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a0c99637726b3c2b2ff1dbf14c6c92752" name="a0c99637726b3c2b2ff1dbf14c6c92752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c99637726b3c2b2ff1dbf14c6c92752">&#9670;&nbsp;</a></span>get_connect_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::get_connect_metadata </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::mutable_buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the serialized connect metadata, as supplied by the user during the connection handshake. </p>
<p >If this side initiated the connection (<a class="el" href="classflow_1_1net__flow_1_1Node.html#a893c8393930110e2aa0823583e37cabd" title="Initiates an active connect to the specified remote Flow server.">Node::connect()</a> and friends), then this will equal what was passed to the connect_with_metadata() (or similar) method. More likely, if this side accepted the connection (<a class="el" href="classflow_1_1net__flow_1_1Server__socket.html#aeea8554e23c8d743ca4956c772adbf24" title="Non-blocking accept: obtain socket for the least recently established not-yet-obtained peer connectio...">Server_socket::accept()</a> and friends), then this will equal what the user on the OTHER side passed to connect_with_metadata() or similar.</p>
<dl class="section note"><dt>Note</dt><dd>It is up to the user to deserialize the metadata portably. One recommended convention is to use <code>boost::endian::native_to_little()</code> (and similar) before connecting; and on the other side use the reverse (<code>boost::endian::little_to_native()</code>) before using the value. Packet dumps will show a flipped (little-endian) representation, while with most platforms the conversion will be a no-op at compile time. Alternatively use <code>native_to_big()</code> and vice-versa. </dd>
<dd>
If a connect() variant without <code>_with_metadata</code> in the name was used, then the metadata are composed of a single byte with the zero value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to copy the metadata into. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the copied metadata. </dd></dl>

</div>
</div>
<a id="aad81cc16fc6f0d353fdc1379e1dd4712" name="aad81cc16fc6f0d353fdc1379e1dd4712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad81cc16fc6f0d353fdc1379e1dd4712">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__info.html">Peer_socket_info</a> flow::net_flow::Peer_socket::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a structure containing the most up-to-date stats about this connection. </p>
<dl class="section note"><dt>Note</dt><dd>At the cost of reducing locking overhead in 99.999999% of the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>'s operation, this method may take a bit of time to run. It's still probably only 10 times or so slower than a simple lock, work, unlock &ndash; there is a condition variable and stuff involved &ndash; but this may matter if done very frequently. So you probably should not. (Hmmm... where did I get these estimates, namely "10 times or so"?)</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Provide a similar <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aad81cc16fc6f0d353fdc1379e1dd4712" title="Returns a structure containing the most up-to-date stats about this connection.">info()</a> method that loads an existing structure (for structure reuse).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7af387476aa0bdc6b3906c153d824acb" name="a7af387476aa0bdc6b3906c153d824acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af387476aa0bdc6b3906c153d824acb">&#9670;&nbsp;</a></span>local_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceflow_1_1net__flow.html#a079d8cd87a68d1c5f04c6bce71f0061d">flow_port_t</a> flow::net_flow::Peer_socket::local_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The local Flow-protocol port chosen by the <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> (if active or passive open) or user (if passive open) for this side of the connection. </p>
<p >For a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, this will always return the same value, even if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>. However, when state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>, the port may be unused or taken by another socket.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aa1f821dde38a7aa572651730744edbd8" name="aa1f821dde38a7aa572651730744edbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f821dde38a7aa572651730744edbd8">&#9670;&nbsp;</a></span>max_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::max_block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes of user data per received or sent packet on this connection. </p>
<p >See <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html#aeaaf832a38a5e334789e81e214686ea7" title="The size of block that we will strive to (and will, assuming at least that many bytes are available i...">Peer_socket_options::m_st_max_block_size</a>. Note that this method is ESSENTIAL when using the socket in unreliable mode (assuming you want to implement reliability outside of <code><a class="el" href="namespaceflow_1_1net__flow.html" title="Flow module containing the API and implementation of the Flow network protocol, a TCP-inspired stream...">net_flow</a></code>).</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="aa9e7e1be830c901bc7348742e79ba2e7" name="aa9e7e1be830c901bc7348742e79ba2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e7e1be830c901bc7348742e79ba2e7">&#9670;&nbsp;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Node.html">Node</a> * flow::net_flow::Peer_socket::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a> that produced this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to (guaranteed valid) <a class="el" href="classflow_1_1net__flow_1_1Node.html" title="An object of this class is a single Flow-protocol networking node, in the sense that: (1) it has a di...">Node</a>; null if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>. </dd></dl>

</div>
</div>
<a id="ad94e37c8cca01f801f13e9e0e0bc857d" name="ad94e37c8cca01f801f13e9e0e0bc857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e37c8cca01f801f13e9e0e0bc857d">&#9670;&nbsp;</a></span>options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> flow::net_flow::Peer_socket::options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this socket's option set and returns that copy. </p>
<p >If you intend to use <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a> to modify a socket's options, we recommend you make the modifications on the copy returned by <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd>Provide a similar <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a> method that loads an existing structure (for structure reuse).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aeb88e9253cc3f52269cb762c8e57e6d0" name="aeb88e9253cc3f52269cb762c8e57e6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb88e9253cc3f52269cb762c8e57e6d0">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of bytes as inferred from size of provided target buffer sequence. </p>
<p >The data are copied into the user's structure and then removed from the Receive buffer.</p>
<p >The method does not block. In particular if there are no data already received from the other side, we return no data.</p>
<p >If the provided buffer has size zero, the method is a NOOP other than possibly logging.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes.</p><ol type="1">
<li>There are no data in the Receive buffer. Socket not Readable. 0 is returned; <code>*err_code</code> is set to success unless null; no data returned.</li>
<li>The socket is not yet fully connected (<code>S_OPEN+S_CONNECTING</code>). Socket not Readable. 0 is returned; <code>*err_code</code> is set to success unless null; no data returned.</li>
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. &gt;= 1 is returned; *err_code is set to success; data returned.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.)</li>
</ol>
<p >The semantics of -3- (the success case) are as follows. N bytes will be copied from Receive buffer beginning at the start of the <code>Mutable_buffer_sequence target</code>. These N bytes may be spread across 1 or more buffers in that sequence; the subdivision structure of the sequence of bytes into buffers has no effect on the bytes, or order thereof, that will be moved from the Receive buffer (e.g., <code>target</code> could be N+ 1-byte buffers, or one N+-byte buffer &ndash; the popped Receive buffer would be the same, as would be the extracted bytes). N equals the smaller of: the available bytes in the Receive buffer; and <code>buffer_size(target)</code>. We return N.</p>
<h3>Reliability and ordering guarantees</h3>
<p >See the <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>Type that models the boost.asio <code>MutableBufferSequence</code> concept (see Boost docs). Basically, it's any container with elements convertible to <code>boost::asio::mutable_buffer</code>; and bidirectional iterator support. Examples: <code>vector&lt;mutable_buffer&gt;</code>, <code>list&lt;mutable_buffer&gt;</code>. Why allow <code>mutable_buffer</code> instead of, say, <code>Sequence</code> of bytes? Same reason as boost.asio's receive functions: it allows a great amount of flexibility without sacrificing performance, since <code>boost::asio::buffer()</code> function can adapt lots of different objects (arrays, <code>vector</code>s, <code>string</code>s, and more of bytes, integers, and more). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Buffer sequence to which a stream of bytes to consume from Receive buffer will be written. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes consumed (placed into <code>target</code>). Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> returns. </dd></dl>

</div>
</div>
<a id="a5e423a9fd18a45cc7cc5fc34af29161e" name="a5e423a9fd18a45cc7cc5fc34af29161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e423a9fd18a45cc7cc5fc34af29161e">&#9670;&nbsp;</a></span>remote_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structflow_1_1net__flow_1_1Remote__endpoint.html">Remote_endpoint</a> &amp; flow::net_flow::Peer_socket::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended other side of the connection (regardless of success, failure, or current State). </p>
<p >For a given <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html" title="A peer (non-server) socket operating over the Flow network protocol, with optional stream-of-bytes an...">Peer_socket</a>, this will always return the same value, even if state is <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a6abcbd1be8478aa03e76aec9c540e14f" title="Neither future reads nor writes are possible, AND Node has disowned the Peer_socket.">State::S_CLOSED</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af90b656d7e0b7e746b8beb4e24717cec" name="af90b656d7e0b7e746b8beb4e24717cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90b656d7e0b7e746b8beb4e24717cec">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asynchronously sends them to the other side. </p>
<p >The data given is copied into <code>*this</code>, in the order given. Only as many bytes as possible without the Send buffer size exceeding a certain max are copied.</p>
<p >The method does not block. Data are then sent asynchronously (in the background).</p>
<p >Method does nothing except possibly logging if there are no bytes in data.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes.</p><ol type="1">
<li>There is no space in the Send buffer (usually due to network congestion). Socket not Writable. 0 is returned; <code>*err_code</code> is set to success unless null; no data buffered.</li>
<li>The socket is not yet fully connected (<code>S_OPEN+S_CONNECTING</code> state). Socket not Writable. 0 is returned; <code>*err_code</code> is set to success unless null; no data buffered.</li>
<li>There is space in the Send buffer, and socket connection is open (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. &gt;= 1 is returned; <code>*err_code</code> is set to success; data buffered.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.)</li>
</ol>
<p >The semantics of -3- (the success case) are as follows. N bytes will be copied into Send buffer from the start of the Const_buffer_sequence data. These N bytes may be spread across 1 or more buffers in that sequence; the subdivision structure of the sequence of bytes into buffers has no effect on what will be buffered in Send buffer (e.g., "data" could be N+ 1-byte buffers, or one N+-byte buffer &ndash; the result would be the same). N equals the smaller of: the available space in the Send buffer; and <code>buffer_size(data)</code>. We return N.</p>
<h3>Reliability and ordering guarantees: if the socket option rexmit-on is enabled</h3>
<p >Reliability and ordering are guaranteed, and there is no notion of message boundaries. There is no possibility of data duplication. In other words full stream-of-bytes functionality is provided, as in TCP.</p>
<h3>Reliability and ordering guarantees: if the socket option rexmit-on is NOT enabled</h3>
<p >NO reliability guarantees are given, UNLESS <em>ALL</em> calls to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> (and other <code>*send</code>() methods) satisfy the condition: '<code>buffer_size(data)</code> is a multiple of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a></code>'; AND all calls to <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> (and other <code>*receive()</code> methods) on the OTHER side satisfy the condition: '<code>buffer_size(target)</code> is a multiple of <code>sock-&gt;<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aa1f821dde38a7aa572651730744edbd8" title="The maximum number of bytes of user data per received or sent packet on this connection.">max_block_size()</a></code>.' If and only if these guidelines are followed, and there is no connection closure, the following reliability guarantee is made:</p>
<p >Let a "block" be a contiguous chunk of bytes in a "data" buffer sequence immediately following another "block," except the first "block" in a connection, which begins with the first byte of the "data" buffer sequence passed to the first <code>*send()</code> call on that connection. Then: Each given block will either be available to <code>*receive()</code> on the other side exactly once and without corruption; or not available to <code>*receive()</code> at all. Blocks may arrive in a different order than specified here, including with respect to other <code>*send()</code> calls performed before or after this one. In other words, these are guaranteed: block boundary preservation, protection against corruption, protection again duplication. These are not guaranteed: order preservation, delivery. Informally, the latter factors are more likely to be present on higher quality network paths.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Const_buffer_sequence</td><td>Type that models the boost.asio <code>ConstBufferSequence</code> concept (see Boost docs). Basically, it's any container with elements convertible to <code>boost::asio::const_buffer</code>; and bidirectional iterator support. Examples: <code>vector&lt;const_buffer&gt;</code>, <code>list&lt;const_buffer&gt;</code>. Why allow <code>const_buffer</code> instead of, say, <code>Sequence</code> of bytes? Same reason as boost.asio's send functions: it allows a great amount of flexibility without sacrificing performance, since <code>boost::asio::buffer()</code> function can adapt lots of different objects (arrays, <code>vector</code>s, <code>string</code>s, and more &ndash; composed of bytes, integers, and more). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer sequence from which a stream of bytes to add to Send buffer will be obtained. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> nor any subsequent <code>*send()</code> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to buffer. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> returns. </dd></dl>

</div>
</div>
<a id="a7d31cf18a3c075873de1c46c0176e41f" name="a7d31cf18a3c075873de1c46c0176e41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d31cf18a3c075873de1c46c0176e41f">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Peer_socket::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structflow_1_1net__flow_1_1Peer__socket__options.html">Peer_socket_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically replaces the current options set (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>) with the given options set. </p>
<p >Only those members of <code>opts</code> designated as dynamic (as opposed to static) may be different between <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a> and <code>opts</code>. If this is violated, it is an error, and no options are changed.</p>
<p >Typically one would acquire a copy of the existing options set via <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#ad94e37c8cca01f801f13e9e0e0bc857d" title="Copies this socket&#39;s option set and returns that copy.">options()</a>, modify the desired dynamic data members of that copy, and then apply that copy back by calling <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a7d31cf18a3c075873de1c46c0176e41f" title="Dynamically replaces the current options set (options()) with the given options set.">set_options()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The new options to apply to this socket. It is copied; no reference is saved. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Generated codes: <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ad7b8da59bb61205572fe985c29863e58" title="When setting options, tried to set an unchangeable (static) option.">error::Code::S_STATIC_OPTION_CHANGED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482a5e0c2b54a5427bc09ecf0dee603ce450" title="When setting options, at least one option&#39;s value violates a required condition on that option.">error::Code::S_OPTION_CHECK_FAILED</a>, <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482affac5d80b4e72f2e55bbbfadce2efd2e" title="Node not running.">error::Code::S_NODE_NOT_RUNNING</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a id="af982953b5136c1df488066eacc293a78" name="af982953b5136c1df488066eacc293a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982953b5136c1df488066eacc293a78">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345">Peer_socket::State</a> flow::net_flow::Peer_socket::state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6f48d01d1269c9d4260d972baa40e548">Open_sub_state</a> *&#160;</td>
          <td class="paramname"><em>open_sub_state</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current State of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_sub_state</td><td>Ignored if null. Otherwise, if and only if <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a6a9bb727c8982f24bcf978c10c2c7345a02dcbe46a8dfde95b9776744dacae189" title="Future reads or writes may be possible. A socket in this state may be Writable or Readable.">State::S_OPEN</a> is returned, <code>*open_sub_state</code> is set to the current sub-state of <code>S_OPEN</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current main state of the socket. </dd></dl>

</div>
</div>
<a id="a45d796625339aa1aae09326091509d18" name="a45d796625339aa1aae09326091509d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d796625339aa1aae09326091509d18">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Readable state is reached &ndash; the actual data are not moved into any buffer, leaving that to the caller to do if desired. </p>
<p >Hence, this is a way of waiting for Readable state that could be more concise in some situations than <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. <code>true</code> is returned; <code>*err_code</code> is set to success unless null.</li>
<li>The operation cannot proceed due to an error. <code>false</code> is returned; <code>*err_code</code> is set to the specific error unless null. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >Note that it is NOT possible to return <code>false</code> and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">Period</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are 1+ bytes ready to read; <code>false</code> if either a timeout has occurred (no bytes ready), or another error has occurred. </dd></dl>

</div>
</div>
<a id="a4429aead81514f99e3120a0b96667cb5" name="a4429aead81514f99e3120a0b96667cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429aead81514f99e3120a0b96667cb5">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_receive(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_receive(null_buffers)</code> with no timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

</div>
</div>
<a id="a256b77e546fff9394ef8d509e2ae771b" name="a256b77e546fff9394ef8d509e2ae771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256b77e546fff9394ef8d509e2ae771b">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>, except that if socket is not immediately Readable (i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> would return 0 and no error), waits until it is Readable (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> would return either &gt;0, or 0 and an error) and returns <code>receive(target, err_code)</code>. If a timeout is specified, and this timeout expires before socket is Readable, it acts as if <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> produced <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There are data in the Receive buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>) or gracefully shutting down (<code>S_OPEN+S_DISCONNECTING</code>). Socket Readable. &gt;= 1 is returned; <code>*err_code</code> is set to success unless null; data returned.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >The semantics of -1- (the success case) equal those of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>.</p>
<p >Note that it is NOT possible to return 0 and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="section see"><dt>See also</dt><dd>The version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See <code>boost::chrono::duration</code> documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait (i.e., no timeout). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#aeb88e9253cc3f52269cb762c8e57e6d0" title="Receives (consumes from the Receive buffer) bytes of data, up to a given maximum cumulative number of...">receive()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to target. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> returns. </dd></dl>

</div>
</div>
<a id="af5143886b33b4f16e4fbfbe3a4e91e44" name="af5143886b33b4f16e4fbfbe3a4e91e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5143886b33b4f16e4fbfbe3a4e91e44">&#9670;&nbsp;</a></span>sync_receive() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_receive </td>
          <td>(</td>
          <td class="paramtype">const Mutable_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_receive(target, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a> with no timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mutable_buffer_sequence</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

</div>
</div>
<a id="a28cb6fc51585c9fa2bf2f152675615a1" name="a28cb6fc51585c9fa2bf2f152675615a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cb6fc51585c9fa2bf2f152675615a1">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a></code> operating in <code>null_buffers</code> mode, wherein &ndash; if Writable state is reached &ndash; the actual data are not moved out of any buffer, leaving that to the caller to do if desired. </p>
<p >Hence, this is a way of waiting for Writable state that could be more concise in some situations than <a class="el" href="classflow_1_1net__flow_1_1Event__set.html#a133c518168fe3922ab6729a99077dd3f" title="Blocks indefinitely until one or more of the previously described events hold  or the wait is interr...">Event_set::sync_wait()</a>.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes:</p><ol type="1">
<li>There is space in the Send buffer; and socket is fully connected (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. <code>true</code> is returned; <code>*err_code</code> is set to success unless null.</li>
<li>The operation cannot proceed due to an error. <code>false</code> is returned; <code>*err_code</code> is set to the specific error unless null. <code>*err_code == S_WAIT_INTERRUPTED</code> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>). (If <code>err_code</code> null, Runtime_error thrown.)</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >Note that it is NOT possible to return <code>false</code> and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
    <tr><td class="paramname">Period</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_wait</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if 1+ bytes are possible to add to Send buffer; <code>false</code> if either a timeout has occurred (bytes not writable), or another error has occurred. </dd></dl>

</div>
</div>
<a id="a7d1f3d07ec71e46ff8f4c4d1bbc44079" name="a7d1f3d07ec71e46ff8f4c4d1bbc44079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1f3d07ec71e46ff8f4c4d1bbc44079">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const boost::asio::null_buffers &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_send(null_buffers(), duration::max(), err_code)</code>; i.e., <code>sync_send(null_buffers)</code> with no timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a256b77e546fff9394ef8d509e2ae771b" title="Blocking (synchronous) version of receive().">sync_receive()</a>. </dd></dl>

</div>
</div>
<a id="a70629642551f18e474b87c128d2d77e2" name="a70629642551f18e474b87c128d2d77e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70629642551f18e474b87c128d2d77e2">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking (synchronous) version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </p>
<p >Acts just like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>, except that if Socket is not immediately Writable (i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> would return 0 and no error), waits until it is Writable (<a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> would return either &gt;0, or 0 and an error) and returns <code>send(data, err_code)</code>. If a timeout is specified, and this timeout expires before socket is Writable, acts like <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> executed on an un-Writable socket.</p>
<h3>Error handling</h3>
<p >These are the possible outcomes (assuming there are data in the argument <code>data</code>).</p><ol type="1">
<li>There is space in the Send buffer, and socket connection is open (<code>S_OPEN+S_CONNECTED</code>). Socket Writable. &gt;= 1 is returned; <code>*err_code</code> is set to success unless null; data buffered.</li>
<li>The operation cannot proceed due to an error. 0 is returned; <code>*err_code</code> is set to the specific error unless null; no data buffered. (If <code>err_code</code> null, Runtime_error thrown.) The code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab92ec3b2b78d74acf0fda0786f601df5" title="A blocking (sync_) or background-blocking (async_) operation was interrupted, such as by a signal.">error::Code::S_WAIT_INTERRUPTED</a> means the wait was interrupted (similarly to POSIX's <code>EINTR</code>).</li>
<li>Neither condition above is detected before the timeout expires (if provided). Output semantics are the same as in 2, with the specific code <a class="el" href="namespaceflow_1_1net__flow_1_1error.html#a18e13de77b119ea0f2be411490859482ab835895723a7d71c964b84e0f0b78c3c" title="A blocking (sync_) or background-blocking (async_) operation timed out versus user-supplied time limi...">error::Code::S_WAIT_USER_TIMEOUT</a>.</li>
</ol>
<p >The semantics of -1- (the success case) equal those of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>.</p>
<p >Note that it is NOT possible to return 0 and no error.</p>
<p >Tip: Typical types you might use for <code>max_wait</code>: <code>boost::chrono::milliseconds</code>, <code>boost::chrono::seconds</code>, <code>boost::chrono::high_resolution_clock::duration</code>.</p>
<dl class="section see"><dt>See also</dt><dd>The version of <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Period</td><td>See boost::chrono::duration documentation (and see above tip). </td></tr>
    <tr><td class="paramname">Const_buffer_sequence</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>See <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a>. </td></tr>
    <tr><td class="paramname">max_wait</td><td>The maximum amount of time from now to wait before giving up on the wait and returning. <code>"duration&lt;Rep, Period&gt;::max()"</code> will eliminate the time limit and cause indefinite wait (i.e., no timeout). </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09" title="Short-hand for a boost.system error code (which basically encapsulates an integer/enum error code and...">flow::Error_code</a> docs for error reporting semantics. Error, except <code>WAIT_INTERRUPTED</code> or <code>WAIT_USER_TIMEOUT</code>, implies that neither this <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> nor any subsequent <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#af90b656d7e0b7e746b8beb4e24717cec" title="Sends (adds to the Send buffer) the given bytes of data up to a maximum internal buffer size; and asy...">send()</a> on this socket will succeeed. (In particular a clean disconnect is an error.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (possibly zero) added to Send buffer. Always 0 if <code>bool(*err_code) == true</code> when <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> returns. </dd></dl>

</div>
</div>
<a id="a6b9fa02a7c41b52fde9e05e862a9d20f" name="a6b9fa02a7c41b52fde9e05e862a9d20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9fa02a7c41b52fde9e05e862a9d20f">&#9670;&nbsp;</a></span>sync_send() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_buffer_sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t flow::net_flow::Peer_socket::sync_send </td>
          <td>(</td>
          <td class="paramtype">const Const_buffer_sequence &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow.html#a29eaaa9d0fac4ce87d8b969222dbed09">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>sync_send(data, duration::max(), err_code)</code>; i.e., <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a> with no timeout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Const_buffer_sequence</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html#a70629642551f18e474b87c128d2d77e2" title="Blocking (synchronous) version of send().">sync_send()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8497776b61df32a79707c264f8f2422b" name="a8497776b61df32a79707c264f8f2422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8497776b61df32a79707c264f8f2422b">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1net__flow_1_1Peer__socket.html">Peer_socket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of given socket to given standard <code>ostream</code> and returns the latter. </p>
<p >The representation includes the local and remote endpoints and the hex pointer value.</p>
<dl class="section note"><dt>Note</dt><dd><code>shared_ptr</code> forwards <code>ostream</code> output to the underlying pointer type, so this will affect <code>Ptr</code> output as well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to print to. </td></tr>
    <tr><td class="paramname">sock</td><td>Object to serialize. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>net_flow/<a class="el" href="peer__socket_8hpp.html">peer_socket.hpp</a></li>
<li>net_flow/<a class="el" href="net__flow__fwd_8hpp.html">net_flow_fwd.hpp</a></li>
<li>net_flow/<a class="el" href="peer__socket_8cpp.html">peer_socket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 9 2024 04:55:14 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
