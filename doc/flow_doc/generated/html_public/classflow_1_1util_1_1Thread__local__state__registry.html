<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Thread_local_state_registry&lt; Thread_local_state_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Thread__local__state__registry-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Thread_local_state_registry&lt; Thread_local_state_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Similar to <code>boost::thread_specific_ptr&lt;T&gt;</code> but with built-in lazy-init semantics; and more importantly on destruction deletes any outstanding <code>T</code>s belonging to threads that are still up; plus allows iteration through all per-thread data.  
 <a href="classflow_1_1util_1_1Thread__local__state__registry.html#details">More...</a></p>

<p><code>#include &lt;thread_lcl.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for flow::util::Thread_local_state_registry&lt; Thread_local_state_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Thread__local__state__registry__inherit__graph.svg" width="172" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for flow::util::Thread_local_state_registry&lt; Thread_local_state_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classflow_1_1util_1_1Thread__local__state__registry__coll__graph.svg" width="172" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflow_1_1util_1_1Thread__local__state__registry_1_1Metadata.html">Metadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General info (as of this writing for logging only) about a given entry (thread/object) in <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a>.  <a href="structflow_1_1util_1_1Thread__local__state__registry_1_1Metadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae7e3943eb37f5c1373b35d6784b0ef3d"><td class="memItemLeft" align="right" valign="top"><a id="ae7e3943eb37f5c1373b35d6784b0ef3d" name="ae7e3943eb37f5c1373b35d6784b0ef3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_local_state</b> = Thread_local_state_t</td></tr>
<tr class="memdesc:ae7e3943eb37f5c1373b35d6784b0ef3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template parameter type. See our class doc header for requirements. <br /></td></tr>
<tr class="separator:ae7e3943eb37f5c1373b35d6784b0ef3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab7dc8cc1e83209fee76f5bc02c38e1"><td class="memItemLeft" align="right" valign="top"><a id="a7ab7dc8cc1e83209fee76f5bc02c38e1" name="a7ab7dc8cc1e83209fee76f5bc02c38e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>State_per_thread_map</b> = boost::unordered_map&lt; <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">Thread_local_state</a> *, <a class="el" href="structflow_1_1util_1_1Thread__local__state__registry_1_1Metadata.html">Metadata</a> &gt;</td></tr>
<tr class="memdesc:a7ab7dc8cc1e83209fee76f5bc02c38e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a>. <br /></td></tr>
<tr class="separator:a7ab7dc8cc1e83209fee76f5bc02c38e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7bc04cffb26fbacf70059ec1ecbc66"><td class="memItemLeft" align="right" valign="top"><a id="aea7bc04cffb26fbacf70059ec1ecbc66" name="aea7bc04cffb26fbacf70059ec1ecbc66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Lock</b> = <a class="el" href="namespaceflow_1_1util.html#a5d2247b715da63e4b960909561b90ae7">Lock_guard</a>&lt; <a class="el" href="namespaceflow_1_1util.html#add6ade273326f27eaf9bfd170a909626">Mutex_non_recursive</a> &gt;</td></tr>
<tr class="memdesc:aea7bc04cffb26fbacf70059ec1ecbc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for mutex lock; made public for use in <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> and <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a>. <br /></td></tr>
<tr class="separator:aea7bc04cffb26fbacf70059ec1ecbc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c76d69dfd3ecd1f169feaf33175e321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a1c76d69dfd3ecd1f169feaf33175e321">Thread_local_state_registry</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr, <a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">String_view</a> nickname_str, decltype(<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7">m_create_state_func</a>)&amp;&amp;create_state_func={})</td></tr>
<tr class="memdesc:a1c76d69dfd3ecd1f169feaf33175e321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty registry.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a1c76d69dfd3ecd1f169feaf33175e321">More...</a><br /></td></tr>
<tr class="separator:a1c76d69dfd3ecd1f169feaf33175e321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d90136ea6dae2acd8e01709e2d589a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a1d90136ea6dae2acd8e01709e2d589a8">~Thread_local_state_registry</a> ()</td></tr>
<tr class="memdesc:a1d90136ea6dae2acd8e01709e2d589a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes each <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> to have been created so far by calls to <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> from various threads (possibly but not necessarily including this thread).  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a1d90136ea6dae2acd8e01709e2d589a8">More...</a><br /></td></tr>
<tr class="separator:a1d90136ea6dae2acd8e01709e2d589a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c1fdf013564b6510dd9db883a66562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">Thread_local_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562">this_thread_state</a> ()</td></tr>
<tr class="memdesc:a00c1fdf013564b6510dd9db883a66562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to this thread's thread-local object, first constructing it via <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a> if it is the first <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a></code> call in this thread.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562">More...</a><br /></td></tr>
<tr class="separator:a00c1fdf013564b6510dd9db883a66562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab721c0e81f502043ffcecaa6aefa810c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">Thread_local_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ab721c0e81f502043ffcecaa6aefa810c">this_thread_state_or_null</a> ()</td></tr>
<tr class="memdesc:ab721c0e81f502043ffcecaa6aefa810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to this thread's thread-local object, if it has been created via an earlier <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> call; or null if that has not yet occurred.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#ab721c0e81f502043ffcecaa6aefa810c">More...</a><br /></td></tr>
<tr class="separator:ab721c0e81f502043ffcecaa6aefa810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aca050b4111b28208e2dea02a981f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a7ab7dc8cc1e83209fee76f5bc02c38e1">State_per_thread_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6">state_per_thread</a> (const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aea7bc04cffb26fbacf70059ec1ecbc66">Lock</a> &amp;safety_lock) const</td></tr>
<tr class="memdesc:aa5aca050b4111b28208e2dea02a981f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to immutable container holding info for each thread in which <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> has been called: the keys are resulting <code>Thread_local_state*</code> pointers; the values are potentially interesting thread info such as thread ID.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6">More...</a><br /></td></tr>
<tr class="separator:aa5aca050b4111b28208e2dea02a981f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a1495f862b1ad71fd012bed9f8f26c"><td class="memTemplParams" colspan="2">template&lt;typename Task &gt; </td></tr>
<tr class="memitem:a77a1495f862b1ad71fd012bed9f8f26c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c">while_locked</a> (const Task &amp;task)</td></tr>
<tr class="memdesc:a77a1495f862b1ad71fd012bed9f8f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) contents of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> shall concurrently occur from within <code>*this</code> or other <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a></code> call(s); executes given task; and unlocks said mutex.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c">More...</a><br /></td></tr>
<tr class="separator:a77a1495f862b1ad71fd012bed9f8f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3ac24f6d4fe62a0f11100187d6fcc9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a7c3ac24f6d4fe62a0f11100187d6fcc9">nickname</a> () const</td></tr>
<tr class="memdesc:a7c3ac24f6d4fe62a0f11100187d6fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nickname, a brief string suitable for logging.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a7c3ac24f6d4fe62a0f11100187d6fcc9">More...</a><br /></td></tr>
<tr class="separator:a7c3ac24f6d4fe62a0f11100187d6fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c55a611d344428b30b00384611d6fd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a4c55a611d344428b30b00384611d6fd1">set_logger</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *logger_ptr)</td></tr>
<tr class="memdesc:a4c55a611d344428b30b00384611d6fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code>Log_context_mt::set_logger(logger_ptr)</code>; and &ndash; if <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#adecdeb578aabd468c70b2eda79566003" title="true if and only if Thread_local_state is a public sub-class of log::Log_context_mt which has implica...">S_TL_STATE_HAS_MT_LOG_CONTEXT</a> is <code>true</code> &ndash; propagates it to each extant <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> via <code>state-&gt;set_logger(logger_ptr)</code>.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a4c55a611d344428b30b00384611d6fd1">More...</a><br /></td></tr>
<tr class="separator:a4c55a611d344428b30b00384611d6fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classflow_1_1log_1_1Log__context__mt"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classflow_1_1log_1_1Log__context__mt')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classflow_1_1log_1_1Log__context__mt.html">flow::log::Log_context_mt</a></td></tr>
<tr class="memitem:a732505fa829624bd9b1ed4f8ce723243 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a732505fa829624bd9b1ed4f8ce723243">Log_context_mt</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger=nullptr)</td></tr>
<tr class="memdesc:a732505fa829624bd9b1ed4f8ce723243 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API.  <a href="classflow_1_1log_1_1Log__context__mt.html#a732505fa829624bd9b1ed4f8ce723243">More...</a><br /></td></tr>
<tr class="separator:a732505fa829624bd9b1ed4f8ce723243 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cca58ff9f167f4d6147c2a5f0ef81a4 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memTemplParams" colspan="2">template&lt;typename Component_payload &gt; </td></tr>
<tr class="memitem:a2cca58ff9f167f4d6147c2a5f0ef81a4 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a2cca58ff9f167f4d6147c2a5f0ef81a4">Log_context_mt</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger, Component_payload component_payload)</td></tr>
<tr class="memdesc:a2cca58ff9f167f4d6147c2a5f0ef81a4 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API.  <a href="classflow_1_1log_1_1Log__context__mt.html#a2cca58ff9f167f4d6147c2a5f0ef81a4">More...</a><br /></td></tr>
<tr class="separator:a2cca58ff9f167f4d6147c2a5f0ef81a4 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b9dbf4d015cbbd80fb77fceeb9d46 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a622b9dbf4d015cbbd80fb77fceeb9d46">Log_context_mt</a> (const <a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;src)</td></tr>
<tr class="memdesc:a622b9dbf4d015cbbd80fb77fceeb9d46 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API.  <a href="classflow_1_1log_1_1Log__context__mt.html#a622b9dbf4d015cbbd80fb77fceeb9d46">More...</a><br /></td></tr>
<tr class="separator:a622b9dbf4d015cbbd80fb77fceeb9d46 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9d72d7d054cb8092466701ddf55f94 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a4e9d72d7d054cb8092466701ddf55f94">Log_context_mt</a> (<a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a4e9d72d7d054cb8092466701ddf55f94 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API.  <a href="classflow_1_1log_1_1Log__context__mt.html#a4e9d72d7d054cb8092466701ddf55f94">More...</a><br /></td></tr>
<tr class="separator:a4e9d72d7d054cb8092466701ddf55f94 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ea950dbd7cf6db76641e22dd80516d inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a31ea950dbd7cf6db76641e22dd80516d">operator=</a> (const <a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;src)</td></tr>
<tr class="memdesc:a31ea950dbd7cf6db76641e22dd80516d inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API; but safe against concurrent operations on a <code>*this</code>.  <a href="classflow_1_1log_1_1Log__context__mt.html#a31ea950dbd7cf6db76641e22dd80516d">More...</a><br /></td></tr>
<tr class="separator:a31ea950dbd7cf6db76641e22dd80516d inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1da7d2f770c2b01bad747ce8362ea inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a62b1da7d2f770c2b01bad747ce8362ea">operator=</a> (<a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a62b1da7d2f770c2b01bad747ce8362ea inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API; but safe against concurrent operations on a <code>*this</code>.  <a href="classflow_1_1log_1_1Log__context__mt.html#a62b1da7d2f770c2b01bad747ce8362ea">More...</a><br /></td></tr>
<tr class="separator:a62b1da7d2f770c2b01bad747ce8362ea inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe75a837fa7caf8d241c3ff492a656 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a05fe75a837fa7caf8d241c3ff492a656">swap</a> (<a class="el" href="classflow_1_1log_1_1Log__context__mt.html">Log_context_mt</a> &amp;other)</td></tr>
<tr class="memdesc:a05fe75a837fa7caf8d241c3ff492a656 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API; but safe against concurrent operations on a <code>*this</code>.  <a href="classflow_1_1log_1_1Log__context__mt.html#a05fe75a837fa7caf8d241c3ff492a656">More...</a><br /></td></tr>
<tr class="separator:a05fe75a837fa7caf8d241c3ff492a656 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4cde1cebc684e940348452bea51665 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a8e4cde1cebc684e940348452bea51665">get_logger</a> () const</td></tr>
<tr class="memdesc:a8e4cde1cebc684e940348452bea51665 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API; but safe against concurrent operations on a <code>*this</code>.  <a href="classflow_1_1log_1_1Log__context__mt.html#a8e4cde1cebc684e940348452bea51665">More...</a><br /></td></tr>
<tr class="separator:a8e4cde1cebc684e940348452bea51665 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae966e47340336f0022195e0b73ed0527 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#ae966e47340336f0022195e0b73ed0527">set_logger</a> (<a class="el" href="classflow_1_1log_1_1Logger.html">Logger</a> *logger)</td></tr>
<tr class="memdesc:ae966e47340336f0022195e0b73ed0527 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API; but safe against concurrent operations on a <code>*this</code>.  <a href="classflow_1_1log_1_1Log__context__mt.html#ae966e47340336f0022195e0b73ed0527">More...</a><br /></td></tr>
<tr class="separator:ae966e47340336f0022195e0b73ed0527 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bf496e7c6ef07eae34aa3fa4fb0648 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classflow_1_1log_1_1Component.html">Component</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a85bf496e7c6ef07eae34aa3fa4fb0648">get_log_component</a> () const</td></tr>
<tr class="memdesc:a85bf496e7c6ef07eae34aa3fa4fb0648 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classflow_1_1log_1_1Log__context.html" title="Convenience class that simply stores a Logger and/or Component passed into a constructor; and returns...">Log_context</a> API.  <a href="classflow_1_1log_1_1Log__context__mt.html#a85bf496e7c6ef07eae34aa3fa4fb0648">More...</a><br /></td></tr>
<tr class="separator:a85bf496e7c6ef07eae34aa3fa4fb0648 inherit pub_methods_classflow_1_1log_1_1Log__context__mt"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3e1d258850df00cabc9f56892145a1b7"><td class="memItemLeft" align="right" valign="top">Function&lt; <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">Thread_local_state</a> *()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7">m_create_state_func</a></td></tr>
<tr class="memdesc:a3e1d258850df00cabc9f56892145a1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a>, when needing to create a thread's local new <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> to return, makes a stack copy of this member, calls that copy with no args, and uses the <code>Thread_local_state*</code> result as the return value for that thread.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7">More...</a><br /></td></tr>
<tr class="separator:a3e1d258850df00cabc9f56892145a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:adecdeb578aabd468c70b2eda79566003"><td class="memItemLeft" align="right" valign="top"><a id="adecdeb578aabd468c70b2eda79566003" name="adecdeb578aabd468c70b2eda79566003"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_TL_STATE_HAS_MT_LOG_CONTEXT</b></td></tr>
<tr class="memdesc:adecdeb578aabd468c70b2eda79566003"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if and only if <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> is a public sub-class of <a class="el" href="classflow_1_1log_1_1Log__context__mt.html" title="Identical to Log_context but is safe w/r/t to set_logger(), assignment, and swap() done concurrently ...">log::Log_context_mt</a> which has implications on <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a4c55a611d344428b30b00384611d6fd1" title="Performs Log_context_mt::set_logger(logger_ptr); and – if S_TL_STATE_HAS_MT_LOG_CONTEXT is true – pro...">set_logger()</a> and default <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a> behavior. <br /></td></tr>
<tr class="separator:adecdeb578aabd468c70b2eda79566003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a1df2ae2db7c1d7a9e3467d6042f3153f"><td class="memTemplParams" colspan="2">template&lt;typename Thread_local_state_t &gt; </td></tr>
<tr class="memitem:a1df2ae2db7c1d7a9e3467d6042f3153f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a1df2ae2db7c1d7a9e3467d6042f3153f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a>&lt; Thread_local_state_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a1df2ae2db7c1d7a9e3467d6042f3153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a> to a standard output stream.  <a href="classflow_1_1util_1_1Thread__local__state__registry.html#a1df2ae2db7c1d7a9e3467d6042f3153f">More...</a><br /></td></tr>
<tr class="separator:a1df2ae2db7c1d7a9e3467d6042f3153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Thread_local_state_t&gt;<br />
class flow::util::Thread_local_state_registry&lt; Thread_local_state_t &gt;</div><p >Similar to <code>boost::thread_specific_ptr&lt;T&gt;</code> but with built-in lazy-init semantics; and more importantly on destruction deletes any outstanding <code>T</code>s belonging to threads that are still up; plus allows iteration through all per-thread data. </p>
<p >An object of this type manages thread-local data as encapsulated in the user-supplied-as-template-arg type, each of which is instantiated (constructed) as needed for each given thread (on first <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> accessor call in that thread); and cleaned (via destructor) at each thread's exit or <code>*this</code> destruction &ndash; whichever occurs earlier.</p>
<h3>Overview/rationale</h3>
<p >Fundamentally <code><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a>&lt;T&gt;</code> is quite similar to <code>boost::thread_specific_ptr&lt;T&gt;</code>. There are some minor differences (it is more rigid, always using <code>new</code> and <code>delete</code> instead of leaving it to the user; mandating a lazy-initialization semantic instead of leaving it to the user; disallowing any reset to null and back from null), but these are just happenstance/preference-based. Likely we'd have just used the Boost guy, if that's all we wanted.</p>
<p >The main reason <code><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a>&lt;T&gt;</code> exists comprises the following (mutually related) features:</p><ol type="1">
<li>The ability to look at all per-thread data accumulated so far (from any thread). See <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> accessor (+ <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>).</li>
<li>If <code>~Thread_local_state_registry</code> (a <code>*this</code> dtor) executes before a given thread X (that has earlier caused the creation of a thread-local <code>T</code>, by calling <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a></code> from X) is joined (exits), then:<ul>
<li>That dtor, from whichever thread invoked it, deletes that thread-local <code>T</code> (for all <code>T</code>).</li>
</ul>
</li>
</ol>
<p >Feature 1 us a clear value-add over <code>thread_specific_ptr</code> (or just <code>static thread_local</code>). If one can get by without dealing with the set of per-thread objects from any 1 thread at a given time, that's good; it will involve far fewer corner cases and worries. Unfortunately it is not always possible to do that. In that case you want a <em>registry</em> of your <code>Thread_local_state</code>s; a <code>*this</code> provides this.</p>
<p >As for feature 2: Consider <code>static thread_specific_ptr</code> (or <code>static thread_local</code>, broadly speaking, without getting into the formal details of C++ language guarantees as to how such per-thread items are cleaned up). By definition of <code>static</code> the <code>thread_specific_ptr</code> will outlive any threads to have been spawned by the time <code>main()</code> exits. Therefore an implicit <code>.reset()</code> will execute when extant threads are joined, and each thread-local object will be cleaned up. No problem! However, a non-<code>static thread_specific_ptr</code> offers no such behavior or guarantee: If the <code>~thread_specific_ptr</code> dtor runs in thread X, at most that thread's TL object shall be auto-<code>.reset()</code>. The other extant threads' TL objects will live on (leak). (Nor can one iterate through them; that would be feature 1.)</p>
<p >However a <code>*this</code> being destroyed in thread X will cause an automatic looping through the extant threads' objects (if any) and their cleanup as well. So if you want that, use a <code>*this</code> instead of non-<code>static thread_specific_ptr</code>.</p>
<p >As a secondary reason (ignoring the above 2 features) <code><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a></code> has a more straightforward/rigid API that enforces certain assumptions/conventions (some of this is mentioned above). These might be appealing depending on one's taste/reasoning.</p>
<h3>How to use</h3>
<p >Ensure the template-arg <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> has a proper destructor; and either ensure it has default (no-arg) ctor (in which case it'll be created via <code>new Thread_local_state</code>), or assign <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a> (to choose a method of creation yourself).</p>
<p >Addendum: the default is <code>new Thread_local_state{this-&gt;<a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a8e4cde1cebc684e940348452bea51665" title="Identical to Log_context API; but safe against concurrent operations on a *this.">get_logger()</a>}</code> if and only if <code>Thread_local_state*</code> is convertible to <code>Log_context_mt*</code> (i.e., the latter is a <code>public</code> super-class of the former). See also Logging section below.</p>
<p >From any thread where you need a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>, call <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a></code>. The first time in a given thread, this shall perform and save <code>new Thread_local_state</code>; subsequent times it shall return the same pointer. (You can also save the pointer and reuse it; just be careful.)</p>
<p >A given thread's <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> object shall be deleted via <code>delete Thread_local_state</code> when one of the following occurs, whichever happens first:</p><ul>
<li>The thread exits (is joined). (Deletion occurs shortly before.)</li>
<li><code>*this</code> is destroyed (in some &ndash; any &ndash; thread, possibly a totally different one; or one of the ones for which <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> was called).</li>
</ul>
<p >That's it. It is simple. However we emphasize that using this properly may take some care: particularly as concerns the contents of the <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> dtor (whether auto-generated or explicit or some mix), which might run from the relevant thread X in which the underlying object was created and used; but it might also instead run from whichever thread invokes the <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a> dtor first.</p>
<p >See doc header for <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a1d90136ea6dae2acd8e01709e2d589a8" title="Deletes each Thread_local_state to have been created so far by calls to this_thread_state() from vari...">~Thread_local_state_registry()</a> (dtor) for more on that particular subject.</p>
<h3>How to iterate over/possibly modify other threads' data (safely)</h3>
<p >In short please see <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> doc header.</p>
<p >Also, particularly if you are employing some variation on the "thread-cached access to central state" pattern, it is potentially critical to read the relevant notes in the <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> doc header.</p>
<h3>Logging</h3>
<p >Logging is somewhat more subtle than is typically the case, because a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a> is often declared <code>static</code> or even global, which means a <a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a> might not be available at times such as before <code>main()</code>, after <code>main()</code>, or inside <code>main()</code> but outside when some main <code>Logger</code> is available. Therefore it is often useful to, e.g., start with <code>Logger* = nullptr</code>, change it to something else, then change it back.</p>
<p >Please use super-class <a class="el" href="classflow_1_1log_1_1Log__context__mt.html#ae966e47340336f0022195e0b73ed0527" title="Identical to Log_context API; but safe against concurrent operations on a *this.">log::Log_context_mt::set_logger()</a> accordingly.</p>
<p >However to avoid any trouble if <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> is called during a <code>Logger</code> change:</p><ul>
<li>Note that it is <code>Log_context_mt</code>, not <code>Log_context</code>, so this is thread-safe.<ul>
<li>Internally, perf-wise, we take steps to avoid this having any appreciable effect on fast-path performance.</li>
</ul>
</li>
<li>If and only if <code>Thread_local_state*</code> is convertible to <code>Log_context_mt*</code> (i.e., the latter is a <code>public</code> super-class of the former), <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a4c55a611d344428b30b00384611d6fd1" title="Performs Log_context_mt::set_logger(logger_ptr); and – if S_TL_STATE_HAS_MT_LOG_CONTEXT is true – pro...">set_logger()</a> shall invoke <code>state-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a4c55a611d344428b30b00384611d6fd1" title="Performs Log_context_mt::set_logger(logger_ptr); and – if S_TL_STATE_HAS_MT_LOG_CONTEXT is true – pro...">set_logger()</a></code> to each <code>state</code> in <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> (i.e., all <code>Thread_local_state</code>s currently extant).<ul>
<li>Note that you can override <code>Log_context_mt::set_logger()</code> in your <code>Thread_local_state</code> so as to, e.g., further propagate the new logger to other parts of <code>Thread_local_state</code> internals.</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Thread_local_state_t</td><td>Managed object type &ndash; see above. We repeat: must have no-arg (default) ctor, or be compatible with your custom <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a>; dtor must perform appropriate cleanup which in particular shall be run from exactly one of exactly the following 2 contexts: (1) from the thread in which it was created via <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a>, just before the thread exits; (2) from within the <code>*this</code> dtor from whichever thread that was invoked (which may be the creation-thread; one of the other creation-threads; or some other thread entirely). See dtor doc header. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1c76d69dfd3ecd1f169feaf33175e321" name="a1c76d69dfd3ecd1f169feaf33175e321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c76d69dfd3ecd1f169feaf33175e321">&#9670;&nbsp;</a></span>Thread_local_state_registry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::Thread_local_state_registry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceflow_1_1util.html#ae4dc52186797094b3040379ff19124c9">String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">decltype(<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7">m_create_state_func</a>)&amp;&amp;&#160;</td>
          <td class="paramname"><em>create_state_func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create empty registry. </p>
<p >Subsequently you may call <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> from any thread where you want to use (when called first time, create) thread-local state (a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a7c3ac24f6d4fe62a0f11100187d6fcc9" title="Returns nickname, a brief string suitable for logging.">nickname()</a>. </td></tr>
    <tr><td class="paramname">create_state_func</td><td>Initial value for <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a>. Default is an <code>.empty()</code> (see member doc header for info). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d90136ea6dae2acd8e01709e2d589a8" name="a1d90136ea6dae2acd8e01709e2d589a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d90136ea6dae2acd8e01709e2d589a8">&#9670;&nbsp;</a></span>~Thread_local_state_registry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::~<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes each <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> to have been created so far by calls to <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> from various threads (possibly but not necessarily including this thread). </p>
<h3>Careful!</h3>
<p >No thread (not the calling or any other thread) must access a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> returned from <code>*this</code>, once this dtor begins executing. This is usually pretty natural to guarantee by having your <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a> properly placed among various private data members and APIs accessing them.</p>
<p >The dtor in the type <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> itself must correctly run from <em>any</em> thread.</p><ul>
<li>For many things that's no problem... just normal C++ data and <code>unique_ptr</code>s and such.</li>
<li>For some resources it might be a problem, namely for resources that are thread-local in nature that must be explicitly freed via API calls. Example: flushing a memory manager's thread-cache X created for/in thread T might be only possible in thread T; while also being a quite-natural thing to do in that thread, during thread T cleanup. From any other thread it might lead to undefined behavior.<ul>
<li>In this case recall this <em>fact</em>: <code>~Thread_local_state()</code> shall run <em>either</em> from its relevant thread; <em>or</em> from the daddy <code><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a1d90136ea6dae2acd8e01709e2d589a8" title="Deletes each Thread_local_state to have been created so far by calls to this_thread_state() from vari...">~Thread_local_state_registry()</a></code>.</li>
<li>Usually in the latter case, everything is going down anyway &ndash; hence typically it is not necessary to specifically clean such per-thread resources as thread-caches.</li>
<li>So it is simple to:<ul>
<li>Save a data member containing, e.g., <code>boost::this_thread::get_id()</code> in <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>.</li>
<li>In its dtor check whether the thread-ID at <em>that</em> time equals the saved one. If so &ndash; great, clean the thing. If not &ndash; just don't (it is probably moot as shown above).</li>
<li>If it is not moot, you'll have to come up with something clever. Unlikely though. </li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c3ac24f6d4fe62a0f11100187d6fcc9" name="a7c3ac24f6d4fe62a0f11100187d6fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3ac24f6d4fe62a0f11100187d6fcc9">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns nickname, a brief string suitable for logging. </p>
<p >This is included in the output by the <code>ostream&lt;&lt;</code> operator as well. This always returns the same value.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a4c55a611d344428b30b00384611d6fd1" name="a4c55a611d344428b30b00384611d6fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c55a611d344428b30b00384611d6fd1">&#9670;&nbsp;</a></span>set_logger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::set_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1log_1_1Logger.html">log::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code>Log_context_mt::set_logger(logger_ptr)</code>; and &ndash; if <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#adecdeb578aabd468c70b2eda79566003" title="true if and only if Thread_local_state is a public sub-class of log::Log_context_mt which has implica...">S_TL_STATE_HAS_MT_LOG_CONTEXT</a> is <code>true</code> &ndash; propagates it to each extant <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> via <code>state-&gt;set_logger(logger_ptr)</code>. </p>
<dl class="section see"><dt>See also</dt><dd>also <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a> doc header w/r/t the effect of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#adecdeb578aabd468c70b2eda79566003" title="true if and only if Thread_local_state is a public sub-class of log::Log_context_mt which has implica...">S_TL_STATE_HAS_MT_LOG_CONTEXT</a> on that by default.</dd></dl>
<h3>Thread safety</h3>
<p >It is safe to call this concurrently with (any thread-first invocation of) <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> on <code>*this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. Reminder: can be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5aca050b4111b28208e2dea02a981f6" name="aa5aca050b4111b28208e2dea02a981f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aca050b4111b28208e2dea02a981f6">&#9670;&nbsp;</a></span>state_per_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a7ab7dc8cc1e83209fee76f5bc02c38e1">::State_per_thread_map</a> &amp; <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::state_per_thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aea7bc04cffb26fbacf70059ec1ecbc66">Lock</a> &amp;&#160;</td>
          <td class="paramname"><em>safety_lock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to immutable container holding info for each thread in which <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> has been called: the keys are resulting <code>Thread_local_state*</code> pointers; the values are potentially interesting thread info such as thread ID. </p>
<h3>What you may do</h3>
<p >You may access the returned data structure, including the <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> pointees, in read-only mode.</p>
<p >You may write to each individual <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> pointee. Moreover you are guaranteed (see "Thread safety" below) that no <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> user is doing the same simultaneously (by <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> contract).</p>
<p >If you <em>do</em> write to a particular pointee, remember these points:</p><ul>
<li>Probably (unless you intentionally avoid it) you're writing to it <em>not</em> from the thread to which it belongs (in the sense that <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> would be called to obtain the same pointer).</li>
<li>Therefore you must synchronize any such concurrent read/write accesses from this thread and the owner thread (your own code therein presumably). You can use a mutex, or the datum could be <code>atomic&lt;&gt;</code>; etc.<ul>
<li>Generally speaking, one uses thread-local stuff to avoid locking, so think hard before you do this. That said, locking is only expensive assuming lock contention; and if <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> work from a not-owner thread is rare, this might not matter perf-wise. It <em>does</em> matter complexity-wise though (typically), so informally we'd recommend avoiding it.</li>
<li>Things like <code>atomic&lt;bool&gt;</code> flags are pretty decent in these situations. E.g., one can put into <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> an <code>atomic&lt;bool&gt; m_do_flush{false}</code>; set it to <code>true</code> (with most-relaxed atomic mode) via <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> + <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> block when wanting a thread to perform an (e.g.) "flush" action; and in the owner-thread do checks like: <code>if (<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a>-&gt;m_do_flush.compare_exchange_strong(true, false, relaxed)) { flush_stuff(); }</code>. It is speedy and easy.</li>
</ul>
</li>
<li>You could also surround any access, from the proper owner thread, to that <code>Thread_local_state</code> pointee with <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>. Again, usually one uses thread-local stuff to avoid such central-locking actions; but it is conceivable to use it judiciously.</li>
</ul>
<h3>Thread safety</h3>
<p >Behavior is undefined, if this is called <em>not</em> from within <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>. Rationale: It might seem like it would have been safe to "just" make a copy of this container (while locking its contents briefly) and return that. In and of itself that's true, and as long as one never dereferences any <code>Thread_local_state</code> pointees, it is safe. (E.g., one could look at the thread IDs/nicknames in the thus-stored <a class="el" href="structflow_1_1util_1_1Thread__local__state__registry_1_1Metadata.html" title="General info (as of this writing for logging only) about a given entry (thread/object) in state_per_t...">Metadata</a> objects and log them. Not bad.) However dereferencing such a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> pointee is not safe outside <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>: at any moment its rightful-owning thread might exit and therefore <code>delete</code> it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">safety_lock</td><td>Please pass the argument to <code>task()</code> given to <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a00c1fdf013564b6510dd9db883a66562" name="a00c1fdf013564b6510dd9db883a66562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c1fdf013564b6510dd9db883a66562">&#9670;&nbsp;</a></span>this_thread_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">::Thread_local_state</a> * <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::this_thread_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to this thread's thread-local object, first constructing it via <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a3e1d258850df00cabc9f56892145a1b7" title="this_thread_state(), when needing to create a thread&#39;s local new Thread_local_state to return,...">m_create_state_func</a> if it is the first <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a></code> call in this thread. </p>
<p >In a given thread this shall always return the same pointer.</p>
<p >The pointee shall be destroyed from <code>*this</code> dtor or just before this thread's exit, from this thread, whichever occurs first. You may not call this, or use the returned pointer, after either routine begins executing.</p>
<h3>Thread-caching of central canonical state: Interaction with <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> and <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a></h3>
<p >The following is irrelevant in the fast-path, wherein this is <em>not</em> the first call to this method in the current thread. It is relevant only in the fast-path, wherein this <em>is</em> the first call to this method in the current thread. In that case we make the following formal guarantee:</p>
<ul>
<li>A ctor of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> is invoked (as you know).</li>
<li>It is invoked <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>.</li>
</ul>
<p >The most immediate consequence of the latter is simply: Do not call <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> inside <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> ctor; it will deadlock. That aside though:</p>
<p >What's the rationale for this guarantee? Answer: In many cases it does not matter, and other than the last bullet one would not need to worry about it. It <em>can</em> however matter in more complex setups, namely the pattern "thread-caching of central canonical state." In this pattern:</p>
<ul>
<li>Some kind of <em>central state</em> (e.g., <em>canonical</em> info being distributed into thread-local caches) must be<ul>
<li>seeded (copied, as a <em>pull</em>) into any new <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>; and</li>
<li>updated (copied, as a <em>push</em>) into any existing <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>, if the canonical state itself is modified (usually assumed to be rare).</li>
</ul>
</li>
<li>Suppose one invokes <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> whenever modifying the central (canonical) state (perhaps infrequently).<ul>
<li>And we also guarantee it is already in effect inside <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> ctor.</li>
<li>Hence, as is natural, we do the seeding/pulling of the central state inside that ctor.</li>
</ul>
</li>
<li>In that case <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> being active in the call stack (&lt;=&gt; its implied mutex being locked) guarantees the synchronization of the following state:<ul>
<li>which <code>Thread_local_state</code>s exist (in the sense that that they might be returned via <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> in the future) in the process;</li>
<li>the cached copies of the canonical state in all existent (as defined in previous bullet) <code>Thread_local_state</code>s;</li>
<li>the canonical state (equal to every cached copy!).</li>
</ul>
</li>
</ul>
<p >This simplifies thinking about the situation immensely, as to the extent that the central state is distributed to threads via thread-local <code>Thread_local_state</code> objects, the whole thing is monolithic: the state is synchronized to all relevant threads at all times. That said the following is an important corollary, at least for this use-case:</p>
<ul>
<li>Assumption: To be useful, the central-state-copy must be accessed by users in relevant threads, probably via an accessor; so something like: <code>const auto cool_state_copy = X.this_thread_state()-&gt;cool_state()</code>.<ul>
<li>There are of course variations on this; it could be a method of <code>Thread_local_state</code> that uses the value of the <code>private</code> central-state-copy for some computation. We'll use the accessor setup for exposition purposes.</li>
</ul>
</li>
<li>Fact: The central-state-copy inside <code>*X.<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a></code> for the current thread can change at any time.<ul>
<li>Therefore: cool_state() accessor, internally, <em>must</em> lock/unlock <em>some</em> mutex in order to guarantee synchronization.</li>
<li>It would be safe for cool_state() to "simply" use <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>. However, in any perf-sensitive scenario (which is essentially guaranteed to be the case: otherwise why setup thread-cached access to the cool-state in the first place?) this is utterly unacceptable. Now any threads using <code>-&gt;cool_state()</code> on their thread-local <code>Thread_local_state</code>s will contend for the same central mutex; it defeats the whole purpose.</li>
</ul>
</li>
<li>Hence the corollary:<ul>
<li>Probably you want to introduce your own additional mutex as a data member of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a>. Call it <code>m_cool_state_mutex</code>, say.</li>
<li>In <code>-&gt;cool_state()</code> impl, lock it, get the copy of the central-state-copy cool-state, unlock it, return the copy.</li>
<li>In the <em>push</em> code invoked when the <em>canonical</em> central-state is updated &ndash; as noted, this occurs <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> already &ndash; similarly, when pushing to per-thread <code>Thread_local_state* x</code>, lock <code>x-&gt;m_cool_state_mutex</code>, update the central-state-copy of <code>*x</code>, unlock.<ul>
<li>Since there are up to 2 mutexes involved (<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> central mutex, <code>x-&gt;m_cool_state_mutex</code> "little" mutex), there is some danger of deadlock; but if you are careful then it will be fine:<ul>
<li>Fast-path is in <code>x-&gt;cool_state()</code>: Only lock <code>x-&gt;m_cool_state_mutex</code>.</li>
<li>Slow-path 1 is in the central-state-updating (push) code: <code>while_locked(F)</code>; inside <code>F()</code> lock <code>x-&gt;m_cool_state_mutex</code> for each <code>x</code> in <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a>.</li>
<li>Slow-path 2 is in the <code>*x</code> ctor: central-state-init (pull) code: <code><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a></code> is automatically in effect inside <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a>; no need to lock <code>x-&gt;m_cool_state_mutex</code>, since no-place has access to <code>*x</code> until its ctor finishes and hence <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> returns.</li>
</ul>
</li>
</ul>
</li>
<li>The bad news: Your impl is no longer lock-free even in the fast-path: <code>X.this_thread_state()-&gt;cool_state()</code> does lock and unlock a mutex.</li>
<li>The good news: This mutex is ~never contended: At most 2 threads can even theoretically vie for it at a time; and except when <em>canonical</em> state must be updated (typically rare), it is only 1 thread. A regular mutex being locked/unlocked, sans contention, is quite cheap. This should more than defeat the preceding "bad news" bullet.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>See above. Never null. </dd></dl>

</div>
</div>
<a id="ab721c0e81f502043ffcecaa6aefa810c" name="ab721c0e81f502043ffcecaa6aefa810c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab721c0e81f502043ffcecaa6aefa810c">&#9670;&nbsp;</a></span>this_thread_state_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">::Thread_local_state</a> * <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::this_thread_state_or_null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to this thread's thread-local object, if it has been created via an earlier <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> call; or null if that has not yet occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a77a1495f862b1ad71fd012bed9f8f26c" name="a77a1495f862b1ad71fd012bed9f8f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a1495f862b1ad71fd012bed9f8f26c">&#9670;&nbsp;</a></span>while_locked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::while_locked </td>
          <td>(</td>
          <td class="paramtype">const Task &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) contents of <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> shall concurrently occur from within <code>*this</code> or other <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a></code> call(s); executes given task; and unlocks said mutex. </p>
<p >It is informally expected, though not required, that <code>task()</code> shall use <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a>. Please see <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#aa5aca050b4111b28208e2dea02a981f6" title="Returns reference to immutable container holding info for each thread in which this_thread_state() ha...">state_per_thread()</a> doc header.</p>
<p >Behavior is undefined (actually: deadlock) if task() calls <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a></code> (the mutex is non-recursive).</p>
<h3>Interaction with <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> ctor</h3>
<p >See <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> doc header. To briefly restate, though: <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> ctor, when invoked by <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> on first call in a given thread, is invoked inside a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a>. Therefore do not call <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> from such a ctor, as it will deadlock. From a more positive perspective, informally speaking: you may rely on <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a77a1495f862b1ad71fd012bed9f8f26c" title="Locks the non-recursive registry mutex, such that no access or modification of the (deep or shallow) ...">while_locked()</a> being active at all points inside a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task</td><td>Function object matching signature <code>void F(const Lock&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This will be invoked as follows: <code>task(lock)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1df2ae2db7c1d7a9e3467d6042f3153f" name="a1df2ae2db7c1d7a9e3467d6042f3153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df2ae2db7c1d7a9e3467d6042f3153f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">Thread_local_state_registry</a>&lt; Thread_local_state_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html" title="Similar to boost::thread_specific_ptr&lt;T&gt; but with built-in lazy-init semantics; and more importantly ...">Thread_local_state_registry</a> to a standard output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to serialize. </td></tr>
    <tr><td class="paramname">val</td><td>Value to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e1d258850df00cabc9f56892145a1b7" name="a3e1d258850df00cabc9f56892145a1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1d258850df00cabc9f56892145a1b7">&#9670;&nbsp;</a></span>m_create_state_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Thread_local_state_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function&lt;<a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d">Thread_local_state</a>* ()&gt; <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html">flow::util::Thread_local_state_registry</a>&lt; Thread_local_state_t &gt;::m_create_state_func</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a>, when needing to create a thread's local new <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> to return, makes a stack copy of this member, calls that copy with no args, and uses the <code>Thread_local_state*</code> result as the return value for that thread. </p>
<p >If, when needed, this value is null (<code>m_create_state_func.empty() == true</code>), then:</p><ul>
<li>If <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> is default-ctible and <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#adecdeb578aabd468c70b2eda79566003" title="true if and only if Thread_local_state is a public sub-class of log::Log_context_mt which has implica...">S_TL_STATE_HAS_MT_LOG_CONTEXT</a> is <code>false</code>: uses <code>new Thread_local_state</code>.</li>
<li>If <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#ae7e3943eb37f5c1373b35d6784b0ef3d" title="Short-hand for template parameter type. See our class doc header for requirements.">Thread_local_state</a> is ctible in form <code>Thread_local_state{lgr}</code> where (<code>lgr</code> is a <code><a class="el" href="classflow_1_1log_1_1Logger.html" title="Interface that the user should implement, passing the implementing Logger into logging classes (Flow&#39;...">log::Logger</a>*</code>), and <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#adecdeb578aabd468c70b2eda79566003" title="true if and only if Thread_local_state is a public sub-class of log::Log_context_mt which has implica...">S_TL_STATE_HAS_MT_LOG_CONTEXT</a> is <code>true</code>: uses <code>new Thread_local_state{<a class="el" href="classflow_1_1log_1_1Log__context__mt.html#a8e4cde1cebc684e940348452bea51665" title="Identical to Log_context API; but safe against concurrent operations on a *this.">get_logger()</a>}</code>.</li>
<li>Otherwise: Behavior is undefined (assertion may trip at this time).</li>
</ul>
<p ><code>m_create_state_func</code> must return a pointer that can be <code>delete</code>d in standard fashion.</p>
<h3>Thread safety</h3>
<p >It is not safe to assign this while a thread-first <a class="el" href="classflow_1_1util_1_1Thread__local__state__registry.html#a00c1fdf013564b6510dd9db883a66562" title="Returns pointer to this thread&#39;s thread-local object, first constructing it via m_create_state_func i...">this_thread_state()</a> is invoked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="thread__lcl_8hpp.html">thread_lcl.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 15 2026 00:48:59 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
