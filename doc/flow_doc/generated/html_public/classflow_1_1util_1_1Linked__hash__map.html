<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow: flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="namespaceflow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classflow_1_1util_1_1Linked__hash__map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An object of this class is a map that combines the lookup speed of an <code>unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>.  
 <a href="classflow_1_1util_1_1Linked__hash__map.html#details">More...</a></p>

<p><code>#include &lt;linked_hash_map.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c528ba7ead507ad4ecf2760937173db"><td class="memItemLeft" align="right" valign="top"><a id="a1c528ba7ead507ad4ecf2760937173db" name="a1c528ba7ead507ad4ecf2760937173db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Key</b> = Key_t</td></tr>
<tr class="memdesc:a1c528ba7ead507ad4ecf2760937173db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:a1c528ba7ead507ad4ecf2760937173db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="memItemLeft" align="right" valign="top"><a id="a7eb9e2d5cdb340c0ec938a88ce2ef5d7" name="a7eb9e2d5cdb340c0ec938a88ce2ef5d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mapped</b> = Mapped_t</td></tr>
<tr class="memdesc:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:a7eb9e2d5cdb340c0ec938a88ce2ef5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232ad8dd1cfa23d0377c8b3db872219a"><td class="memItemLeft" align="right" valign="top"><a id="a232ad8dd1cfa23d0377c8b3db872219a" name="a232ad8dd1cfa23d0377c8b3db872219a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Hash</b> = Hash_t</td></tr>
<tr class="memdesc:a232ad8dd1cfa23d0377c8b3db872219a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:a232ad8dd1cfa23d0377c8b3db872219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea14e7770b9b7e7529753502f818505b"><td class="memItemLeft" align="right" valign="top"><a id="aea14e7770b9b7e7529753502f818505b" name="aea14e7770b9b7e7529753502f818505b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Pred</b> = Pred_t</td></tr>
<tr class="memdesc:aea14e7770b9b7e7529753502f818505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for template arg. <br /></td></tr>
<tr class="separator:aea14e7770b9b7e7529753502f818505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="memItemLeft" align="right" valign="top"><a id="a1bda4cef68dc1775ae5a02f0f349bb62" name="a1bda4cef68dc1775ae5a02f0f349bb62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b> = std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> const, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &gt;</td></tr>
<tr class="memdesc:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for key/mapped-value pairs stored in the structure. <br /></td></tr>
<tr class="separator:a1bda4cef68dc1775ae5a02f0f349bb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7bf4c62aad92c36900c7974354dfcb"><td class="memItemLeft" align="right" valign="top"><a id="a1a7bf4c62aad92c36900c7974354dfcb" name="a1a7bf4c62aad92c36900c7974354dfcb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Value_movable</b> = std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &gt;</td></tr>
<tr class="memdesc:a1a7bf4c62aad92c36900c7974354dfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for key/mapped-value pair best-suited (perf-wise) as arg type for the moving <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a></code> overload. <br /></td></tr>
<tr class="separator:a1a7bf4c62aad92c36900c7974354dfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ce79aa68113033d3d5295bf6e3fdf"><td class="memItemLeft" align="right" valign="top"><a id="a135ce79aa68113033d3d5295bf6e3fdf" name="a135ce79aa68113033d3d5295bf6e3fdf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:a135ce79aa68113033d3d5295bf6e3fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses sizes/lengths of relevant things. <br /></td></tr>
<tr class="separator:a135ce79aa68113033d3d5295bf6e3fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8574ed84883500dbb67270facdb328"><td class="memItemLeft" align="right" valign="top"><a id="a8f8574ed84883500dbb67270facdb328" name="a8f8574ed84883500dbb67270facdb328"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8f8574ed84883500dbb67270facdb328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for difference of <code>size_type</code>s. <br /></td></tr>
<tr class="separator:a8f8574ed84883500dbb67270facdb328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcf7b6069c82bb96bd31e9351f21704"><td class="memItemLeft" align="right" valign="top"><a id="a0fcf7b6069c82bb96bd31e9351f21704" name="a0fcf7b6069c82bb96bd31e9351f21704"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b> = typename Value_list::iterator</td></tr>
<tr class="memdesc:a0fcf7b6069c82bb96bd31e9351f21704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into a mutable structure of this type. <br /></td></tr>
<tr class="separator:a0fcf7b6069c82bb96bd31e9351f21704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b082d4967a366aeb30fa644bb4605"><td class="memItemLeft" align="right" valign="top"><a id="aa81b082d4967a366aeb30fa644bb4605" name="aa81b082d4967a366aeb30fa644bb4605"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_iterator</b> = typename Value_list::const_iterator</td></tr>
<tr class="memdesc:aa81b082d4967a366aeb30fa644bb4605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for iterator pointing into an immutable structure of this type. <br /></td></tr>
<tr class="separator:aa81b082d4967a366aeb30fa644bb4605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6caa6709547211a33b894f0c267218"><td class="memItemLeft" align="right" valign="top"><a id="acf6caa6709547211a33b894f0c267218" name="acf6caa6709547211a33b894f0c267218"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Reverse_iterator</b> = typename Value_list::reverse_iterator</td></tr>
<tr class="memdesc:acf6caa6709547211a33b894f0c267218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into a mutable structure of this type. <br /></td></tr>
<tr class="separator:acf6caa6709547211a33b894f0c267218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca606e926a239c4e94d428aadf1f74d"><td class="memItemLeft" align="right" valign="top"><a id="a4ca606e926a239c4e94d428aadf1f74d" name="a4ca606e926a239c4e94d428aadf1f74d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Const_reverse_iterator</b> = typename Value_list::const_reverse_iterator</td></tr>
<tr class="memdesc:a4ca606e926a239c4e94d428aadf1f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse iterator pointing into an immutable structure of this type. <br /></td></tr>
<tr class="separator:a4ca606e926a239c4e94d428aadf1f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b472c1256b3661c73018fd07ca446"><td class="memItemLeft" align="right" valign="top"><a id="abe6b472c1256b3661c73018fd07ca446" name="abe6b472c1256b3661c73018fd07ca446"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a></td></tr>
<tr class="memdesc:abe6b472c1256b3661c73018fd07ca446"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> type. <br /></td></tr>
<tr class="separator:abe6b472c1256b3661c73018fd07ca446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9995f0c063e81317c64e3f1a9924f7"><td class="memItemLeft" align="right" valign="top"><a id="a1e9995f0c063e81317c64e3f1a9924f7" name="a1e9995f0c063e81317c64e3f1a9924f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a></td></tr>
<tr class="memdesc:a1e9995f0c063e81317c64e3f1a9924f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> type. <br /></td></tr>
<tr class="separator:a1e9995f0c063e81317c64e3f1a9924f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400decc79397fec52be13e1098e04661"><td class="memItemLeft" align="right" valign="top"><a id="a400decc79397fec52be13e1098e04661" name="a400decc79397fec52be13e1098e04661"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a></td></tr>
<tr class="memdesc:a400decc79397fec52be13e1098e04661"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. <br /></td></tr>
<tr class="separator:a400decc79397fec52be13e1098e04661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816dda3b07a92e4446347b71f420f82f"><td class="memItemLeft" align="right" valign="top"><a id="a816dda3b07a92e4446347b71f420f82f" name="a816dda3b07a92e4446347b71f420f82f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a></td></tr>
<tr class="memdesc:a816dda3b07a92e4446347b71f420f82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a" title="Convenience alias for template arg.">Hash</a> type. <br /></td></tr>
<tr class="separator:a816dda3b07a92e4446347b71f420f82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f8b89d9bc13270c601b89c62b74191"><td class="memItemLeft" align="right" valign="top"><a id="a39f8b89d9bc13270c601b89c62b74191" name="a39f8b89d9bc13270c601b89c62b74191"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a></td></tr>
<tr class="memdesc:a39f8b89d9bc13270c601b89c62b74191"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b" title="Convenience alias for template arg.">Pred</a> type. <br /></td></tr>
<tr class="separator:a39f8b89d9bc13270c601b89c62b74191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="memItemLeft" align="right" valign="top"><a id="a18a7ba77b88c3dfa8547a54747a72bf6" name="a18a7ba77b88c3dfa8547a54747a72bf6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> *</td></tr>
<tr class="memdesc:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. <br /></td></tr>
<tr class="separator:a18a7ba77b88c3dfa8547a54747a72bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5425ac3f7f0b5760b92312b60753adb"><td class="memItemLeft" align="right" valign="top"><a id="ac5425ac3f7f0b5760b92312b60753adb" name="ac5425ac3f7f0b5760b92312b60753adb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> *</td></tr>
<tr class="memdesc:ac5425ac3f7f0b5760b92312b60753adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): pointer to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. <br /></td></tr>
<tr class="separator:ac5425ac3f7f0b5760b92312b60753adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="memItemLeft" align="right" valign="top"><a id="a6d63f26c3fb953b0ab2856a3c76a22d6" name="a6d63f26c3fb953b0ab2856a3c76a22d6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;</td></tr>
<tr class="memdesc:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. <br /></td></tr>
<tr class="separator:a6d63f26c3fb953b0ab2856a3c76a22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a762084112e0def72d1e94493bba1f4"><td class="memItemLeft" align="right" valign="top"><a id="a6a762084112e0def72d1e94493bba1f4" name="a6a762084112e0def72d1e94493bba1f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;</td></tr>
<tr class="memdesc:a6a762084112e0def72d1e94493bba1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): reference to <code>const Key</code>/<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> pair type. <br /></td></tr>
<tr class="separator:a6a762084112e0def72d1e94493bba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d16a268b95319c8611d57951c3317b"><td class="memItemLeft" align="right" valign="top"><a id="a18d16a268b95319c8611d57951c3317b" name="a18d16a268b95319c8611d57951c3317b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a></td></tr>
<tr class="memdesc:a18d16a268b95319c8611d57951c3317b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704" title="Type for iterator pointing into a mutable structure of this type.">Iterator</a> type. <br /></td></tr>
<tr class="separator:a18d16a268b95319c8611d57951c3317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616e1be6dd8a0e20a2a7dce501864039"><td class="memItemLeft" align="right" valign="top"><a id="a616e1be6dd8a0e20a2a7dce501864039" name="a616e1be6dd8a0e20a2a7dce501864039"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a></td></tr>
<tr class="memdesc:a616e1be6dd8a0e20a2a7dce501864039"><td class="mdescLeft">&#160;</td><td class="mdescRight">For container compliance (hence the irregular capitalization): <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605" title="Type for iterator pointing into an immutable structure of this type.">Const_iterator</a> type. <br /></td></tr>
<tr class="separator:a616e1be6dd8a0e20a2a7dce501864039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0033ec6c091d68ac9804cae1675b93f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af0033ec6c091d68ac9804cae1675b93f">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{})</td></tr>
<tr class="memdesc:af0033ec6c091d68ac9804cae1675b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty structure with some basic parameters.  <a href="classflow_1_1util_1_1Linked__hash__map.html#af0033ec6c091d68ac9804cae1675b93f">More...</a><br /></td></tr>
<tr class="separator:af0033ec6c091d68ac9804cae1675b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa5c23bc3d7a79eb3e334b80bf37b5529">Linked_hash_map</a> (std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &gt; values, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a> n_buckets=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1), const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;hasher_obj=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;pred=<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{})</td></tr>
<tr class="memdesc:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs structure with some basic parameters, and values initialized from initializer list.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aa5c23bc3d7a79eb3e334b80bf37b5529">More...</a><br /></td></tr>
<tr class="separator:aa5c23bc3d7a79eb3e334b80bf37b5529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae42dd8b8ecfd51d6414e4c8c8ac79924">Linked_hash_map</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;src)</td></tr>
<tr class="memdesc:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object that is a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae42dd8b8ecfd51d6414e4c8c8ac79924">More...</a><br /></td></tr>
<tr class="separator:ae42dd8b8ecfd51d6414e4c8c8ac79924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad440ab087f3335e9ba2664826d99f9e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad440ab087f3335e9ba2664826d99f9e5">Linked_hash_map</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad440ab087f3335e9ba2664826d99f9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs object by making it equal to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad440ab087f3335e9ba2664826d99f9e5">More...</a><br /></td></tr>
<tr class="separator:ad440ab087f3335e9ba2664826d99f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621b7defed9015b5d0eeca0301450ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad621b7defed9015b5d0eeca0301450ba">operator=</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;src)</td></tr>
<tr class="memdesc:ad621b7defed9015b5d0eeca0301450ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object with a copy of the given source.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad621b7defed9015b5d0eeca0301450ba">More...</a><br /></td></tr>
<tr class="separator:ad621b7defed9015b5d0eeca0301450ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08522b4af94f87b543649e367afd643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad08522b4af94f87b543649e367afd643">operator=</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad08522b4af94f87b543649e367afd643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad08522b4af94f87b543649e367afd643">More...</a><br /></td></tr>
<tr class="separator:ad08522b4af94f87b543649e367afd643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8393b9576ef14102a467e317f443471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a> &amp;other)</td></tr>
<tr class="memdesc:ac8393b9576ef14102a467e317f443471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this structure and <code>other</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471">More...</a><br /></td></tr>
<tr class="separator:ac8393b9576ef14102a467e317f443471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">insert</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;key_and_mapped)</td></tr>
<tr class="memdesc:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; if key already in <code>*this</code> makes no change.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">More...</a><br /></td></tr>
<tr class="separator:ac99cc54acf0b5a74e8e7a1f5ca30c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a6444fd8206c662fe4ebe61a91acb3eb9">insert</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;key_and_mapped)</td></tr>
<tr class="memdesc:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload, except that (if key not already present in <code>*this</code>) the key and mapped-value are moved, not copied, into <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a6444fd8206c662fe4ebe61a91acb3eb9">More...</a><br /></td></tr>
<tr class="separator:a6444fd8206c662fe4ebe61a91acb3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e4a04383d686564b3c0cc3383b3880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a18e4a04383d686564b3c0cc3383b3880">operator[]</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a18e4a04383d686564b3c0cc3383b3880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either finds the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value at the given key, or if not found inserts one with a default-constructed <code>Mapped{}</code>; then returns reference to the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a18e4a04383d686564b3c0cc3383b3880">More...</a><br /></td></tr>
<tr class="separator:a18e4a04383d686564b3c0cc3383b3880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8766bd2c286c40e1036cf3836558d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7">Mapped</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ae8766bd2c286c40e1036cf3836558d55">operator[]</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&amp;key)</td></tr>
<tr class="memdesc:ae8766bd2c286c40e1036cf3836558d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ae8766bd2c286c40e1036cf3836558d55">More...</a><br /></td></tr>
<tr class="separator:ae8766bd2c286c40e1036cf3836558d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a18e44447eb0b848f1ed4c6d947427d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d">find</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a9a18e44447eb0b848f1ed4c6d947427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find value at the given key in the map.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d">More...</a><br /></td></tr>
<tr class="separator:a9a18e44447eb0b848f1ed4c6d947427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b55a895a78341363146459f45f345c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a50b55a895a78341363146459f45f345c">find</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a50b55a895a78341363146459f45f345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other overload but in a <code>const</code> context: the returned iterator is to immutable memory.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a50b55a895a78341363146459f45f345c">More...</a><br /></td></tr>
<tr class="separator:a50b55a895a78341363146459f45f345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f75f926f679c06727298db80b18ea67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a8f75f926f679c06727298db80b18ea67">count</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a8f75f926f679c06727298db80b18ea67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a8f75f926f679c06727298db80b18ea67">More...</a><br /></td></tr>
<tr class="separator:a8f75f926f679c06727298db80b18ea67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283501e0657922191813c9a465ea0748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a283501e0657922191813c9a465ea0748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748">More...</a><br /></td></tr>
<tr class="separator:a283501e0657922191813c9a465ea0748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad5252a028dae9a6cee1e7fccabc37d8f">touch</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad5252a028dae9a6cee1e7fccabc37d8f">More...</a><br /></td></tr>
<tr class="separator:ad5252a028dae9a6cee1e7fccabc37d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1ef46da85774193ad4153e56460ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a58c1ef46da85774193ad4153e56460ad">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a58c1ef46da85774193ad4153e56460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element pointed to by the given valid iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a58c1ef46da85774193ad4153e56460ad">More...</a><br /></td></tr>
<tr class="separator:a58c1ef46da85774193ad4153e56460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ca10ae279f49663ba17df190f36fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a50ca10ae279f49663ba17df190f36fab">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it_newest, const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;it_past_oldest)</td></tr>
<tr class="memdesc:a50ca10ae279f49663ba17df190f36fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>).  <a href="classflow_1_1util_1_1Linked__hash__map.html#a50ca10ae279f49663ba17df190f36fab">More...</a><br /></td></tr>
<tr class="separator:a50ca10ae279f49663ba17df190f36fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad3e9ea0a2c3675577b4582b6a7f59312">erase</a> (const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element with the given key, if it exists.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad3e9ea0a2c3675577b4582b6a7f59312">More...</a><br /></td></tr>
<tr class="separator:ad3e9ea0a2c3675577b4582b6a7f59312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81c78165446043355a1e3f0cc42c65"><td class="memItemLeft" align="right" valign="top"><a id="acb81c78165446043355a1e3f0cc42c65" name="acb81c78165446043355a1e3f0cc42c65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:acb81c78165446043355a1e3f0cc42c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so that <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510" title="Returns number of elements stored.">size()</a> == 0</code>. <br /></td></tr>
<tr class="separator:acb81c78165446043355a1e3f0cc42c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b7d184077a8644d764d104feed76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a">begin</a> ()</td></tr>
<tr class="memdesc:a585b7d184077a8644d764d104feed76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a">More...</a><br /></td></tr>
<tr class="separator:a585b7d184077a8644d764d104feed76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b0e5555bd112c464d4ab053fb3d06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c">newest</a> ()</td></tr>
<tr class="memdesc:a43b0e5555bd112c464d4ab053fb3d06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "newest," element's iterator; or <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c">More...</a><br /></td></tr>
<tr class="separator:a43b0e5555bd112c464d4ab053fb3d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc31f275883d1076755d2b179bc66d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6">end</a> ()</td></tr>
<tr class="memdesc:abbc31f275883d1076755d2b179bc66d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6">More...</a><br /></td></tr>
<tr class="separator:abbc31f275883d1076755d2b179bc66d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9135b5521dd34bea817b2326b04737f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3">past_oldest</a> ()</td></tr>
<tr class="memdesc:a9135b5521dd34bea817b2326b04737f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns special iterator indicating the position just past the iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "oldest," element in the iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3">More...</a><br /></td></tr>
<tr class="separator:a9135b5521dd34bea817b2326b04737f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed">cbegin</a> () const</td></tr>
<tr class="memdesc:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed">More...</a><br /></td></tr>
<tr class="separator:a0e0722bbd2cc5ba9192f299545b9d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2385c71b4970ba71af8479900117ab79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2385c71b4970ba71af8479900117ab79">begin</a> () const</td></tr>
<tr class="memdesc:a2385c71b4970ba71af8479900117ab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2385c71b4970ba71af8479900117ab79">More...</a><br /></td></tr>
<tr class="separator:a2385c71b4970ba71af8479900117ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1640cce76b51f0fa0d8c1e95b682808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808">const_newest</a> () const</td></tr>
<tr class="memdesc:ad1640cce76b51f0fa0d8c1e95b682808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> but operating on immutable <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808">More...</a><br /></td></tr>
<tr class="separator:ad1640cce76b51f0fa0d8c1e95b682808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deb6b537745b164988fed8755722999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999">cend</a> () const</td></tr>
<tr class="memdesc:a4deb6b537745b164988fed8755722999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999">More...</a><br /></td></tr>
<tr class="separator:a4deb6b537745b164988fed8755722999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f223c371de3409879887bbb3a558b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1f223c371de3409879887bbb3a558b65">end</a> () const</td></tr>
<tr class="memdesc:a1f223c371de3409879887bbb3a558b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a1f223c371de3409879887bbb3a558b65">More...</a><br /></td></tr>
<tr class="separator:a1f223c371de3409879887bbb3a558b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29dc85660cc2ed821cd887bff0ed953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953">const_past_oldest</a> () const</td></tr>
<tr class="memdesc:ad29dc85660cc2ed821cd887bff0ed953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> but operating on immutable <code>*this</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953">More...</a><br /></td></tr>
<tr class="separator:ad29dc85660cc2ed821cd887bff0ed953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a2bba3816cc1c1d0f43b0d8205f04ec66">rbegin</a> ()</td></tr>
<tr class="memdesc:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a2bba3816cc1c1d0f43b0d8205f04ec66">More...</a><br /></td></tr>
<tr class="separator:a2bba3816cc1c1d0f43b0d8205f04ec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155305b98475f232236ec395ec925e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4">oldest</a> ()</td></tr>
<tr class="memdesc:a3155305b98475f232236ec395ec925e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4">More...</a><br /></td></tr>
<tr class="separator:a3155305b98475f232236ec395ec925e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a797e0ff66fe4044f5a551bee4540e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a84a797e0ff66fe4044f5a551bee4540e">rend</a> ()</td></tr>
<tr class="memdesc:a84a797e0ff66fe4044f5a551bee4540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a84a797e0ff66fe4044f5a551bee4540e">More...</a><br /></td></tr>
<tr class="separator:a84a797e0ff66fe4044f5a551bee4540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e24934208292fb4096b7e036d5227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">Reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227">past_newest</a> ()</td></tr>
<tr class="memdesc:a0a4e24934208292fb4096b7e036d5227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one past last, a/k/a "newest," element's reverse iterator.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227">More...</a><br /></td></tr>
<tr class="separator:a0a4e24934208292fb4096b7e036d5227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d426d7711d31be672f504593783887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a85d426d7711d31be672f504593783887">crbegin</a> () const</td></tr>
<tr class="memdesc:a85d426d7711d31be672f504593783887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a85d426d7711d31be672f504593783887">More...</a><br /></td></tr>
<tr class="separator:a85d426d7711d31be672f504593783887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af841fbe9ea76f962a56828098934199d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d">const_oldest</a> () const</td></tr>
<tr class="memdesc:af841fbe9ea76f962a56828098934199d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns first, a/k/a "oldest," element's reverse iterator (to immutable element).  <a href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d">More...</a><br /></td></tr>
<tr class="separator:af841fbe9ea76f962a56828098934199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146bacf7c55bc513217fc0c8a951cfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a146bacf7c55bc513217fc0c8a951cfd8">crend</a> () const</td></tr>
<tr class="memdesc:a146bacf7c55bc513217fc0c8a951cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a146bacf7c55bc513217fc0c8a951cfd8">More...</a><br /></td></tr>
<tr class="separator:a146bacf7c55bc513217fc0c8a951cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">Const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47">const_past_newest</a> () const</td></tr>
<tr class="memdesc:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns special reverse iterator indicating the position just past the reverse-iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "newest," element in the reverse-iteration order.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47">More...</a><br /></td></tr>
<tr class="separator:a93725b3e4e10c7841fb34ca9ac5aff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff10ef8e0f54d49462c1a651efca6424"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424">empty</a> () const</td></tr>
<tr class="memdesc:aff10ef8e0f54d49462c1a651efca6424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if container is empty.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424">More...</a><br /></td></tr>
<tr class="separator:aff10ef8e0f54d49462c1a651efca6424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ea7121aa85856c9d977777f6c7c510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510">size</a> () const</td></tr>
<tr class="memdesc:a97ea7121aa85856c9d977777f6c7c510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510">More...</a><br /></td></tr>
<tr class="separator:a97ea7121aa85856c9d977777f6c7c510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059c278705edc45e9b2660f17a295837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a059c278705edc45e9b2660f17a295837">max_size</a> () const</td></tr>
<tr class="memdesc:a059c278705edc45e9b2660f17a295837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max number of elements that can be stored.  <a href="classflow_1_1util_1_1Linked__hash__map.html#a059c278705edc45e9b2660f17a295837">More...</a><br /></td></tr>
<tr class="separator:a059c278705edc45e9b2660f17a295837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memTemplParams" colspan="2">template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </td></tr>
<tr class="memitem:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aaac7b774853aa9a83e2935634fd5e7a6">swap</a> (<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;val1, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;val2)</td></tr>
<tr class="memdesc:aaac7b774853aa9a83e2935634fd5e7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>val1.swap(val2)</code>.  <a href="classflow_1_1util_1_1Linked__hash__map.html#aaac7b774853aa9a83e2935634fd5e7a6">More...</a><br /></td></tr>
<tr class="separator:aaac7b774853aa9a83e2935634fd5e7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key_t, typename Mapped_t, typename Hash_t, typename Pred_t&gt;<br />
class flow::util::Linked_hash_map&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;</div><p >An object of this class is a map that combines the lookup speed of an <code>unordered_map&lt;&gt;</code> and ordering and iterator stability capabilities of a <code>list&lt;&gt;</code>. </p>
<p >The API is generally that of an <code>unordered_map&lt;&gt;</code>. The differences essentially all have to do with iterators. This map introduces a concept of "newness," which determines the iteration order. Moreover, <em>every</em> iterator remains valid except (of course) under erasure of the underlying element. Newness is defined as follows inductively: whenever an element is inserted, it is "newest," thus it is placed at the front of the iterator order. Furthermore, the methods <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> can be used to make any element "newest" (moved to the front of the iterator order). Iterator thus formed orders elements from newest to oldest (hence <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a585b7d184077a8644d764d104feed76a" title="Synonym of newest().">begin()</a>, <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> is <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a>).</p>
<p >Performance expectations: The best way to determine a method's time needs is to imagine what it must do. If it must perform a lookup by key, that is an <code>unordered_set&lt;&gt;</code> lookup resulting in an (at least internal) iterator. If it must insert an element, it is always inserted at the start of a <code>list</code>; and also into an <code>unordered_set&lt;&gt;</code>. If it must erase an element based on an iterator, that element is erased from a list based on that iterator; and also by key from said <code>unordered_set&lt;&gt;</code>. Iteration itself is iteration along a <code>list</code>. But essentially, every operation is either near constant time or constant time. In terms of space needs, this essentially stores the values themselves in a <code>list</code>; and also a pointer to each list-held key/element in an <code>unordered_set&lt;&gt;</code>, which also stores a pointer or list iterator per element.</p>
<p >Move semantics for both keys and mapped-values are supported (let <code>T</code> be a concrete type for a <code>*this</code> and <code>x</code> a <code>*this</code>):</p><ul>
<li><code>x.insert(std::make_pair&lt;Key, Mapped&gt;(..., ...))</code>;<ul>
<li>or <code>x.insert(T::Value_movable{..., ...})</code>;</li>
</ul>
</li>
<li><code>x[std::move(...)] = std::move(...)</code>.</li>
</ul>
<p >There is the standard complement of container-wide move operations: move-construction, move-assignment, and <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471" title="Swaps the contents of this structure and other.">swap()</a></code> (all constant-time, excluding any implied <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65" title="Makes it so that size() == 0.">clear()</a></code> in the move-assignment).</p>
<p >The iterators are, really, <code>list&lt;pair&lt;const Key, Mapped&gt;&gt;</code> iterators; and as such are not invalidated except due to direct erasure of a given pointee.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html" title="An object of this class is a map that combines the lookup speed of an unordered_map&lt;&gt; and ordering an...">Linked_hash_map</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__set.html" title="An object of this class is a map that combines the lookup speed of an unordered_set&lt;&gt; and ordering an...">Linked_hash_set</a> have a reasonable complement of C++1x-ish APIs including move-semantics; but the API does not quite mirror the full complement of what is in existence for <code>unordered_*</code> counterparts in C++17 STL/Boost &ndash; it would be nice to add these. This includes such things as <code>.emplace()</code> and <code>.try_emplace()</code> but more fundamentally would probably involve trolling <code>std::unordered_*</code> and copying its ~full API (and likely some of a decent impl too). That said what's available already acquits itself reasonably well. (Historically this was first written before C++11 and hasn't been given the full-on C++1x overhaul but instead merely the essentials thereof.)</dd></dl>
<h3>Thread safety</h3>
<p >Same as for <code>unordered_map&lt;&gt;</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key_t</td><td>Key type. We omit formal requirements, as it is tedious and full of corner cases depending on what you plan to invoke (e.g., whether you use move-semantics for keys). Please use common sense knowing the basic data structures involved as explained above. That said: if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> is of non-trivial size, it is good to have it have performant move-constructibility and move-assignability and then make use of it via move-aware APIs as suggested in the doc header above. </td></tr>
    <tr><td class="paramname">Mapped_t</td><td>The 2nd (satellite) part of the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a> pair type. Same commentary as for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a> applies here. </td></tr>
    <tr><td class="paramname">Hash_t</td><td>Hasher type. Same requirements and behavior as <code>boost::unordered_set&lt;&gt;</code> counterpart. If using the default value for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a" title="Convenience alias for template arg.">Hash</a> (<code>boost::hash&lt;Key&gt;</code>), and the default object is passed to ctor (<code>Hash{}</code>) (this is typical), but there is no hash-function already defined for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, then the easiest way to define it is: make a <code>size_t hash_value(Key)</code> free function in the same namespace as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>. </td></tr>
    <tr><td class="paramname">Pred_t</td><td>Equality-determiner type. Same requirements and behavior as <code>boost::unordered_set&lt;&gt;</code> counterpart. If using the default value for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b" title="Convenience alias for template arg.">Pred</a> (<code>std::equal_to&lt;Key&gt;</code>), and the default object is passed to ctor (<code>Pred{}</code>) (this is typical), but there is no equality op defined for <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db" title="Convenience alias for template arg.">Key</a>, then the easiest way to define it is: make an operator-method or free function such that <code>k1 == k2</code> (where <code>k1</code> and <code>k2</code> are <code>Key</code>s) determines equality or lack thereof. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0033ec6c091d68ac9804cae1675b93f" name="af0033ec6c091d68ac9804cae1675b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0033ec6c091d68ac9804cae1675b93f">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs empty structure with some basic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_buckets</td><td>Number of buckets for the unordered (hash) table. Special value -1 (default) will cause us to use whatever <code>unordered_set&lt;&gt;</code> would use by default. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>Instance of the hash function type (<code>hasher_obj(k) -&gt; size_t</code> should be hash of <code>Key k</code>). </td></tr>
    <tr><td class="paramname">pred</td><td>Instance of the equality function type (<code>pred(k1, k2)</code> should return <code>true</code> if and only if the <code>Key</code>s are equal by value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c23bc3d7a79eb3e334b80bf37b5529" name="aa5c23bc3d7a79eb3e334b80bf37b5529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c23bc3d7a79eb3e334b80bf37b5529">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>&#160;</td>
          <td class="paramname"><em>n_buckets</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">size_type</a>(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher_obj</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a">Hash</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b">Pred</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs structure with some basic parameters, and values initialized from initializer list. </p>
<p >The values are inserted as if <code>insert(v)</code> was called for each pair <code>v</code> in <code>values</code> <b>in reverse order</b>. Since the canonical ordering places the <em>newest</em> (last inserted/<code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a></code>ed) element at the <em>front</em> of the ordering, that means that forward iteration through the set (right after this constructor runs) will yield values in the <em>same</em> order as in initializer list <code>values</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Values with which to fill the structure after initializing it. Typically you'd provide a series of key/value pairs like this: <code>{ { key1, value1 }, { key2, value2 }, ... }</code>. They will appear in iterated sequence in the same order as they appear in this list. </td></tr>
    <tr><td class="paramname">n_buckets</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">hasher_obj</td><td>See other constructor. </td></tr>
    <tr><td class="paramname">pred</td><td>See other constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae42dd8b8ecfd51d6414e4c8c8ac79924" name="ae42dd8b8ecfd51d6414e4c8c8ac79924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42dd8b8ecfd51d6414e4c8c8ac79924">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object that is a copy of the given source. </p>
<p >Equivalent to default-ction followed by <code>operator=(src)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad440ab087f3335e9ba2664826d99f9e5" name="ad440ab087f3335e9ba2664826d99f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad440ab087f3335e9ba2664826d99f9e5">&#9670;&nbsp;</a></span>Linked_hash_map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::Linked_hash_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object by making it equal to the given source, while the given source becomes as-if default-cted. </p>
<p >Equivalent to default-ction followed by <code>operator=(std::move(src))</code>.</p>
<p >This is a constant-time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a585b7d184077a8644d764d104feed76a" name="a585b7d184077a8644d764d104feed76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585b7d184077a8644d764d104feed76a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a>. </dd></dl>

</div>
</div>
<a id="a2385c71b4970ba71af8479900117ab79" name="a2385c71b4970ba71af8479900117ab79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2385c71b4970ba71af8479900117ab79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0e0722bbd2cc5ba9192f299545b9d0ed" title="Synonym of const_newest().">cbegin()</a>. </dd></dl>

</div>
</div>
<a id="a0e0722bbd2cc5ba9192f299545b9d0ed" name="a0e0722bbd2cc5ba9192f299545b9d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0722bbd2cc5ba9192f299545b9d0ed">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad1640cce76b51f0fa0d8c1e95b682808" title="Same as newest() but operating on immutable *this.">const_newest()</a>. </dd></dl>

</div>
</div>
<a id="a4deb6b537745b164988fed8755722999" name="a4deb6b537745b164988fed8755722999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deb6b537745b164988fed8755722999">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>. </p>
<p >Exists as standard container method (hence the odd formatting). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ad29dc85660cc2ed821cd887bff0ed953" title="Same as past_oldest() but operating on immutable *this.">const_past_oldest()</a>. </dd></dl>

</div>
</div>
<a id="ad1640cce76b51f0fa0d8c1e95b682808" name="ad1640cce76b51f0fa0d8c1e95b682808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1640cce76b51f0fa0d8c1e95b682808">&#9670;&nbsp;</a></span>const_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a43b0e5555bd112c464d4ab053fb3d06c" title="Returns first, a/k/a &quot;newest,&quot; element&#39;s iterator; or past_oldest() if empty().">newest()</a> but operating on immutable <code>*this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="af841fbe9ea76f962a56828098934199d" name="af841fbe9ea76f962a56828098934199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af841fbe9ea76f962a56828098934199d">&#9670;&nbsp;</a></span>const_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator (to immutable element). </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a93725b3e4e10c7841fb34ca9ac5aff47" name="a93725b3e4e10c7841fb34ca9ac5aff47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93725b3e4e10c7841fb34ca9ac5aff47">&#9670;&nbsp;</a></span>const_past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns special reverse iterator indicating the position just past the reverse-iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "newest," element in the reverse-iteration order. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="ad29dc85660cc2ed821cd887bff0ed953" name="ad29dc85660cc2ed821cd887bff0ed953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29dc85660cc2ed821cd887bff0ed953">&#9670;&nbsp;</a></span>const_past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::const_past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> but operating on immutable <code>*this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a8f75f926f679c06727298db80b18ea67" name="a8f75f926f679c06727298db80b18ea67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f75f926f679c06727298db80b18ea67">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times a key equal to the given one is present (as-if via <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9a18e44447eb0b848f1ed4c6d947427d" title="Attempts to find value at the given key in the map.">find()</a>) in the map: either 1 or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or 1. </dd></dl>

</div>
</div>
<a id="a85d426d7711d31be672f504593783887" name="a85d426d7711d31be672f504593783887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d426d7711d31be672f504593783887">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#af841fbe9ea76f962a56828098934199d" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator (to immutable element).">const_oldest()</a>. </dd></dl>

</div>
</div>
<a id="a146bacf7c55bc513217fc0c8a951cfd8" name="a146bacf7c55bc513217fc0c8a951cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146bacf7c55bc513217fc0c8a951cfd8">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4ca606e926a239c4e94d428aadf1f74d">::Const_reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a93725b3e4e10c7841fb34ca9ac5aff47" title="Returns special reverse iterator indicating the position just past the reverse-iteration order; if no...">const_past_newest()</a>. </dd></dl>

</div>
</div>
<a id="aff10ef8e0f54d49462c1a651efca6424" name="aff10ef8e0f54d49462c1a651efca6424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff10ef8e0f54d49462c1a651efca6424">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if container is empty. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="abbc31f275883d1076755d2b179bc66d6" name="abbc31f275883d1076755d2b179bc66d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc31f275883d1076755d2b179bc66d6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a>. </dd></dl>

</div>
</div>
<a id="a1f223c371de3409879887bbb3a558b65" name="a1f223c371de3409879887bbb3a558b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f223c371de3409879887bbb3a558b65">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>. </p>
<p >Exists to satisfy the C++11 rangy stuff (which makes <code>for(:)</code> &ndash; and other magic &ndash; work). </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a>. </dd></dl>

</div>
</div>
<a id="a58c1ef46da85774193ad4153e56460ad" name="a58c1ef46da85774193ad4153e56460ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c1ef46da85774193ad4153e56460ad">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element pointed to by the given valid iterator. </p>
<p >Behavior undefined if it is not valid. <code>it</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator of element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator one position past (i.e., "older") than <code>it</code>, before <code>*it</code> was removed. </dd></dl>

</div>
</div>
<a id="a50ca10ae279f49663ba17df190f36fab" name="a50ca10ae279f49663ba17df190f36fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ca10ae279f49663ba17df190f36fab">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_newest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it_past_oldest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements in the range [<code>it_newest</code>, <code>it_past_oldest</code>). </p>
<p >Behavior undefined if a given iterator is invalid, or if the range is invalid. Corner case: an empty range is allowed; then this no-ops. Unless no-op, <code>it_newest</code> becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it_newest</td><td>Iterator of first ("newest") element to erase. </td></tr>
    <tr><td class="paramname">it_past_oldest</td><td>Iterator of one past last ("oldest") element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>it_past_oldest</code> copy. </dd></dl>

</div>
</div>
<a id="ad3e9ea0a2c3675577b4582b6a7f59312" name="ad3e9ea0a2c3675577b4582b6a7f59312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e9ea0a2c3675577b4582b6a7f59312">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the element with the given key, if it exists. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it existed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key such that its equal's (if found) element will be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased (0 or 1). </dd></dl>

</div>
</div>
<a id="a9a18e44447eb0b848f1ed4c6d947427d" name="a9a18e44447eb0b848f1ed4c6d947427d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a18e44447eb0b848f1ed4c6d947427d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find value at the given key in the map. </p>
<p >Key presence is determined identically to how it would be done in an <code>unordered_set&lt;Key, Hash, Pred&gt;</code>, with the particular <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a232ad8dd1cfa23d0377c8b3db872219a" title="Convenience alias for template arg.">Hash</a> and <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aea14e7770b9b7e7529753502f818505b" title="Convenience alias for template arg.">Pred</a> instances given to ctor (typically their default-cted instances, typically occupying no memory).</p>
<p >The returned iterator (if valid) can be used to mutate the element inside the map; though only the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> is mutable; the <code>const Key</code> is immutable.</p>
<p >Any subsequent writes to the referred-to (by returned iterator) area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#abbc31f275883d1076755d2b179bc66d6" title="Synonym of past_oldest().">end()</a></code>. </dd></dl>

</div>
</div>
<a id="a50b55a895a78341363146459f45f345c" name="a50b55a895a78341363146459f45f345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b55a895a78341363146459f45f345c">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">::Const_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload but in a <code>const</code> context: the returned iterator is to immutable memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, iterator to the key/mapped-value pair with the equivalent key; else <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a4deb6b537745b164988fed8755722999" title="Synonym of const_past_oldest().">cend()</a></code>. </dd></dl>

</div>
</div>
<a id="ac99cc54acf0b5a74e8e7a1f5ca30c2eb" name="ac99cc54acf0b5a74e8e7a1f5ca30c2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cc54acf0b5a74e8e7a1f5ca30c2eb">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a>, bool &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; if key already in <code>*this</code> makes no change. </p>
<p >See also the overload which can avoid a copy and destructively move the key and mapped-value instead.</p>
<p >Return value indicates various info of interest about what occurred or did not occur. If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected (use <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> upon consulting the return value, if this is desirable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>The key/mapped-value pair to attempt to insert. A copy of this value is placed in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair whose second element is true if and only if the insertion occurred; and whose first element is an iterator pointing to either the newly inserted element or already present one with a key equal to <code>key_and_mapped.first</code>. </dd></dl>

</div>
</div>
<a id="a6444fd8206c662fe4ebe61a91acb3eb9" name="a6444fd8206c662fe4ebe61a91acb3eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6444fd8206c662fe4ebe61a91acb3eb9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a>, bool &gt; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb">Value_movable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_and_mapped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload, except that (if key not already present in <code>*this</code>) the key and mapped-value are moved, not copied, into <code>*this</code>. </p>
<dl class="section note"><dt>Note</dt><dd><code>key_and_mapped</code> pointee must be of type <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1a7bf4c62aad92c36900c7974354dfcb" title="Short-hand for key/mapped-value pair best-suited (perf-wise) as arg type for the moving insert() over...">Value_movable</a>, a/k/a <code>pair&lt;Key, Mapped&gt;</code> &ndash; not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1bda4cef68dc1775ae5a02f0f349bb62" title="Short-hand for key/mapped-value pairs stored in the structure.">Value</a>, a/k/a <code>pair&lt;const Key, Mapped&gt;</code> &ndash; otherwise the other <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac99cc54acf0b5a74e8e7a1f5ca30c2eb" title="Attempts to insert (copying both key and mapped-value) the given key/mapped-value pair into the map; ...">insert()</a> overload may get invoked, and copying may occur contrary to your intention. E.g., use <code>std::make_pair&lt;Key, Mapped&gt;()</code> or <code>"decltype(*this)::Value_movable{}"</code>. (For a move to occur, the source-object can't be <code>const</code>; so that's why.) </dd>
<dd>
You can often also use <code>x[std::move(key)] = std::move(value)</code>, particularly if you know <code>key</code> isn't in there, or you are OK with replacing the value if it is. In those cases it's probably more convenient, no pairs or <code>Value_movable</code>s to worry oneself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_and_mapped</td><td>The key/mapped-value pair to attempt to insert (both key and mapped-value are moved-from, if insertion occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other overload. </dd></dl>

</div>
</div>
<a id="a059c278705edc45e9b2660f17a295837" name="a059c278705edc45e9b2660f17a295837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059c278705edc45e9b2660f17a295837">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max number of elements that can be stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;</code> + <code>list&lt;&gt;</code>. </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a43b0e5555bd112c464d4ab053fb3d06c" name="a43b0e5555bd112c464d4ab053fb3d06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b0e5555bd112c464d4ab053fb3d06c">&#9670;&nbsp;</a></span>newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "newest," element's iterator; or <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a9135b5521dd34bea817b2326b04737f3" title="Returns special iterator indicating the position just past the iteration order; if not empty() this i...">past_oldest()</a> if <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a3155305b98475f232236ec395ec925e4" name="a3155305b98475f232236ec395ec925e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3155305b98475f232236ec395ec925e4">&#9670;&nbsp;</a></span>oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns first, a/k/a "oldest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="ad621b7defed9015b5d0eeca0301450ba" name="ad621b7defed9015b5d0eeca0301450ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621b7defed9015b5d0eeca0301450ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object with a copy of the given source. </p>
<p >We become equal to <code>src</code> but independent of it to a common-sense extent. In addition, the hasher instance and equality predicate are copied from <code>src</code>. Finally, a reasonable attempt is made to also make the internal structure of the hash map to be similar to that of `src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. No-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="ad08522b4af94f87b543649e367afd643" name="ad08522b4af94f87b543649e367afd643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08522b4af94f87b543649e367afd643">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites this object making it identical to the given source, while the given source becomes as-if default-cted. </p>
<p >This is a constant-time operation, plus whatever is the cost of <code>this-&gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acb81c78165446043355a1e3f0cc42c65" title="Makes it so that size() == 0.">clear()</a></code> (linear in pre-op <code>.<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a97ea7121aa85856c9d977777f6c7c510" title="Returns number of elements stored.">size()</a></code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is emptied; except no-op if <code>this == &amp;src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a18e4a04383d686564b3c0cc3383b3880" name="a18e4a04383d686564b3c0cc3383b3880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e4a04383d686564b3c0cc3383b3880">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mapped_t &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either finds the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value at the given key, or if not found inserts one with a default-constructed <code>Mapped{}</code>; then returns reference to the <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a>. </p>
<p >That ref can be used to read and/or modify that value directly. See also the overload which can avoid a copy and destructively move the key instead.</p>
<p >If inserted, the new element is considered "newest," as if by <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If not inserted, the existing element location is not affected.</p>
<p >So it is ~equivalent to</p>
<ul>
<li>(<code>key</code> is in map) <code>return this-&gt;find(key)-&gt;second</code>; or</li>
<li>(otherwise) <code>return this-&gt;insert(key, Mapped{}).first-&gt;second</code>.</li>
</ul>
<p >As long as the value is not removed from the map, the reference will continue to be valid.</p>
<p >Any subsequent writes to the referred-to area of memory will NOT have the effect of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a>. If you need it call <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a283501e0657922191813c9a465ea0748" title="Given a valid iterator into the structure, makes the pointed-to element &quot;newest&quot; by moving it from wh...">touch()</a> yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find or insert if not found. A copy of this value is placed in <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to mutable <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a7eb9e2d5cdb340c0ec938a88ce2ef5d7" title="Convenience alias for template arg.">Mapped</a> value directly inside the data structure. </dd></dl>

</div>
</div>
<a id="ae8766bd2c286c40e1036cf3836558d55" name="ae8766bd2c286c40e1036cf3836558d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8766bd2c286c40e1036cf3836558d55">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mapped_t &amp; <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other overload, except that (if key not already present in <code>*this</code>) the key is moved, not copied, into <code>*this</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to attempt to insert (key is moved-from, if insertion occurs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other overload. </dd></dl>

</div>
</div>
<a id="a0a4e24934208292fb4096b7e036d5227" name="a0a4e24934208292fb4096b7e036d5227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4e24934208292fb4096b7e036d5227">&#9670;&nbsp;</a></span>past_newest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_newest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one past last, a/k/a "newest," element's reverse iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a9135b5521dd34bea817b2326b04737f3" name="a9135b5521dd34bea817b2326b04737f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9135b5521dd34bea817b2326b04737f3">&#9670;&nbsp;</a></span>past_oldest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0fcf7b6069c82bb96bd31e9351f21704">::Iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::past_oldest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns special iterator indicating the position just past the iteration order; if not <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aff10ef8e0f54d49462c1a651efca6424" title="Returns true if and only if container is empty.">empty()</a> this is one past last, a/k/a "oldest," element in the iteration order. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="a2bba3816cc1c1d0f43b0d8205f04ec66" name="a2bba3816cc1c1d0f43b0d8205f04ec66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bba3816cc1c1d0f43b0d8205f04ec66">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a3155305b98475f232236ec395ec925e4" title="Returns first, a/k/a &quot;oldest,&quot; element&#39;s reverse iterator.">oldest()</a>. </dd></dl>

</div>
</div>
<a id="a84a797e0ff66fe4044f5a551bee4540e" name="a84a797e0ff66fe4044f5a551bee4540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a797e0ff66fe4044f5a551bee4540e">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#acf6caa6709547211a33b894f0c267218">::Reverse_iterator</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym of <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </p>
<p >Exists as standard container method. </p><dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a0a4e24934208292fb4096b7e036d5227" title="Returns one past last, a/k/a &quot;newest,&quot; element&#39;s reverse iterator.">past_newest()</a>. </dd></dl>

</div>
</div>
<a id="a97ea7121aa85856c9d977777f6c7c510" name="a97ea7121aa85856c9d977777f6c7c510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ea7121aa85856c9d977777f6c7c510">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;<a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a135ce79aa68113033d3d5295bf6e3fdf">::size_type</a> <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements stored. </p>
<p >Same performance as of <code>unordered_set&lt;&gt;.</code> </p><dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

</div>
</div>
<a id="ac8393b9576ef14102a467e317f443471" name="ac8393b9576ef14102a467e317f443471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8393b9576ef14102a467e317f443471">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this structure and <code>other</code>. </p>
<p >This is a constant-time operation, as internal representations are swapped instead of any copy-assignment.</p>
<dl class="section see"><dt>See also</dt><dd>The <code><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#ac8393b9576ef14102a467e317f443471" title="Swaps the contents of this structure and other.">swap()</a></code> free function. It is generally best (equivalent but covers more generic cases) to use the ADL-enabled <code>swap(a, b)</code> pattern instead of this member function. That is: <code>using std::swap; ...; swap(a, b);</code>. (Details are outside our scope here; but in short ADL will cause the right thing to happen.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a283501e0657922191813c9a465ea0748" name="a283501e0657922191813c9a465ea0748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283501e0657922191813c9a465ea0748">&#9670;&nbsp;</a></span>touch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#aa81b082d4967a366aeb30fa644bb4605">Const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a valid iterator into the structure, makes the pointed-to element "newest" by moving it from wherever it is to be first in the iteration order. </p>
<p >Behavior undefined if iterator invalid.</p>
<p >The iterator continues to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to an element of the structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5252a028dae9a6cee1e7fccabc37d8f" name="ad5252a028dae9a6cee1e7fccabc37d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5252a028dae9a6cee1e7fccabc37d8f">&#9670;&nbsp;</a></span>touch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">flow::util::Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt;::touch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classflow_1_1util_1_1Linked__hash__map.html#a1c528ba7ead507ad4ecf2760937173db">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a key into the structure, makes the corresponding element "newest" by moving it from wherever it is to be first in the iteration order; or does nothing if no such key. </p>
<p ><code>find(key)</code> equivalent is performed first. Return value indicates whether it was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose equal to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key was found (even if it was already "newest"); <code>false</code> if not found. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaac7b774853aa9a83e2935634fd5e7a6" name="aaac7b774853aa9a83e2935634fd5e7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac7b774853aa9a83e2935634fd5e7a6">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_t , typename Mapped_t , typename Hash_t , typename Pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classflow_1_1util_1_1Linked__hash__map.html">Linked_hash_map</a>&lt; Key_t, Mapped_t, Hash_t, Pred_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>val1.swap(val2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="linked__hash__map_8hpp.html">linked_hash_map.hpp</a></li>
<li>util/<a class="el" href="util__fwd_8hpp.html">util_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 15 2026 00:48:59 for Flow by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
